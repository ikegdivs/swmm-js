class swmm_full {
//-----------------------------------------------------------------------------
//   consts.h
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/14  (Build 5.1.001)
//            08/01/16  (Build 5.1.011)
//            05/10/18  (Build 5.1.013)
//            03/01/20  (Build 5.1.014)
//            04/01/20  (Build 5.1.015)
//   Author:  L. Rossman
//
//   Various Constants
//-----------------------------------------------------------------------------

//------------------
// General Constants
//------------------

VERSION =           51015
MAGICNUMBER =       516114522
EOFMARK =           0x1A           // Use 0x04 for UNIX systems
MAXTITLE =          3              // Max. # title lines
MAXMSG  =           1024           // Max. # characters in message text
MAXLINE =           1024           // Max. # characters per input line
MAXFNAME =          259            // Max. # characters in file name
MAXTOKS =           40             // Max. items per line of input
MAXSTATES =         10             // Max. # computed hyd. variables
MAXODES =           4              // Max. # ODE's to be solved
NA  =               -1             // NOT APPLICABLE code
TRUE =              1              // Value for TRUE state
FALSE =             0              // Value for FALSE state
BIG =               1.E10          // Generic large value
TINY =              1.E-6          // Generic small value
ZERO =              1.E-10         // Effective zero value
MISSING =           -1.E10         // Missing value code
PI =                3.141592654    // Value of pi
GRAVITY =           32.2           // accel. of gravity in US units
SI_GRAVITY =        9.81           // accel of gravity in SI units
MAXFILESIZE =       2147483647    // largest file size in bytes

//-----------------------------
// Units factor in Manning Eqn.
//-----------------------------
PHI = 1.486

//----------------------------------------------
// Definition of measureable runoff flow & depth
//----------------------------------------------
MIN_RUNOFF_FLOW  =  0.001          // cfs
MIN_EXCESS_DEPTH =  0.0001         // ft, = 0.03 mm  <NOT USED>
MIN_TOTAL_DEPTH =   0.004167       // ft, = 0.05 inches
MIN_RUNOFF =        2.31481e-8     // ft/sec = 0.001 in/hr

//----------------------------------------------------------------------
// Minimum flow, depth & volume used to evaluate steady state conditions
//----------------------------------------------------------------------
FLOW_TOL =     0.00001  // cfs
DEPTH_TOL =    0.00001  // ft    <NOT USED>
VOLUME_TOL =   0.01     // ft3   <NOT USED>

//---------------------------------------------------
// Minimum depth for reporting non-zero water quality
//---------------------------------------------------
//MIN_WQ_DEPTH  0.01     // ft (= 3 mm)
//MIN_WQ_FLOW   0.001    // cfs

//-----------------------------------------------------
// Minimum flow depth and area for dynamic wave routing
//-----------------------------------------------------
FUDGE =   0.0001    // ft or ft2

//---------------------------
// Various conversion factors
//---------------------------
GPMperCFS =  448.831
AFDperCFS =  1.9837
MGDperCFS =  0.64632
IMGDperCFS = 0.5382
LPSperCFS =  28.317
LPMperCFS =  1699.0
CMHperCFS =  101.94
CMDperCFS =  2446.6
MLDperCFS =  2.4466
M3perFT3 =  0.028317
LperFT3 =    28.317
MperFT  =    0.3048
PSIperFT =   0.4333
KPAperPSI =  6.895
KWperHP  =   0.7457
SECperDAY =  86400
MSECperDAY = 8.64e7
MMperINCH =  25.40

//---------------------------
// Token separator characters
//---------------------------
SEPSTR =   " \t\n\r"


// for tranlating an integer into a 4 byte output string
// input: num: integer
toBytes32(num){
    let ascii = '';
    for (let i=3; i>=0; i--){
        ascii+=String.fromCharCode((num>>(8*i))&255);
    }
    return ascii;
}

// for tranlating a float into a 4 byte output string
// input: num: float
toBytes32f(num){
    let ascii = '';
    for (let i=3; i>=0; i--){
        ascii+=String.fromCharCode((Math.fround(num)>>(8*i))&255);
    }
    return ascii;
}

// for tranlating an integer into a 4 byte output string
// input: num: character
toBytes32a(char){
    let arr1 = [];
    for(let n = 0, l = char.length; n < l; n++){
        let hex = Number(char.charCodeAt(n)).toString(16);
        arr1.push(hex);
    }
    return arr1.join('');
}

//--------------------------------------------------
// Macro to test for successful allocation of memory
//--------------------------------------------------
 MEMCHECK(x)  {(((x) == null) ? 101 : 0 )}

//--------------------------------------------------
// Macro to free a non-null pointer
//--------------------------------------------------
 FREE(x) { if (x) { x = null; } }

//---------------------------------------------------
// Conversion macros to be used in place of functions
//---------------------------------------------------
ABS(x)   { return (((x)<0) ? -(x) : (x))  }        /* absolute value of x   */
MIN(x,y) { return (((x)<=(y)) ? (x) : (y))  }      /* minimum of x and y    */
MAX(x,y) { return (((x)>=(y)) ? (x) : (y)) }       /* maximum of x and y    */
MOD(x,y) { return ((x)%(y))     }                  /* x modulus y           */
LOG10(x) { return ((x) > 0.0 ? log10((x)) : (x))}  /* safe log10 of x       */
SQR(x)   { return ((x)*(x))}                       /* x-squared             */
SGN(x)   { return (((x)<0) ? (-1) : (1))}          /* sign of x             */
SIGN(x,y) { return ((y) >= 0.0 ? Math.abs(x) : -Math.abs(x))}
UCHAR(x) { return (((x) >= 'a' && (x) <= 'z') ? ((x)&~32) : (x))}
                                                 /* uppercase char of x   */
ARRAY_LENGTH(x) {(sizeof(x)/sizeof(x[0]))} /* length of array x     */

//-------------------------------------------------
// Macro to evaluate x with error checking
//-------------------------------------------------
CALL(x) { return (ErrorCode = ((ErrorCode>0) ? (ErrorCode) : (x)))}

fopen(dataStream) {
    return dataStream;
}

fopen_path(filePath) {
    result = null;
    xmlhttp = new XMLHttpRequest();
    xmlhttp.open("GET", filePath, false);
    xmlhttp.send();
    if(xmlhttp.status==200){
        result = xmlhttp.responseText;
    }
    return result;
}

//-----------------------------------------------------------------------------
//   enums.h
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/14  (Build 5.1.001)
//            04/14/14  (Build 5.1.004)
//            09/15/14  (Build 5.1.007)
//            03/19/15  (Build 5.1.008)
//            08/05/15  (Build 5.1.010)
//            08/01/16  (Build 5.1.011)
//            05/10/18  (Build 5.1.013)
//   Author:  L. Rossman
//
//   Enumerated variables
//
//   Build 5.1.004:
//   - IGNORE_RDII for the ignore RDII option added.
//
//   Build 5.1.007:
//   - s_GWF for [GWF] input file section added.
//   - s_ADJUST for [ADJUSTMENTS] input file section added.
//
//   Build 5.1.008:
//   - Enumerations for fullness state of a conduit added.
//   - NUM_THREADS added for number of parallel threads option.
//   - Runoff flow categories added to represent mass balance components.
//
//   Build 5.1.010:
//   - New ROADWAY_WEIR type of weir added.
//   - Potential evapotranspiration (PET) added as a system output variable.
//
//   Build 5.1.011:
//   - s_EVENT added to InputSectionType enumeration.
//
//   Build 5.1.013:
//   - SURCHARGE_METHOD and RULE_STEP options added.
//   - WEIR_CURVE added as a curve type.
//
//-----------------------------------------------------------------------------

//mempool.c
ALLOC_BLOCK_SIZE =  64000

//-------------------------------------
// Names of major object types
//-------------------------------------

GAGE = 0                            // rain gage
SUBCATCH = 1                        // subcatchment
NODE = 2                            // conveyance system node
LINK = 3                            // conveyance system link
POLLUT = 4                          // pollutant
LANDUSE = 5                         // land use category
TIMEPATTERN = 6                     // dry weather flow time pattern
CURVE = 7                           // generic table of values
TSERIES = 8                         // generic time series of values
CONTROL = 9                         // conveyance system control rules
TRANSECT = 10                       // irregular channel cross-section
AQUIFER = 11                        // groundwater aquifer
UNITHYD = 12                        // RDII unit hydrograph
SNOWMELT = 13                       // snowmelt parameter set
SHAPE = 14                          // custom conduit shape
LID = 15                            // LID treatment units
MAX_OBJ_TYPES = 16

//-------------------------------------
// Names of Node sub-types
//-------------------------------------
MAX_NODE_TYPES = 4

JUNCTION = 0
OUTFALL = 1
STORAGE = 2
DIVIDER = 3

//-------------------------------------
// Names of Link sub-types
//-------------------------------------
MAX_LINK_TYPES = 5

CONDUIT = 0
PUMP = 1
ORIFICE = 2
WEIR = 3
OUTLET = 4

//-------------------------------------
// File types
//-------------------------------------

RAINFALL_FILE = 0                   // rainfall file
RUNOFF_FILE = 1                     // runoff file
HOTSTART_FILE = 2                   // hotstart file
RDII_FILE = 3                       // RDII file
INFLOWS_FILE = 4                    // inflows interface file
OUTFLOWS_FILE = 5                    // outflows interface file

//-------------------------------------
// File usage types
//-------------------------------------
NO_FILE = 0                         // no file usage
SCRATCH_FILE = 1                    // use temporary scratch file
USE_FILE = 2                        // use previously saved file
SAVE_FILE = 3                        // save file currently in use

//-------------------------------------
// Rain gage data types
//-------------------------------------

RAIN_TSERIES = 0                     // rainfall from user-supplied time series
RAIN_FILE = 1                        // rainfall from external file

//-------------------------------------
// Cross section shape types
//-------------------------------------
 
DUMMY = 0                           // 0
CIRCULAR = 1                        // 1      closed
FILLED_CIRCULAR = 2                 // 2      closed
RECT_CLOSED = 3                     // 3      closed
RECT_OPEN = 4                       // 4
TRAPEZOIDAL = 5                     // 5
TRIANGULAR = 6                      // 6
PARABOLIC = 7                       // 7
POWERFUNC = 8                       // 8
RECT_TRIANG = 9                     // 9
RECT_ROUND = 10                      // 10
MOD_BASKET = 11                      // 11
HORIZ_ELLIPSE = 12                   // 12     closed
VERT_ELLIPSE = 13                    // 13     closed
ARCH = 14                            // 14     closed
EGGSHAPED = 15                       // 15     closed
HORSESHOE = 16                       // 16     closed
GOTHIC = 17                          // 17     closed
CATENARY = 18                        // 18     closed
SEMIELLIPTICAL = 19                  // 19     closed
BASKETHANDLE = 20                    // 20     closed
SEMICIRCULAR = 21                    // 21     closed
IRREGULAR = 22                       // 22
CUSTOM = 23                          // 23     closed
FORCE_MAIN  = 24                     // 24     closed

//-------------------------------------
// Measurement units types
//-------------------------------------

US = 0                              // US units
SI = 1                             // SI (metric) units

 //enum FlowUnitsType {
CFS = 0                             // cubic feet per second
GPM = 1                             // gallons per minute
MGD = 2                             // million gallons per day
CMS = 3                             // cubic meters per second
LPS = 4                             // liters per second
MLD = 5                             // million liters per day

 //enum ConcUnitsType {
MG = 0                              // Milligrams / L
UG = 1                              // Micrograms / L
COUNT = 2                           // Counts / L

//--------------------------------------
// Quantities requiring unit conversions
//--------------------------------------
 //enum ConversionType {
RAINFALL = 0
RAINDEPTH = 1
EVAPRATE = 2
LENGTH = 3
LANDAREA = 4
VOLUME = 5
WINDSPEED = 6
TEMPERATURE = 7
MASS = 8
GWFLOW = 9
FLOW = 10                           // Flow must always be listed last

//-------------------------------------
// Computed subcatchment quantities
//-------------------------------------
MAX_SUBCATCH_RESULTS = 9
 //enum SubcatchResultType {
SUBCATCH_RAINFALL = 0               // rainfall intensity
SUBCATCH_SNOWDEPTH = 1              // snow depth
SUBCATCH_EVAP = 2                   // evap loss
SUBCATCH_INFIL = 3                  // infil loss
SUBCATCH_RUNOFF = 4                 // runoff flow rate
SUBCATCH_GW_FLOW = 5                // groundwater flow rate to node
SUBCATCH_GW_ELEV = 6                // elevation of saturated gw table
SUBCATCH_SOIL_MOIST = 7             // soil moisture
SUBCATCH_WASHOFF = 8                // pollutant washoff concentration

//-------------------------------------
// Computed node quantities
//-------------------------------------
MAX_NODE_RESULTS = 7
//enum NodeResultType {
NODE_DEPTH = 0                      // water depth above invert
NODE_HEAD = 1                       // hydraulic head
NODE_VOLUME = 2                     // volume stored & ponded
NODE_LATFLOW = 3                    // lateral inflow rate
NODE_INFLOW = 4                     // total inflow rate
NODE_OVERFLOW = 5                   // overflow rate
NODE_QUAL = 6                       // concentration of each pollutant

//-------------------------------------
// Computed link quantities
//-------------------------------------
MAX_LINK_RESULTS = 6
//enum LinkResultType {
LINK_FLOW = 0                        // flow rate
LINK_DEPTH = 1                       // flow depth
LINK_VELOCITY = 2                    // flow velocity
LINK_VOLUME = 3                      // link volume
LINK_CAPACITY = 4                    // ratio of area to full area
LINK_QUAL = 5                        // concentration of each pollutant

//-------------------------------------
// System-wide flow quantities
//-------------------------------------
MAX_SYS_RESULTS = 15
//enum SysFlowType {
     SYS_TEMPERATURE = 0                  // air temperature
     SYS_RAINFALL = 1                     // rainfall intensity
     SYS_SNOWDEPTH = 2                    // snow depth
     SYS_INFIL = 3                        // infil
     SYS_RUNOFF = 4                       // runoff flow
     SYS_DWFLOW = 5                       // dry weather inflow
     SYS_GWFLOW = 6                       // ground water inflow
     SYS_IIFLOW = 7                       // RDII inflow
     SYS_EXFLOW = 8                       // external inflow
     SYS_INFLOW = 9                       // total lateral inflow
     SYS_FLOODING = 10                     // flooding outflow
     SYS_OUTFLOW = 11                      // outfall outflow
     SYS_STORAGE = 12                      // storage volume
     SYS_EVAP = 13                         // evaporation
     SYS_PET = 14                          // potential ET

//-------------------------------------
// Conduit flow classifications
//-------------------------------------
//enum FlowClassType {
DRY = 0                             // dry conduit
UP_DRY = 1                          // upstream end is dry
DN_DRY = 2                          // downstream end is dry
SUBCRITICAL = 3                     // sub-critical flow
SUPCRITICAL = 4                     // super-critical flow
UP_CRITICAL = 5                     // free-fall at upstream end
DN_CRITICAL = 6                     // free-fall at downstream end
MAX_FLOW_CLASSES = 7                // number of distinct flow classes
UP_FULL = 8                         // upstream end is full
DN_FULL = 9                         // downstream end is full
ALL_FULL = 10                       // completely full

//------------------------
// Runoff flow categories
//------------------------
//enum RunoffFlowType {
RUNOFF_RAINFALL = 0                  // rainfall
RUNOFF_EVAP = 1                      // evaporation
RUNOFF_INFIL = 2                     // infiltration
RUNOFF_RUNOFF = 3                    // runoff
RUNOFF_DRAINS = 4                    // LID drain flow
RUNOFF_RUNON = 5                     // runon from outfalls

//-------------------------------------
// Surface pollutant loading categories
//-------------------------------------
//enum LoadingType {
BUILDUP_LOAD = 0                    // pollutant buildup load
DEPOSITION_LOAD = 1                 // rainfall deposition load
SWEEPING_LOAD = 2                   // load removed by sweeping
BMP_REMOVAL_LOAD = 3                // load removed by BMPs
INFIL_LOAD = 4                      // runon load removed by infiltration
RUNOFF_LOAD = 5                     // load removed by runoff
FINAL_LOAD = 6                      // load remaining on surface

//-------------------------------------
// Input data options
//-------------------------------------
//enum RainfallType {
RAINFALL_INTENSITY = 0              // rainfall expressed as intensity
RAINFALL_VOLUME = 1                 // rainfall expressed as volume
CUMULATIVE_RAINFALL = 2             // rainfall expressed as cumulative volume

//enum TempType {
NO_TEMP = 0                         // no temperature data supplied
TSERIES_TEMP = 1                    // temperatures come from time series
FILE_TEMP = 2                       // temperatures come from file

//enum  WindType {
MONTHLY_WIND = 0                    // wind speed varies by month
FILE_WIND = 1                       // wind speed comes from file

//enum EvapType {
CONSTANT_EVAP = 0                   // constant evaporation rate
MONTHLY_EVAP = 1                    // evaporation rate varies by month
TIMESERIES_EVAP = 2                 // evaporation supplied by time series
TEMPERATURE_EVAP = 3                // evaporation from daily temperature
FILE_EVAP = 4                       // evaporation comes from file
RECOVERY = 5                        // soil recovery pattern
DRYONLY = 6                         // evap. allowed only in dry periods

//enum NormalizerType {
PER_AREA = 0                       // buildup is per unit or area
PER_CURB = 1                       // buildup is per unit of curb length

//enum BuildupType {
NO_BUILDUP = 0                      // no buildup
POWER_BUILDUP = 1                   // power buildup equation
EXPON_BUILDUP = 2                   // exponential buildup equation
SATUR_BUILDUP = 3                   // saturation buildup equation
EXTERNAL_BUILDUP = 4                // external time series buildup

//enum WashoffType {
NO_WASHOFF = 0                      // no washoff
EXPON_WASHOFF = 1                   // exponential washoff equation
RATING_WASHOFF = 2                  // rating curve washoff equation
EMC_WASHOFF = 3                     // event mean concentration washoff

//enum  SubAreaType {
IMPERV0 = 0                         // impervious w/o depression storage
IMPERV1 = 1                         // impervious w/ depression storage
PERV = 2                            // pervious

//enum RunoffRoutingType {
TO_OUTLET = 0                       // perv & imperv runoff goes to outlet
TO_IMPERV = 1                       // perv runoff goes to imperv area
TO_PERV = 2                        // imperv runoff goes to perv subarea

//enum RouteModelType {
NO_ROUTING = 0                      // no routing
SF = 1                              // steady flow model
KW = 2                              // kinematic wave model
EKW = 3                             // extended kin. wave model
DW = 4                              // dynamic wave model

//enum ForceMainType {
H_W = 0                             // Hazen-Williams eqn.
D_W = 1                             // Darcy-Weisbach eqn.

//enum OffsetType {
DEPTH_OFFSET = 0                    // offset measured as depth
ELEV_OFFSET = 1                     // offset measured as elevation

//enum KinWaveMethodType {
NORMAL = 0                          // normal method
MODIFIED = 1                        // modified method

//enum  CompatibilityType {
SWMM5 = 0                           // SWMM 5 weighting for area & hyd. radius
SWMM3 = 1                           // SWMM 3 weighting
SWMM4 = 2                           // SWMM 4 weighting

//enum NormalFlowType {
SLOPE = 0                           // based on slope only
FROUDE = 1                          // based on Fr only
BOTH = 2                            // based on slope & Fr

//enum InertialDampingType {
NO_DAMPING = 0                      // no inertial damping
PARTIAL_DAMPING = 1                 // partial damping
FULL_DAMPING = 2                    // full damping

////  Added to release 5.1.013.  ////                                          //(5.1.013)
//enum  SurchargeMethodType {
EXTRAN = 0                          // original EXTRAN method
SLOT = 1                            // Preissmann slot method

//enum InflowType {
EXTERNAL_INFLOW = 0                 // user-supplied external inflow
DRY_WEATHER_INFLOW = 1              // user-supplied dry weather inflow
WET_WEATHER_INFLOW = 2              // computed runoff inflow
GROUNDWATER_INFLOW = 3              // computed groundwater inflow
RDII_INFLOW = 4                     // computed I&I inflow
FLOW_INFLOW = 5                     // inflow parameter is flow
CONCEN_INFLOW = 6                   // inflow parameter is pollutant concen.
MASS_INFLOW  = 7                    // inflow parameter is pollutant mass

//enum PatternType {
MONTHLY_PATTERN = 0                 // DWF multipliers for each month
DAILY_PATTERN = 1                   // DWF multipliers for each day of week
HOURLY_PATTERN = 2                  // DWF multipliers for each hour of day
WEEKEND_PATTERN = 3                 // hourly multipliers for week end days

//enum OutfallType {
FREE_OUTFALL = 0                    // critical depth outfall condition
NORMAL_OUTFALL = 1                  // normal flow depth outfall condition
FIXED_OUTFALL = 2                   // fixed depth outfall condition
TIDAL_OUTFALL = 3                   // variable tidal stage outfall condition
TIMESERIES_OUTFALL = 4              // variable time series outfall depth

//enum StorageType {
TABULAR = 0                         // area v. depth from table
FUNCTIONAL = 1                      // area v. depth from power function

//enum ReactorType {
CSTR = 0                            // completely mixed reactor
PLUG = 1                            // plug flow reactor

//enum TreatmentType {
REMOVAL = 0                         // treatment stated as a removal
CONCEN = 1                          // treatment stated as effluent concen.

//enum DividerType {
CUTOFF_DIVIDER = 0                  // diverted flow is excess of cutoff flow
TABULAR_DIVIDER = 1                 // table of diverted flow v. inflow
WEIR_DIVIDER = 2                    // diverted flow proportional to excess flow
OVERFLOW_DIVIDER = 3                // diverted flow is flow > full conduit flow

//enum PumpCurveType {
TYPE1_PUMP = 0                      // flow varies stepwise with wet well volume
TYPE2_PUMP = 1                      // flow varies stepwise with inlet depth
TYPE3_PUMP = 2                      // flow varies with head delivered
TYPE4_PUMP = 3                      // flow varies with inlet depth
IDEAL_PUMP = 4                      // outflow equals inflow

//enum OrificeType {
SIDE_ORIFICE = 0                    // side orifice
BOTTOM_ORIFICE = 1                  // bottom orifice

//enum WeirType {
TRANSVERSE_WEIR = 0                 // transverse weir
SIDEFLOW_WEIR = 1                   // side flow weir
VNOTCH_WEIR = 2                     // V-notch (triangular) weir
TRAPEZOIDAL_WEIR = 3                // trapezoidal weir
ROADWAY_WEIR = 4                    // FHWA HDS-5 roadway weir

//enum CurveType {
STORAGE_CURVE = 0                   // surf. area v. depth for storage node
DIVERSION_CURVE = 1                 // diverted flow v. inflow for divider node
TIDAL_CURVE = 2                     // water elev. v. hour of day for outfall
RATING_CURVE = 3                    // flow rate v. head for outlet link
CONTROL_CURVE = 4                   // control setting v. controller variable
SHAPE_CURVE = 5                     // width v. depth for custom x-section
WEIR_CURVE = 6                      // discharge coeff. v. head for weir    //(5.1.013)
PUMP1_CURVE = 7                     // flow v. wet well volume for pump
PUMP2_CURVE = 8                     // flow v. depth for pump (discrete)
PUMP3_CURVE = 9                     // flow v. head for pump (continuous)
PUMP4_CURVE = 10                    // flow v. depth for pump (continuous)

//enum InputSectionType {
s_TITLE = 0
s_OPTION = 1
s_FILE = 2
s_RAINGAGE = 3
s_TEMP = 4
s_EVAP = 5
s_SUBCATCH = 6
s_SUBAREA = 7
s_INFIL = 8
s_AQUIFER = 9
s_GROUNDWATER = 10
s_SNOWMELT = 11
s_JUNCTION = 12
s_OUTFALL = 13
s_STORAGE = 14
s_DIVIDER = 15
s_CONDUIT = 16
s_PUMP = 17
s_ORIFICE = 18
s_WEIR = 19
s_OUTLET = 20
s_XSECTION = 21
s_TRANSECT = 22
s_LOSSES = 23
s_CONTROL = 24
s_POLLUTANT = 25
s_LANDUSE = 26
s_BUILDUP = 27
s_WASHOFF = 28
s_COVERAGE = 29
s_INFLOW = 30
s_DWF = 31
s_PATTERN = 32
s_RDII = 33
s_UNITHYD = 34
s_LOADING = 35
s_TREATMENT = 36
s_CURVE = 37
s_TIMESERIES = 38
s_REPORT = 39
s_COORDINATE = 40
s_VERTICES = 41
s_POLYGON = 42
s_LABEL = 43
s_SYMBOL = 44
s_BACKDROP = 45
s_TAG = 46
s_PROFILE = 47
s_MAP = 48
s_LID_CONTROL = 49
s_LID_USAGE = 50
s_GWF = 51
s_ADJUST = 52
s_EVENT = 53

//enum InputOptionType {
FLOW_UNITS = 0
INFIL_MODEL = 1
 ROUTE_MODEL = 2
START_DATE = 3
START_TIME = 4
END_DATE = 5
END_TIME = 6
REPORT_START_DATE = 7
REPORT_START_TIME = 8
SWEEP_START = 9
SWEEP_END = 10
START_DRY_DAYS = 11
WET_STEP = 12
DRY_STEP = 13
ROUTE_STEP = 14
RULE_STEP = 15
REPORT_STEP = 16
ALLOW_PONDING = 17
INERT_DAMPING = 18
SLOPE_WEIGHTING = 19
VARIABLE_STEP = 20
NORMAL_FLOW_LTD = 21
LENGTHENING_STEP = 22
MIN_SURFAREA = 23 
COMPATIBILITY = 24
SKIP_STEADY_STATE = 25
TEMPDIR = 26
IGNORE_RAINFALL = 27
FORCE_MAIN_EQN = 28
LINK_OFFSETS = 29
MIN_SLOPE = 30
IGNORE_SNOWMELT = 31
IGNORE_GWATER = 32
IGNORE_ROUTING = 33
IGNORE_QUALITY = 34
MAX_TRIALS = 35
HEAD_TOL = 36
SYS_FLOW_TOL = 37
LAT_FLOW_TOL = 38
IGNORE_RDII = 39
MIN_ROUTE_STEP = 40
NUM_THREADS = 41
SURCHARGE_METHOD = 42                            //(5.1.013)

//enum  NoYesType {
NO = 0
YES = 1

//enum  NoneAllType {
NONE = 0
ALL = 1
SOME = 2


//-----------------------------------------------------------------------------
//   error.h
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/14  (Build 5.1.001)
//            04/14/20  (Build 5.1.015)
//   Author:  L. Rossman
//
//   Error codes
//
//-----------------------------------------------------------------------------

//ErrorType {

  //... Runtime Errors
  ERR_NONE = 0                 //     0
  ERR_MEMORY = 1               //101  1
  ERR_KINWAVE = 2              //103  2
  ERR_ODE_SOLVER = 3           //105  3
  ERR_TIMESTEP = 4             //107  4

//... Subcatchment/Aquifer Errors
  ERR_SUBCATCH_OUTLET = 5      //108  5
  ERR_AQUIFER_PARAMS = 6       //109  6
  ERR_GROUND_ELEV = 7          //110  7

//... Conduit/Pump Errors
  ERR_LENGTH = 8               //111  8
  ERR_ELEV_DROP = 9            //112  9
  ERR_ROUGHNESS = 10            //113  10
  ERR_BARRELS = 11              //114  11
  ERR_SLOPE = 12                //115  12
  ERR_NO_XSECT = 13             //117  13
  ERR_XSECT = 14                //119  14
  ERR_NO_CURVE = 15             //121  15
  ERR_PUMP_LIMITS = 16          //122  16

//... Topology Errors
  ERR_LOOP = 17                 //131  17
  ERR_MULTI_OUTLET = 18         //133  18
  ERR_DUMMY_LINK = 19           //134  19

//... Node Errors
  ERR_DIVIDER = 20              //135  20
  ERR_DIVIDER_LINK = 21         //136  21
  ERR_WEIR_DIVIDER = 22         //137  22
  ERR_NODE_DEPTH = 23           //138  23
  ERR_REGULATOR = 24            //139  24
  ERR_OUTFALL = 25              //141  25
  ERR_REGULATOR_SHAPE = 26      //143  26
  ERR_NO_OUTLETS = 27           //145  27

//... RDII Errors
  ERR_UNITHYD_TIMES = 28        //151  28
  ERR_UNITHYD_RATIOS = 29       //153  29
  ERR_RDII_AREA = 30            //155  30

//... Rain Gage Errors
  ERR_RAIN_FILE_CONFLICT = 31   //156  31
  ERR_RAIN_GAGE_FORMAT = 32     //157  32
  ERR_RAIN_GAGE_TSERIES = 33    //158  33
  ERR_RAIN_GAGE_INTERVAL = 34   //159  34

//... Treatment Error
  ERR_CYCLIC_TREATMENT = 35     //161  35

//... Curve/Time Series Errors
  ERR_CURVE_SEQUENCE = 36       //171  36
  ERR_TIMESERIES_SEQUENCE = 37  //173  37

//... Snowmelt Errors
  ERR_SNOWMELT_PARAMS = 38      //181  38
  ERR_SNOWPACK_PARAMS = 39      //182  39

//... LID Errors
  ERR_LID_TYPE = 40             //183  40
  ERR_LID_LAYER = 41            //184  41
  ERR_LID_PARAMS = 42           //185  42
  ERR_SUBCATCH_LID = 43         //186  43
  ERR_LID_AREAS = 44            //187  44
  ERR_LID_CAPTURE_AREA = 45     //188  45

//... Simulation Date/Time Errors
  ERR_START_DATE = 46           //191  46
  ERR_REPORT_DATE = 47          //193  47
  ERR_REPORT_STEP = 48          //195  48

//... Input Parser Errors
  ERR_INPUT = 49                //200  49
  ERR_LINE_LENGTH = 50          //201  50
  ERR_ITEMS = 51                //203  51
  ERR_KEYWORD = 52              //205  52
  ERR_DUP_NAME = 53             //207  53
  ERR_NAME = 54                 //209  54
  ERR_NUMBER = 55               //211  55
  ERR_DATETIME = 56             //213  56
  ERR_RULE = 57                 //217  57
  ERR_TRANSECT_UNKNOWN = 58     //219  58
  ERR_TRANSECT_SEQUENCE = 59    //221  59
  ERR_TRANSECT_TOO_FEW = 60     //223  60
  ERR_TRANSECT_TOO_MANY = 61    //225  61
  ERR_TRANSECT_MANNING = 62     //227  62
  ERR_TRANSECT_OVERBANK = 63    //229  63
  ERR_TRANSECT_NO_DEPTH = 64    //231  64
  ERR_TREATMENT_EXPR = 65       //233  65

//... File Name/Opening Errors
  ERR_FILE_NAME = 66            //301  66
  ERR_INP_FILE = 67             //303  67
  ERR_RPT_FILE = 68             //305  68
  ERR_OUT_FILE = 69             //307  69
  ERR_OUT_WRITE = 70            //309  70
  ERR_OUT_READ = 71             //311  71

//... Rain File Errors
  ERR_RAIN_FILE_SCRATCH = 72    //313  72
  ERR_RAIN_FILE_OPEN = 73       //315  73
  ERR_RAIN_FILE_DATA = 74       //317  74
  ERR_RAIN_FILE_SEQUENCE = 75   //318  75
  ERR_RAIN_FILE_FORMAT = 76     //319  76
  ERR_RAIN_IFACE_FORMAT = 77    //320  77
  ERR_RAIN_FILE_GAGE = 78       //321  78

//... Runoff File Errors
  ERR_RUNOFF_FILE_OPEN = 79    //323  79
  ERR_RUNOFF_FILE_FORMAT = 80   //325  80
  ERR_RUNOFF_FILE_END = 81      //327  81
  ERR_RUNOFF_FILE_READ = 82     //329  82

//... Hotstart File Errors
  ERR_HOTSTART_FILE_NAMES = 83  //330  83
  ERR_HOTSTART_FILE_OPEN = 84   //331  84
  ERR_HOTSTART_FILE_FORMAT = 85 //333  85
  ERR_HOTSTART_FILE_READ = 86   //335  86

//... Climate File Errors
  ERR_NO_CLIMATE_FILE = 87      //336  87
  ERR_CLIMATE_FILE_OPEN = 88    //337  88
  ERR_CLIMATE_FILE_READ = 89    //338  89
  ERR_CLIMATE_END_OF_FILE = 90  //339  90

//... RDII File Errors
  ERR_RDII_FILE_SCRATCH = 91    //341  91
  ERR_RDII_FILE_OPEN = 92       //343  92
  ERR_RDII_FILE_FORMAT = 93     //345  93

//... Routing File Errors
  ERR_ROUTING_FILE_OPEN = 94    //351  94
  ERR_ROUTING_FILE_FORMAT = 95  //353  95
  ERR_ROUTING_FILE_NOMATCH = 96 //355  96
  ERR_ROUTING_FILE_NAMES = 97   //357  97

//... Time Series File Errors
  ERR_TABLE_FILE_OPEN = 98      //361  98
  ERR_TABLE_FILE_READ = 99      //363  99

//... Runtime Errors
  ERR_SYSTEM = 100               //401  100
  ERR_NOT_CLOSED = 101           //402  101
  ERR_NOT_OPEN = 102             //403  102
  ERR_FILE_SIZE = 103            //405  103

//... API Errors
  ERR_API_OUTBOUNDS = 104        //501  104
  ERR_API_INPUTNOTOPEN = 105     //502  105
  ERR_API_SIM_NRUNNING = 106     //503  106
  ERR_API_WRONG_TYPE = 107       //504  107
  ERR_API_OBJECT_INDEX = 108     //505  108
  ERR_API_POLLUT_INDEX = 109     //506  109
  ERR_API_INFLOWTYPE = 110       //507  110
  ERR_API_TSERIES_INDEX = 111    //508  111
  ERR_API_PATTERN_INDEX = 112    //509  112

//... Additional Errors
  ERR_STORAGE_VOLUME = 113       //140  113                                     //(5.1.015)
  MAXERRMSG = 114;

//-----------------------------------------------------------------------------
//   error.c
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/14  (Build 5.1.001)
//            03/19/15  (Build 5.1.008)
//            08/05/15  (Build 5.1.010)
//            04/14/20  (Build 5.1.015)
//   Author:  L. Rossman
//
//   Error messages
//
//   Build 5.1.008:
//   - Text of Error 217 for control rules modified.
//
//   Build 5.1.010:
//   - Text of Error 318 for rainfall data files modified.
//
//   Build 5.1.015:
//   - Added new Error 140 for storage nodes.
//-----------------------------------------------------------------------------

ERR101 = "\n  ERROR 101: memory allocation error."
ERR103 = "\n  ERROR 103: cannot solve KW equations for Link %s."
ERR105 = "\n  ERROR 105: cannot open ODE solver."
ERR107 = "\n  ERROR 107: cannot compute a valid time step."

ERR108 = "\n  ERROR 108: ambiguous outlet ID name for Subcatchment %s."
ERR109 = "\n  ERROR 109: invalid parameter values for Aquifer %s."
ERR110 = "\n  ERROR 110: ground elevation is below water table for Subcatchment %s."

ERR111 = "\n  ERROR 111: invalid length for Conduit %s."
ERR112 = "\n  ERROR 112: elevation drop exceeds length for Conduit %s."
ERR113 = "\n  ERROR 113: invalid roughness for Conduit %s."
ERR114 = "\n  ERROR 114: invalid number of barrels for Conduit %s."
ERR115 = "\n  ERROR 115: adverse slope for Conduit %s."
ERR117 = "\n  ERROR 117: no cross section defined for Link %s."
ERR119 = "\n  ERROR 119: invalid cross section for Link %s."
ERR121 = "\n  ERROR 121: missing or invalid pump curve assigned to Pump %s."
ERR122 = "\n  ERROR 122: startup depth not higher than shutoff depth for Pump %s."

ERR131 = "\n  ERROR 131: the following links form cyclic loops in the drainage system:"
ERR133 = "\n  ERROR 133: Node %s has more than one outlet link."
ERR134 = "\n  ERROR 134: Node %s has illegal DUMMY link connections."

ERR135 = "\n  ERROR 135: Divider %s does not have two outlet links."
ERR136 = "\n  ERROR 136: Divider %s has invalid diversion link."
ERR137 = "\n  ERROR 137: Weir Divider %s has invalid parameters."
ERR138 = "\n  ERROR 138: Node %s has initial depth greater than maximum depth."
ERR139 = "\n  ERROR 139: Regulator %s is the outlet of a non-storage node."
ERR140 = "\n  ERROR 140: Storage node %s has negative volume at full depth."            //(5.1.015) 
ERR141 = "\n  ERROR 141: Outfall %s has more than 1 inlet link or an outlet link."
ERR143 = "\n  ERROR 143: Regulator %s has invalid cross-section shape."
ERR145 = "\n  ERROR 145: Drainage system has no acceptable outlet nodes."

ERR151 = "\n  ERROR 151: a Unit Hydrograph in set %s has invalid time base."
ERR153 = "\n  ERROR 153: a Unit Hydrograph in set %s has invalid response ratios."
ERR155 = "\n  ERROR 155: invalid sewer area for RDII at node %s."

ERR156 = "\n  ERROR 156: ambiguous station ID for Rain Gage %s."
ERR157 = "\n  ERROR 157: inconsistent rainfall format for Rain Gage %s."
ERR158 = "\n  ERROR 158: time series for Rain Gage %s is also used by another object."
ERR159 = "\n  ERROR 159: recording interval greater than time series interval for Rain Gage %s."

ERR161 = "\n  ERROR 161: cyclic dependency in treatment functions at node %s."

ERR171 = "\n  ERROR 171: Curve %s has invalid or out of sequence data."
ERR173 = "\n  ERROR 173: Time Series %s has its data out of sequence."

ERR181 = "\n  ERROR 181: invalid Snow Melt Climatology parameters."
ERR182 = "\n  ERROR 182: invalid parameters for Snow Pack %s."

ERR183 = "\n  ERROR 183: no type specified for LID %s."
ERR184 = "\n  ERROR 184: missing layer for LID %s."
ERR185 = "\n  ERROR 185: invalid parameter value for LID %s."
ERR186 = "\n  ERROR 186: invalid parameter value for LID placed in Subcatchment %s."
ERR187 = "\n  ERROR 187: LID area exceeds total area for Subcatchment %s."
ERR188 = "\n  ERROR 188: LID capture area exceeds total impervious area for Subcatchment %s."

ERR191 = "\n  ERROR 191: simulation start date comes after ending date."
ERR193 = "\n  ERROR 193: report start date comes after ending date."
ERR195 = "\n  ERROR 195: reporting time step or duration is less than routing time step."

ERR200 = "\n  ERROR 200: one or more errors in input file."
ERR201 = "\n  ERROR 201: too many characters in input line "
ERR203 = "\n  ERROR 203: too few items "
ERR205 = "\n  ERROR 205: invalid keyword %s "
ERR207 = "\n  ERROR 207: duplicate ID name %s "
ERR209 = "\n  ERROR 209: undefined object %s "
ERR211 = "\n  ERROR 211: invalid number %s "
ERR213 = "\n  ERROR 213: invalid date/time %s "
ERR217 = "\n  ERROR 217: control rule clause invalid or out of sequence "  //(5.1.008)
ERR219 = "\n  ERROR 219: data provided for unidentified transect "
ERR221 = "\n  ERROR 221: transect station out of sequence "
ERR223 = "\n  ERROR 223: Transect %s has too few stations." 
ERR225 = "\n  ERROR 225: Transect %s has too many stations."
ERR227 = "\n  ERROR 227: Transect %s has no Manning's N."
ERR229 = "\n  ERROR 229: Transect %s has invalid overbank locations."
ERR231 = "\n  ERROR 231: Transect %s has no depth."
ERR233 = "\n  ERROR 233: invalid treatment expression "

ERR301 = "\n  ERROR 301: files share same names."
ERR303 = "\n  ERROR 303: cannot open input file."
ERR305 = "\n  ERROR 305: cannot open report file."
ERR307 = "\n  ERROR 307: cannot open binary results file."
ERR309 = "\n  ERROR 309: error writing to binary results file."
ERR311 = "\n  ERROR 311: error reading from binary results file."

ERR313 = "\n  ERROR 313: cannot open scratch rainfall interface file."
ERR315 = "\n  ERROR 315: cannot open rainfall interface file %s."
ERR317 = "\n  ERROR 317: cannot open rainfall data file %s."
ERR318 = "\n  ERROR 318: the following line is out of sequence in rainfall data file %s." //(5.1.010)
ERR319 = "\n  ERROR 319: unknown format for rainfall data file %s."
ERR320 = "\n  ERROR 320: invalid format for rainfall interface file."
ERR321 = "\n  ERROR 321: no data in rainfall interface file for gage %s."

ERR323 = "\n  ERROR 323: cannot open runoff interface file %s."
ERR325 = "\n  ERROR 325: incompatible data found in runoff interface file."
ERR327 = "\n  ERROR 327: attempting to read beyond end of runoff interface file."
ERR329 = "\n  ERROR 329: error in reading from runoff interface file."

ERR330 = "\n  ERROR 330: hotstart interface files have same names."
ERR331 = "\n  ERROR 331: cannot open hotstart interface file %s."
ERR333 = "\n  ERROR 333: incompatible data found in hotstart interface file."
ERR335 = "\n  ERROR 335: error in reading from hotstart interface file."

ERR336 = "\n  ERROR 336: no climate file specified for evaporation and/or wind speed."
ERR337 = "\n  ERROR 337: cannot open climate file %s."
ERR338 = "\n  ERROR 338: error in reading from climate file %s."
ERR339 = "\n  ERROR 339: attempt to read beyond end of climate file %s."

ERR341 = "\n  ERROR 341: cannot open scratch RDII interface file."
ERR343 = "\n  ERROR 343: cannot open RDII interface file %s."
ERR345 = "\n  ERROR 345: invalid format for RDII interface file."

ERR351 = "\n  ERROR 351: cannot open routing interface file %s."
ERR353 = "\n  ERROR 353: invalid format for routing interface file %s."
ERR355 = "\n  ERROR 355: mis-matched names in routing interface file %s."
ERR357 = "\n  ERROR 357: inflows and outflows interface files have same name."

ERR361 = "\n  ERROR 361: could not open external file used for Time Series %s."
ERR363 = "\n  ERROR 363: invalid data in external file used for Time Series %s."

ERR401 = "\n  ERROR 401: general system error."
ERR402 = "\n  ERROR 402: cannot open new project while current project still open."
ERR403 = "\n  ERROR 403: project not open or last run not ended."
ERR405 = "\n  ERROR 405: amount of output produced will exceed maximum file size;\n             either reduce Ending Date or increase Reporting Time Step."

// API Error Keys
ERR501 = "\n API Key Error: Object Type Outside Bonds"
ERR502 = "\n API Key Error: Network Not Initialized (Input file open?)"
ERR503 = "\n API Key Error: Simulation Not Running"
ERR504 = "\n API Key Error: Incorrect object type for parameter chosen"
ERR505 = "\n API Key Error: Object index out of Bounds."
ERR506 = "\n API Key Error: Invalid Pollutant Index"
ERR507 = "\n API Key Error: Invalid Inflow Type"
ERR508 = "\n API Key Error: Invalid Timeseries Index"
ERR509 = "\n API Key Error: Invalid Pattern Index"

////////////////////////////////////////////////////////////////////////////
//  NOTE: Need to update ErrorMsgs[], ErrorCodes[], and ErrorType
//        (in error.h) whenever a new error message is added.
/////////////////////////////////////////////////////////////////////////////

ErrorMsgs =
    [ "",     ERR101, ERR103, ERR105, ERR107, ERR108, ERR109, ERR110, ERR111,
      ERR112, ERR113, ERR114, ERR115, ERR117, ERR119, ERR121, ERR122, ERR131,
      ERR133, ERR134, ERR135, ERR136, ERR137, ERR138, ERR139, ERR141, ERR143,
      ERR145, ERR151, ERR153, ERR155, ERR156, ERR157, ERR158, ERR159, ERR161,
      ERR171, ERR173, ERR181, ERR182, ERR183, ERR184, ERR185, ERR186, ERR187,
      ERR188, ERR191, ERR193, ERR195, ERR200, ERR201, ERR203, ERR205, ERR207,
      ERR209, ERR211, ERR213, ERR217, ERR219, ERR221, ERR223, ERR225, ERR227,
      ERR229, ERR231, ERR233, ERR301, ERR303, ERR305, ERR307, ERR309, ERR311,
      ERR313, ERR315, ERR317, ERR318, ERR319, ERR320, ERR321, ERR323, ERR325,
      ERR327, ERR329, ERR330, ERR331, ERR333, ERR335, ERR336, ERR337, ERR338,
      ERR339, ERR341, ERR343, ERR345, ERR351, ERR353, ERR355, ERR357, ERR361,
      ERR363, ERR401, ERR402, ERR403, ERR405, ERR501, ERR502, ERR503, ERR504,
	  ERR505, ERR506, ERR507, ERR508, ERR509, ERR140];                         //(5.1.015)

ErrorCodes =
    [ 0,      101,    103,    105,    107,    108,    109,    110,    111,
      112,    113,    114,    115,    117,    119,    121,    122,    131,
      133,    134,    135,    136,    137,    138,    139,    141,    143,
      145,    151,    153,    155,    156,    157,    158,    159,    161,
      171,    173,    181,    182,    183,    184,    185,    186,    187,
      188,    191,    193,    195,    200,    201,    203,    205,    207,
      209,    211,    213,    217,    219,    221,    223,    225,    227,
      229,    231,    233,    301,    303,    305,    307,    309,    311,
      313,    315,    317,    318,    319,    320,    321,    323,    325,
      327,    329,    330,    331,    333,    335,    336,    337,    338,
      339,    341,    343,    345,    351,    353,    355,    357,    361,
      363,    401,    402,    403,    405,    501,    502,    503,    504,
	  505,    506,    507,    508,    509,    140];                            //(5.1.015)

 ErrString;

error_getMsg(i)
{
    if ( i >= 0 && i < MAXERRMSG ) return ErrorMsgs[i];
    else return ErrorMsgs[0];
};

 error_getCode(i)
{
    if ( i >= 0 && i < MAXERRMSG ) return ErrorCodes[i];
    else return 0;
}

 error_setInpError(errcode, s)
{
    //strcpy(ErrString, s);
    ErrString = s;
    return errcode;
}


//-----------------------------------------------------------------------------
//   datetime.h
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             08/01/16   (Build 5.1.011)
//   Author:   L. Rossman
//
//   The DateTime type is used to store date and time values. It is
//   equivalent to a double floating point type.
//
//   The integral part of a DateTime value is the number of days that have
//   passed since 12/31/1899. The fractional part of a DateTime value is the
//   fraction of a 24 hour day that has elapsed.
//
//   Build 5.1.011
//   - New getTimeStamp added.
//-----------------------------------------------------------------------------

//typedef double DateTime;

Y_M_D = 0
M_D_Y = 1
D_M_Y = 2
NO_DATE = -693594 // 1/1/0001
DATE_STR_SIZE = 12
TIME_STR_SIZE = 9

//-----------------------------------------------------------------------------
//   datetime.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             08/01/16   (Build 5.1.011)
//   Author:   L. Rossman
//
//   DateTime functions.
//
//   Build 5.1.011
//   - decodeTime() no longer rounds up.
//   - New getTimeStamp added.
//
//-----------------------------------------------------------------------------


// Macro to convert character x to upper case
UCHAR(x) {
    return x.toUpperCase();
}

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
MonthTxt =
    ["JAN", "FEB", "MAR", "APR",
     "MAY", "JUN", "JUL", "AUG",
     "SEP", "OCT", "NOV", "DEC"];
DaysPerMonth =      // days per month
    [[31, 28, 31, 30, 31, 30,               // normal years
      31, 31, 30, 31, 30, 31],
     [31, 29, 31, 30, 31, 30,               // leap years
      31, 31, 30, 31, 30, 31]];
DateDelta = 693594;        // days since 01/01/00
SecsPerDay = 86400.;    // seconds per day

//=============================================================================

////////////////////////////////////
//returnObj = {result: i, remainder: d}
//divMod(t, D100, returnObj);
//i = returnObj.result;
//d = returnObj.remainder;
////////////////////////////////////
divMod(n, d, inObj)
//void divMod(int n, int d, int* result, int* remainder)
//  Input:   n = numerator
//           d = denominator
//  Output:  result = integer part of n/d
//           remainder = remainder of n/d
//  Purpose: finds integer part and remainder of n/d.
{
    if (d == 0)
    {
        inObj.result = 0;
        inObj.remainder = 0;
    }
    else
    {
        inObj.result = Math.trunc(n/d);
        inObj.remainder = n - d*(inObj.result);
    }
}

//=============================================================================

isLeapYear(year)
//  Input:   year = a year
//  Output:  returns 1 if year is a leap year, 0 if not
//  Purpose: determines if year is a leap year.
{
    if ((year % 4   == 0)
    && ((year % 100 != 0)
    ||  (year % 400 == 0))) return 1;
    else return 0;
}

//=============================================================================

datetime_findMonth(month)
//  Input:   month = month of year as character string
//  Output:  returns: month of year as a number (1-12)
//  Purpose: finds number (1-12) of month.
{
    let i;
    for (i = 0; i < 12; i++)
    {
        //if (UCHAR(month[0]) == MonthTxt[i][0]
        //&&  UCHAR(month[1]) == MonthTxt[i][1]
        //&&  UCHAR(month[2]) == MonthTxt[i][2]) return i+1;
        if(month.toUpperCase() === MonthTxt[i].toUpperCase()){
            return i+1;
        }
    }
    return 0;
}

//=============================================================================

datetime_encodeDate(year, month, day)
//DateTime datetime_encodeDate(int year, int month, int day)
//  Input:   year = a year
//           month = a month (1 to 12)
//           day = a day of month
//  Output:  returns encoded value of year-month-day
//  Purpose: encodes year-month-day to a DateTime value.
{
    let i, j;
    i = isLeapYear(year);
    if ((year >= 1)
    && (year <= 9999)
    && (month >= 1)
    && (month <= 12)
    && (day >= 1)
    && (day <= DaysPerMonth[i][month-1]))
    {
        for (j = 0; j < month-1; j++) day += DaysPerMonth[i][j];
        i = year - 1;
        return i*365 + i/4 - i/100 + i/400 + day - DateDelta;
    }
    else return -DateDelta;
}

//=============================================================================

datetime_encodeTime(hour, minute, second)
//  Input:   hour = hour of day (0-24)
//           minute = minute of hour (0-60)
//           second = seconds of minute (0-60)
//  Output:  returns time encoded as fractional part of a day
//  Purpose: encodes hour:minute:second to a DateTime value
{
    let s;
    if ((hour >= 0)
    && (minute >= 0)
    && (second >= 0))
    {
        s = (hour * 3600 + minute * 60 + second);
        return s/SecsPerDay;
    }
    else return 0.0;
}

//=============================================================================

//datetime_decodeDate(date, year, month, day)
datetime_decodeDate(date, inObj)
//  Input:   date = encoded date/time value
//  Output:  year = 4-digit year
//           month = month of year (1-12)
//           day   = day of month
//  Purpose: decodes DateTime value to year-month-day.
{
    let  D1, D4, D100, D400;
    let  y, m, d, i, k, t;
    let returnObj;

    D1 = 365;              //365
    D4 = D1 * 4 + 1;       //1461
    D100 = D4 * 25 - 1;    //36524
    D400 = D100 * 4 + 1;   //146097

    t = (Math.floor(date)) + DateDelta;
    if (t <= 0)
    {
        inObj.year = 0;
        inObj.month = 1;
        inObj.day = 1;
    }
    else
    {
        t--;
        y = 1;
        while (t >= D400)
        {
            t -= D400;
            y += 400;
        }
        //divMod(t, D100, i, d);
        ////////////////////////////////////
        returnObj = {result: i, remainder: d}
        divMod(t, D100, returnObj);
        i = returnObj.result;
        d = returnObj.remainder;
        ////////////////////////////////////

        if (i == 4)
        {
            i--;
            d += D100;
        }
        y += i*100;

        //divMod(d, D4, &i, &d);
        ////////////////////////////////////
        returnObj = {result: i, remainder: d}
        divMod(d, D4, returnObj);
        i = returnObj.result;
        d = returnObj.remainder;
        ////////////////////////////////////

        y += i*4;
        //divMod(d, D1, i, d);
        ////////////////////////////////////
        returnObj = {result: i, remainder: d}
        divMod(d, D1, returnObj);
        i = returnObj.result;
        d = returnObj.remainder;
        ////////////////////////////////////
        if (i == 4)
        {
            i--;
            d += D1;
        }
        y += i;
        k = isLeapYear(y);
        m = 1;
        for (;;)
        {
            i = DaysPerMonth[k][m-1];
            if (d < i) break;
            d -= i;
            m++;
        }
        inObj.year = y;
        inObj.month = m;
        inObj.day = d + 1;
    }
}

//=============================================================================

//datetime_decodeTime(time, h, m, s)
//let returnObj = {h: inObj.hrs, m: inObj.mins, s: secs}
//datetime_decodeTime(x, returnObj);
//inObj.hrs = returnObj.h;
//inObj.mins = returnObj.m;
//inObj.secs = returnObj.s;
datetime_decodeTime(time, inObj)
//  Input:   time = decimal fraction of a day
//  Output:  h = hour of day (0-23)
//           m = minute of hour (0-59)
//           s = second of minute (0-59)
//  Purpose: decodes DateTime value to hour:minute:second.
{
    let secs;
    let mins;
    let fracDay = (time - Math.floor(time)) * SecsPerDay;
    let returnObj;

    secs = (Math.floor(fracDay + 0.5));
    if ( secs >= 86400 ) secs = 86399;
    //divMod(secs, 60, mins, s);
    ////////////////////////////////////
    returnObj = {result: mins, remainder: inObj.s}
    divMod(secs, 60, returnObj);
    mins = returnObj.result;
    inObj.s = returnObj.remainder;
    ////////////////////////////////////
    //divMod(mins, 60, h, m);
    ////////////////////////////////////
    returnObj = {result: inObj.h, remainder: inObj.m}
    divMod(mins, 60, returnObj);
    inObj.h = returnObj.result;
    inObj.m = returnObj.remainder;
    ////////////////////////////////////
    if ( inObj.h > 23 ) inObj.h = 0;
}

//=============================================================================

datetime_dateToStr(date, s)
//  Input:   date = encoded date/time value
//  Output:  s = formatted date string
//  Purpose: represents DateTime date value as a formatted string.
{
    let  y, m, d;
    let dateStr = new Array(DATE_STR_SIZE);
    //datetime_decodeDate(date, y, m, d);
    ////////////////////////////////////
    let returnObj = {year: y, month: m, day: d}
    datetime_decodeDate(date, returnObj);
    y = returnObj.year;
    m = returnObj.month;
    d = returnObj.day;
    ////////////////////////////////////
    switch (DateFormat)
    {
      case Y_M_D:
        //sprintf(dateStr, "%4d-%3s-%02d", y, MonthTxt[m-1], d);
        dateStr = y.toString().padStart(4, "0") 
                    + '-'
                    + MonthTxt[m-1]
                    + '-'
                    + d.toString().padStart(2, "0")
        break;

      case M_D_Y:
        //sprintf(dateStr, "%3s-%02d-%4d", MonthTxt[m-1], d, y);
        //sprintf(dateStr, "%02d/%02d/%04d", m, d, y);
        dateStr = m.toString().padStart(2, "0")
                    + '/'
                    + d.toString().padStart(2, "0")
                    + '/'
                    + y.toString().padStart(4, "0") 
        break;

      default:
        //sprintf(dateStr, "%02d-%3s-%4d", d, MonthTxt[m-1], y);
        dateStr = d.toString().padStart(2, "0")
                    + '-'
                    + MonthTxt[m-1]
                    + '-'
                    + y.toString().padStart(4, "0") 
    }
    s = dateStr;

    return s;
}

//=============================================================================

datetime_timeToStr(time, s)
//  Input:   time = decimal fraction of a day
//  Output:  s = time in hr:min:sec format
//  Purpose: represents DateTime time value as a formatted string.
{
    let  hr, min, sec;
    let timeStr;
    //datetime_decodeTime(time, hr, min, sec);
    ////////////////////////////////////
    let returnObj = {h: hr, m: min, s: sec}
    datetime_decodeTime(time, returnObj);
    hr = returnObj.h;
    min = returnObj.m;
    sec = returnObj.s;
    ////////////////////////////////////
    //sprintf(timeStr, "%02d:%02d:%02d", hr, min, sec);
    timeStr = hr.toString().padStart(2, "0")
                + ':'
                + min.toString().padStart(2, "0")
                + ':'
                + sec.toString().padStart(2, "0")
    //strcpy(s, timeStr);
    s = timeStr;

    return s;
}

//=============================================================================

////////////////////////////////////
//let returnObj = {d: val1}
//datetime_strToDate(time, returnObj);
//val1 = returnObj.d;
////////////////////////////////////
datetime_strToDate(s, inObj)
//int datetime_strToDate(char* s, DateTime* d)
//  Input:   s = date as string
//  Output:  d = encoded date;
//           returns 1 if conversion successful, 0 if not
//  Purpose: converts string date s to DateTime value.
//
{
    let  yr = 0, mon = 0, day = 0, n;
    let month;
    let sep1, sep2;
    inObj.d = -DateDelta;
    //if (strchr(s, '-') || strchr(s, '/'))
    if (s.includes('-') || s.includes('/'))
    {
        switch (DateFormat)
        {
          case Y_M_D:
            // Scan string s for the year, month, and day
            //n = sscanf(s, "%d%c%d%c%d", &yr, &sep1, &mon, &sep2, &day);
            vals = s.split(/[-//]+/)
            n = vals.length
            yr = parseInt(vals[0])
            mon = parseInt(vals[1])
            day = parseInt(vals[2])
            if ( n < 3 )
            {
                return 0;
            }
            break;

          case D_M_Y:
            //n = sscanf(s, "%d%c%d%c%d", day, sep1, mon, sep2, yr);
            vals = s.split(/[-//]+/)
            n = vals.length
            yr = parseInt(vals[2])
            mon = parseInt(vals[1])
            day = parseInt(vals[0])
            if ( n < 3 )
            {
                return 0;
            }
            break;

          default: // M_D_Y
            //n = sscanf(s, "%d%c%d%c%d", mon, sep1, day, sep2, yr);
            vals = s.split(/[-//]+/)
            n = vals.length
            yr = parseInt(vals[2])
            mon = parseInt(vals[0])
            day = parseInt(vals[1])
            if ( n < 3 )
            {
                return 0;
            }
            break;
        }
        //if (!(/\d/.test(mon))) mon = datetime_findMonth(month);
        if (mon == 0) mon = datetime_findMonth(month);
        inObj.d = datetime_encodeDate(yr, mon, day);
    }
    if (inObj.d == -DateDelta) return 0;
    else return 1;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {t: val1}
//let returnVal = datetime_strToTime(formula, returnObj);
//val1 = returnObj.t;
////////////////////////////////////
datetime_strToTime(s, inObj)
//datetime_strToTime(s, t)
//  Input:   s = time as string
//  Output:  t = encoded time,
//           returns 1 if conversion successful, 0 if not
//  Purpose: converts a string time to a DateTime value.
//  Note:    accepts time as hr:min:sec or as decimal hours.
{
    let  n, hr, min = 0, sec = 0;

    // Attempt to read time as decimal hours
    inObj.t = parseInt(s);
    if ( inObj.t == NaN )
    {
        inObj.t /= 24.0;
        return t;
    }

    // Read time in hr:min:sec format
    inObj.t = 0.0;
    //n = sscanf(s, "%d:%d:%d", &hr, &min, &sec);
    vals = s.split(/[:]+/)
            n = vals.length
            //hr = parseInt(vals[n-3])
            //min = parseInt(vals[n-2])
            //sec = parseInt(vals[n-1])
            hr = parseInt(vals[0])
            min = parseInt(vals[1])
            sec = parseInt(vals[2])
    if ( n == 0 ) return 0;
    if(isNaN(hr)) hr = 0;
    if(isNaN(min)) min = 0;
    if(isNaN(sec)) sec = 0;
    inObj.t = datetime_encodeTime(hr, min, sec);
    if ( (hr >= 0) && (min >= 0) && (sec >= 0) ) return 1;
    
    // conversion not successful
    else return 0;
}

//=============================================================================

datetime_setDateFormat(fmt)
//  Input:   fmt = date format code
//  Output:  none
//  Purpose: sets date format
{
    if ( fmt >= Y_M_D && fmt <= M_D_Y) DateFormat = fmt;
}

//=============================================================================

datetime_addSeconds(date1, seconds)
//  Input:   date1 = an encoded date/time value
//           seconds = number of seconds to add to date1
//  Output:  returns updated value of date1
//  Purpose: adds a given number of seconds to a date/time.
{
    let d = Math.floor(date1);
    let h, m, s;
    //datetime_decodeTime(date1, h, m, s);
    ////////////////////////////////////
    let returnObj = {h: h, m: m, s: s}
    datetime_decodeTime(date1, returnObj);
    h = returnObj.h;
    m = returnObj.m;
    s = returnObj.s;
    ////////////////////////////////////
    return d + (3600.0*h + 60.0*m + s + seconds)/SecsPerDay;
}

//=============================================================================

datetime_addDays(date1, date2)
//  Input:   date1 = an encoded date/time value
//           date2 = decimal days to be added to date1
//  Output:  returns date1 + date2
//  Purpose: adds a given number of decimal days to a date/time.
{
    let d1 = Math.floor(date1);
    let d2 = Math.floor(date2);
    let h1, m1, s1;
    let h2, m2, s2;
    let returnObj;

    //datetime_decodeTime(date1, h1, m1, s1);
    ////////////////////////////////////
    returnObj = {h: h1, m: m1, s: s1}
    datetime_decodeTime(date1, returnObj);
    h1 = returnObj.h;
    m1 = returnObj.m;
    s1 = returnObj.s;
    ////////////////////////////////////
    //datetime_decodeTime(date2, h2, m2, s2);
    ////////////////////////////////////
    returnObj = {h: h2, m: m2, s: s2}
    datetime_decodeTime(date2, returnObj);
    h2 = returnObj.h;
    m2 = returnObj.m;
    s2 = returnObj.s;
    ////////////////////////////////////
    return d1 + d2 + datetime_encodeTime(h1+h2, m1+m2, s1+s2);
}

//=============================================================================

datetime_timeDiff(date1, date2)
//  Input:   date1 = an encoded date/time value
//           date2 = an encoded date/time value
//  Output:  returns date1 - date2 in seconds
//  Purpose: finds number of seconds between two dates.
{
    let d1 = Math.floor(date1);
    let d2 = Math.floor(date2);
    let    h, m, s;
    let   s1, s2, secs;
    let returnObj;
    //datetime_decodeTime(date1, h, m, s);
    ////////////////////////////////////
    returnObj = {h: h, m: m, s: s}
    datetime_decodeTime(date1, returnObj);
    h = returnObj.h;
    m = returnObj.m;
    s = returnObj.s;
    ////////////////////////////////////
    s1 = 3600*h + 60*m + s;
    //datetime_decodeTime(date2, h, m, s);
    ////////////////////////////////////
    returnObj = {h: h, m: m, s: s}
    datetime_decodeTime(date2, returnObj);
    h = returnObj.h;
    m = returnObj.m;
    s = returnObj.s;
    ////////////////////////////////////
    s2 = 3600*h + 60*m + s;
    secs = (Math.floor((d1 - d2)*SecsPerDay + 0.5));
    secs += (s1 - s2);
    return secs;
}

//=============================================================================

 datetime_monthOfYear(date)
//  Input:   date = an encoded date/time value
//  Output:  returns index of month of year (1..12)
//  Purpose: finds month of year (Jan = 1 ...) for a given date.
{
    let year, month, day;
    //datetime_decodeDate(date, year, month, day);
    ////////////////////////////////////
    let returnObj = {year: year, month: month, day: day}
    datetime_decodeDate(date, returnObj);
    year = returnObj.year;
    month = returnObj.month;
    day = returnObj.day;
    ////////////////////////////////////
    return month;
}

//=============================================================================

 datetime_dayOfYear(date)
//  Input:   date = an encoded date/time value
//  Output:  returns day of year (1..365)
//  Purpose: finds day of year (Jan 1 = 1) for a given date.
{
    let year, month, day;
    let startOfYear;
    //datetime_decodeDate(date, year, month, day);
    ////////////////////////////////////
    let returnObj = {year: year, month: month, day: day}
    datetime_decodeDate(date, returnObj);
    year = returnObj.year;
    month = returnObj.month;
    day = returnObj.day;
    ////////////////////////////////////
    startOfYear = datetime_encodeDate(year, 1, 1);
    return (Math.floor(date - startOfYear)) + 1;
}

//=============================================================================

datetime_dayOfWeek(date)
//  Input:   date = an encoded date/time value
//  Output:  returns index of day of week (1..7)
//  Purpose: finds day of week (Sun = 1, ... Sat = 7) for a given date.
{
    let t = (Math.floor(date)) + DateDelta;
    return (t % 7) + 1;
}

//=============================================================================

 datetime_hourOfDay(date)
//  Input:   date = an encoded date/time value
//  Output:  returns hour of day (0..23)
//  Purpose: finds hour of day (0 = 12 AM, ..., 23 = 11 PM) for a given date.
{
    let hour, min, sec;
    //datetime_decodeTime(date, hour, min, sec);
    ////////////////////////////////////
    let returnObj = {h: hour, m: min, s: sec}
    datetime_decodeTime(date, returnObj);
    hour = returnObj.h;
    min = returnObj.m;
    sec = returnObj.s;
    ////////////////////////////////////
    return hour;
}

//=============================================================================

 datetime_daysPerMonth(year, month)
//  Input:   year = year in which month falls
//           month = month of year (1..12)
//  Output:  returns number of days in the month
//  Purpose: finds number of days in a given month of a specified year.
{
    if ( month < 1 || month > 12 ) return 0;
    return DaysPerMonth[isLeapYear(year)][month-1];
}

//=============================================================================
////////////////////////////////////
//let returnObj = {timeStamp: val}
//datetime_getTimeStamp(fmt, aDate, stampSize, returnObj);
//val = returnObj.h;
////////////////////////////////////
//datetime_getTimeStamp(fmt, aDate, stampSize, timeStamp)
datetime_getTimeStamp(fmt, aDate, stampSize, inObj)

//  Input:   fmt = desired date format code
//           aDate = a date/time value in decimal days
//           stampSize = the number of bytes allocated for the time stamp
//  Output:  returns a time stamp string (e.g., Year-Month-Day Hr:Min:Sec)
//  Purpose: Expresses a decimal day date by a time stamp.
{
    let dateStr;
    let timeStr;
    let oldDateFormat = DateFormat;
    
    if ( stampSize < DATE_STR_SIZE + TIME_STR_SIZE + 2 ) return;
    datetime_setDateFormat(fmt);     
    dateStr = datetime_dateToStr(aDate, dateStr);
    DateFormat = oldDateFormat;
    timeStr = datetime_timeToStr(aDate, timeStr);
    //sprintf(timeStamp, "%s %s", dateStr, timeStr);
    inObj.timeStamp = dateStr + ' ' + timeStr;
}

/******************************************************************************
**  MODULE:        MATHEXPR.H
**  PROJECT:       SWMM 5.1
**  DESCRIPTION:   header file for the math expression parser in mathexpr.c.
**  AUTHORS:       L. Rossman, US EPA - NRMRL
**                 F. Shang, University of Cincinnati
**  VERSION:       5.1.001
**  LAST UPDATE:   03/20/14
******************************************************************************/

//  Node in a tokenized math expression list
ExprNode
{
    constructor(){
        this.opcode;                // operator code
        this.ivar;                  // variable index
        this.fvalue;                // numerical value
        this.prev; // = new ExprNode();        // previous node
        this.next; // = new ExprNode();        // next node
    }
};

class MathExpr{
    constructor(){
        this.opcode;                // operator code
        this.ivar;                  // variable index
        this.fvalue;                // numerical value
        prev = new ExprNode();        // previous node
        next = new ExprNode();        // next node
    }
}

/******************************************************************************
**  MODULE:        MATHEXPR.C
**  PROJECT:       EPA SWMM 5.1
**  DESCRIPTION:   Evaluates symbolic mathematical expression consisting
**                 of numbers, variable names, math functions & arithmetic
**                 operators.
**  AUTHORS:       L. Rossman, US EPA - NRMRL
**                 F. Shang, University of Cincinnati
**  VERSION:       5.1.008
**  LAST UPDATE:   04/01/15
******************************************************************************/
/*
**   Operand codes:
** 	   1 = (
** 	   2 = )
** 	   3 = +
** 	   4 = - (subtraction)
** 	   5 = *
** 	   6 = /
** 	   7 = number
** 	   8 = user-defined variable
** 	   9 = - (negative)
**	  10 = cos
**	  11 = sin
**	  12 = tan
**	  13 = cot
**	  14 = abs
**	  15 = sgn
**	  16 = sqrt
**	  17 = log
**	  18 = exp
**	  19 = asin
**	  20 = acos
**	  21 = atan
**	  22 = acot
**    23 = sinh
**	  24 = cosh
**	  25 = tanh
**	  26 = coth
**	  27 = log10
**    28 = step (x<=0 ? 0 : 1)
**	  31 = ^
******************************************************************************/


MAX_STACK_SIZE = 1024

//  Local declarations
//--------------------
//  Structure for binary tree representation of math expression
class TreeNode
{
    constructor(){
        this.opcode;                // operator code
        this.ivar;                  // variable index
        this.fvalue;                // numerical value
        this.left; //= new TreeNode();        // left sub-tree of tokenized formula
        this.right; //= new TreeNode();       // right sub-tree of tokenized formula
    }
};
//  Structure for binary tree representation of math expression
class ExprTree
{
    constructor(){
        this.opcode;                // operator code
        this.ivar;                  // variable index
        this.fvalue;                // numerical value
        this.left; //= new TreeNode();        // left sub-tree of tokenized formula
        this.right; //= new TreeNode();       // right sub-tree of tokenized formula
    }
};


// Local variables
//----------------
Err;
Bc;
PrevLex, CurLex;
Len, Pos;
S;
Token;
Ivar;
Fvalue;

// math names
MathFunc =  ["COS", "SIN", "TAN", "COT", "ABS", "SGN",
                     "SQRT", "LOG", "EXP", "ASIN", "ACOS", "ATAN",
                     "ACOT", "SINH", "COSH", "TANH", "COTH", "LOG10",
                     "STEP", null];

// Local functions
//----------------
//static int        sametext(char *, char *);
//static int        isDigit(char);
//static int        isLetter(char);
//static void       getToken(void);
//static int        getMathFunc(void);
//static int        getVariable(void);
//static int        getOperand(void);
//static int        getLex(void);
//static double     getNumber(void);
//static ExprTree * newNode(void);
//static ExprTree * getSingleOp(int *);
//static ExprTree * getOp(int *);
//static ExprTree * getTree(void);
//static void       traverseTree(ExprTree *, MathExpr **);
//static void       deleteTree(ExprTree *);

// Callback functions
// static int    (*getVariableIndex) (char *); // return index of named variable

//=============================================================================
// char *s1, char *s2
 sametext(s1, s2)
/*
**  Purpose:
**    performs case insensitive comparison of two strings.
**
**  Input:
**    s1 = character string
**    s2 = character string.
**  
**  Returns:
**    1 if strings are the same, 0 otherwise.
*/
{
   if(s1.localeCompare(s2) == 0){
       return 1;
   } else {
       return 0;
   }
}

//=============================================================================
// char c
isDigit(c)
{
    if(Number.isInteger(c.parseInt())){
        return 1;
    } else {
        return 0;
    }
}

//=============================================================================
// char c
// returns: 1 if the character is a letter or an underscore.
isLetter(c)
{
    if((/[a-zA-Z_]/).test(c)){
        return 1;
    } else {
        return 0;
    }
}

setCharAt(str, index, chr){
    if(index > str.length-1) return str;
    return str.substring(0, index) + chr + str.substring(index + 1);
}

//=============================================================================

getToken()
{
    let c = " ";
    Token = "";
    while ( Pos <= Len &&
        ( isLetter(S.substring(Pos, Pos + 1)) || isDigit(S.substring(Pos, Pos + 1) ) )) 
    {
        c = setCharAt(c, 0, S.substring(Pos, Pos + 1))
        c = S.substring(Pos, Pos + 1)
        Token += c;
        Pos++;
    }
    Pos--;
}

//=============================================================================

getMathFunc()
{
    let i = 0;
    while (MathFunc[i] != null)
    {
        if (sametext(MathFunc[i], Token)) return i+10;
        i++;
    }
    return(0);
}

//=============================================================================

getVariable()
{
    if ( !getVariableIndex ) return 0;
    I= getVariableIndex(Token);
    if (I>= 0) return 8;
    return 0;
}

//=============================================================================

getNumber()
{
    let c = " ";
    let sNumber;
    let errflag = 0;

    /* --- get whole number portion of number */
    sNumber = "";
    while (Pos < Len && isDigit(S.substring(Pos, Pos + 1)))
    {
        //c[0] = S[Pos]
        c = setCharAt(c, 0, S.substring(Pos, Pos + 1))
        sNumber += c;
        Pos++;
    }

    /* --- get fractional portion of number */
    if (Pos < Len)
    {
        if (S.substring(Pos, Pos + 1) === '.')
        {
            sNumber += ".";
            Pos++;
            while (Pos < Len && isDigit(S.substring(Pos, Pos + 1)))
            {
                c = setCharAt(c, 0, S.substring(Pos, Pos + 1))
                sNumber += c;  
                Pos++;
            }
        }

        /* --- get exponent */
        if (Pos < Len && (S.substring(Pos, Pos + 1) === 'e' || S.substring(Pos, Pos + 1) === 'E'))
        {
            sNumber += "E";  
            Pos++;
            if (Pos >= Len) errflag = 1;
            else
            {
                if (S.substring(Pos, Pos + 1) == '-' || S.substring(Pos, Pos + 1) == '+')
                {
                    c = setCharAt(c, 0, S.substring(Pos, Pos + 1))
                    sNumber += c;  
                    Pos++;
                }
                if (Pos >= Len || !isDigit(S.substring(Pos, Pos + 1))) errflag = 1;
                else while ( Pos < Len && isDigit(S.substring(Pos, Pos + 1)))
                {
                    c = setCharAt(c, 0, S.substring(Pos, Pos + 1))
                    sNumber += c;  
                    Pos++;
                }
            }
        }
    }
    Pos--;
    if (errflag) return 0;
    else return sNumber.parseFloat();
}

//=============================================================================

getOperand()
{
    let code;
    switch(S.substring(Pos, Pos + 1))
    {
      case '(': code = 1;  break;
      case ')': code = 2;  break;
      case '+': code = 3;  break;
      case '-': code = 4;
        if (Pos < Len-1 &&
            isDigit(S.substring(Pos+1, Pos + 2)) &&
            (CurLex == 0 || CurLex == 1))
        {
            Pos++;
            Fvalue = -getNumber();
            code = 7;
        }
        break;
      case '*': code = 5;  break;
      case '/': code = 6;  break;
      case '^': code = 31; break;
      default:  code = 0;
    }
    return code;
}

//=============================================================================

getLex()
{
    let n;

    /* --- skip spaces */
    while ( Pos < Len && S.substring(Pos, Pos + 1) === ' ' ) Pos++;
    if ( Pos >= Len ) return 0;

    /* --- check for operand */
    n = getOperand();

    /* --- check for function/variable/number */
    if ( n == 0 )
    {
        if ( isLetter(S.substring(Pos, Pos + 1)) )
        {
            getToken();
            n = getMathFunc();
            if ( n == 0 ) n = getVariable();
        }
        else if ( isDigit(S.substring(Pos, Pos + 1)) )
        {
            n = 7;
            Fvalue = getNumber();
        }
    }
    Pos++;
    PrevLex = CurLex;
    CurLex = n;
    return n;
}

//=============================================================================

newNode()
{
    //ExprTree *node;
    //node = (ExprTree *) malloc(sizeof(ExprTree));
    node = new ExprTree()
    if (!node) Err = 2;
    else
    {
        node.opcode = 0;
        node.i  = -1;
        node.fvalue = 0.;
        node.left   = null;
        node.right  = null;
    }
    return node;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {lex: val}
//let returnVal = getSingleOp(returnObj);
//val = returnObj.lex;
////////////////////////////////////
//int *lex
getSingleOp(inObj)
{
    let bracket;
    let opcode;
    //ExprTree *left;
    //ExprTree *right;
    //ExprTree *node;
    let left;
    let right;
    let node;

    /* --- open parenthesis, so continue to grow the tree */
    if ( inObj.lex == 1 )
    {
        Bc++;
        left = getTree();
    }

    else
    {
        /* --- Error if not a singleton operand */
        if ( inObj.lex < 7 || inObj.lex == 9 || inObj.lex > 30)
        {
            Err = 1;
            return null;
        }

        opcode = inObj.lex;

        /* --- simple number or variable name */
        if ( inObj.lex == 7 || inObj.lex == 8 )
        {
            left = newNode();
            left.opcode = opcode;
            if ( inObj.lex == 7 ) left.fvalue = Fvalue;
            if ( inObj.lex == 8 ) left.i= Ivar;
        }

        /* --- which must have a '(' after it */
        else
        {
            inObj.lex = getLex();
            if ( inObj.lex != 1 )
            {
               Err = 1;
               return null;
            }
            Bc++;
            left = newNode();
            left.left = getTree();
            left.opcode = opcode;
        }
    }   
    inObj.lex = getLex();

    /* --- exponentiation */
    while ( inObj.lex == 31 )
    {
        inObj.lex = getLex();
        bracket = 0;
        if ( inObj.lex == 1 )
        {
            bracket = 1;
            inObj.lex = getLex();
        }
        if ( inObj.lex != 7 )
        {
            Err = 1;
            return null;
        }
        right = newNode();
        right.opcode = inObj.lex;
        right.fvalue = Fvalue;
        node = newNode();
        node.left = left;
        node.right = right;
        node.opcode = 31;
        left = node;
        if (bracket)
        {
            inObj.lex = getLex();
            if ( inObj.lex != 2 )
            {
                Err = 1;
                return null;
            }
        }
        inObj.lex = getLex();
    }
    return left;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {lex: val}
//let returnVal = getOp(returnObj);
//val = returnObj.lex;
////////////////////////////////////
getOp(inObj)
//ExprTree * getOp(int *lex)
{
    let opcode;
    //ExprTree *left;
    //ExprTree *right;
    //ExprTree *node;
    let left;
    let right;
    let node;
    let neg = 0;

    // Return object & value
    let returnObj;
    let returnVal;

    inObj.lex = getLex();
    if (PrevLex == 0 || PrevLex == 1)
    {
        if ( inObj.lex == 4 )
        {
            neg = 1;
            inObj.lex = getLex();
        }
        else if ( inObj.lex == 3) inObj.lex = getLex();
    }

    ////////////////////////////////////
    returnObj = {lex: inObj.lex}
    returnVal = getSingleOp(returnObj);
    inObj.lex = returnObj.lex;
    ////////////////////////////////////
    left = returnVal;
    //left = getSingleOp(lex);
    while ( inObj.lex == 5 || inObj.lex == 6 )
    {
        opcode = inObj.lex;
        inObj.lex = getLex();

        ////////////////////////////////////
        returnObj = {lex: inObj.lex}
        returnVal = getSingleOp(returnObj);
        inObj.lex = returnObj.lex;
        ////////////////////////////////////
        right = returnVal;
        //right = getSingleOp(lex);
        node = newNode();
        if (Err) return null;
        node.left = left;
        node.right = right;
        node.opcode = opcode;
        left = node;
    }
    if ( neg )
    {
        node = newNode();
        if (Err) return null;
        node.left = left;
        node.right = null;
        node.opcode = 9;
        left = node;
    }
    return left;
}

//=============================================================================

getTree()
//ExprTree * getTree()
{
    let      lex;
    let      opcode;
    //ExprTree *left;
    //ExprTree *right;
    //ExprTree *node;
    let left;
    let right;
    let node;

    // return facilitators
    let returnObj;
    let returnVal;

    ////////////////////////////////////
    returnObj = {lex: lex}
    returnVal = getOp(returnObj);
    lex = returnObj.lex;
    ////////////////////////////////////
    left = returnVal;
    //left = getOp(&lex);
    for (;;)
    {
        if ( lex == 0 || lex == 2 )
        {
            if ( lex == 2 ) Bc--;
            break;
        }

        if (lex != 3 && lex != 4 )
        {
            Err = 1;
            break;
        }

        opcode = lex;
        ////////////////////////////////////
        returnObj = {lex: lex}
        returnVal = getOp(returnObj);
        lex = returnObj.lex;
        ////////////////////////////////////
        right = returnVal;
        //right = getOp(&lex);
        node = newNode();
        if (Err) break;
        node.left = left;
        node.right = right;
        node.opcode = opcode;
        left = node;
    } 
    return left;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {tree: val1, expr: val2}
//let returnVal = traverseTree(returnObj);
//val1 = returnObj.tree;
//val2 = returnObj.expr;
////////////////////////////////////
traverseTree(inObj)
//void traverseTree(ExprTree *tree, MathExpr **expr)
// Converts binary tree to linked list (postfix format)
{
    //MathExpr *node;
    let node;

    // return facilitators
    let returnObj;
    let returnVal;

    if ( inObj.tree == null) return;

    ////////////////////////////////////
    returnObj = {tree: inObj.tree.left, expr: inObj.expr}
    returnVal = traverseTree(returnObj);
    inObj.tree.left = returnObj.tree;
    inObj.expr = returnObj.expr;
    ////////////////////////////////////
    //traverseTree(inObj.tree.left,  inObj.expr);
    ////////////////////////////////////
    returnObj = {tree: inObj.tree.right, expr: inObj.expr}
    returnVal = traverseTree(returnObj);
    inObj.tree.right = returnObj.tree;
    inObj.expr = returnObj.expr;
    ////////////////////////////////////
    //traverseTree(inObj.tree.right, inObj.expr);

    //node = (MathExpr *) malloc(sizeof(MathExpr));
    node = new MathExpr();
    node.fvalue = inObj.tree.fvalue;
    node.opcode = inObj.tree.opcode;
    node.i= inObj.tree.ivar;
    node.next = null;
    node.prev = (inObj.expr);
    if (inObj.expr) (inObj.expr).next = node;
    (inObj.expr) = node;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {tree: val1}
//let returnVal = deleteTree(returnObj);
//val1 = returnObj.tree;
////////////////////////////////////
deleteTree(inObj)
//void deleteTree(ExprTree *tree)
{
    // return facilitators
    let returnObj;
    let returnVal;

    if (inObj.tree)
    {
        if (inObj.tree.left){
            ////////////////////////////////////
            returnObj = {tree: inObj.tree.left}
            returnVal = deleteTree(returnObj);
            inObj.tree.left = returnObj.tree;
            ////////////////////////////////////
            //deleteTree(inObj.tree.left);
        }
        if (inObj.tree.right){
            ////////////////////////////////////
            returnObj = {tree: inObj.tree.right}
            returnVal = deleteTree(returnObj);
            inObj.tree.right = returnObj.tree;
            ////////////////////////////////////
            //deleteTree(inObj.tree.right);
        }
        inObj.tree = null;
    }
}

//=============================================================================

// Turn on "precise" floating point option
//#pragma float_control(precise, on, push)
//float_control(precise, on, push)


////////////////////////////////////
//let returnObj = {expr: val1, getVariableValue: function(){return result;}}
//let returnVal = mathexpr_eval(returnObj);
//val1 = returnObj.expr;
////////////////////////////////////
mathexpr_eval(inObj)
//double mathexpr_eval(MathExpr *expr, double (*getVariableValue) (int))
//  Mathematica expression evaluation using a stack
{
    
// --- Note: the ExprStack array must be declared locally and not globally
//     since this can be called recursively.

    ExprStack = new Array(MAX_STACK_SIZE);
    //MathExpr *node = expr;
    node = inObj.expr;
    let r1, r2;
    let stackindex = 0;
    
    ExprStack[0] = 0.0;
    while(node != null)
    {
	switch (node.opcode)
	{
	    case 3:  
		r1 = ExprStack[stackindex];
		stackindex--;
		r2 = ExprStack[stackindex];
		ExprStack[stackindex] = r2 + r1;
		break;

        case 4:  
		r1 = ExprStack[stackindex];
		stackindex--;
		r2 = ExprStack[stackindex];
		ExprStack[stackindex] = r2 - r1;
		break;

        case 5:  
		r1 = ExprStack[stackindex];
		stackindex--;
		r2 = ExprStack[stackindex];
		ExprStack[stackindex] = r2 * r1;
		break;

        case 6:  
		r1 = ExprStack[stackindex];
		stackindex--;
		r2 = ExprStack[stackindex];
		ExprStack[stackindex] = r2 / r1;
		break;				

        case 7:  
		stackindex++;
		ExprStack[stackindex] = node.fvalue;
		break;

        case 8:
        if (inObj.getVariableValue != null)
        {
           r1 = inObj.getVariableValue(node.ivar);
        }
        else r1 = 0.0;
		stackindex++;
		ExprStack[stackindex] = r1;
		break;

        case 9: 
		ExprStack[stackindex] = -ExprStack[stackindex];
		break;

        case 10: 
		r1 = ExprStack[stackindex];
		r2 = Math.cos(r1);
		ExprStack[stackindex] = r2;
		break;

        case 11: 
		r1 = ExprStack[stackindex];
		r2 = Math.sin(r1);
		ExprStack[stackindex] = r2;
		break;

        case 12: 
		r1 = ExprStack[stackindex];
		r2 = Math.tan(r1);
		ExprStack[stackindex] = r2;
		break;

        case 13: 
		r1 = ExprStack[stackindex];
		if (r1 == 0.0) r2 = 0.0;
		else r2 = 1.0/Math.tan( r1 );    
		ExprStack[stackindex] = r2;
		break;

        case 14: 
		r1 = ExprStack[stackindex];
		r2 = Math.abs( r1 );       
		ExprStack[stackindex] = r2;
		break;

        case 15: 
		r1 = ExprStack[stackindex];
		if (r1 < 0.0) r2 = -1.0;
		else if (r1 > 0.0) r2 = 1.0;
		else r2 = 0.0;
		ExprStack[stackindex] = r2;
		break;

        case 16: 
		r1 = ExprStack[stackindex];
		if (r1 < 0.0) r2 = 0.0;
		else r2 = Math.sqrt( r1 );     
		ExprStack[stackindex] = r2;
		break;

        case 17: 
		r1 = ExprStack[stackindex];
		if (r1 <= 0) r2 = 0.0;
		else r2 = Math.log(r1);
		ExprStack[stackindex] = r2;
		break;

        case 18: 
		r1 = ExprStack[stackindex];
		r2 = Math.exp(r1);
		ExprStack[stackindex] = r2;
		break;

        case 19: 
		r1 = ExprStack[stackindex];
		r2 = Math.asin( r1 );
		ExprStack[stackindex] = r2;
		break;

        case 20: 
		r1 = ExprStack[stackindex];
		r2 = Math.acos( r1 );      
		ExprStack[stackindex] = r2;
		break;

        case 21: 
		r1 = ExprStack[stackindex];
		r2 = Math.atan( r1 );      
		ExprStack[stackindex] = r2;
		break;

        case 22: 
		r1 = ExprStack[stackindex];
		r2 = 1.57079632679489661923 - Math.atan(r1);  
		ExprStack[stackindex] = r2;
		break;

        case 23:
		r1 = ExprStack[stackindex];
		r2 = (Math.exp(r1)-Math.exp(-r1))/2.0;
		ExprStack[stackindex] = r2;
		break;

        case 24: 
		r1 = ExprStack[stackindex];
		r2 = (Math.exp(r1)+Math.exp(-r1))/2.0;
		ExprStack[stackindex] = r2;
		break;

        case 25: 
		r1 = ExprStack[stackindex];
		r2 = (Math.exp(r1)-Math.exp(-r1))/(Math.exp(r1)+Math.exp(-r1));
		ExprStack[stackindex] = r2;
		break;

        case 26: 
		r1 = ExprStack[stackindex];
		r2 = (Math.exp(r1)+Math.exp(-r1))/(Math.exp(r1)-Math.exp(-r1));
		ExprStack[stackindex] = r2;
		break;

        case 27: 
		r1 = ExprStack[stackindex];
		if (r1 == 0.0) r2 = 0.0;
		else r2 = Math.log10( r1 );     
		ExprStack[stackindex] = r2;
		break;

        case 28:
 		r1 = ExprStack[stackindex];
		if (r1 <= 0.0) r2 = 0.0;
		else           r2 = 1.0;
		ExprStack[stackindex] = r2;
		break;
               
        case 31: 
		r1 = ExprStack[stackindex];
		r2 = ExprStack[stackindex-1];
		if (r2 <= 0.0) r2 = 0.0;
		else r2 = Math.exp(r1*Math.log(r2));
		ExprStack[stackindex-1] = r2;
		stackindex--;
		break;
        }
        node = node.next;
    }
    r1 = ExprStack[stackindex];

    // Set result to 0 if it is NaN due to an illegal math op
    if ( r1 != r1 ) r1 = 0.0;

    return r1;
}

// Turn off "precise" floating point option
//#pragma float_control(pop)
//float_control(pop)

//=============================================================================
////////////////////////////////////
//let returnObj = {expr: val1}
//let returnVal = mathexpr_delete(returnObj);
//val1 = returnObj.expr;
////////////////////////////////////
mathexpr_delete(inObj)
//void mathexpr_delete(MathExpr *expr)
{
    // return facilitators
    let returnObj;
    let returnVal;

    
    if(inObj){
        if (inObj.expr) {
            if(inObj.expr.next){
                ////////////////////////////////////
                returnObj = {expr: inObj.expr.next}
                returnVal = mathexpr_delete(returnObj);
                inObj.expr.next = returnObj.expr;
                ////////////////////////////////////
                //mathexpr_delete(inObj.expr.next);
            }
        }
        inObj.expr = null;
        //free(expr);
    }
}

//=============================================================================

////////////////////////////////////
//let returnObj = {getVar: function(){return;}}
//let returnVal = mathexpr_delete(formula, returnObj);
//val1 = returnObj.expr;
////////////////////////////////////
mathexpr_create(formula, inObj)
//MathExpr * mathexpr_create(char *formula, int (*getVar) (char *))
{
    //ExprTree *tree;
    //MathExpr *expr = null;
    //MathExpr *result = null;
    let tree;
    let expr;
    let result;

    // return facilitators
    let returnObj;
    let returnVal;


    getVariableIndex = inObj.getVar;
    Err = 0;
    PrevLex = 0;
    CurLex = 0;
    S = formula;
    Len = S.length;
    Pos = 0;
    Bc = 0;
    tree = getTree();
    if (Bc == 0 && Err == 0)
    {
        ////////////////////////////////////
        returnObj = {tree: tree, expr: expr}
        returnVal = traverseTree(returnObj);
        tree = returnObj.tree;
        expr = returnObj.expr;
        ////////////////////////////////////
	    //traverseTree(tree, &expr);
	    while (expr)
	    {
            result = expr;
            expr = expr.prev;
        }
    }
    ////////////////////////////////////
    returnObj = {tree: tree}
    returnVal = deleteTree(returnObj);
    tree = returnObj.tree;
    ////////////////////////////////////
    //deleteTree(tree);
    return result;
}

//-----------------------------------------------------------------------------
//   infil.h
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/14   (Build 5.1.001)
//            09/15/14   (Build 5.1.007)
//            08/05/15   (Build 5.1.010)
//            05/10/18   (Build 5.1.013)
//            04/01/20   (Build 5.1.015)
//   Author:  L. Rossman (US EPA)
//
//   Public interface for infiltration functions.
//
//   Build 5.1.010:
//   - New Modified Green Ampt infiltration option added.
//
//   Build 5.1.013:
//   - New infil_setInfilFactor() added.
//
//   Build 5.1.015:
//   - Support added for multiple infiltration methods within a project.
//-----------------------------------------------------------------------------

//---------------------
// Enumerated Constants
//---------------------
//enum InfilType {
HORTON = 0                     // Horton infiltration
MOD_HORTON = 1                 // Modified Horton infiltration
GREEN_AMPT = 2                 // Green-Ampt infiltration
MOD_GREEN_AMPT = 3             // Modified Green-Ampt infiltration
CURVE_NUMBER = 4               // SCS Curve Number infiltration

//---------------------
// Horton Infiltration
//---------------------
class THorton
{
    constructor(){
        this.f0;              // initial infil. rate (ft/sec)
        this.fmin;            // minimum infil. rate (ft/sec)
        this.Fmax;            // maximum total infiltration (ft);
        this.decay;           // decay coeff. of infil. rate (1/sec)
        this.regen;           // regeneration coeff. of infil. rate (1/sec)
        //-----------------------------
        this.tp;              // present time on infiltration curve (sec)
        this.Fe;              // cumulative infiltration (ft)
    }
}  ;


//-------------------------
// Green-Ampt Infiltration
//-------------------------
class TGrnAmpt
{
    constructor(){
        this.S;               // avg. capillary suction (ft)
        this.Ks;              // saturated conductivity (ft/sec)
        this.IMDmax;          // max. soil moisture deficit (ft/ft)
        //-----------------------------
        this.IMD;             // current initial soil moisture deficit
        this.F;               // current cumulative infiltrated volume (ft)
        this.Fu;              // current upper zone infiltrated volume (ft)
        this.Lu;              // depth of upper soil zone (ft)
        this.T;               // time until start of next rain event (sec)
        this.Sat;             // saturation flag
    }
}  ;


//--------------------------
// Curve Number Infiltration
//--------------------------
class TCurveNum
{
    constructor(){
        this.Smax;            // max. infiltration capacity (ft)
        this.regen;           // infil. capacity regeneration constant (1/sec)
        this.Tmax;            // maximum inter-event time (sec)
        //-----------------------------
        this.S;               // current infiltration capacity (ft)
        this.F;               // current cumulative infiltration (ft)
        this.P;               // current cumulative precipitation (ft)
        this.T;               // current inter-event time (sec)
        this.Se;              // current event infiltration capacity (ft)
        this.f;               // previous infiltration rate (ft/sec)
    }
}  ;

//-----------------------------------------------------------------------------
//   Exported Variables
//-----------------------------------------------------------------------------
// type: THorton
 HortInfil;
// type: TGrnAmpt
 GAInfil;
// type: TCurveNum
 CNInfil;

//-----------------------------------------------------------------------------
//   infil.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14  (Build 5.1.001)
//             09/15/14  (Build 5.1.007)
//             03/19/15  (Build 5.1.008)
//             08/05/15  (Build 5.1.010)
//             08/01/16  (Build 5.1.011)
//             05/10/17  (Build 5.1.013)
//             04/01/20  (Build 5.1.015)
//   Author:   L. Rossman
//
//   Infiltration functions.
//
//   Build 5.1.007:
//   - Revised formula for infiltration capacity recovery for the Modified
//     Horton method.
//   - The Green-Ampt functions were re-written.
//
//   Build 5.1.008:
//   - Monthly adjustment factors applied to hydraulic conductivity.
//
//   Build 5.1.010:
//   - Support for Modified Green Ampt model added.
//   - Green-Ampt initial recovery time set to 0.
//
//   Build 5.1.011:
//   - Monthly hydraulic conductivity factor also applied to Fu parameter
//     for Green-Ampt infiltration.
//   - Prevented computed Horton infiltration from dropping below f0.
//
//   Build 5.1.013:
//   - Support added for subcatchment-specific time patterns that adjust
//     hydraulic conductivity.
//
//   Build 5.1.015:
//   - Support added for multiple infiltration methods within a project.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Local Variables
//-----------------------------------------------------------------------------
class TInfil {
    constructor(){
        this.horton = new THorton();        // THorton   
        this.grnAmpt = new TGrnAmpt();       // TGrnAmpt  
        this.curveNum = new TCurveNum();      // TCurveNum
    }
} ;
//TInfil *Infil;
Infil = [];

Fumax;   // saturated water volume in upper soil zone (ft)
InfilFactor;                                                     //(5.1.013)

//-----------------------------------------------------------------------------
//  External Functions (declared in infil.h)
//-----------------------------------------------------------------------------
//  infil_create     (called by createObjects in project.c)
//  infil_delete     (called by deleteObjects in project.c)
//  infil_readParams (called by input_readLine)
//  infil_initState  (called by subcatch_initState)
//  infil_getState   (called by writeRunoffFile in hotstart.c)
//  infil_setState   (called by readRunoffFile in hotstart.c)
//  infil_getInfil   (called by getSubareaRunoff in subcatch.c)

//  Called locally and by storage node methods in node.c
//  grnampt_setParams
//  grnampt_initState
//  grnampt_getInfil


//=============================================================================
// int n
infil_create(n)
//
//  Purpose: creates an array of infiltration objects.
//  Input:   n = number of subcatchments
//  Output:  none
//
{
    //Infil = (TInfil *) calloc(n, sizeof(TInfil));
    Infil = [];
    for(let i = 0; i < n; i++){Infil.push(new TInfil())}
    if (Infil == null) ErrorCode = ERR_MEMORY;
    InfilFactor = 1.0;
    return;
}

//=============================================================================

infil_delete()
//
//  Purpose: deletes infiltration objects associated with subcatchments
//  Input:   none
//  Output:  none
//
{
    Infil = null;
}

//=============================================================================
//int m, char* tok[], int ntoks
infil_readParams(m, tok, ntoks)
//
//  Input:   m = default infiltration model
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: sets infiltration parameters from a line of input data.
//
//  Format of data line is:
//     subcatch  p1  p2 ... (infilMethod)
{
    let   i, j, n, status;
    let x = new Array(5);

    //return facilitators
    let returnObj;
    let returnVal;

    // --- check that subcatchment exists
    j = project_findObject(SUBCATCH, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- check for infiltration method keyword is last token 
    i = findmatch(tok[ntoks-1], InfilModelWords);
    if ( i >= 0 )
    {
        m = i; 
        --ntoks;
    }

    // --- number of input tokens depends on infiltration model m
    if      ( m == HORTON )         n = 5; 
    else if ( m == MOD_HORTON )     n = 5;
    else if ( m == GREEN_AMPT )     n = 4;
    else if ( m == MOD_GREEN_AMPT ) n = 4;
    else if ( m == CURVE_NUMBER )   n = 4;
    else return 0; 

    if ( ntoks < n ) return error_setInpError(ERR_ITEMS, "");
   
    // --- parse numerical values from tokens
    for (i = 0; i < 5; i++) x[i] = 0.0;
    for (i = 1; i < n; i++)
    {
        ////////////////////////////////////
        returnObj = {y: x[i - 1]}
        returnVal = getDouble(tok[i], returnObj);
        x[i - 1] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal ) 
        //if (null == (x[i - 1] = getDouble(tok[i])))
            return error_setInpError(ERR_NUMBER, tok[i]);
    }

    // --- special case for Horton infil. - last parameter is optional
    if ( (m == HORTON || m == MOD_HORTON) && ntoks > n )
    {
        ////////////////////////////////////
        returnObj = {y: x[n-1]}
        returnVal = getDouble(tok[n], returnObj);
        x[n-1] = returnObj.y;
        ////////////////////////////////////
        if(!returnVal)
        //if ( null == (x[n-1] = getDouble(tok[n])))
            return error_setInpError(ERR_NUMBER, tok[n]);
    }

    // --- assign parameter values to infil, infilModel object
    Subcatch[j].infil = j;
    Subcatch[j].infilModel = m;
    switch (m)
    {
      case HORTON:
      case MOD_HORTON:   status = horton_setParams(Infil[j].horton, x);
                         break;
      case GREEN_AMPT:
      case MOD_GREEN_AMPT:
                         status = grnampt_setParams(Infil[j].grnAmpt, x);
                         break;
      case CURVE_NUMBER: status = curvenum_setParams(Infil[j].curveNum, x);
                         break;
      default:           status = TRUE;
    }
    if ( !status ) return error_setInpError(ERR_NUMBER, "");
    return 0;
}

//=============================================================================
// int j
infil_initState(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: initializes state of infiltration for a subcatchment.
//
{
    switch (Subcatch[j].infilModel)
    {
      case HORTON:
      case MOD_HORTON:   horton_initState(Infil[j].horton);   break;
      case GREEN_AMPT:
      case MOD_GREEN_AMPT:
                         grnampt_initState(Infil[j].grnAmpt);    break;
      case CURVE_NUMBER: curvenum_initState(Infil[j].curveNum);   break;
    }
}

//=============================================================================
// int j, double x[]
infil_getState(j, x)
//
//  Input:   j = subcatchment index
//  Output:  x = subcatchment's infiltration state
//  Purpose: retrieves the current infiltration state for a subcatchment.
//
{
    switch (Subcatch[j].infilModel)
    {
      case HORTON:
      case MOD_HORTON:   horton_getState(Infil[j].horton, x); break;
      case GREEN_AMPT:
      case MOD_GREEN_AMPT:
                         grnampt_getState(Infil[j].grnAmpt, x);   break;
      case CURVE_NUMBER: curvenum_getState(Infil[j].curveNum, x); break;
    }
}

//=============================================================================
// int j, double x[]
infil_setState(j, x)
//
//  Input:   j = subcatchment index
//           m = infiltration method code
//  Output:  none
//  Purpose: sets the current infiltration state for a subcatchment.
//
{
    switch (Subcatch[j].infilModel)
    {
      case HORTON:
      case MOD_HORTON:   horton_setState(Infil[j].horton, x); break;
      case GREEN_AMPT:
      case MOD_GREEN_AMPT:
                         grnampt_setState(Infil[j].grnAmpt, x);   break;
      case CURVE_NUMBER: curvenum_setState(Infil[j].curveNum, x); break;
    }
}

//=============================================================================

////  New added for release 5.1.013.  ////                            //(5.1.013)
// int j
infil_setInfilFactor(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: assigns a value to the infiltration adjustment factor.
{
    let m;
    let p;

    // ... set factor to the global conductivity adjustment factor
    InfilFactor = Adjust.hydconFactor;

    // ... override global factor with subcatchment's adjustment if assigned 
    if (j >= 0)
    {
        p = Subcatch[j].infilPattern;
        if (p >= 0 && Pattern[p].type == MONTHLY_PATTERN)
        {
            m = datetime_monthOfYear(getDateTime(OldRunoffTime)) - 1;
            InfilFactor = Pattern[p].factor[m];
        }
    }
}

//=============================================================================
// int j, double tstep, double rainfall,
//     double runon, double depth
infil_getInfil(j, tstep, rainfall,
                     runon, depth)
//
//  Input:   j = subcatchment index
//           tstep = runoff time step (sec)
//           rainfall = rainfall rate (ft/sec)
//           runon = runon rate from other sub-areas or subcatchments (ft/sec)
//           depth = depth of surface water on subcatchment (ft)
//  Output:  returns infiltration rate (ft/sec)
//  Purpose: computes infiltration rate depending on infiltration method.
//
{
    switch (Subcatch[j].infilModel)
    {
      case HORTON:
          return horton_getInfil(Infil[j].horton, tstep, rainfall+runon, depth);

      case MOD_HORTON:
          return modHorton_getInfil(Infil[j].horton, tstep, rainfall+runon,
                                    depth);

      case GREEN_AMPT:
      case MOD_GREEN_AMPT:
        return grnampt_getInfil(Infil[j].grnAmpt, tstep, rainfall+runon, depth,
            Subcatch[j].infilModel);

      case CURVE_NUMBER:
        depth += runon / tstep;
        return curvenum_getInfil(Infil[j].curveNum, tstep, rainfall, depth);

      default:
        return 0.0;
    }
}

//=============================================================================
// THorton *infil, double p[]
horton_setParams(infil, p)
//
//  Input:   infil = ptr. to Horton infiltration object
//           p[] = array of parameter values
//  Output:  returns TRUE if parameters are valid, FALSE otherwise
//  Purpose: assigns Horton infiltration parameters to a subcatchment.
//
{
    let k;
    for (k = 0; k < 5; k++) if ( p[k] < 0.0 ) return FALSE;

    // --- max. & min. infil rates (ft/sec)
    infil.f0   = p[0] / UCF(RAINFALL);
    infil.fmin = p[1] / UCF(RAINFALL);

    // --- convert decay const. to 1/sec
    infil.decay = p[2] / 3600.;

    // --- convert drying time (days) to a regeneration const. (1/sec)
    //     assuming that former is time to reach 98% dry along an
    //     exponential drying curve
    if (p[3] == 0.0 ) p[3] = TINY;
    infil.regen = -Math.log(1.0-0.98) / p[3] / SECperDAY;

    // --- optional max. infil. capacity (ft) (p[4] = 0 if no value supplied)
    infil.Fmax = p[4] / UCF(RAINDEPTH);
    if ( infil.f0 < infil.fmin ) return FALSE;
    return TRUE;
}

//=============================================================================
// THorton *infil
horton_initState(infil)
//
//  Input:   infil = ptr. to Horton infiltration object
//  Output:  none
//  Purpose: initializes time on Horton infiltration curve for a subcatchment.
//
{
    infil.tp = 0.0;
    infil.Fe = 0.0;
}

//=============================================================================
// THorton *infil, double x[]
horton_getState(infil, x)
{
    x[0] = infil.tp;
    x[1] = infil.Fe;
}
// THorton *infil, double x[]
horton_setState(infil, x)
{
    infil.tp = x[0];
    infil.Fe = x[1];
}

//=============================================================================
// THorton *infil, double tstep, double irate, double depth
horton_getInfil(infil, tstep, irate, depth)
//
//  Input:   infil = ptr. to Horton infiltration object
//           tstep =  runoff time step (sec),
//           irate = net "rainfall" rate (ft/sec),
//                 = rainfall + snowmelt + runon - evaporation
//           depth = depth of ponded water (ft).
//  Output:  returns infiltration rate (ft/sec)
//  Purpose: computes Horton infiltration for a subcatchment.
//
{
    // --- assign local variables
    let    iter;
    let fa, fp = 0.0;
    let Fp, F1, t1, tlim, ex, kt;
    let FF, FF1, r;
    let f0   = infil.f0 * InfilFactor;                                     //(5.1.013)
    let fmin = infil.fmin * InfilFactor;                                   //(5.1.013)
    let Fmax = infil.Fmax;
    let tp   = infil.tp;
    let df   = f0 - fmin;
    let kd   = infil.decay;
    let kr   = infil.regen * Evap.recoveryFactor;

    // --- special cases of no infil. or constant infil
    if ( df < 0.0 || kd < 0.0 || kr < 0.0 ) return 0.0;
    if ( df == 0.0 || kd == 0.0 )
    {
        fp = f0;
        fa = irate + depth / tstep;
        if ( fp > fa ) fp = fa;
        return MAX(0.0, fp);
    }

    // --- compute water available for infiltration
    fa = irate + depth / tstep;

    // --- case where there is water to infiltrate
    if ( fa > ZERO )
    {
        // --- compute average infil. rate over time step
        t1 = tp + tstep;         // future cumul. time
        tlim = 16.0 / kd;        // for tp >= tlim, f = fmin
        if ( tp >= tlim )
        {
            Fp = fmin * tp + df / kd;
            F1 = Fp + fmin * tstep;
        }
        else
        {
            Fp = fmin * tp + df / kd * (1.0 - Math.exp(-kd * tp));
            F1 = fmin * t1 + df / kd * (1.0 - Math.exp(-kd * t1));
        }
        fp = (F1 - Fp) / tstep;
        fp = MAX(fp, fmin);

        // --- limit infil rate to available infil
        if ( fp > fa ) fp = fa;

        // --- if fp on flat portion of curve then increase tp by tstep
        if ( t1 > tlim ) tp = t1;

        // --- if infil < available capacity then increase tp by tstep
        else if ( fp < fa ) tp = t1;

        // --- if infil limited by available capacity then
        //     solve F(tp) - F1 = 0 using Newton-Raphson method
        else
        {
            F1 = Fp + fp * tstep;
            tp = tp + tstep / 2.0;
            for ( iter=1; iter<=20; iter++ )
            {
                kt = MIN( 60.0, kd*tp );
                ex = Math.exp(-kt);
                FF = fmin * tp + df / kd * (1.0 - ex) - F1;
                FF1 = fmin + df * ex;
                r = FF / FF1;
                tp = tp - r;
                if ( Math.abs(r) <= 0.001 * tstep ) break;
            }
        }

        // --- limit cumulative infiltration to Fmax
        if ( Fmax > 0.0 )
        {
            if ( infil.Fe + fp * tstep > Fmax )
                fp = (Fmax - infil.Fe) / tstep;
            fp = MAX(fp, 0.0);
            infil.Fe += fp * tstep;
        }
    }

    // --- case where infil. capacity is regenerating; update tp.
    else if (kr > 0.0)
    {
        r = Math.exp(-kr * tstep);
        tp = 1.0 - Math.exp(-kd * tp);
        tp = -Math.log(1.0 - r*tp) / kd;

        // reduction in cumulative infiltration
        if ( Fmax > 0.0 )
        {
            infil.Fe = fmin*tp + (df/kd)*(1.0 - Math.exp(-kd*tp));
        }
    }
    infil.tp = tp;
    return fp;
}

//=============================================================================
// THorton *infil, double tstep, double irate,
//    double depth
modHorton_getInfil(infil, tstep, irate,
                         depth)
//
//  Input:   infil = ptr. to Horton infiltration object
//           tstep =  runoff time step (sec),
//           irate = net "rainfall" rate (ft/sec),
//                 = rainfall + snowmelt + runon
//           depth = depth of ponded water (ft).
//  Output:  returns infiltration rate (ft/sec)
//  Purpose: computes modified Horton infiltration for a subcatchment.
//
{
    // --- assign local variables
    let f  = 0.0;
    let fp, fa;
    let f0 = infil.f0 * InfilFactor;                                       //(5.1.013)
    let fmin = infil.fmin * InfilFactor;                                   //(5.1.013)
    let df = f0 - fmin;
    let kd = infil.decay;
    let kr = infil.regen * Evap.recoveryFactor;

    // --- special cases of no or constant infiltration
    if ( df < 0.0 || kd < 0.0 || kr < 0.0 ) return 0.0;
    if ( df == 0.0 || kd == 0.0 )
    {
        fp = f0;
        fa = irate + depth / tstep;
        if ( fp > fa ) fp = fa;
        return MAX(0.0, fp);
    }

    // --- compute water available for infiltration
    fa = irate + depth / tstep;

    // --- case where there is water to infiltrate
    if ( fa > ZERO )
    {
        // --- saturated condition
        if ( infil.Fmax > 0.0 && infil.Fe >= infil.Fmax ) return 0.0;

        // --- potential infiltration
        fp = f0 - kd * infil.Fe;
        fp = MAX(fp, fmin);

        // --- actual infiltration
        f = MIN(fa, fp);

        // --- new cumulative infiltration minus seepage
        infil.Fe += MAX((f - fmin), 0.0) * tstep;
        if ( infil.Fmax > 0.0 ) infil.Fe = MAX(infil.Fe, infil.Fmax);
    }

    // --- reduce cumulative infiltration for dry condition
    else if (kr > 0.0)
    {
        infil.Fe *= Math.exp(-kr * tstep);
        infil.Fe = MAX(infil.Fe, 0.0);
    }
    return f;
}

//=============================================================================
// int j, double p[]
grnampt_getParams(j, p)
//
//  Input:   j = subcatchment index
//           p[] = array of parameter values
//  Output:  none
//  Purpose: retrieves Green-Ampt infiltration parameters for a subcatchment.
//
{
    p[0] = Infil[j].grnAmpt.S * UCF(RAINDEPTH);   // Capillary suction head (ft)
    p[1] = Infil[j].grnAmpt.Ks * UCF(RAINFALL);   // Sat. hyd. conductivity (ft/sec)
    p[2] = Infil[j].grnAmpt.IMDmax;               // Max. init. moisture deficit
}

//=============================================================================
// TGrnAmpt *infil, double p[]
grnampt_setParams(infil, p)
//
//  Input:   infil = ptr. to Green-Ampt infiltration object
//           p[] = array of parameter values
//  Output:  returns TRUE if parameters are valid, FALSE otherwise
//  Purpose: assigns Green-Ampt infiltration parameters to a subcatchment.
//
{
    let ksat;                       // sat. hyd. conductivity in in/hr

    if ( p[0] < 0.0 || p[1] <= 0.0 || p[2] < 0.0 ) return FALSE;
    infil.S      = p[0] / UCF(RAINDEPTH);   // Capillary suction head (ft)
    infil.Ks     = p[1] / UCF(RAINFALL);    // Sat. hyd. conductivity (ft/sec)
    infil.IMDmax = p[2];                    // Max. init. moisture deficit

    // --- find depth of upper soil zone (ft) using Mein's eqn.
    ksat = infil.Ks * 12. * 3600.;
    infil.Lu = 4.0 * Math.sqrt(ksat) / 12.;
    return TRUE;
}

//=============================================================================
// TGrnAmpt *infil
grnampt_initState(infil)
//
//  Input:   infil = ptr. to Green-Ampt infiltration object
//  Output:  none
//  Purpose: initializes state of Green-Ampt infiltration for a subcatchment.
//
{
    if (infil == null) return;
    infil.IMD = infil.IMDmax;
    infil.Fu = 0.0;
    infil.F = 0.0;
    infil.Sat = FALSE;
    infil.T = 0.0;
}
// TGrnAmpt *infil, double x[]
grnampt_getState(infil, x)
{
    x[0] = infil.IMD;
    x[1] = infil.F;
    x[2] = infil.Fu;
    x[3] = infil.Sat;
    x[4] = infil.T;
}
// TGrnAmpt *infil, double x[]
grnampt_setState(infil, x)
{
    infil.IMD = x[0];
    infil.F   = x[1];
    infil.Fu  = x[2];
    infil.Sat = x[3];
    infil.T   = x[4];
}

//=============================================================================
// TGrnAmpt *infil, double tstep, double irate,
//    double depth, int modelType
grnampt_getInfil(infil, tstep, irate,
 depth,  modelType) 
//
//  Input:   infil = ptr. to Green-Ampt infiltration object
//           tstep =  time step (sec),
//           irate = net "rainfall" rate to upper zone (ft/sec);
//                 = rainfall + snowmelt + runon,
//                   does not include ponded water (added on below)
//           depth = depth of ponded water (ft)
//           modelType = either GREEN_AMPT or MOD_GREEN_AMPT 
//  Output:  returns infiltration rate (ft/sec)
//  Purpose: computes Green-Ampt infiltration for a subcatchment
//           or a storage node.
//
{
    // --- find saturated upper soil zone water volume
    Fumax = infil.IMDmax * infil.Lu * Math.sqrt(InfilFactor);                     //(5.1.013)

    // --- reduce time until next event
    infil.T -= tstep;

    // --- use different procedures depending on upper soil zone saturation
    if ( infil.Sat ) return grnampt_getSatInfil(infil, tstep, irate, depth);
    else return grnampt_getUnsatInfil(infil, tstep, irate, depth, modelType);
}

//=============================================================================
// TGrnAmpt *infil, double tstep, double irate,
//    double depth, int modelType
grnampt_getUnsatInfil(infil, tstep, irate,
    depth, modelType)
//
//  Input:   infil = ptr. to Green-Ampt infiltration object
//           tstep =  runoff time step (sec),
//           irate = net "rainfall" rate to upper zone (ft/sec);
//                 = rainfall + snowmelt + runon,
//                   does not include ponded water (added on below)
//           depth = depth of ponded water (ft)
//           modelType = either GREEN_AMPT or MOD_GREEN_AMPT
//  Output:  returns infiltration rate (ft/sec)
//  Purpose: computes Green-Ampt infiltration when upper soil zone is
//           unsaturated.
//
{
    let ia, c1, F2, dF, Fs, kr, ts;
    let ks = infil.Ks * InfilFactor;                                       //(5.1.013)
    let lu = infil.Lu * Math.sqrt(InfilFactor);                                 //(5.1.013)

    // --- get available infiltration rate (rainfall + ponded water)
    ia = irate + depth / tstep;
    if ( ia < ZERO ) ia = 0.0;

    // --- no rainfall so recover upper zone moisture
    if ( ia == 0.0 )
    {
        if ( infil.Fu <= 0.0 ) return 0.0;
        kr = lu / 90000.0 * Evap.recoveryFactor; 
        dF = kr * Fumax * tstep;
        infil.F -= dF;
        infil.Fu -= dF;
        if ( infil.Fu <= 0.0 )
        {
            infil.Fu = 0.0;
            infil.F = 0.0;
            infil.IMD = infil.IMDmax;
            return 0.0;
        }

        // --- if new wet event begins then reset IMD & F
        if ( infil.T <= 0.0 )
        {
            infil.IMD = (Fumax - infil.Fu) / lu; 
            infil.F = 0.0;
        }
        return 0.0;
    }

    // --- rainfall does not exceed Ksat
    if ( ia <= ks )
    {
        dF = ia * tstep;
        infil.F += dF;
        infil.Fu += dF;
        infil.Fu = MIN(infil.Fu, Fumax);
        if ( modelType == GREEN_AMPT &&  infil.T <= 0.0 )
        {
            infil.IMD = (Fumax - infil.Fu) / lu;
            infil.F = 0.0;
        }
        return ia;
    }

    // --- rainfall exceeds Ksat; renew time to drain upper zone
    infil.T = 5400.0 / lu / Evap.recoveryFactor; 

    // --- find volume needed to saturate surface layer
    Fs = ks * (infil.S + depth) * infil.IMD / (ia - ks);

    // --- surface layer already saturated
    if ( infil.F > Fs )
    {
        infil.Sat = TRUE;
        return grnampt_getSatInfil(infil, tstep, irate, depth);
    }

    // --- surface layer remains unsaturated
    if ( infil.F + ia*tstep < Fs )
    {
        dF = ia * tstep;
        infil.F += dF;
        infil.Fu += dF;
        infil.Fu = MIN(infil.Fu, Fumax);
        return ia;
    }

    // --- surface layer becomes saturated during time step;
    // --- compute portion of tstep when saturated
    ts  = tstep - (Fs - infil.F) / ia;
    if ( ts <= 0.0 ) ts = 0.0;

    // --- compute new total volume infiltrated
    c1 = (infil.S + depth) * infil.IMD;
    F2 = grnampt_getF2(Fs, c1, ks, ts);
    if ( F2 > Fs + ia*ts ) F2 = Fs + ia*ts;

    // --- compute infiltration rate
    dF = F2 - infil.F;
    infil.F = F2;
    infil.Fu += dF;
    infil.Fu = MIN(infil.Fu, Fumax);
    infil.Sat = TRUE;
    return dF / tstep;
}

//=============================================================================
// TGrnAmpt *infil, double tstep, double irate,
//    double depth
grnampt_getSatInfil(infil, tstep, irate,
     depth)
//
//  Input:   infil = ptr. to Green-Ampt infiltration object
//           tstep =  runoff time step (sec),
//           irate = net "rainfall" rate to upper zone (ft/sec);
//                 = rainfall + snowmelt + runon,
//                   does not include ponded water (added on below)
//           depth = depth of ponded water (ft).
//  Output:  returns infiltration rate (ft/sec)
//  Purpose: computes Green-Ampt infiltration when upper soil zone is
//           saturated.
//
{
    let ia, c1, dF, F2;
    let ks = infil.Ks * InfilFactor;                                       //(5.1.013)
    let lu = infil.Lu * Math.sqrt(InfilFactor);                                 //(5.1.013)

    // --- get available infiltration rate (rainfall + ponded water)
    ia = irate + depth / tstep;
    if ( ia < ZERO ) return 0.0;

    // --- re-set new event recovery time
    infil.T = 5400.0 / lu / Evap.recoveryFactor;

    // --- solve G-A equation for new cumulative infiltration volume (F2)
    c1 = (infil.S + depth) * infil.IMD;
    F2 = grnampt_getF2(infil.F, c1, ks, tstep);
    dF = F2 - infil.F;

    // --- all available water infiltrates -- set saturated state to false
    if ( dF > ia * tstep )
    {
        dF = ia * tstep;
        infil.Sat = FALSE;
    }

    // --- update total infiltration and upper zone moisture deficit
    infil.F += dF;
    infil.Fu += dF;
    infil.Fu = MIN(infil.Fu, Fumax);
    return dF / tstep;
}

//=============================================================================
// double f1, double c1, double ks, double ts
grnampt_getF2(f1, c1, ks, ts)
//
//  Input:   f1 = old infiltration volume (ft)
//           c1 = head * moisture deficit (ft)
//           ks = sat. hyd. conductivity (ft/sec)
//           ts = time step (sec)
//  Output:  returns infiltration volume at end of time step (ft)
//  Purpose: computes new infiltration volume over a time step
//           using Green-Ampt formula for saturated upper soil zone.
//
{
    let    i;
    let f2 = f1;
    let f2min;
    let df2;
    let c2;

    // --- find min. infil. volume
    f2min = f1 + ks * ts;

    // --- use min. infil. volume for 0 moisture deficit
    if ( c1 == 0.0 ) return f2min;

    // --- use direct form of G-A equation for small time steps
    //     and c1/f1 < 100
    if ( ts < 10.0 && f1 > 0.01 * c1 )
    {
        f2 = f1 + ks * (1.0 + c1/f1) * ts;
        return MAX(f2, f2min);
    }

    // --- use Newton-Raphson method to solve integrated G-A equation
    //     (convergence limit reduced from that used in previous releases)
    c2 = c1 * Math.log(f1 + c1) - ks * ts;
    for ( i = 1; i <= 20; i++ )
    {
        df2 = (f2 - f1 - c1 * Math.log(f2 + c1) + c2) / (1.0 - c1 / (f2 + c1) );
        if ( Math.abs(df2) < 0.00001 )
        {
            return MAX(f2, f2min);
        }
        f2 -= df2;
    }
    return f2min;
}

//=============================================================================
// TCurveNum *infil, double p[]
curvenum_setParams(infil, p)
//
//  Input:   infil = ptr. to Curve Number infiltration object
//           p[] = array of parameter values
//  Output:  returns TRUE if parameters are valid, FALSE otherwise
//  Purpose: assigns Curve Number infiltration parameters to a subcatchment.
//
{

    // --- convert Curve Number to max. infil. capacity
    if ( p[0] < 10.0 ) p[0] = 10.0;
    if ( p[0] > 99.0 ) p[0] = 99.0;
    infil.Smax    = (1000.0 / p[0] - 10.0) / 12.0;
    if ( infil.Smax < 0.0 ) return FALSE;

    // --- convert drying time (days) to a regeneration const. (1/sec)
    if ( p[2] > 0.0 )  infil.regen =  1.0 / (p[2] * SECperDAY);
    else return FALSE;

    // --- compute inter-event time from regeneration const. as in Green-Ampt
    infil.Tmax = 0.06 / infil.regen;

    return TRUE;
}

//==================================// ===========================================
// TCurveNum *infil
curvenum_initState(infil)
//
//  Input:   infil = ptr. to Curve Number infiltration object
//  Output:  none
//  Purpose: initializes state of Curve Number infiltration for a subcatchment.
//
{
    infil.S  = infil.Smax;
    infil.P  = 0.0;
    infil.F  = 0.0;
    infil.T  = 0.0;
    infil.Se = infil.Smax;
    infil.f  = 0.0;
}
// TCurveNum *infil, double x[]
curvenum_getState(infil, x)
{
    x[0] = infil.S;
    x[1] = infil.P;
    x[2] = infil.F;
    x[3] = infil.T;
    x[4] = infil.Se;
    x[5] = infil.f;
}
// TCurveNum *infil, double x[]
curvenum_setState(infil, x)
{
    infil.S  = x[0];
    infil.P  = x[1];
    infil.F  = x[2];
    infil.T  = x[3];
    infil.Se = x[4];
    infil.f  = x[5];
}

//=============================================================================
// TCurveNum *infil, double tstep, double irate,
//    double depth
curvenum_getInfil(infil, tstep, irate, depth)
//
//  Input:   infil = ptr. to Curve Number infiltration object
//           tstep = runoff time step (sec),
//           irate = rainfall rate (ft/sec);
//           depth = depth of runon + ponded water (ft)
//  Output:  returns infiltration rate (ft/sec)
//  Purpose: computes infiltration rate using the Curve Number method.
//  Note:    this treats runon from other subcatchments as part
//           of the ponded depth and not as an effective rainfall rate.
{
    let F1;                         // new cumulative infiltration (ft)
    let f1 = 0.0;                   // new infiltration rate (ft/sec)
    let fa = irate + depth/tstep;   // max. available infil. rate (ft/sec)

    // --- case where there is rainfall
    if ( irate > ZERO )
    {
        // --- check if new rain event
        if ( infil.T >= infil.Tmax )
        {
            infil.P = 0.0;
            infil.F = 0.0;
            infil.f = 0.0;
            infil.Se = infil.S;
        }
        infil.T = 0.0;

        // --- update cumulative precip.
        infil.P += irate * tstep;

        // --- find potential new cumulative infiltration
        F1 = infil.P * (1.0 - infil.P / (infil.P + infil.Se));

        // --- compute potential infiltration rate
        f1 = (F1 - infil.F) / tstep;
        if ( f1 < 0.0 || infil.S <= 0.0 ) f1 = 0.0;

    }

    // --- case of no rainfall
    else
    {
        // --- if there is ponded water then use previous infil. rate
        if ( depth > MIN_TOTAL_DEPTH && infil.S > 0.0 )
        {
            f1 = infil.f;
            if ( f1*tstep > infil.S ) f1 = infil.S / tstep;
        }

        // --- otherwise update inter-event time
        else infil.T += tstep;
    }

    // --- if there is some infiltration
    if ( f1 > 0.0 )
    {
        // --- limit infil. rate to max. available rate
        f1 = MIN(f1, fa);
        f1 = MAX(f1, 0.0);

        // --- update actual cumulative infiltration
        infil.F += f1 * tstep;

        // --- reduce infil. capacity if a regen. constant was supplied
        if ( infil.regen > 0.0 )
        {
            infil.S -= f1 * tstep;
            if ( infil.S < 0.0 ) infil.S = 0.0;
        }
    }

    // --- otherwise regenerate infil. capacity
    else
    {
        infil.S += infil.regen * infil.Smax * tstep * Evap.recoveryFactor;
        if ( infil.S > infil.Smax ) infil.S = infil.Smax;
    }
    infil.f = f1;
    return f1;
}

//-----------------------------------------------------------------------------
//   objects.h
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/19/14  (Build 5.1.000)
//            09/15/14  (Build 5.1.007)
//            03/19/15  (Build 5.1.008)
//            08/05/15  (Build 5.1.010)
//            08/01/16  (Build 5.1.011)
//            05/10/18  (Build 5.1.013)
//            04/01/20  (Build 5.1.015)
//
//   Author:  L. Rossman (EPA)
//            M. Tryby (EPA)
//            R. Dickinson (CDM)
//
//   Definitions of data structures.
//
//   Most SWMM 5 "objects" are represented as C data structures.
//
//   The units shown next to each structure's properties are SWMM's
//   internal units and may be different than the units required
//   for the property as it appears in the input file.
//
//   In many structure definitions, a blank line separates the set of
//   input properties from the set of computed output properties.
//
//   Build 5.1.007:
//   - Data structure for monthly adjustments of temperature, evaporation,
//     and rainfall added.
//   - User-supplied equation for deep GW flow added to subcatchment object.
//   - Exfiltration added to storage node object.
//   - Surcharge option added to weir object.
//
//   Build 5.1.008:
//   - Route to subcatchment option added to Outfall data structure.
//   - Hydraulic conductivity added to monthly adjustments data structure.
//   - Total LID drain flow and outfall runon added to Runoff Totals.
//   - Groundwater statistics object added.
//   - Maximum depth for reporting times added to node statistics object.
//
//   Build 5.1.010:
//   - Additional fields added to Weir object to support ROADWAY_WEIR type.
//   - New field added to Link object to record when its setting was changed.
//   - q1Old and q2Old of Link object restored.
//
//   Build 5.1.011:
//   - Description of oldFlow & newFlow for TGroundwater object modified.
//   - Weir shape parameter deprecated.
//   - Added definition of a hydraulic event time period (TEvent).
//
//   Build 5.1.013:
//   - New member 'averages' added to the TRptFlags structure.
//   - Adjustment patterns added to TSubcatch structure.
//   - Members impervRunoff and pervRunoff added to TSubcatchStats structure.
//   - Member cdCurve (weir coeff. curve) added to TWeir structure.
//
//   Build 5.1.015:
//   - Support added for multiple infiltration methods within a project.
//   - Support added for grouped freqency table of routing time steps.
//-----------------------------------------------------------------------------

//-----------------
// FILE INFORMATION
//-----------------
class TFile
{
   constructor(){
      this.name;     // Array of size [MAXFNAME+1]. file name
      this.mode;                 // NO_FILE, SCRATCH, USE, or SAVE
      this.state;                // current state (OPENED, CLOSED)
      //this.file;                 // FILE structure pointer
      this.contents;             // Replacement for file: allows for browser-created reports.
   }
}  ;

//-----------------------------------------
// LINKED LIST ENTRY FOR TABLES/TIME SERIES
//-----------------------------------------
class  TableEntry
{
   constructor(){
      this.x;
      this.y;
      this.next;  //TableEntry
   }
};

class  TTableEntry
{
   constructor(){
      this.x;
      this.y;
      this.next;  //TableEntry
   }
};

//-------------------------
// CURVE/TIME SERIES OBJECT
//-------------------------
class TTable
{
   constructor(){
      this.ID;              // Table/time series ID
      this.curveType;       // type of curve tabulated
      this.refersTo;        // reference to some other object
      this.dxMin;           // smallest x-value interval
      this.lastDate;        // last input date for time series
      this.x1;          // current bracket on x-values
      this.x2;
      this.y1;          // current bracket on y-values
      this.y2;
      this.firstEntry = new TTableEntry();      //TTableEntry first data point
      this.lastEntry = new TTableEntry();       //TTableEntry last data point
      this.thisEntry = new TTableEntry();       //TTableEntry current data point
      this.file = new TFile();            //TFile external data file
      this.contents;        //Replaces this.file for browser models
   }
}  ;

//-----------------
// RAIN GAGE OBJECT
//-----------------
class TGage
{
   constructor(){
      this.ID;              // raingage name
      this.dataSource;      // data from time series or file
      this.tSeries;         // rainfall data time series index
      this.fname; // char[MAXFNAME+1] name of rainfall data file
      this.staID; // char[MAXMSG+1]. station number
      this.startFileDate;   // starting date of data read from file
      this.endFileDate;     // ending date of data read from file
      this.rainType;        // intensity, volume, cumulative
      this.rainInterval;    // recording time interval (seconds)
      this.rainUnits;       // rain depth units (US or SI)
      this.snowFactor;      // snow catch deficiency correction
      //-----------------------------
      this.startFilePos;    // starting byte position in Rain file
      this.endFilePos;      // ending byte position in Rain file
      this.currentFilePos;  // current byte position in Rain file
      this.rainAccum;       // cumulative rainfall
      this.unitsFactor;     // units conversion factor (to inches or mm)
      this.startDate;       // start date of current rainfall
      this.endDate;         // end date of current rainfall
      this.nextDate;        // next date with recorded rainfall
      this.rainfall;        // current rainfall (in/hr or mm/hr)
      this.nextRainfall;    // next rainfall (in/hr or mm/hr)
      this.reportRainfall;  // rainfall value used for reported results
      this.coGage;          // index of gage with same rain timeseries
      this.isUsed;          // TRUE if gage used by any subcatchment
      this.isCurrent;       // TRUE if gage's rainfall is current
   }
}  ;

//-------------------
// TEMPERATURE OBJECT
//-------------------
class TTemp
{
   constructor(){
      this.dataSource;      // data from time series or file
      this.tSeries;         // temperature data time series index
      this.fileStartDate;   // starting date of data read from file
      this.elev;            // elev. of study area (ft)
      this.anglat;          // latitude (degrees)
      this.dtlong;          // longitude correction (hours)
      //-----------------------------
      this.ta;              // air temperature (deg F)
      this.tmax;            // previous day's max. temp. (deg F)
      this.ea;              // saturation vapor pressure (in Hg)
      this.gamma;           // psychrometric constant
      this.tanAnglat;       // tangent of latitude angle
   }
}  ;

//-----------------
// WINDSPEED OBJECT
//-----------------
class TWind
{
   constructor(){
      this.type;             // monthly or file data
      this.aws = new Array(12);          // double[12]. monthly avg. wind speed (mph)
      //-----------------------------
      this.ws;              // wind speed (mph)
   }
}  ;

//------------
// SNOW OBJECT
//------------
class TSnow
{
   constructor(){
      this.snotmp;           // temp. dividing rain from snow (deg F)
      this.tipm;             // antecedent temp. index parameter
      this.rnm;              // ratio of neg. melt to melt coeff.
      //-----------------------------
      this.season;           // snowmelt season
      this.removed;          // total snow plowed out of system (ft3)
      this.adc = Array.from( // Array of [2][10], areal depletion curves
                     Array(2),  
                     () => new Array(4)
                  );
   }
}  ;

//-------------------
// EVAPORATION OBJECT
//-------------------
class TEvap
{
   constructor(){
      this.type;            // type of evaporation data
      this.tSeries;         // time series index
      this.recoveryPattern; // soil recovery factor pattern
      this.dryOnly;         // true if evaporation only in dry periods
      //----------------------------
      this.rate;            // current evaporation rate (ft/sec)
      this.recoveryFactor;  // current soil recovery factor
      // The following are arrays of size 12
      this.monthlyEvap = new Array(12); // monthly evaporation values
      this.panCoeff = new Array(12);    // monthly pan coeff. values
   }
}   ;

//-------------------
// ADJUSTMENTS OBJECT
//-------------------
class TAdjust
{
   constructor(){
      this.rainFactor;      // current rainfall adjustment multiplier
      this.hydconFactor;    // current conductivity multiplier
      // The following are all arrays of size 12
      this.temp = new Array(12);        // monthly temperature adjustments (deg F)
      this.evap = new Array(12);        // monthly evaporation adjustments (ft/s)
      this.rain = new Array(12);        // monthly rainfall adjustment multipliers
      this.hydcon = new Array(12);      // hyd. conductivity adjustment multipliers
   }
}   ;

//-------------
// EVENT OBJECT
//-------------
class TEvent
{
   constructor(){
      this.start;            // event start date
      this.end;              // event end date
   }
}   ;

//-------------------
// AQUIFER OBJECT
//-------------------
class TAquifer
{
   constructor(){
      this.ID;               // aquifer name
      this.porosity;         // soil porosity
      this.wiltingPoint;     // soil wilting point
      this.fieldCapacity;    // soil field capacity
      this.conductivity;     // soil hyd. conductivity (ft/sec)
      this.conductSlope;     // slope of conductivity v. moisture curve
      this.tensionSlope;     // slope of tension v. moisture curve
      this.upperEvapFrac;    // evaporation available in upper zone
      this.lowerEvapDepth;   // evap depth existing in lower zone (ft)
      this.lowerLossCoeff;   // coeff. for losses to deep GW (ft/sec)
      this.bottomElev;       // elevation of bottom of aquifer (ft)
      this.waterTableElev;   // initial water table elevation (ft)
      this.upperMoisture;    // initial moisture content of unsat. zone
      this.upperEvapPat;     // monthly upper evap. adjustment factors
   }
}   ;

//-----------------------
// GROUNDWATER STATISTICS
//-----------------------
class TGWaterStats
{
   constructor(){
      this.infil;           // total infiltration (ft)
      this.evap;            // total evaporation (ft)
      this.latFlow;         // total lateral outflow (ft)
      this.deepFlow;        // total flow to deep aquifer (ft)
      this.avgUpperMoist;   // avg. upper zone moisture
      this.finalUpperMoist; // final upper zone moisture
      this.avgWaterTable;   // avg. water table height (ft)
      this.finalWaterTable; // final water table height (ft)
      this.maxFlow;         // max. lateral outflow (cfs)
   }
}  ;

//------------------------
// GROUNDWATER OBJECT
//------------------------
class TGroundwater
{
   constructor(){
      this.aquifer;        // index of associated gw aquifer
      this.node;           // index of node receiving gw flow
      this.surfElev;       // elevation of ground surface (ft)
      this.a1;             // ground water outflow coeff. & exponent
      this.b1;         
      this.a2;             // surface water outflow coeff. & exponent
      this.b2;         
      this.a3;             // surf./ground water interaction coeff.
      this.fixedDepth;     // fixed surface water water depth (ft)
      this.nodeElev;       // elevation of receiving node invert (ft)
      this.bottomElev;     // bottom elevation of lower GW zone (ft)
      this.waterTableElev; // initial water table elevation (ft)
      this.upperMoisture;  // initial moisture content of unsat. zone
      //----------------------------
      this.theta;          // upper zone moisture content
      this.lowerDepth;     // depth of saturated zone (ft)
      this.oldFlow;        // gw outflow from previous time period (fps)
      this.newFlow;        // gw outflow from current time period (fps)
      this.evapLoss;       // evaporation loss rate (ft/sec)
      this.maxInfilVol;    // max. infil. upper zone can accept (ft)
      this.stats;          // TGWaterStats gw statistics
   }
} ;

//----------------
// SNOWMELT OBJECT
//----------------
// Snowmelt objects contain parameters that describe the melting
// process of snow packs on 3 different types of surfaces:
//   1 - plowable impervious area
//   2 - non-plowable impervious area
//   3 - pervious area
class TSnowmelt
{
   constructor(){
      this.ID;              // snowmelt parameter set name
      this.snn;             // fraction of impervious area plowable
      this.weplow;          // depth at which plowing begins (ft)
      this.toSubcatch;      // index of subcatch receiving plowed snow
      // The following are all arrays of size 3.
      this.si = new Array(3);           // snow depth for 100% cover
      this.dhmin = new Array(3);        // min. melt coeff. for each surface (ft/sec-F)
      this.dhmax = new Array(3);        // max. melt coeff. for each surface (ft/sec-F)
      this.tbase = new Array(3);        // base temp. for melting (F)
      this.fwfrac = new Array(3);       // free water capacity / snow depth
      this.wsnow = new Array(3);        // initial snow depth on each surface (ft)
      this.fwnow = new Array(3);        // initial free water in snow pack (ft)
      this.dhm = new Array(3);          // melt coeff. for each surface (ft/sec-F)
      // The following are arrays of size 5.
      this.sfrac = new Array(5);        // fractions moved to other areas by plowing
   }
}  ;

//----------------
// SNOWPACK OBJECT
//----------------
// Snowpack objects describe the state of the snow melt process on each
// of 3 types of snow surfaces.
class TSnowpack
{
   constructor(){
      this.snowmeltIndex;   // index of snow melt parameter set
      // The following are arrays of size 3
      this.fArea = new Array(3);        // fraction of total area of each surface
      this.wsnow = new Array(3);        // depth of snow pack (ft)
      this.fw = new Array(3);           // depth of free water in snow pack (ft)
      this.coldc = new Array(3);        // cold content of snow pack
      this.ati = new Array(3);          // antecedent temperature index (deg F)
      this.sba = new Array(3);          // initial ASC of linear ADC
      this.awe = new Array(3);          // initial AWESI of linear ADC
      this.sbws = new Array(3);         // final AWESI of linear ADC
      this.imelt = new Array(3);        // immediate melt (ft)
   }
}  ;

//---------------
// SUBAREA OBJECT
//---------------
// An array of 3 subarea objects is associated with each subcatchment object.
// They describe the runoff process on 3 types of surfaces:
//   1 - impervious with no depression storage
//   2 - impervious with depression storage
//   3 - pervious
class TSubarea
{
   constructor(){
      this.routeTo;         // code indicating where outflow is sent
      this.fOutlet;         // fraction of outflow to outlet
      this.N;               // Manning's n
      this.fArea;           // fraction of total area
      this.dStore;          // depression storage (ft)
      //-----------------------------
      this.alpha;           // overland flow factor
      this.inflow;          // inflow rate (ft/sec)
      this.runoff;          // runoff rate (ft/sec)
      this.depth;           // depth of surface runoff (ft)
   }
}  ;

//-------------------------
// LAND AREA LANDUSE FACTOR
//-------------------------
class TLandFactor
{
   constructor(){
      this.fraction;        // fraction of land area with land use
      this.buildup = [];         // array of buildups for each pollutant
      this.lastSwept;       // date/time of last street sweeping
   }
}  ;

//--------------------
// SUBCATCHMENT OBJECT
//--------------------
class TSubcatch
{
   constructor(){
      this.ID;              // subcatchment name
      this.rptFlag;         // reporting flag
      this.gage;            // raingage index
      this.outNode;         // outlet node index
      this.outSubcatch;     // outlet subcatchment index
      this.infilModel;      // infiltration method index                 //(5.1.015)
      this.infil;           // infiltration object index
      this.subArea = [];      // Array size 3 sub-area data
      for(let i = 0; i < 3; i++){this.subArea.push(new TSubarea())}
      this.width;           // overland flow width (ft)
      this.area;            // area (ft2)
      this.fracImperv;      // fraction impervious
      this.slope;           // slope (ft/ft)
      this.curbLength;      // total curb length (ft)
      this.initBuildup = [];     // initial pollutant buildup (mass/ft2)
      this.landFactor = [];      // array of land use factors TLandFactor
      this.groundwater = [];     // associated groundwater data TGroundwater*
      this.gwLatFlowExpr = [];   // user-supplied lateral outflow expression MathExpr*     
      this.gwDeepFlowExpr = [];  // user-supplied deep percolation expression MathExpr*     
      this.snowpack = [];        // associated snow pack data TSnowpack*    
      this.nPervPattern;    // pervious N pattern index                  //(5.1.013)
      this.dStorePattern;   // depression storage pattern index          //
      this.infilPattern;    // infiltration rate pattern index           //
      //-----------------------------
      this.lidArea;         // area devoted to LIDs (ft2)
      this.rainfall;        // current rainfall (ft/sec)
      this.evapLoss;        // current evap losses (ft/sec)
      this.infilLoss;       // current infil losses (ft/sec)
      this.runon;           // runon from other subcatchments (cfs)
      this.oldRunoff;       // previous runoff (cfs)
      this.newRunoff;       // current runoff (cfs)
      this.oldSnowDepth;    // previous snow depth (ft)
      this.newSnowDepth;    // current snow depth (ft)
      this.oldQual = [];         // previous runoff quality (mass/L)
      this.newQual = [];         // current runoff quality (mass/L)
      this.pondedQual = [];      // ponded surface water quality (mass)
      this.totalLoad = [];       // total washoff load (lbs or kg)
   }
   
}  ;

//-----------------------
// TIME PATTERN DATA
//-----------------------
class TPattern
{
   constructor(){
      this.ID;              // time pattern name
      this.type;            // time pattern type code
      this.count;           // number of factors
      this.factor = new Array(24);          // Array size 24time pattern factors
   }
}  ;

//------------------------------
// DIRECT EXTERNAL INFLOW OBJECT
//------------------------------
class ExtInflow
{
   constructor(){
      this.param;           // pollutant index (flow = -1)
      this.type;            // CONCEN or MASS
      this.tSeries;         // index of inflow time series
      this.basePat;         // baseline time pattern
      this.cFactor;         // units conversion factor for mass inflow
      this.baseline;        // constant baseline value
      this.sFactor;         // time series scaling factor
      this.extIfaceInflow;  // external interfacing inflow
      this.next; 
   }          // ExtInflow pointer to next inflow data object
};

class TExtInflow
{
   constructor(){
      this.param;           // pollutant index (flow = -1)
      this.type;            // CONCEN or MASS
      this.tSeries;         // index of inflow time series
      this.basePat;         // baseline time pattern
      this.cFactor;         // units conversion factor for mass inflow
      this.baseline;        // constant baseline value
      this.sFactor;         // time series scaling factor
      this.extIfaceInflow;  // external interfacing inflow
      this.next; 
   }          // ExtInflow pointer to next inflow data object
};

//-------------------------------
// DRY WEATHER FLOW INFLOW OBJECT
//-------------------------------
class DwfInflow
{
   constructor(){
      this.param;          // pollutant index (flow = -1)
      this.avgValue;       // average value (cfs or concen.)
      this.patterns = new Array(4);       // monthly, daily, hourly, weekend time patterns, array of 4
      this.next;  
   }         // /*DwfInflow*/ pointer to next inflow data object
};

class TDwfInflow
{
   constructor(){
      this.param;          // pollutant index (flow = -1)
      this.avgValue;       // average value (cfs or concen.)
      this.patterns = new Array(4);       // monthly, daily, hourly, weekend time patterns, array of 4
      this.next;  
   }         // /*DwfInflow*/ pointer to next inflow data object
};


//-------------------
// RDII INFLOW OBJECT
//-------------------
class TRdiiInflow
{
   constructor(){
      this.unitHyd;         // index of unit hydrograph
      this.area;
   }            // area of sewershed (ft2)
}  ;

//-----------------------------
// UNIT HYDROGRAPH GROUP OBJECT
//-----------------------------
class TUnitHyd
{
   constructor(){
      this.ID;              // name of the unit hydrograph object
      this.rainGage;        // index of rain gage
      // The following are all [12][3] arrays.
      this.iaMax = Array.from(Array(12), () => new Array(3));    // max. initial abstraction (IA) (in or mm)
      this.iaRecov = Array.from(Array(12), () => new Array(3));  // IA recovery rate (in/day or mm/day)
      this.iaInit = Array.from(Array(12), () => new Array(3));   // starting IA (in or mm)
      this.r = Array.from(Array(12), () => new Array(3));        // fraction of rainfall becoming I&I
      this.tBase = Array.from(Array(12), () => new Array(3));    // time base of each UH in each month (sec)
      this.tPeak = Array.from(Array(12), () => new Array(3));    // time to peak of each UH in each month (sec)
   }
}  ;

//-----------------
// TREATMENT OBJECT
//-----------------
class TTreatment
{
   constructor(){
      this.treatType;       // treatment equation type: REMOVAL/CONCEN
      this.equation;        // treatment eqn. as tokenized math terms
   }
};

//------------
// NODE OBJECT
//------------
class TNode
{
   constructor(){
      this.ID;              // node ID
      this.type;            // node type code
      this.subIndex;        // index of node's sub-category
      this.rptFlag;         // reporting flag
      this.invertElev;      // invert elevation (ft)
      this.initDepth;       // initial storage level (ft)
      this.fullDepth;       // dist. from invert to surface (ft)
      this.surDepth;        // added depth under surcharge (ft)
      this.pondedArea;      // area filled by ponded water (ft2)
      this.extInflow;       // pointer to external inflow data
      this.dwfInflow;       // pointer to dry weather flow inflow data
      this.rdiiInflow;      // pointer to RDII inflow data
      this.treatment = [];       // array of treatment data
      //-----------------
      this.degree;          // number of outflow links
      this.updated;         // true if state has been updated
      this.crownElev;       // top of highest flowing closed conduit (ft)
      this.inflow;          // total inflow (cfs)
      this.outflow;         // total outflow (cfs)
      this.losses;          // evap + exfiltration loss (ft3)
      this.oldVolume;       // previous volume (ft3)
      this.newVolume;       // current volume (ft3)
      this.fullVolume;      // max. storage available (ft3)
      this.overflow;        // overflow rate (cfs)
      this.oldDepth;        // previous water depth (ft)
      this.newDepth;        // current water depth (ft)
      this.oldLatFlow;      // previous lateral inflow (cfs)
      this.newLatFlow;      // current lateral inflow (cfs)
      this.oldQual = [];         // previous quality state
      this.newQual = [];         // current quality state
      this.oldFlowInflow;   // previous flow inflow
      this.oldNetInflow;    // previous net inflow
   }
} 

//---------------
// OUTFALL OBJECT
//---------------
class TOutfall
{
   constructor(){
      this.type;               // outfall type code
      this.hasFlapGate;        // true if contains flap gate
      this.fixedStage;         // fixed outfall stage (ft)
      this.tideCurve;          // index of tidal stage curve
      this.stageSeries;        // index of outfall stage time series
      this.routeTo;            // subcatchment index routed onto
      this.vRouted;            // flow volume routed (ft3)
      this.wRouted = [];            // pollutant load routed (mass)
   }
}  ;

//--------------------
// STORAGE UNIT OBJECT
//--------------------
class TStorage
{
   constructor(){
      this.fEvap;             // fraction of evaporation realized
      this.aConst;            // surface area at zero height (ft2)
      this.aCoeff;            // coeff. of area v. height curve
      this.aExpon;            // exponent of area v. height curve
      this.aCurve;            // index of tabulated area v. height curve
      this.exfil;             // TExfil ptr. to exfiltration object
      //-------------------
      this.hrt;               // hydraulic residence time (sec)
      this.evapLoss;          // evaporation loss (ft3)
      this.exfilLoss;         // exfiltration loss (ft3)
   }
}  ;

//--------------------
// FLOW DIVIDER OBJECT
//--------------------
class TDivider
{
   constructor(){
      this.link;              // index of link with diverted flow
      this.type;              // divider type code
      this.qMin;              // minimum inflow for diversion (cfs)
      this.qMax;              // flow when weir is full (cfs)
      this.dhMax;             // height of weir (ft)
      this.cWeir;             // weir discharge coeff.
      this.flowCurve;         // index of inflow v. diverted flow curve
   }
}  ;

//-----------------------------
// CROSS SECTION DATA STRUCTURE
//-----------------------------
class TXsect
{
   constructor(){
      this.type;            // type code of cross section shape
      this.culvertCode;     // type of culvert (if any)
      this.transect;        // index of transect/shape (if applicable)
      this.yFull;           // depth when full (ft)
      this.wMax;            // width at widest point (ft)
      this.ywMax;           // depth at widest point (ft)
      this.aFull;           // area when full (ft2)
      this.rFull;           // hyd. radius when full (ft)
      this.sFull;           // section factor when full (ft^4/3)
      this.sMax;            // section factor at max. flow (ft^4/3)
      // These variables have different meanings depending on section shape
      this.yBot;            // depth of bottom section
      this.aBot;            // area of bottom section
      this.sBot;            // slope of bottom section
      this.rBot;            // radius of bottom section
   }
}  ;

//--------------------------------------
// CROSS SECTION TRANSECT DATA STRUCTURE
//--------------------------------------
 N_TRANSECT_TBL = 51       // size of transect geometry tables

class TTransect
{
   constructor(){
      this.ID;                        // section ID
      this.yFull;                     // depth when full (ft)
      this.aFull;                     // area when full (ft2)
      this.rFull;                     // hyd. radius when full (ft)
      this.wMax;                      // width at widest point (ft)
      this.ywMax;                     // depth at max width (ft)
      this.sMax;                      // section factor at max. flow (ft^4/3)
      this.aMax;                      // area at max. flow (ft2)
      this.lengthFactor;              // floodplain / channel length
      //--------------------------------------
      this.roughness;                 // Manning's n
      this.areaTbl = new Array(N_TRANSECT_TBL); // Array size [N_TRANSECT_TBL]. table of area v. depth
      this.hradTbl = new Array(N_TRANSECT_TBL);                   // Array size [N_TRANSECT_TBL]. table of hyd. radius v. depth
      this.widthTbl = new Array(N_TRANSECT_TBL);                  // Array size [N_TRANSECT_TBL]. table of top width v. depth
      this.nTbl;                      // size of geometry tables
   }
}   ;

//-------------------------------------
// CUSTOM CROSS SECTION SHAPE STRUCTURE
//-------------------------------------
N_SHAPE_TBL = 51           // size of shape geometry tables
class TShape
{
   constructor(){
      this.curve;                     // index of shape curve
      this.nTbl;                      // size of geometry tables
      this.aFull;                     // area when full
      this.rFull;                     // hyd. radius when full
      this.wMax;                      // max. width
      this.sMax;                      // max. section factor
      this.aMax;                      // area at max. section factor
      this.areaTbl = new Array(N_SHAPE_TBL);      // double[N_SHAPE_TBL]. table of area v. depth
      this.hradTbl = new Array(N_SHAPE_TBL);      // double[N_SHAPE_TBL]. table of hyd. radius v. depth
      this.widthTbl = new Array(N_SHAPE_TBL);     // double[N_SHAPE_TBL]. table of top width v. depth
   }
}   ;

//------------
// LINK OBJECT
//------------
class TLink
{
   constructor(){
      this.ID;              // link ID
      this.type;            // link type code
      this.subIndex;        // index of link's sub-category
      this.rptFlag;         // reporting flag
      this.node1;           // start node index
      this.node2;           // end node index
      this.offset1;         // ht. above start node invert (ft)
      this.offset2;         // ht. above end node invert (ft)
      this.xsect;           // TXsect. cross section data
      this.q0;              // initial flow (cfs)
      this.qLimit;          // constraint on max. flow (cfs)
      this.cLossInlet;      // inlet loss coeff.
      this.cLossOutlet;     // outlet loss coeff.
      this.cLossAvg;        // avg. loss coeff.
      this.seepRate;        // seepage rate (ft/sec)
      this.hasFlapGate;     // true if flap gate present
      //-----------------------------
      this.oldFlow;         // previous flow rate (cfs)
      this.newFlow;         // current flow rate (cfs)
      this.oldDepth;        // previous flow depth (ft)
      this.newDepth;        // current flow depth (ft)
      this.oldVolume;       // previous flow volume (ft3)
      this.newVolume;       // current flow volume (ft3)
      this.surfArea1;       // upstream surface area (ft2)
      this.surfArea2;       // downstream surface area (ft2)
      this.qFull;           // flow when full (cfs)
      this.setting;         // current control setting
      this.targetSetting;   // target control setting
      this.timeLastSet;     // time when setting was last changed
      this.froude;          // Froude number
      this.oldQual = [];         // previous quality state
      this.newQual = [];         // current quality state
      this.totalLoad = [];       // total quality mass loading
      this.flowClass;       // flow classification
      this.dqdh;            // change in flow w.r.t. head (ft2/sec)
      this.direction;       // flow direction flag
      this.bypassed;        // bypass dynwave calc. flag
      this.normalFlow;      // normal flow limited flag
      this.inletControl;    // culvert inlet control flag
   }
}  ;

//---------------
// CONDUIT OBJECT
//---------------
class TConduit
{
   constructor(){
      this.length;          // conduit length (ft)
      this.roughness;       // Manning's n
      this.barrels;         // number of barrels
      //-----------------------------
      this.modLength;       // modified conduit length (ft)
      this.roughFactor;     // roughness factor for DW routing
      this.slope;           // slope
      this.beta;            // discharge factor
      this.qMax;            // max. flow (cfs)
      this.a1;              // upstream & downstream areas (ft2)
      this.a2;
      this.q1;              // upstream & downstream flows per barrel (cfs)
      this.q2;          
      this.q1Old;           // previous values of q1 & q2 (cfs)
      this.q2Old;
      this.evapLossRate;    // evaporation rate (cfs)
      this.seepLossRate;    // seepage rate (cfs)
      this.capacityLimited; // capacity limited flag
      this.superCritical;   // super-critical flow flag
      this.hasLosses;       // local losses flag
      this.fullState;       // determines if either or both ends full
   }
}  ;

//------------
// PUMP OBJECT
//------------
class TPump
{
   constructor(){
      this.type;            // pump type
      this.pumpCurve;       // pump curve table index
      this.initSetting;     // initial speed setting
      this.yOn;             // startup depth (ft)
      this.yOff;            // shutoff depth (ft)
      this.xMin;            // minimum pt. on pump curve
      this.xMax;            // maximum pt. on pump curve
   }
}  ;


//---------------
// ORIFICE OBJECT
//---------------
class TOrifice
{
   constructor(){
      this.type;            // orifice type code
      this.shape;           // orifice shape code
      this.cDisch;          // discharge coeff.
      this.orate;           // time to open/close (sec)
      //-----------------------------
      this.cOrif;           // coeff. for orifice flow (ft^2.5/sec)
      this.hCrit;           // inlet depth where weir flow begins (ft)
      this.cWeir;           // coeff. for weir flow (cfs)
      this.length;          // equivalent length (ft)
      this.surfArea;        // equivalent surface area (ft2)
   }
}  ;

//------------
// WEIR OBJECT
//------------
class TWeir
{
   constructor(){
      this.type;            // weir type code
      this.cDisch1;         // discharge coeff.
      this.cDisch2;         // discharge coeff. for ends
      this.endCon;          // end contractions
      this.canSurcharge;    // true if weir can surcharge
      this.roadWidth;       // width for ROADWAY weir
      this.roadSurface;     // road surface material
      this.cdCurve;         // discharge coeff. curve index              //(5.1.013)
      //-----------------------------
      this.cSurcharge;      // orifice coeff. for surcharge
      this.length;          // equivalent length (ft)
      this.slope;           // slope for Vnotch & Trapezoidal weirs
      this.surfArea;        // equivalent surface area (ft2)
   }
}  ;

//---------------------
// OUTLET DEVICE OBJECT
//---------------------
class TOutlet
{
   constructor(){
      this.qCoeff;          // discharge coeff.
      this.qExpon;          // discharge exponent
      this.qCurve;          // index of discharge rating curve
      this.curveType;       // rating curve type
   }
}   

//-----------------
// POLLUTANT OBJECT
//-----------------
class TPollut
{
   constructor(){
      this.ID;              // Pollutant ID
      this.units;           // units
      this.mcf;             // mass conversion factor
      this.dwfConcen;       // dry weather sanitary flow concen.
      this.pptConcen;       // precip. concen.
      this.gwConcen;        // groundwater concen.
      this.rdiiConcen;      // RDII concen.
      this.initConcen;      // initial concen. in conveyance network
      this.kDecay;          // decay constant (1/sec)
      this.coPollut;        // co-pollutant index
      this.coFraction;      // co-pollutant fraction
      this.snowOnly;        // TRUE if buildup occurs only under snow
   }
}  ;

//------------------------
// BUILDUP OBJECT
//------------------------
class TBuildup
{
   constructor(){
      this.normalizer;      // normalizer code (area or curb length)
      this.funcType;        // buildup type code
      this.coeff = new Array(3);           // Array of size 3. Coeffs. of buildup function
      this.maxDays;         // time to reach max. buildup (days)
   }
}  ;

//------------------------
// WASHOFF OBJECT
//------------------------
class TWashoff
{
   constructor(){
      this.funcType;        // washoff type code
      this.coeff;           // coeff.
      this.expon;           // exponent
      this.sweepEffic;      // street sweeping fractional removal
      this.bmpEffic;        // best mgt. practice fractional removal
   }
}  ;

//---------------
// LANDUSE OBJECT
//---------------
class TLanduse
{
   constructor(){
      this.ID;              // landuse name
      this.sweepInterval;   // street sweeping interval (days)
      this.sweepRemoval;    // fraction of buildup available for sweeping
      this.sweepDays0;      // days since last sweeping at start
      this.buildupFunc = [];     // TBuildup. array of buildup functions for pollutants
      this.washoffFunc = [];     // TWashoff. array of washoff functions for pollutants
   }
}  ;

//--------------------------
// REPORTING FLAGS STRUCTURE
//--------------------------
class TRptFlags
{
   constructor(){
      this.report;          // TRUE if results report generated
      this.input;           // TRUE if input summary included
      this.subcatchments;   // TRUE if subcatchment results reported
      this.nodes;           // TRUE if node results reported
      this.links;           // TRUE if link results reported
      this.continuity;      // TRUE if continuity errors reported
      this.flowStats;       // TRUE if routing link flow stats. reported
      this.nodeStats;       // TRUE if routing node depth stats. reported
      this.controls;        // TRUE if control actions reported
      this.averages;        // TRUE if average results reported          //(5.1.013)
      this.linesPerPage;    // number of lines printed per page
   }
}  ;

//-------------------------------
// CUMULATIVE RUNOFF TOTALS
//-------------------------------
class TRunoffTotals
{                                 // All volume totals are in ft3.
   constructor(){
      this.rainfall;        // rainfall volume
      this.evap;            // evaporation loss
      this.infil;           // infiltration loss
      this.runoff;          // runoff volume
      this.drains;          // LID drains
      this.runon;           // runon from outfalls
      this.initStorage;     // inital surface storage
      this.finalStorage;    // final surface storage
      this.initSnowCover;   // initial snow cover
      this.finalSnowCover;  // final snow cover
      this.snowRemoved;     // snow removal
      this.pctError;        // continuity error (%)
   }
}  ;

//--------------------------
// CUMULATIVE LOADING TOTALS
//--------------------------
class TLoadingTotals
{                                 // All loading totals are in lbs.
   constructor(){
      this.initLoad;        // initial loading
      this.buildup;         // loading added from buildup
      this.deposition;      // loading added from wet deposition
      this.sweeping;        // loading removed by street sweeping
      this.bmpRemoval;      // loading removed by BMPs
      this.infil;           // loading removed by infiltration
      this.runoff;          // loading removed by runoff
      this.finalLoad;       // final loading
      this.pctError;        // continuity error (%)
   }
}  ;

//------------------------------
// CUMULATIVE GROUNDWATER TOTALS
//------------------------------
class TGwaterTotals
{                                 // All GW flux totals are in feet.
   constructor(){
      this.infil;           // surface infiltration
      this.upperEvap;       // upper zone evaporation loss
      this.lowerEvap;       // lower zone evaporation loss
      this.lowerPerc;       // percolation out of lower zone
      this.gwater;          // groundwater flow
      this.initStorage;     // initial groundwater storage
      this.finalStorage;    // final groundwater storage
      this.pctError;        // continuity error (%)
   }
}  ;

//----------------------------
// CUMULATIVE ROUTING TOTALS
//----------------------------
class TRoutingTotals
{                                  // All routing totals are in ft3.
   constructor(){
      this.dwInflow;         // dry weather inflow
      this.wwInflow;         // wet weather inflow
      this.gwInflow;         // groundwater inflow
      this.iiInflow;         // RDII inflow
      this.exInflow;         // direct inflow
      this.flooding;         // internal flooding
      this.outflow;          // external outflow
      this.evapLoss;         // evaporation loss
      this.seepLoss;         // seepage loss
      this.reacted;          // reaction losses
      this.initStorage;      // initial storage volume
      this.finalStorage;     // final storage volume
      this.pctError;         // continuity error
   }
}  ;

//-----------------------
// SYSTEM-WIDE STATISTICS
//-----------------------
TIMELEVELS = 6                                          //(5.1.015)
class TSysStats
{
   constructor(){
      this.minTimeStep;
      this.maxTimeStep;
      this.avgTimeStep;
      this.avgStepCount;
      this.steadyStateCount;
      this.timeStepIntervals = new Array(TIMELEVELS); // Array of size [TIMELEVELS];      //(5.1.015)
      this.timeStepCounts = new Array(TIMELEVELS);    // Array of size [TIMELEVELS];      //(5.1.015)   
   }
   
}  ;

//--------------------
// RAINFALL STATISTICS
//--------------------
class TRainStats
{
   constructor(){
      this.startDate;
      this.endDate;
      this.periodsRain;
      this.periodsMissing;
      this.periodsMalfunc;
   }
}  ;

//------------------------
// SUBCATCHMENT STATISTICS
//------------------------
class TSubcatchStats
{
   constructor(){
      this.precip;
      this.runon;
      this.evap;
      this.infil;
      this.runoff;
      this.maxFlow;
      this.impervRunoff;                                                 //(5.1.013)
      this.pervRunoff;                                                   //
   }
}  ;

//----------------
// NODE STATISTICS
//----------------
class TNodeStats
{
   constructor(){
      this.avgDepth;
      this.maxDepth;
      this.maxDepthDate;
      this.maxRptDepth;
      this.volFlooded;
      this.timeFlooded;
      this.timeSurcharged;
      this.timeCourantCritical;
      this.totLatFlow;
      this.maxLatFlow;
      this.maxInflow;
      this.maxOverflow;
      this.maxPondedVol;
      this.maxInflowDate;
      this.maxOverflowDate;
   }
}  ;

//-------------------
// STORAGE STATISTICS
//-------------------
class TStorageStats
{
   constructor(){
      this.initVol;
      this.avgVol;
      this.maxVol;
      this.maxFlow;
      this.evapLosses;
      this.exfilLosses;
      this.maxVolDate;
   }
}  ;

//-------------------
// OUTFALL STATISTICS
//-------------------
class TOutfallStats
{
   constructor(){
      this.avgFlow;
      this.maxFlow;
      this.totalLoad = [];
      this.totalPeriods;
   }
}  ;

//----------------
// PUMP STATISTICS
//----------------
class TPumpStats
{
   constructor(){
      this.utilized;
      this.minFlow;
      this.avgFlow;
      this.maxFlow;
      this.volume;
      this.energy;
      this.offCurveLow;
      this.offCurveHigh;
      this.startUps;
      this.totalPeriods;
   }
}  ;

//----------------
// LINK STATISTICS
//----------------
class TLinkStats
{
   constructor(){
      this.maxFlow;
      this.maxFlowDate;
      this.maxVeloc;
      this.maxDepth;
      this.timeNormalFlow;
      this.timeInletControl;
      this.timeSurcharged;
      this.timeFullUpstream;
      this.timeFullDnstream;
      this.timeFullFlow;
      this.timeCapacityLimited;
      this.timeInFlowClass = new Array(MAX_FLOW_CLASSES)      // Array of size [MAX_FLOW_CLASSES];
      this.timeCourantCritical;
      this.flowTurns;
      this.flowTurnSign;
   }
}  ;

//-------------------------
// MAXIMUM VALUE STATISTICS
//-------------------------
class TMaxStats
{
   constructor(){
      this.objType;         // either NODE or LINK
      this.index;           // node or link index
      this.value;           // value of node or link statistic
   }
}  ;

//------------------
// REPORT FIELD INFO
//------------------
class TRptField
{
   constructor(){
      this.Name;        // Array [80]. name of reported variable
      this.Units;       // Array [80]. units of reported variable
      this.Enabled;         // TRUE if appears in report table
      this.Precision;       // number of decimal places when reported
   }
}  ;

//-----------------------------------------------------------------------------
//   text.h
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/19/14  (Build 5.1.001)
//            04/02/14  (Build 5.1.003)
//            04/14/14  (Build 5.1.004)
//            04/23/14  (Build 5.1.005)
//            05/19/14  (Build 5.1.006)
//            09/15/14  (Build 5.1.007)
//            03/19/15  (Build 5.1.008)
//            04/30/15  (Build 5.1.009)
//            08/05/15  (Build 5.1.010)
//            08/01/16  (Build 5.1.011)
//            03/14/17  (Build 5.1.012)
//            05/10/18  (Build 5.1.013)
//            03/01/20  (Build 5.1.014)
//            04/01/20  (Build 5.1.015)
//
//   Author:  L. Rossman
//
//   Text strings
//-----------------------------------------------------------------------------

 FMT01 = "\tswmm5 <input file> <report file> <output file>\n"

 FMT03 = " There are errors.\n"
 FMT04 = " There are warnings.\n"
 FMT05 = "\n"
 FMT06 = "\n o  Retrieving project data"
 FMT07 = "\n o  Writing output report"
 FMT08 = "\n  EPA STORM WATER MANAGEMENT MODEL - VERSION 5.1 (Build 5.1.015)"         //(5.1.015)
 FMT09 = "\n  --------------------------------------------------------------"
 FMT10 = "\n"
 FMT11  = "\n    Cannot use duplicate file names."
 FMT12  = "\n    Cannot open input file = "
 FMT13  = "\n    Cannot open report file = "
 FMT14  = "\n    Cannot open output file = "
 FMT15  = "\n    Cannot open temporary output file"
 FMT16  = "\n  ERROR %d detected. Execution halted."
 FMT17  = "at line %ld of input file:"                                    //(5.1.013)
 FMT18  = "at line %ld of %s] section:"                                   //(5.1.013)
 FMT19  = "\n  Maximum error count exceeded."
 FMT20  = "\n\n  Analysis begun on:  {0}"
 FMT20a = "  Analysis ended on:  {0}"
 FMT21  = "  Total elapsed time: = "

// Warning messages
 WARN01 = "WARNING 01: wet weather time step reduced to recording interval for Rain Gage"
 WARN02 = "WARNING 02: maximum depth increased for Node"
 WARN03 = "WARNING 03: negative offset ignored for Link"
 WARN04 = "WARNING 04: minimum elevation drop used for Conduit"
 WARN05 = "WARNING 05: minimum slope used for Conduit"
 WARN06 = "WARNING 06: dry weather time step increased to the wet weather time step"
 WARN07 = "WARNING 07: routing time step reduced to the wet weather time step"
 WARN08 = "WARNING 08: elevation drop exceeds length for Conduit"
 WARN09 = "WARNING 09: time series interval greater than recording interval for Rain Gage"
 WARN10a ="WARNING 10: crest elevation is below downstream invert for regulator Link"    //(5.1.013)
 WARN10b ="WARNING 10: crest elevation raised to downstream invert for regulator Link"   //(5.1.013)
 WARN11 = "WARNING 11: non-matching attributes in Control Rule"

// Analysis Option Keywords
  w_FLOW_UNITS        = "FLOW_UNITS"
  w_INFIL_MODEL       = "INFILTRATION"
  w_ROUTE_MODEL       = "FLOW_ROUTING"
  w_START_DATE        = "START_DATE"
  w_START_TIME        = "START_TIME"
  w_END_DATE          = "END_DATE"
  w_END_TIME          = "END_TIME"
  w_REPORT_START_DATE = "REPORT_START_DATE"
  w_REPORT_START_TIME = "REPORT_START_TIME"
  w_SWEEP_START       = "SWEEP_START"
  w_SWEEP_END         = "SWEEP_END"
  w_START_DRY_DAYS    = "DRY_DAYS"
  w_WET_STEP          = "WET_STEP"
  w_DRY_STEP          = "DRY_STEP"
  w_ROUTE_STEP        = "ROUTING_STEP"
  w_REPORT_STEP       = "REPORT_STEP"
  w_RULE_STEP         = "RULE_STEP"                                       //(5.1.013)
  w_ALLOW_PONDING     = "ALLOW_PONDING"
  w_INERT_DAMPING     = "INERTIAL_DAMPING"
  w_SLOPE_WEIGHTING   = "SLOPE_WEIGHTING"
  w_VARIABLE_STEP     = "VARIABLE_STEP"
  w_NORMAL_FLOW_LTD   = "NORMAL_FLOW_LIMITED"
  w_LENGTHENING_STEP  = "LENGTHENING_STEP"
  w_MIN_SURFAREA      = "MIN_SURFAREA"
  w_COMPATIBILITY     = "COMPATIBILITY"
  w_SKIP_STEADY_STATE = "SKIP_STEADY_STATE"
  w_TEMPDIR           = "TEMPDIR"
  w_IGNORE_RAINFALL   = "IGNORE_RAINFALL"
  w_FORCE_MAIN_EQN    = "FORCE_MAIN_EQUATION"
  w_LINK_OFFSETS      = "LINK_OFFSETS"
  w_MIN_SLOPE         = "MIN_SLOPE"
  w_IGNORE_SNOWMELT   = "IGNORE_SNOWMELT"
  w_IGNORE_GWATER     = "IGNORE_GROUNDWATER"
  w_IGNORE_ROUTING    = "IGNORE_ROUTING"
  w_IGNORE_QUALITY    = "IGNORE_QUALITY"
  w_MAX_TRIALS        = "MAX_TRIALS"
  w_HEAD_TOL          = "HEAD_TOLERANCE"
  w_SYS_FLOW_TOL      = "SYS_FLOW_TOL"
  w_LAT_FLOW_TOL      = "LAT_FLOW_TOL"
  w_IGNORE_RDII       = "IGNORE_RDII"
  w_MIN_ROUTE_STEP    = "MINIMUM_STEP"
  w_NUM_THREADS       = "THREADS"
  w_SURCHARGE_METHOD  = "SURCHARGE_METHOD"                                //(5.1.013)

// Flow Units
  w_CFS               = "CFS"
  w_GPM               = "GPM"
  w_MGD               = "MGD"
  w_CMS               = "CMS"
  w_LPS               = "LPS"
  w_MLD               = "MLD"

// Flow Routing Methods
  w_NF                = "NF"
  w_KW                = "KW"
  w_EKW               = "EKW"
  w_DW                = "DW"

  w_STEADY            = "STEADY"
  w_KINWAVE           = "KINWAVE"
  w_XKINWAVE          = "XKINWAVE"
  w_DYNWAVE           = "DYNWAVE"

// Surcharge Methods                                                           //(5.1.013)
  w_EXTRAN            = "EXTRAN"
  w_SLOT              = "SLOT"

// Infiltration Methods
  w_HORTON            = "HORTON"
  w_MOD_HORTON        = "MODIFIED_HORTON"
  w_GREEN_AMPT        = "GREEN_AMPT"
  w_MOD_GREEN_AMPT    = "MODIFIED_GREEN_AMPT"
  w_CURVE_NUMEBR      = "CURVE_NUMBER"

// Normal Flow Criteria
  w_SLOPE             = "SLOPE"
  w_FROUDE            = "FROUDE"
  w_BOTH              = "BOTH"

// Snowmelt Data Keywords
  w_WINDSPEED         = "WINDSPEED"
  w_SNOWMELT          = "SNOWMELT"
  w_ADC               = "ADC"
  w_PLOWABLE          = "PLOWABLE"

// Evaporation Data Options
  w_CONSTANT          = "CONSTANT"
  w_TIMESERIES        = "TIMESERIES"
  w_TEMPERATURE       = "TEMPERATURE"
  w_FILE              = "FILE"
  w_RECOVERY          = "RECOVERY"
  w_DRYONLY           = "DRY_ONLY"

// DWF Time Pattern Types
  w_MONTHLY           = "MONTHLY"
  w_DAILY             = "DAILY"
  w_HOURLY            = "HOURLY"
  w_WEEKEND           = "WEEKEND"

// Rainfall Record Types
  w_INTENSITY         = "INTENSITY"
  w_VOLUME            = "VOLUME"
  w_CUMULATIVE        = "CUMULATIVE"

// Unit Hydrograph Types
  w_SHORT             = "SHORT"
  w_MEDIUM            = "MEDIUM"
  w_LONG              = "LONG"

// Internal Runoff Routing Options
  w_OUTLET            = "OUTLET"
  w_IMPERV            = "IMPERV"
  w_PERV              = "PERV"

// Outfall Node Types
  w_FREE              = "FREE"
  w_FIXED             = "FIXED"
  w_TIDAL             = "TIDAL"
  w_CRITICAL          = "CRITICAL"
  w_NORMAL            = "NORMAL"

// Flow Divider Node Types
  w_FUNCTIONAL        = "FUNCTIONAL"
  w_TABULAR           = "TABULAR"
  w_CUTOFF            = "CUTOFF"
  w_OVERFLOW          = "OVERFLOW"

// Pump Curve Types
  w_TYPE1             = "TYPE1"
  w_TYPE2             = "TYPE2"
  w_TYPE3             = "TYPE3"
  w_TYPE4             = "TYPE4"
  w_IDEAL             = "IDEAL"

// Pump Curve Variables
  w_VOLUME            = "VOLUME"
  w_DEPTH             = "DEPTH"
  w_HEAD              = "HEAD"

// Orifice Types
  w_SIDE              = "SIDE"
  w_BOTTOM            = "BOTTOM"

// Weir Types
  w_TRANSVERSE        = "TRANSVERSE"
  w_SIDEFLOW          = "SIDEFLOW"
  w_VNOTCH            = "V-NOTCH"
  w_ROADWAY           = "ROADWAY"

// Conduit Cross-Section Shapes
  w_DUMMY             = "DUMMY"
  w_CIRCULAR          = "CIRCULAR"
  w_FILLED_CIRCULAR   = "FILLED_CIRCULAR"
  w_RECT_CLOSED       = "RECT_CLOSED"
  w_RECT_OPEN         = "RECT_OPEN"
  w_TRAPEZOIDAL       = "TRAPEZOIDAL"
  w_TRIANGULAR        = "TRIANGULAR"
  w_PARABOLIC         = "PARABOLIC"
  w_POWERFUNC         = "POWER"
  w_RECT_TRIANG       = "RECT_TRIANGULAR"
  w_RECT_ROUND        = "RECT_ROUND"
  w_MOD_BASKET        = "MODBASKETHANDLE"
  w_HORIZELLIPSE      = "HORIZ_ELLIPSE"
  w_VERTELLIPSE       = "VERT_ELLIPSE"
  w_ARCH              = "ARCH"
  w_EGGSHAPED         = "EGG"
  w_HORSESHOE         = "HORSESHOE"
  w_GOTHIC            = "GOTHIC"
  w_CATENARY          = "CATENARY"
  w_SEMIELLIPTICAL    = "SEMIELLIPTICAL"
  w_BASKETHANDLE      = "BASKETHANDLE"
  w_SEMICIRCULAR      = "SEMICIRCULAR"
  w_IRREGULAR         = "IRREGULAR"
  w_CUSTOM            = "CUSTOM"
  w_FORCE_MAIN        = "FORCE_MAIN"
  w_H_W               = "H-W"
  w_D_W               = "D-W"

// Link Offset Options
  w_ELEVATION         = "ELEVATION"

// Transect Data Input Codes
  w_NC                = "NC"
  w_X1                = "X1"
  w_GR                = "GR"

// Rain Volume Units
  w_INCHES            = "IN"
  w_MMETER            = "MM"

// Flow Volume Units
  w_MGAL              = "10^6 gal"
  w_MLTRS             = "10^6 ltr"
  w_GAL               = "gal"
  w_LTR               = "ltr"

// Ponded Depth Units
  w_PONDED_FEET       = "Feet"
  w_PONDED_METERS     = "Meters"

// Concentration Units
  w_MGperL            = "MG/L"
  w_UGperL            = "UG/L"
  w_COUNTperL         = "#/L"

// Mass Units
  w_MG                = "MG"
  w_UG                = "UG"
  w_COUNT             = "#"

// Load Units
  w_LBS               = "lbs"
  w_KG                = "kg"
  w_LOGN              = "LogN"

// Pollutant Buildup Functions
  w_POW               = "POW"
  w_EXP               = "EXP"
  w_SAT               = "SAT"
  w_EXT               = "EXT"

// Normalizing Variables for Pollutant Buildup
  w_PER_AREA          = "AREA"
  w_PER_CURB          = "CURB"

// Pollutant Washoff Functions
// (EXP defined above)
  w_RC                = "RC"
  w_EMC               = "EMC"

// Treatment Keywords
  w_REMOVAL           = "REMOVAL"
  w_RATE              = "RATE"
  w_HRT               = "HRT"
  w_DT                = "DT"
  w_AREA              = "AREA"

// Curve Types
//define  w_STORAGE (defined below)
  w_DIVERSION         = "DIVERSION"
  w_TIDAL             = "TIDAL"
  w_RATING            = "RATING"
  w_SHAPE             = "SHAPE"
  w_PUMP1             = "PUMP1"
  w_PUMP2             = "PUMP2"
  w_PUMP3             = "PUMP3"
  w_PUMP4             = "PUMP4"

// Reporting Options
  w_INPUT             = "INPUT"
  w_CONTINUITY        = "CONTINUITY"
  w_FLOWSTATS         = "FLOWSTATS"
  w_CONTROLS          = "CONTROL"
  w_NODESTATS         = "NODESTATS"
  w_AVERAGES          = "AVERAGES"                                        //(5.1.013)

// Interface File Types
  w_RAINFALL          = "RAINFALL"
  w_RUNOFF            = "RUNOFF"
  w_HOTSTART          = "HOTSTART"
  w_RDII              = "RDII"
  w_ROUTING           = "ROUTING"
  w_INFLOWS           = "INFLOWS"
  w_OUTFLOWS          = "OUTFLOWS"

// Miscellaneous Keywords
  w_OFF               = "OFF"
  w_ON                = "ON"
  w_NO                = "NO"
  w_YES               = "YES"
  w_NONE              = "NONE"
  w_ALL               = "ALL"
  w_SCRATCH           = "SCRATCH"
  w_USE               = "USE"
  w_SAVE              = "SAVE"
  w_FULL              = "FULL"
  w_PARTIAL           = "PARTIAL"

// Major Object Types
  w_GAGE              = "RAINGAGE"
  w_SUBCATCH          = "SUBCATCH"
  w_NODE              = "NODE"
  w_LINK              = "LINK"
  w_POLLUT            = "POLLUTANT"
  w_LANDUSE           = "LANDUSE"
  w_TSERIES           = "TIME SERIES"
  w_TABLE             = "TABLE"
  w_UNITHYD           = "HYDROGRAPH"

// Node Sub-Types
  w_JUNCTION          = "JUNCTION"
  w_OUTFALL           = "OUTFALL"
  w_STORAGE           = "STORAGE"
  w_DIVIDER           = "DIVIDER"

// Link Sub-Types
  w_CONDUIT           = "CONDUIT"
  w_PUMP              = "PUMP"
  w_ORIFICE           = "ORIFICE"
  w_WEIR              = "WEIR"

// Control Rule Keywords
  w_RULE              = "RULE"
  w_IF                = "IF"
  w_AND               = "AND"
  w_OR                = "OR"
  w_THEN              = "THEN"
  w_ELSE              = "ELSE"
  w_PRIORITY          = "PRIORITY"

// External Inflow Types
  w_FLOW              = "FLOW"
  w_CONCEN            = "CONCEN"
  w_MASS              = "MASS"

// Variable Units
  w_FEET              = "FEET"
  w_METERS            = "METERS"
  w_FPS               = "FT/SEC"
  w_MPS               = "M/SEC"
  w_PCNT              = "PERCENT"
  w_ACRE              = "acre"
  w_HECTARE           = "hectare"

// Input File Sections
  ws_TITLE            = "[TITLE"
  ws_OPTION           = "[OPTION"
  ws_FILE             = "[FILE"
  ws_RAINGAGE         = "[RAINGAGE"
  ws_TEMP             = "[TEMPERATURE"
  ws_EVAP             = "[EVAP"
  ws_SUBCATCH         = "[SUBCATCHMENT"
  ws_SUBAREA          = "[SUBAREA"
  ws_INFIL            = "[INFIL"
  ws_AQUIFER          = "[AQUIFER"
  ws_GROUNDWATER      = "[GROUNDWATER"
  ws_SNOWMELT         = "[SNOWPACK"
  ws_JUNCTION         = "[JUNC"
  ws_OUTFALL          = "[OUTFALL"
  ws_STORAGE          = "[STORAGE"
  ws_DIVIDER          = "[DIVIDER"
  ws_CONDUIT          = "[CONDUIT"
  ws_PUMP             = "[PUMP"
  ws_ORIFICE          = "[ORIFICE"
  ws_WEIR             = "[WEIR"
  ws_OUTLET           = "[OUTLET"
  ws_XSECTION         = "[XSECT"
  ws_TRANSECT         = "[TRANSECT"
  ws_LOSS             = "[LOSS"
  ws_CONTROL          = "[CONTROL"
  ws_POLLUTANT        = "[POLLUT"
  ws_LANDUSE          = "[LANDUSE"
  ws_BUILDUP          = "[BUILDUP"
  ws_WASHOFF          = "[WASHOFF"
  ws_COVERAGE         = "[COVERAGE"
  ws_INFLOW           = "[INFLOW"
  ws_DWF              = "[DWF"
  ws_PATTERN          = "[PATTERN"
  ws_RDII             = "[RDII"
  ws_UNITHYD          = "[HYDROGRAPH"
  ws_LOADING          = "[LOADING"
  ws_TREATMENT        = "[TREATMENT"
  ws_CURVE            = "[CURVE"
  ws_TIMESERIES       = "[TIMESERIES"
  ws_REPORT           = "[REPORT"
  ws_MAP              = "[MAP"
  ws_COORDINATE       = "[COORDINATE"
  ws_VERTICES         = "[VERTICES"
  ws_POLYGON          = "[POLYGON"
  ws_SYMBOL           = "[SYMBOL"
  ws_LABEL            = "[LABEL"
  ws_BACKDROP         = "[BACKDROP"
  ws_TAG              = "[TAG"
  ws_PROFILE          = "[PROFILE"
  ws_LID_CONTROL      = "[LID_CONTROL"
  ws_LID_USAGE        = "[LID_USAGE"
  ws_GW_FLOW          = "[GW_FLOW"     //Deprecated
  ws_GWF              = "[GWF"
  ws_ADJUST           = "[ADJUSTMENT"
  ws_EVENT            = "[EVENT"

//-----------------------------------------------------------------------------
//   keywords.c
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/14  (Build 5.1.000)
//            04/14/14  (Build 5.1.004)
//            09/15/14  (Build 5.1.007)
//            03/19/15  (Build 5.1.008)
//            08/05/15  (Build 5.1.010)
//            08/01/16  (Build 5.1.011)
//            05/10/18  (Build 5.1.013)
//   Author:  L. Rossman
//
//   Exportable keyword dictionary
//
//   NOTE: the keywords in each list must appear in same order used
//         by its complementary enumerated variable in enums.h and
//         must be terminated by null. The actual text of each keyword
//         is defined in text.h.
//
//   Build 5.1.007:
//   - Keywords for Ignore RDII option and groundwater flow equation
//     and climate adjustment input sections added.
//
//   Build 5.1.008:
//   - Keyword arrays placed in alphabetical order for better readability.
//   - Keywords added for Minimum Routing Step and Number of Threads options.
//
//   Build 5.1.010:
//   - New Modified Green Ampt keyword added to InfilModelWords.
//   - New Roadway weir keyword added to WeirTypeWords.
//
//   Build 5.1.011:
//   - New section keyword for [EVENTS] added.
//
//   Build 5.1.013:
//   - New option keywords w_SURCHARGE_METHOD, w_RULE_STEP, w_AVERAGES 
//     and w_WEIR added.
//-----------------------------------------------------------------------------

BuildupTypeWords   = [ w_NONE, w_POW, w_EXP, w_SAT, w_EXT, null];
CurveTypeWords     = [ w_STORAGE, w_DIVERSION, w_TIDAL, w_RATING,
                               w_CONTROLS, w_SHAPE, w_WEIR,                    //(5.1.013)
                               w_PUMP1, w_PUMP2, w_PUMP3, w_PUMP4, null]; 
DividerTypeWords   = [ w_CUTOFF, w_TABULAR, w_WEIR, w_OVERFLOW, null];
EvapTypeWords      = [ w_CONSTANT, w_MONTHLY, w_TIMESERIES,
                               w_TEMPERATURE, w_FILE, w_RECOVERY,
                               w_DRYONLY, null];
FileTypeWords      = [ w_RAINFALL, w_RUNOFF, w_HOTSTART, w_RDII,
                               w_INFLOWS, w_OUTFLOWS, null];
FileModeWords      = [ w_NO, w_SCRATCH, w_USE, w_SAVE, null];
FlowUnitWords      = [ w_CFS, w_GPM, w_MGD, w_CMS, w_LPS, w_MLD, null];
ForceMainEqnWords  = [ w_H_W, w_D_W, null];
GageDataWords      = [ w_TIMESERIES, w_FILE, null];
InfilModelWords    = [ w_HORTON, w_MOD_HORTON, w_GREEN_AMPT,
                               w_MOD_GREEN_AMPT, w_CURVE_NUMEBR, null];
InertDampingWords  = [ w_NONE, w_PARTIAL, w_FULL, null];
LinkOffsetWords    = [ w_DEPTH, w_ELEVATION, null];
LinkTypeWords      = [ w_CONDUIT, w_PUMP, w_ORIFICE,
                               w_WEIR, w_OUTLET ];
LoadUnitsWords     = [ w_LBS, w_KG, w_LOGN ];
NodeTypeWords      = [ w_JUNCTION, w_OUTFALL,
                               w_STORAGE, w_DIVIDER ];
NoneAllWords       = [ w_NONE, w_ALL, null];
NormalFlowWords    = [ w_SLOPE, w_FROUDE, w_BOTH, null];
NormalizerWords    = [ w_PER_AREA, w_PER_CURB, null];
NoYesWords         = [ w_NO, w_YES, null];
OffOnWords         = [ w_OFF, w_ON, null];
OldRouteModelWords = [ w_NONE, w_NF, w_KW, w_EKW, w_DW, null];
OptionWords        = [ w_FLOW_UNITS,        w_INFIL_MODEL,
                               w_ROUTE_MODEL,       w_START_DATE,
                               w_START_TIME,        w_END_DATE,
                               w_END_TIME,          w_REPORT_START_DATE,
                               w_REPORT_START_TIME, w_SWEEP_START,
                               w_SWEEP_END,         w_START_DRY_DAYS,
                               w_WET_STEP,          w_DRY_STEP,
                               w_ROUTE_STEP,        w_RULE_STEP,               //(5.1.013)
                               w_REPORT_STEP,
                               w_ALLOW_PONDING,     w_INERT_DAMPING,
                               w_SLOPE_WEIGHTING,   w_VARIABLE_STEP,
                               w_NORMAL_FLOW_LTD,   w_LENGTHENING_STEP,
                               w_MIN_SURFAREA,      w_COMPATIBILITY,
                               w_SKIP_STEADY_STATE, w_TEMPDIR,
                               w_IGNORE_RAINFALL,   w_FORCE_MAIN_EQN,
                               w_LINK_OFFSETS,      w_MIN_SLOPE,
                               w_IGNORE_SNOWMELT,   w_IGNORE_GWATER,
                               w_IGNORE_ROUTING,    w_IGNORE_QUALITY,
                               w_MAX_TRIALS,        w_HEAD_TOL,
                               w_SYS_FLOW_TOL,      w_LAT_FLOW_TOL,
                               w_IGNORE_RDII,       w_MIN_ROUTE_STEP,
                               w_NUM_THREADS,       w_SURCHARGE_METHOD,        //(5.1.013)
                               null ];
OrificeTypeWords   = [ w_SIDE, w_BOTTOM, null];
OutfallTypeWords   = [ w_FREE, w_NORMAL, w_FIXED, w_TIDAL,
                               w_TIMESERIES, null];
PatternTypeWords   = [ w_MONTHLY, w_DAILY, w_HOURLY, w_WEEKEND, null];
PondingUnitsWords  = [ w_PONDED_FEET, w_PONDED_METERS ];
ProcessVarWords    = [ w_HRT, w_DT, w_FLOW, w_DEPTH, w_AREA, null];
PumpTypeWords      = [ w_TYPE1, w_TYPE2, w_TYPE3, w_TYPE4, w_IDEAL ];
QualUnitsWords     = [ w_MGperL, w_UGperL, w_COUNTperL, null];
RainTypeWords      = [ w_INTENSITY, w_VOLUME, w_CUMULATIVE, null];
RainUnitsWords     = [ w_INCHES, w_MMETER, null];
RelationWords      = [ w_TABULAR, w_FUNCTIONAL, null];
ReportWords        = [ w_INPUT, w_CONTINUITY, w_FLOWSTATS,
                               w_CONTROLS, w_SUBCATCH, w_NODE, w_LINK,
                               w_NODESTATS, w_AVERAGES, null];                 //(5.1.013)
RouteModelWords    = [ w_NONE, w_STEADY, w_KINWAVE, w_XKINWAVE,
                               w_DYNWAVE, null];
RuleKeyWords       = [ w_RULE, w_IF, w_AND, w_OR, w_THEN, w_ELSE, 
                               w_PRIORITY, null];
SectWords          = [ ws_TITLE,          ws_OPTION,
                               ws_FILE,           ws_RAINGAGE,
                               ws_TEMP,           ws_EVAP, 
                               ws_SUBCATCH,       ws_SUBAREA,
                               ws_INFIL,          ws_AQUIFER,
                               ws_GROUNDWATER,    ws_SNOWMELT,
                               ws_JUNCTION,       ws_OUTFALL,
                               ws_STORAGE,        ws_DIVIDER,
                               ws_CONDUIT,        ws_PUMP,
                               ws_ORIFICE,        ws_WEIR,
                               ws_OUTLET,         ws_XSECTION,
                               ws_TRANSECT,       ws_LOSS,
                               ws_CONTROL,        ws_POLLUTANT,
                               ws_LANDUSE,        ws_BUILDUP,
                               ws_WASHOFF,        ws_COVERAGE,
                               ws_INFLOW,         ws_DWF,
                               ws_PATTERN,        ws_RDII, 
                               ws_UNITHYD,        ws_LOADING,
                               ws_TREATMENT,      ws_CURVE,
                               ws_TIMESERIES,     ws_REPORT,
                               ws_COORDINATE,     ws_VERTICES,
                               ws_POLYGON,        ws_LABEL,
                               ws_SYMBOL,         ws_BACKDROP, 
                               ws_TAG,            ws_PROFILE,
                               ws_MAP,            ws_LID_CONTROL,
                               ws_LID_USAGE,      ws_GWF,
                               ws_ADJUST,         ws_EVENT,
                               null];                       
SnowmeltWords      = [ w_PLOWABLE, w_IMPERV, w_PERV, w_REMOVAL, null];
SurchargeWords     = [ w_EXTRAN, w_SLOT, null];                        //(5.1.013)
TempKeyWords       = [ w_TIMESERIES, w_FILE, w_WINDSPEED, w_SNOWMELT,
                               w_ADC, null];
TransectKeyWords   = [ w_NC, w_X1, w_GR, null];
TreatTypeWords     = [ w_REMOVAL, w_CONCEN, null];
UHTypeWords        = [ w_SHORT, w_MEDIUM, w_LONG, null];
VolUnitsWords      = [ w_MGAL, w_MLTRS ];
VolUnitsWords2     = [ w_GAL, w_LTR ];
WashoffTypeWords   = [ w_NONE, w_EXP, w_RC, w_EMC, null];
WeirTypeWords      = [ w_TRANSVERSE, w_SIDEFLOW, w_VNOTCH,
                               w_TRAPEZOIDAL, w_ROADWAY, null]; 
XsectTypeWords     = [ w_DUMMY,           w_CIRCULAR,
                               w_FILLED_CIRCULAR, w_RECT_CLOSED,
                               w_RECT_OPEN,       w_TRAPEZOIDAL,
                               w_TRIANGULAR,      w_PARABOLIC,
                               w_POWERFUNC,       w_RECT_TRIANG,
                               w_RECT_ROUND,      w_MOD_BASKET,
                               w_HORIZELLIPSE,    w_VERTELLIPSE,
                               w_ARCH,            w_EGGSHAPED,
                               w_HORSESHOE,       w_GOTHIC,
                               w_CATENARY,        w_SEMIELLIPTICAL,
                               w_BASKETHANDLE,    w_SEMICIRCULAR,
                               w_IRREGULAR,       w_CUSTOM,
                               w_FORCE_MAIN,      null];

//-----------------------------------------------------------------------------
//   globals.h
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/19/14  (Build 5.1.000)
//            04/14/14  (Build 5.1.004)
//            09/15/14  (Build 5.1.007)
//            03/19/15  (Build 5.1.008)
//            08/01/16  (Build 5.1.011)
//            03/14/17  (Build 5.1.012)
//            05/10/18  (Build 5.1.013)
//            04/01/20  (Build 5.1.015)
//   Author:  L. Rossman
//
//   Global Variables
//
//   Build 5.1.004:
//   - Ignore RDII option added.
//
//   Build 5.1.007:
//   - Monthly climate variable adjustments added.
//
//   Build 5.1.008:
//   - Number of parallel threads for dynamic wave routing added.
//   - Minimum dynamic wave routing variable time step added.
//
//   Build 5.1.011:
//   - Changed WarningCode to Warnings (# warnings issued)
//   - Added error message text as a variable.
//   - Added elapsed simulation time (in decimal days) variable.
//   - Added variables associated with detailed routing events.
//
//   Build 5.1.012:
//   - InSteadyState variable made local to routing_execute in routing.c.
//
//   Build 5.1.013:
//   - CrownCutoff and RuleStep added as analysis option variables.
//
//   Build 5.1.015:
//   - Fixes bug in summary statistics when Report Start date > Start Date.
//-----------------------------------------------------------------------------


Finp        = new TFile();  // Input file
Fout        = new TFile();  // Output file
Frpt        = new TFile();  // Report file
Fclimate    = new TFile();  // Climate file
Frain       = new TFile();  // Rainfall file
Frunoff     = new TFile();  // Runoff file
Frdii       = new TFile();  // RDII inflow file
Fhotstart1  = new TFile();  // Hot start input file
Fhotstart2  = new TFile();  // Hot start output file
Finflows    = new TFile();  // Inflows routing file
Foutflows   = new TFile();  // Outflows routing file

//long
Nperiods;                 // Number of reporting periods
TotalStepCount;           // Total routing steps used        //(5.1.015)
ReportStepCount;          // Reporting routing steps used    //(5.1.015)
NonConvergeCount;         // Number of non-converging steps

//char
Msg = '';                                   // Text of output message
ErrorMsg = '';                              // Text of error message
Title = new Array(MAXTITLE);                // Project title
TempDir = '';                               // Temporary file directory


RptFlags = new TRptFlags();                 // Reporting options

//int
Nobjects = new Array(MAX_OBJ_TYPES)     // Number of each object type
Nnodes = new Array(MAX_NODE_TYPES)      // Number of each node sub-type
Nlinks = new Array(MAX_LINK_TYPES)      // Number of each link sub-type
UnitSystem                              // Unit system
FlowUnits                               // Flow units
InfilModel                              // Infiltration method
RouteModel                              // Flow routing method
ForceMainEqn                            // Flow equation for force mains
LinkOffsets                             // Link offset convention
SurchargeMethod                         // EXTRAN or SLOT method           //(5.1.013)
AllowPonding                            // Allow water to pond at nodes
InertDamping                            // Degree of inertial damping
NormalFlowLtd                           // Normal flow limited
SlopeWeighting                          // Use slope weighting
Compatibility                           // SWMM 5/3/4 compatibility
SkipSteadyState                         // Skip over steady state periods
IgnoreRainfall                          // Ignore rainfall/runoff
IgnoreRDII                              // Ignore RDII
IgnoreSnowmelt                          // Ignore snowmelt
IgnoreGwater                            // Ignore groundwater
IgnoreRouting                           // Ignore flow routing
IgnoreQuality                           // Ignore water quality
ErrorCode                               // Error code number
Warnings                                // Number of warning messages
WetStep                                 // Runoff wet time step (sec)
DryStep                                 // Runoff dry time step (sec)
ReportStep                              // Reporting time step (sec)
RuleStep                                // Rule evaluation time step (sec) //(5.1.013)
SweepStart                              // Day of year when sweeping starts
SweepEnd                                // Day of year when sweeping ends
MaxTrials                               // Max. trials for DW routing
NumThreads                              // Number of parallel threads used
NumEvents                               // Number of detailed events
                //InSteadyState;            // System flows remain constant

//double
RouteStep                // Routing time step (sec)
MinRouteStep             // Minimum variable time step (sec)
LengtheningStep          // Time step for lengthening (sec)
StartDryDays             // Antecedent dry days
CourantFactor            // Courant time step factor
MinSurfArea              // Minimum nodal surface area
MinSlope                 // Minimum conduit slope
RunoffError              // Runoff continuity error
GwaterError              // Groundwater continuity error
FlowError                // Flow routing error
QualError                // Quality routing error
HeadTol                  // DW routing head tolerance (ft)
SysFlowTol               // Tolerance for steady system flow
LatFlowTol               // Tolerance for steady nodal inflow
CrownCutoff              // Fractional pipe crown cutoff    //(5.1.013)

StartDate = new Date()                // Starting date
StartTime = new Date()                // Starting time
StartDateTime = new Date()            // Starting Date+Time
EndDate = new Date()                  // Ending date
EndTime = new Date()                  // Ending time
EndDateTime = new Date()              // Ending Date+Time
ReportStartDate = new Date()          // Report start date
ReportStartTime = new Date()          // Report start time
ReportStart = new Date()              // Report start Date+Time

//double
ReportTime               // Current reporting time (msec)
OldRunoffTime            // Previous runoff time (msec)
NewRunoffTime            // Current runoff time (msec)
OldRoutingTime           // Previous routing time (msec)
NewRoutingTime           // Current routing time (msec)
TotalDuration            // Simulation duration (msec)
ElapsedTime              // Current elapsed time (days)

Temp        = new TTemp();                     // Temperature data
Evap        = new TEvap();                     // Evaporation data
Wind        = new TWind();                     // Wind speed data
Snow        = new TSnow();                     // Snow melt data
Adjust      = new TAdjust();                   // Climate adjustments

Snowmelt = []                // Array of snow melt objects
Gage = []                     // Array of rain gages
Subcatch = []                 // Array of subcatchments
Aquifer = []                  // Array of groundwater aquifers
UnitHyd = []                  // Array of unit hydrographs
Node = []                     // Array of nodes
Outfall = []                  // Array of outfall nodes
Divider = []                  // Array of divider nodes
Storage = []                  // Array of storage nodes
Link = []                     // Array of links
Conduit = []                  // Array of conduit links
Pump = []                     // Array of pump links
Orifice = []                  // Array of orifice links
Weir = []                     // Array of weir links
Outlet = []                   // Array of outlet device links
Pollut = []                   // Array of pollutants
Landuse = []                  // Array of landuses
Pattern = []                  // Array of time patterns
Curve = []                    // Array of curve tables
Tseries = []                  // Array of time series tables
Transect = []                 // Array of transect data
Shape = []                    // Array of custom conduit shapes
swmm_Event = []                    // Array of routing events

/*
Snowmelt    = new TSnowmelt();                 // Array of snow melt objects
Gage        = new TGage();                     // Array of rain gages
Subcatch    = new TSubcatch();                 // Array of subcatchments
Aquifer     = new TAquifer();                  // Array of groundwater aquifers
UnitHyd     = new TUnitHyd();                  // Array of unit hydrographs
Node        = new TNode();                     // Array of nodes
Outfall     = new TOutfall();                  // Array of outfall nodes
Divider     = new TDivider();                  // Array of divider nodes
Storage     = new TStorage();                  // Array of storage nodes
Link        = new TLink();                     // Array of links
Conduit     = new TConduit();                  // Array of conduit links
Pump        = new TPump();                     // Array of pump links
Orifice     = new TOrifice();                  // Array of orifice links
Weir        = new TWeir();                     // Array of weir links
Outlet      = new TOutlet();                   // Array of outlet device links
Pollut      = new TPollut();                   // Array of pollutants
Landuse     = new TLanduse();                  // Array of landuses
Pattern     = new TPattern();                  // Array of time patterns
Curve       = new TTable();                    // Array of curve tables
Tseries     = new TTable();                    // Array of time series tables
Transect    = new TTransect();                 // Array of transect data
Shape       = new TShape();                    // Array of custom conduit shapes
Event       = new TEvent();                    // Array of routing events
*/

//-----------------------------------------------------------------------------
//   hash.h
//
//   Header file for Hash Table module hash.c.
//-----------------------------------------------------------------------------

HTMAXSIZE = 1999
NOTFOUND  = -1

class HTentry
{
    constructor(){
        this.key;
        this.data;
        //struct HTentry *next
        this.next;
    }
};

class HTtable
{
    constructor(){
        this.key;
        this.data;
        //struct HTentry *next
        this.next;
    }
};

//typedef struct HTentry *HTtable;

//-----------------------------------------------------------------------------
//   hash.c
//
//   Implementation of a simple Hash Table for string storage & retrieval
//   CASE INSENSITIVE
//
//   Written by L. Rossman
//   Last Updated on 6/19/03
//
//   The hash table data structure (HTable) is defined in "hash.h".
//   Interface Functions:
//      HTcreate() - creates a hash table
//      HTinsert() - inserts a string & its index value into a hash table
//      HTfind()   - retrieves the index value of a string from a table
//      HTfree()   - frees a hash table
//-----------------------------------------------------------------------------

//UCHAR(x) {(((x) >= 'a' && (x) <= 'z') ? ((x)&~32) : (x))}

/* Case-insensitive comparison of strings s1 and s2 */
// char *s1, 
// char *s2
// returns 1 if they are spelled the same, 0 if they are not.
 samestr(s1, s2)
{
    if(s1.toUpperCase() == s2.toUpperCase()){
        return 1;
    } else {
        return 0;
    }
}                                       /*  End of samestr  */

/* Use Fletcher's checksum to compute 2-byte hash of string */
// char *str
hash(str)
{
    sum1 = 0, check1;
    sum2 = 0;
    for(let i = 0; i < str.length; i++){
        sum1 += str[i];
        if (  255 <= sum1  ) sum1 -= 255;
        sum2 += sum1;
    }
    check1 = sum2;
    check1 %= 255;
    check1 = 255 - (sum1+check1) % 255;
    sum1 = 255 - (sum1+check1) % 255;
    return( ( ( check1 << 8 )  |  sum1  ) % HTMAXSIZE);
}

//HTtable *HTcreate()
HTcreate()
{
        //HTtable *ht = (HTtable *) calloc(HTMAXSIZE, sizeof(HTtable));
        ht = [];
        for(let i = 0; i < HTMAXSIZE; i++){ht.push(new HTtable())}
        //if (ht != null) for (i=0; i<HTMAXSIZE; i++) ht[i] = null;
        return(ht);
}
// HTtable *ht, char *key, int data
HTinsert(ht, key, data)
{
        let i = hash(key);
        //struct HTentry *entry;
        let entry = new HTentry();
        if ( i >= HTMAXSIZE ) return(0);
        entry.key = key;
        entry.data = data;
        entry.next = ht[i];
        ht[i] = entry;
        return(1);
}

// HTtable *ht, char *key
HTfind(ht, key)
{
        let i = hash(key);
        if ( i >= HTMAXSIZE ) return(NOTFOUND);
        let entry = ht[i];
        while (entry.key != null)
        {
            if ( samestr(entry.key,key) ) {
                return(entry.data);
            }
            entry = entry.next;
        }
        return(NOTFOUND);
}

// HTtable *ht, char *key
HTfindKey(ht, key)
{
        let i = hash(key);
        if ( i >= HTMAXSIZE ) return(null);
        let entry = ht[i];
        while (entry.key != null)
        {
            if ( samestr(entry.key,key) ) {
                return(entry.key);
            }
            entry = entry.next;
        }
        return(null);
}

// HTtable *ht
HTfree(ht)
{
        let i;

        for (i=0; i<HTMAXSIZE; i++)
        {
            ht[i] = null;
        }
        ht = null;
}

//-----------------------------------------------------------------------------
//   table.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             09/15/14   (Build 5.1.007)
//             03/19/15   (Build 5.1.008)
//   Author:   L. Rossman
//
//   Table (curve and time series) functions.
//
//   Curve and Time Series objects in SWMM 5 are both modeled with
//   TTable data structures.
//
//   The table_getFirstEntry and table_getNextEntry functions, as well as the
//   Time Series functions that use them, are not thread safe.
//
//   Build 5.1.008:
//   - The lookup functions used for Curve tables (table_lookup, table_lookupEx,
//     table_intervalLookup, table_inverseLookup, table_getSlope, table_getMaxY,
//     table_getArea, and table_getInverseArea) were made thread-safe (thanks to
//     suggestions by CHI).
//
//-----------------------------------------------------------------------------

//=============================================================================
//double x, double x1, double y1, double x2, double y2
table_interpolate(x, x1, y1, x2, y2)
//
//  Input:   x = x value being interpolated
//           x1, x2 = x values on either side of x
//           y1, y2 = y values corrresponding to x1 and x2, respectively
//  Output:  returns the y value corresponding to x
//  Purpose: interpolates a y value for a given x value.
//
{
    let dx = x2 - x1;
    if ( Math.abs(dx) < 1.0e-20 ) return (y1 + y2) / 2.;
    return y1 + (x - x1) * (y2 - y1) / dx;
}

//=============================================================================
//char* tok[], int ntoks
table_readCurve(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads a tokenized line of data for a curve table.
//
{
    let    j, m, k, k1 = 1;
    let x, y;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check for minimum number of tokens
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that curve exists in database
    j = project_findObject(CURVE, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- check if this is first line of curve's data
    //     (curve's ID will not have been assigned yet)
    if ( Curve[j].ID == null )
    {
        // --- assign ID pointer & curve type
        Curve[j].ID = project_findID(CURVE, tok[0]);
        m = findmatch(tok[1], CurveTypeWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);
        Curve[j].curveType = m;
        k1 = 2;
    }

    // --- start reading pairs of X-Y value tokens
    for ( k = k1; k < ntoks; k = k+2)
    {
        if ( k+1 >= ntoks ) return error_setInpError(ERR_ITEMS, "");
        ////////////////////////////////////
        returnObj = {y: x}
        returnVal = getDouble(tok[k], returnObj);
        x = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x = getDouble(tok[k])) )
            return error_setInpError(ERR_NUMBER, tok[k]);
        ////////////////////////////////////
        returnObj = {y: y}
        returnVal = getDouble(tok[k+1], returnObj);
        y = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (y = getDouble(tok[k+1])) )
            return error_setInpError(ERR_NUMBER, tok[k+1]);
        table_addEntry(Curve[j], x, y);
    }
    return 0;
}

//=============================================================================
// char* tok[], int ntoks
table_readTimeseries(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads a tokenized line of data for a time series table.
//
{
    let    j;                          // time series index
    let    k;                          // token index
    let    state;                      // 1: next token should be a date
                                       // 2: next token should be a time
                                       // 3: next token should be a value 
    let x, y;                           // time & value table entries
    let d;                        // day portion of date/time value
    let t;                        // time portion of date/time value
    let returnObj;
    let returnVal;

    // --- check for minimum number of tokens
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that time series exists in database
    j = project_findObject(TSERIES, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- if first line of data, assign ID pointer
    if ( Tseries[j].ID == null )
        Tseries[j].ID = project_findID(TSERIES, tok[0]);

    // --- check if time series data is in an external file
    if ( strcomp(tok[1], w_FILE ) )
    {
        sstrncpy(Tseries[j].file.name, tok[2], MAXFNAME);
        Tseries[j].file.mode = USE_FILE;
        return 0;
    }

    // --- parse each token of input line
    x = 0.0;
    k = 1;
    state = 1;               // start off looking for a date
    while ( k < ntoks )
    {
        switch(state)
        {
          case 1:            // look for a date entry
            ////////////////////////////////////
            returnObj = {d: d}
            returnVal = datetime_strToDate(tok[k], returnObj);
            d = returnObj.d;
            ////////////////////////////////////
            // datetime_strToDate(tok[k], d)
            if ( returnVal )
            {
                Tseries[j].lastDate = d;
                k++;
            }

            // --- next token must be a time
            state = 2;
            break;

          case 2:            // look for a time entry
            if ( k >= ntoks ) return error_setInpError(ERR_ITEMS, "");

            
            // --- first check for decimal hours format
            // --- then for an hrs:min format
            ////////////////////////////////////
            returnObj = {y: t}
            returnVal = getDouble(tok[k], returnObj);
            t = returnObj.y;
            ////////////////////////////////////
            //if ( null != (t = getDouble(tok[k])) ){
            if( !returnVal ){
                t /= 24.0;
            } 
            //else if ( !datetime_strToTime(tok[k], t) )
            else{
                ////////////////////////////////////
                returnObj = {t: t}
                returnVal = datetime_strToTime(tok[k], returnObj);
                t = returnObj.t;
                ////////////////////////////////////
                if(!returnVal)
                    return error_setInpError(ERR_NUMBER, tok[k]);
            }

            // --- save date + time in x
            x = Tseries[j].lastDate + t;

            // --- next token must be a numeric value
            k++;
            state = 3;
            break;

          case 3:
            // --- extract a numeric value from token
            if ( k >= ntoks ) return error_setInpError(ERR_ITEMS, "");
            ////////////////////////////////////
            returnObj = {y: y}
            returnVal = getDouble(tok[k], returnObj);
            y = returnObj.y;
            ////////////////////////////////////
            if ( !returnVal )
            //if ( null == (y = getDouble(tok[k])) )
                return error_setInpError(ERR_NUMBER, tok[k]);

            // --- add date/time & value to time series
            table_addEntry(Tseries[j], x, y);

            // --- start over looking first for a date
            k++;
            state = 1;
            break;
        }
    }
    return 0;
}

//=============================================================================
// TTable* table, double x, double y
table_addEntry(table, x, y)
//
//  Input:   table = pointer to a TTable structure
//           x = x value
//           y = y value
//  Output:  returns true if successful, false if not
//  Purpose: adds a new x/y entry to a table.
//
{
    let entry = new TTableEntry();
    entry.x = x;
    entry.y = y;
    entry.next = null;
    if ( table.firstEntry == null )  table.firstEntry = entry;
    else table.lastEntry.next = entry;
    table.lastEntry = entry;
    return true;
}

//=============================================================================
// TTable *table
  table_deleteEntries(table)
//
//  Input:   table = pointer to a TTable structure
//  Output:  none
//  Purpose: deletes all x/y entries in a table.
//
{
    //TTableEntry *entry;
    //TTableEntry *nextEntry;
    let entry;
    let nextEntry;
    entry = table.firstEntry;
    while (entry)
    {
        nextEntry = entry.next;
        entry = nextEntry;
    }
    table.firstEntry = null;
    table.lastEntry  = null;
    table.thisEntry  = null;

    if (table.file.file)
    { 
        fclose(table.file.file);
        table.file.file = null;
    }
}

//=============================================================================
//TTable *table
  table_init(table)
//
//  Input:   table = pointer to a TTable structure
//  Output:  none
//  Purpose: initializes properties when table is first created.
//
{
    if(true){
        let x = 1;
    }
    table.ID = null;
    table.refersTo = -1;
    table.firstEntry = null;
    table.lastEntry = null;
    table.thisEntry = table.firstEntry;
    table.lastDate = 0.0;
    table.x1 = 0.0;
    table.x2 = 0.0;
    table.y1 = 0.0;
    table.y2 = 0.0;
    table.dxMin = 0.0;
    table.file.mode = NO_FILE;
    table.file.file = null;
    table.curveType = -1;
}

//=============================================================================
// TTable *table
  table_validate(table)
//
//  Input:   table = pointer to a TTable structure
//  Output:  returns error code
//  Purpose: checks that table's x-values are in ascending order.
//
{
    let    result;
    let x1, x2, y1, y2;
    let dx, dxMin = BIG;

    // --- open external file if used as the table's data source
    if ( table.file.mode == USE_FILE )
    {
        table.file.file = fopen(table.file.name, "rt");
        if ( table.file.file == null ) return ERR_TABLE_FILE_OPEN;
    }

    // --- retrieve the first data entry in the table
    ////////////////////////////////////
    returnObj = {x: x1, y: y1}
    returnVal = table_getFirstEntry(table, returnObj)
    x1 = returnObj.x;
    y1 = returnObj.y;
    ////////////////////////////////////
    //result = table_getFirstEntry(table, x1, y1);
    result = returnVal;

    // --- return error condition if external file has no valid data
    if ( !result && table.file.mode == USE_FILE ) return ERR_TABLE_FILE_READ;

    // --- retrieve successive table entries and check for non-increasing x-values
    ////////////////////////////////////
    returnObj = {x: x2, y: y2}
    returnVal = table_getNextEntry(table, returnObj)
    x2 = returnObj.x;
    y2 = returnObj.y;
    ////////////////////////////////////
    //while ( table_getNextEntry(table, x2, y2) )
    while ( returnVal )
    {
        dx = x2 - x1;
        if ( dx <= 0.0 )
        {
            table.x2 = x2;
            return ERR_CURVE_SEQUENCE;
        }
        dxMin = Math.min(dxMin, dx);
        x1 = x2;
        ////////////////////////////////////
        returnObj = {x: x2, y: y2}
        returnVal = table_getNextEntry(table, returnObj)
        x2 = returnObj.x;
        y2 = returnObj.y;
        ////////////////////////////////////
    }
    table.dxMin = dxMin;

    // --- return error if external file could not be read completely
    if ( table.file.mode == USE_FILE && !feof(table.file.file) )
        return ERR_TABLE_FILE_READ;
    return 0;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {x: val1, y: val2}
//let returnVal = table_getFirstEntry(table, returnObj)
//val1 = returnObj.x;
//val2 = returnObj.y;
////////////////////////////////////
table_getFirstEntry(table, returnObj)
//int table_getFirstEntry(TTable *table, double *x, double *y)
//
//  Input:   table = pointer to a TTable structure
//  Output:  x = x-value of first table entry
//           y = y-value of first table entry
//           returns true if successful, false if not
//  Purpose: retrieves the first x/y entry in a table.
//
//  NOTE: also moves the current position pointer (thisEntry) to the 1st entry.
//
{
    //TTableEntry *entry;
    let entry;
    returnObj.x = 0;
    returnObj.y = 0.0;

    if ( table.file.mode == USE_FILE )
    {
        if ( table.file.file == null ) return false;
        rewind(table.file.file);
        return table_getNextFileEntry(table, returnObj.x, returnObj.y);
    }

    entry = table.firstEntry;
    if ( entry )
    {
        returnObj.x = entry.x;
        returnObj.y = entry.y;
        table.thisEntry = entry;
        return true;
    }
    else return false;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {x: val1, y: val2}
//let returnVal = table_getNextEntry(table, returnObj)
//val1 = returnObj.x;
//val2 = returnObj.y;
////////////////////////////////////
table_getNextEntry(table, inObj)
//int table_getNextEntry(TTable *table, double *x, double *y)
//
//  Input:   table = pointer to a TTable structure
//  Output:  x = x-value of next table entry
//           y = y-value of next table entry
//           returns true if successful, false if not
//  Purpose: retrieves the next x/y entry in a table.
//
//  NOTE: also updates the current position pointer (thisEntry).
//
{
    //TTableEntry *entry;
    let entry;

    // ret facil
    let returnObj;
    let returnVal;

    if ( table.file.mode == USE_FILE ){
        ////////////////////////////////////
        //returnObj = {x: inObj.x, y: inObj.y}
        //returnVal = table_getNextEntry(table, returnObj)
        //inObj.x = returnObj.x;
        //inObj.y = returnObj.y;
        ////////////////////////////////////
        //return returnVal;
        return table_getNextFileEntry(table, inObj.x, inObj.y);
    }
    
    if(table.thisEntry){
        entry = table.thisEntry.next;
        if ( entry )
        {
            inObj.x = entry.x;
            inObj.y = entry.y;
            table.thisEntry = entry;
            return true;
        }
        else return false;
    } else {
        return false;
    }
}

//=============================================================================
// TTable *table, double x
table_lookup(table, x)
//
//  Input:   table = pointer to a TTable structure
//           x = an x-value
//  Output:  returns a y-value
//  Purpose: retrieves the y-value corresponding to an x-value in a table,
//           using interploation if necessary.
//
//  NOTE: if x is below the first table entry, then the first y-value is
//        returned; if x is above the last entry, then the last y-value is
//        returned.
//
{
    let x1,y1,x2,y2;
    //TTableEntry* entry;
    let entry;

    entry = table.firstEntry;
    if ( entry == null ) return 0.0;
    x1 = entry.x;
    y1 = entry.y;
    if ( x <= x1 ) return y1;
    while ( entry.next )
    {
        entry = entry.next;
        x2 = entry.x;
        y2 = entry.y;
        if ( x <= x2 ) return table_interpolate(x, x1, y1, x2, y2);
        x1 = x2;
        y1 = y2;
    }
    return y1;
}

//=============================================================================
// TTable *table, double x
table_getSlope(table, x)
//
//  Input:   table = pointer to a TTable structure
//           x = an x-value
//  Output:  returns the slope of the curve at x
//  Purpose: retrieves the slope of the curve at the line segment containing x.
//
{
    let x1,y1,x2,y2;
    let dx;
    //TTableEntry* entry;
    let entry;

    entry = table.firstEntry;
    if ( entry == null ) return 0.0;
    x1 = entry.x;
    y1 = entry.y;
    x2 = x1;
    y2 = y1;
    while ( entry.next )
    {
        entry = entry.next;
        x2 = entry.x;
        y2 = entry.y;
        if ( x <= x2 ) break;
        x1 = x2;
        y1 = y2;
    }
    dx = x2 - x1;
    if ( dx == 0.0 ) return 0.0;
    return (y2 - y1) / dx;
}

//=============================================================================
// TTable *table, double x
table_lookupEx(table, x)
//
//  Input:   table = pointer to a TTable structure
//           x = an x-value
//  Output:  returns a y-value
//  Purpose: retrieves the y-value corresponding to an x-value in a table,
//           using interploation if necessary within the table and linear
//           extrapolation outside of the table.
//
{
    let x1,y1,x2,y2;
    let s = 0.0;
    //TTableEntry* entry;

    let entry = table.firstEntry;
    if (entry == null ) return 0.0;
    x1 = entry.x;
    y1 = entry.y;
    if ( x <= x1 )
    {
        if (x1 > 0.0 ) return x/x1*y1;
        else return y1;
    }
    while ( entry.next )
    {
        entry = entry.next;
        x2 = entry.x;
        y2 = entry.y;
        if ( x2 != x1 ) s = (y2 - y1) / (x2 - x1);
        if ( x <= x2 ) return table_interpolate(x, x1, y1, x2, y2);
        x1 = x2;
        y1 = y2;
    }
    if ( s < 0.0 ) s = 0.0;
    return y1 + s*(x - x1);
}

//=============================================================================
// TTable *table, double x
table_intervalLookup(table, x)
//
//  Input:   table = pointer to a TTable structure
//           x = an x-value
//  Output:  returns a y-value
//  Purpose: retrieves the y-value corresponding to the first table entry
//           whose x-value is > x.
//
{
    //TTableEntry* entry;

    let entry = table.firstEntry;
    if (entry == null ) return 0.0;
    if ( x < entry.x ) return entry.y;
    while ( entry.next )
    {
        entry = entry.next;
        if ( x < entry.x ) return entry.y;
    }
    return entry.y;
}

//=============================================================================
// TTable *table, double y
table_inverseLookup(table, y)
//
//  Input:   table = pointer to a TTable structure
//           y = a y-value
//  Output:  returns an x-value
//  Purpose: retrieves the x-value corresponding to an y-value in a table,
//           using interploation if necessary.
//
//  NOTE: if y is below the first table entry, then the first x-value is
//        returned; if y is above the last entry, then the last x-value is
//        returned.
//
{
    let x1,y1,x2,y2;
    //TTableEntry* entry;

    let entry = table.firstEntry;
    if (entry == null ) return 0.0;
    x1 = entry.x;
    y1 = entry.y;
    if ( y <= y1 ) return x1;
    while ( entry.next )
    {
        entry = entry.next;
        x2 = entry.x;
        y2 = entry.y;
        if ( y <= y2 ) return table_interpolate(y, y1, x1, y2, x2);
        x1 = x2;
        y1 = y2;
    }
    return x1;
}

//=============================================================================
// TTable *table, double x
 table_getMaxY(table, x)
//
//  Input:   table = pointer to a TTable structure
//           x = an x-value
//  Output:  returns the maximum y-value for x-values below x.
//  Purpose: finds the largest y value in the initial non-decreasing
//           portion of a table that appear before value x.
//
{
    let ymax;
    TTableEntry* entry;

    entry = table.firstEntry;
    ymax = entry.y;
    while ( x > entry.x && entry.next )
    {
        entry = entry.next;
        if ( entry.y < ymax ) return ymax;
        ymax = entry.y;
    }
    return 0.0;
}

//=============================================================================
// TTable* table, double x
 table_getArea(table, x)
//
//  Input:   table = pointer to a TTable structure
//           x = an value
//  Output:  returns area value
//  Purpose: finds area under a tabulated curve from 0 to x;
//           requires that table's x values be non-negative
//           and non-decreasing.
//
//  The area within each interval i of the table is given by:
//     Integral{ y(x)*dx } from x(i) to x
//  where y(x) = y(i) + s*dx
//        dx = x - x(i)
//        s = [y(i+1) - y(i)] / [x(i+1) - x(i)]
//  This results in the following expression for a(i):
//     a(i) = y(i)*dx + s*dx*dx/2
//
{
    let x1, x2;
    let y1, y2;
    let dx = 0.0, dy = 0.0;
    let a, s = 0.0;
    //TTableEntry* entry;

    // --- get area up to first table entry
    //     and see if x-value lies in this interval
    let entry = table.firstEntry;
    if (entry == null ) return 0.0;
    x1 = entry.x;
    y1 = entry.y;
    if ( x1 > 0.0 ) s = y1/x1;
    if ( x <= x1 ) return s*x*x/2.0;
    a = y1*x1/2.0;
    
    // --- add next table entry to area until target x-value is bracketed
    while ( entry.next )
    {
        entry = entry.next;
        x2 = entry.x;
        y2 = entry.y;
        dx = x2 - x1;
        dy = y2 - y1;
        if ( x <= x2 )
        {
            if ( dx <= 0.0 ) return a;
            y2 = table_interpolate(x, x1, y1, x2, y2);
            return a + (x - x1) * (y1 + y2) / 2.0;
        }
        a += (y1 + y2) * dx / 2.0;
        x1 = x2;
        y1 = y2;
    }

    // --- extrapolate area if table limit exceeded
    if ( dx > 0.0 ) s = dy/dx;
    else s = 0.0;
    dx = x - x1;
    return a + y1*dx + s*dx*dx/2.0;
}

//=============================================================================
// TTable* table, double a
 table_getInverseArea(table, a)
//
//  Input:   table = pointer to a TTable structure
//           a = an area value
//  Output:  returns an x value
//  Purpose: finds x value for given area under a curve.
//
//  Refer to table_getArea to see how area is computed.
//
{
    let x1, x2;
    let y1, y2;
    let dx = 0.0, dy = 0.0;
    let a1, a2, s;
    //TTableEntry* entry;

    // --- see if target area is below that of 1st table entry
    let entry = table.firstEntry;
    if (entry == null ) return 0.0;
    x1 = entry.x;
    y1 = entry.y;
    a1 = y1*x1/2.0;
    if ( a <= a1 )
    {
        if ( y1 > 0.0 ) return Math.sqrt(2.0*a*x1/y1);
        else return 0.0;
    }

    // --- add next table entry to area until target area is bracketed
    while ( entry.next )
    {
        entry = entry.next;
        x2 = entry.x;
        y2 = entry.y;
        dx = x2 - x1;
        dy = y2 - y1;
        a2 = a1 + y1*dx + dy*dx/2.0;
        if ( a <= a2 )
        {
            if ( dx <= 0.0 ) return x1;
            if ( dy == 0.0 )
            {
                if ( a2 == a1 ) return x1;
                else return x1 + dx * (a - a1) / (a2 - a1);
            }

            // --- if y decreases with x then replace point 1 with point 2
            if ( dy < 0.0 )
            {
                x1 = x2;
                y1 = y2;
                a1 = a2;
            }

            s = dy/dx;
            dx = (sqrt(y1*y1 + 2.0*s*(a-a1)) - y1) / s;
            return x1 + dx;
        }
        x1 = x2;
        y1 = y2;
        a1 = a2;
    }

    // --- extrapolate area if table limit exceeded
    if ( dx == 0.0 || dy == 0.0 )
    {
        if ( y1 > 0.0 ) dx = (a - a1) / y1;
        else dx = 0.0;
    }
    else
    {
        s = dy/dx;
        dx = (sqrt(y1*y1 + 2.0*s*(a-a1)) - y1) / s;
        if (dx < 0.0) dx = 0.0;
    }
    return x1 + dx;
}

//=============================================================================
// TTable *table
  table_tseriesInit(table)
//
//  Input:   table = pointer to a TTable structure
//  Output:  none
//  Purpose: initializes the time bracket within a time series table.
//
{
    ////////////////////////////////////
    returnObj = {x: table.x1, y: table.y1}
    returnVal = table_getFirstEntry(table, returnObj)
    table.x1 = returnObj.x;
    table.y1 = returnObj.y;
    ////////////////////////////////////
    //table_getFirstEntry(table, (table.x1), (table.y1));
    table.x2 = table.x1;
    table.y2 = table.y1;
    ////////////////////////////////////
    returnObj = {x: table.x2, y: table.y2}
    returnVal = table_getNextEntry(table, returnObj)
    table.x2 = returnObj.x;
    table.y2 = returnObj.y;
    ////////////////////////////////////
    //table_getNextEntry(table, (table.x2), (table.y2));
}

//=============================================================================
////////////////////////////////////
//returnObj = {table: val1}
//returnVal = table_tseriesLookup(returnObj, x, extend);
//val1 = returnObj.table;
////////////////////////////////////
table_tseriesLookup(inObj, x, extend)
//double table_tseriesLookup(TTable *table, double x, char extend)
//
//  Input:   table = pointer to a TTable structure
//           x = a date/time value
//           extend = true if time series extended on either end
//  Output:  returns a y-value
//  Purpose: retrieves the y-value corresponding to a time series date,
//           using interploation if necessary.
//
//  NOTE: if extend is false and date x is outside the range of the table
//        then 0 is returned; if true then the first or last value is
//        returned.
//
{
    // --- x lies within current time bracket
    if ( inObj.table.x1 <= x
    &&   inObj.table.x2 >= x
    &&   inObj.table.x1 != table.x2 )
    return table_interpolate(x, inObj.table.x1, inObj.table.y1, inObj.table.x2, inObj.table.y2);

    // --- x lies before current time bracket:
    //     move to start of time series
    if ( inObj.table.x1 == inObj.table.x2 || x < inObj.table.x1 )
    {
        ////////////////////////////////////
        returnObj = {x: inObj.table.x1, y: inObj.table.y1}
        returnVal = table_getFirstEntry(inObj.table, returnObj)
        inObj.table.x1 = returnObj.x;
        inObj.table.y1 = returnObj.y;
        ////////////////////////////////////
        //table_getFirstEntry(inObj.table, (inObj.table.x1), (inObj.table.y1));
        if ( x < inObj.table.x1 )
        {
            if ( extend == true ) return inObj.table.y1;
            else return 0;
        }
    }

    // --- x lies beyond current time bracket:
    //     update start of next time bracket
    inObj.table.x1 = inObj.table.x2;
    inObj.table.y1 = inObj.table.y2;

    // --- get end of next time bracket
    ////////////////////////////////////
    returnObj = {x: inObj.table.x2, y: inObj.table.y2}
    returnVal = table_getNextEntry(inObj.table, returnObj)
    inObj.table.x2 = returnObj.x;
    inObj.table.y2 = returnObj.y;
    ////////////////////////////////////
    //while ( table_getNextEntry(inObj.table, (inObj.table.x2), (inObj.table.y2)) )
    while ( returnVal )
    {
        // --- x lies within the bracket
        if ( x <= inObj.table.x2 )
            return table_interpolate(x, inObj.table.x1, inObj.table.y1, inObj.table.x2, inObj.table.y2);
        // --- otherwise move to next time bracket
        inObj.table.x1 = inObj.table.x2;
        inObj.table.y1 = inObj.table.y2;
        ////////////////////////////////////
        returnObj = {x: inObj.table.x2, y: inObj.table.y2}
        returnVal = table_getNextEntry(inObj.table, returnObj)
        inObj.table.x2 = returnObj.x;
        inObj.table.y2 = returnObj.y;
        ////////////////////////////////////
    }

    // --- return last value or 0 if beyond last data value
    if ( extend == true ) return inObj.table.y1;
    else return 0.0;
}

//=============================================================================
// TTable* table, double* x, double* y
 table_getNextFileEntry(table, x, y)
//
//  Input:   table = pointer to a TTable structure
//           x = pointer to a date (as decimal days)
//           y = pointer to a time series value
//  Output:  updates values of x and y;
//           returns true if successful, false if not
//  Purpose: retrieves the next date and value for a time series
//           table stored in an external file.
//
{
    let line;
    let  code;
    if ( table.file.file == null ) return false;
    while ( !feof(table.file.file) && fgets(line, MAXLINE, table.file.file) != null )
    {
        code = table_parseFileLine(line, table, x, y);
        if ( code < 0 ) continue;      //skip blank & comment lines
        return code;
    }
    return false;
}

//=============================================================================
// char* line, TTable* table, double* x, double* y
 table_parseFileLine(line, table, x, y)
//
//  Input:   table = pointer to a TTable structure
//           x = pointer to a date (as decimal days)
//           y = pointer to a time series value
//  Output:  updates values of x and y;
//           returns -1 if line was a comment, 
//           true if line successfully parsed,
//           false if line could not be parsed
//  Purpose: parses a line of time series data from an external file.
//
{
    let   n;
    let  s1,
          s2,
          s3;
    let tStr;              // time as string
    let yStr;              // value as string
    let yy;               // value as double
    let d;              // day portion of date/time value
    let t;              // time portion of date/time value
    let returnObj;
    let returnVal;

    // --- get 3 string tokens from line and check if its a comment
    n = sscanf(line, "%s %s %s", s1, s2, s3);

    // --- return if line is blank or is a comment
    tStr = strtok(line, SEPSTR);
    if ( tStr == null || tStr == ';' ) return -1;

    // --- line only has a time and a value
    if ( n == 2 )
    {
        // --- calendar date is same as last recorded date
        d = table.lastDate;
        tStr = s1;
        yStr = s2;
    }

    // --- line has date, time and a value
    else if ( n == 3 )
    {
        // --- convert date string to numeric value
        ////////////////////////////////////
        returnObj = {d: d}
        returnVal = datetime_strToDate(s1, returnObj);
        d = returnObj.d;
        ////////////////////////////////////
        //datetime_strToDate(s1, d)
        if ( !returnVal ) return false;

        // --- update last recorded calendar date
        table.lastDate = d;
        tStr = s2;
        yStr = s3;
    }
    else return false;

    // --- convert time string to numeric value
    
    ////////////////////////////////////
    returnObj = {y: t}
    returnVal = getDouble(tStr, returnObj);
    t = returnObj.y;
    ////////////////////////////////////
    //if ( null != (t = getDouble(tStr)) ) t /= 24.0;
    if ( !returnVal ){
        t /= 24.0;
    }
    else{
        ////////////////////////////////////
        returnObj = {t: t}
        returnVal = datetime_strToTime(tStr, returnObj);
        t = returnObj.t;
        ////////////////////////////////////
        if (!returnVal) {
        //if ( !datetime_strToTime(tStr, t) )
            return false;
        }
    } 

    // --- convert value string to numeric value
    ////////////////////////////////////
    returnObj = {y: yy}
    returnVal = getDouble(yStr, returnObj);
    yy = returnObj.y;
    ////////////////////////////////////
    if ( !returnVal ){
    //if ( null == (yy = getDouble(yStr)) ) 
        return false;
    }

    // --- assign values to current date and value
    x = d + t;
    y = yy;
    return true;
}


//-----------------------------------------------------------------------------
//   input.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14  (Build 5.1.001)
//             09/15/14  (Build 5.1.007)
//             08/01/16  (Build 5.1.011)
//             04/01/20  (Build 5.1.015)
//   Author:   L. Rossman
//
//   Input data processing functions.
//
//   Build 5.1.007:
//   - Support added for climate adjustment input data.
//
//   Build 5.1.011:
//   - Support added for reading hydraulic event dates.
//
//   Build 5.1.015:
//   - Support added for multiple infiltration methods within a project.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
MAXERRS = 100;        // Max. input errors reported

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
 Tok = new Array(MAXTOKS);             // String tokens from line of input
 Ntokens;                   // Number of tokens in line of input
 Mobjects = new Array(MAX_OBJ_TYPES);   // Working number of objects of each type
 Mnodes = new Array(MAX_NODE_TYPES);    // Working number of node objects
 Mlinks = new Array(MAX_LINK_TYPES);    // Working number of link objects
 Mevents;                   // Working number of event periods

//=============================================================================

input_countObjects()
//
//  Input:   none
//  Output:  returns error code
//  Purpose: reads input file to determine number of system objects.
//
{
    let  line;             // line from input data file     
    let  wLine;            // working copy of input line   
    let  tok;                        // first string token of line          
    let  sect = -1, newsect;          // input data sections          
    let  errcode = 0;                 // error code
    let  errsum = 0;                  // number of errors found                   
    let  i;
    let  lineCount = 0;
    let  iter;
    let  lineIter;

    // --- initialize number of objects & set default values
    if ( ErrorCode ) return ErrorCode;
    error_setInpError(0, "");
    for (i = 0; i < MAX_OBJ_TYPES; i++) Nobjects[i] = 0;
    for (i = 0; i < MAX_NODE_TYPES; i++) Nnodes[i] = 0;
    for (i = 0; i < MAX_LINK_TYPES; i++) Nlinks[i] = 0;

    // --- make pass through data file counting number of each object
    //while ( fgets(line, MAXLINE, Finp.contents) != null )
    while((lineIter = Finp.contents.indexOf('\n', iter)) !== -1)
    {
        // Get the contents of a line
        line = Finp.contents.substring(iter, lineIter)
        iter = lineIter + 1;

        if(lineCount >= 79){
          let goofy = 1;
        }

        // --- skip blank lines & those beginning with a comment
        lineCount++;
        wLine = line;           // make working copy of line
        //tok = strtok(wLine, SEPSTR);   // get first text token on line
        wLine = wLine.trim();
        tok = wLine.split(/[\s\t\n\r]+/)[0];
        if ( tok == null || tok == '' ) continue;
        if ( tok[0] == ';' ) continue;

        // --- check if line begins with a new section heading
        if ( tok[0] == '[' )
        {
            // --- look for heading in list of section keywords
            newsect = findmatch(tok, SectWords);
            if ( newsect >= 0 )
            {
                sect = newsect;
                continue;
            }
            else
            {
                sect = -1;
                errcode = ERR_KEYWORD;
            }
        }

        // --- if in OPTIONS section then read the option setting
        //     otherwise add object and its ID name (tok) to project
        if ( sect == s_OPTION ) errcode = readOption(line);
        else if ( sect >= 0 )   errcode = addObject(sect, tok);

        // --- report any error found
        if ( errcode )
        {
            report_writeInputErrorMsg(errcode, sect, line, lineCount);
            errsum++;
            if (errsum >= MAXERRS ) break;
        }
    }

    // --- set global error code if input errors were found
    if ( errsum > 0 ) ErrorCode = ERR_INPUT;
    return ErrorCode;
}

//=============================================================================

input_readData()
//
//  Input:   none
//  Output:  returns error code
//  Purpose: reads input file to determine input parameters for each object.
//
{
    let  line;        // line from input data file
    let  wLine;       // working copy of input line
    let  comment;                // ptr. to start of comment in input line
    let  sect, newsect;          // data sections
    let  inperr, errsum;         // error code & total error count
    let  lineLength;             // number of characters in input line
    let  i;
    let  lineCount = 0;
    let  lineIter;
    let  iter;

    // --- initialize working item count arrays
    //     (final counts in Mobjects, Mnodes & Mlinks should
    //      match those in Nobjects, Nnodes and Nlinks).
    if ( ErrorCode ) return ErrorCode;
    error_setInpError(0, "");
    for (i = 0; i < MAX_OBJ_TYPES; i++)  Mobjects[i] = 0;
    for (i = 0; i < MAX_NODE_TYPES; i++) Mnodes[i] = 0;
    for (i = 0; i < MAX_LINK_TYPES; i++) Mlinks[i] = 0;
    Mevents = 0;

    // --- initialize starting date for all time series
    for ( i = 0; i < Nobjects[TSERIES]; i++ )
    {
        Tseries[i].lastDate = StartDate + StartTime;
    }

    // --- read each line from input file
    sect = 0;
    errsum = 0;
    //rewind(Finp.file);
    // Not sure if a contents string needs rewind.
    //rewind(Finp.contents);
    //while ( fgets(line, MAXLINE, Finp.file) != null )
    while((lineIter = Finp.contents.indexOf('\n', iter)) !== -1)
    {
        // Get the contents of a line
        line = Finp.contents.substring(iter, lineIter)
        iter = lineIter + 1;

        // --- make copy of line and scan for tokens
        lineCount++;
        wLine = line;
        Ntokens = getTokens(wLine);

        // --- skip blank lines and comments
        if ( Ntokens == 0 ) continue;
        if ( Tok[0][0] == ';' ) continue;

        // --- check if max. line length exceeded
        lineLength = line.length;
        if ( lineLength >= MAXLINE )
        {
            // --- don't count comment if present
            comment = line.indexOf(';');
            if ( comment ) lineLength = comment - line;    // Pointer math here
            if ( lineLength >= MAXLINE )
            {
                inperr = ERR_LINE_LENGTH;
                report_writeInputErrorMsg(inperr, sect, line, lineCount);
                errsum++;
            }
        }

        // --- check if at start of a new input section
        if (Tok[0][0] == '[')
        {
            // --- match token against list of section keywords
            newsect = findmatch(Tok[0], SectWords);
            if (newsect >= 0)
            {
                // --- SPECIAL CASE FOR TRANSECTS
                //     finish processing the last set of transect data
                if ( sect == s_TRANSECT )
                    transect_validate(Nobjects[TRANSECT]-1);

                // --- begin a new input section
                sect = newsect;
                continue;
            }
            else
            {
                inperr = error_setInpError(ERR_KEYWORD, Tok[0]);
                report_writeInputErrorMsg(inperr, sect, line, lineCount);
                errsum++;
                break;
            }
        }

        // --- otherwise parse tokens from input line
        else
        {
            inperr = parseLine(sect, line);
            if ( inperr > 0 )
            {
                errsum++;
                if ( errsum > MAXERRS ) report_writeLine(FMT19);
                else report_writeInputErrorMsg(inperr, sect, line, lineCount);
            }
        }

        // --- stop if reach end of file or max. error count
        if (errsum > MAXERRS) break;
    }   /* End of while */

    // --- check for errors
    if (errsum > 0)  ErrorCode = ERR_INPUT;
    return ErrorCode;
}

//=============================================================================
// int objType, char* id
 addObject(objType, id)
//
//  Input:   objType = object type index
//           id = object's ID string
//  Output:  returns an error code
//  Purpose: adds a new object to the project.
//
{
    let errcode = 0;
    switch( objType )
    {
      case s_RAINGAGE:
        if ( !project_addObject(GAGE, id, Nobjects[GAGE]) )
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[GAGE]++;
        break;

      case s_SUBCATCH:
        if ( !project_addObject(SUBCATCH, id, Nobjects[SUBCATCH]) )
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[SUBCATCH]++;
        break;

      case s_AQUIFER:
        if ( !project_addObject(AQUIFER, id, Nobjects[AQUIFER]) )
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[AQUIFER]++;
        break;

      case s_UNITHYD:
        // --- the same Unit Hydrograph can span several lines
        if ( project_findObject(UNITHYD, id) < 0 )
        {
            if ( !project_addObject(UNITHYD, id, Nobjects[UNITHYD]) )
                errcode = error_setInpError(ERR_DUP_NAME, id);
            Nobjects[UNITHYD]++;
        }
        break;

      case s_SNOWMELT:
        // --- the same Snowmelt object can appear on several lines
        if ( project_findObject(SNOWMELT, id) < 0 )
        {
            if ( !project_addObject(SNOWMELT, id, Nobjects[SNOWMELT]) )
                errcode = error_setInpError(ERR_DUP_NAME, id);
            Nobjects[SNOWMELT]++;
        }
        break;

      case s_JUNCTION:
        if ( !project_addObject(NODE, id, Nobjects[NODE]) )
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[NODE]++;
        Nnodes[JUNCTION]++;
        break;

      case s_OUTFALL:
        if ( !project_addObject(NODE, id, Nobjects[NODE]) )
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[NODE]++;
        Nnodes[OUTFALL]++;
        break;

      case s_STORAGE:
        if ( !project_addObject(NODE, id, Nobjects[NODE]) )
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[NODE]++;
        Nnodes[STORAGE]++;
        break;

      case s_DIVIDER:
        if ( !project_addObject(NODE, id, Nobjects[NODE]) )
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[NODE]++;
        Nnodes[DIVIDER]++;
        break;

      case s_CONDUIT:
        if ( !project_addObject(LINK, id, Nobjects[LINK]) )
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[LINK]++;
        Nlinks[CONDUIT]++;
        break;

      case s_PUMP:
        if ( !project_addObject(LINK, id, Nobjects[LINK]) ) 
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[LINK]++;
        Nlinks[PUMP]++;
        break;

      case s_ORIFICE:
        if ( !project_addObject(LINK, id, Nobjects[LINK]) ) 
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[LINK]++;
        Nlinks[ORIFICE]++;
        break;

      case s_WEIR:
        if ( !project_addObject(LINK, id, Nobjects[LINK]) ) 
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[LINK]++;
        Nlinks[WEIR]++;
        break;

      case s_OUTLET:
        if ( !project_addObject(LINK, id, Nobjects[LINK]) )
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[LINK]++;
        Nlinks[OUTLET]++;
        break;

      case s_POLLUTANT:
        if ( !project_addObject(POLLUT, id, Nobjects[POLLUT]) ) 
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[POLLUT]++;
        break;

      case s_LANDUSE:
        if ( !project_addObject(LANDUSE, id, Nobjects[LANDUSE]) ) 
            errcode = error_setInpError(ERR_DUP_NAME, id);
        Nobjects[LANDUSE]++;
        break;

      case s_PATTERN:
        // --- a time pattern can span several lines
        if ( project_findObject(TIMEPATTERN, id) < 0 )
        {
            if ( !project_addObject(TIMEPATTERN, id, Nobjects[TIMEPATTERN]) )
                errcode = error_setInpError(ERR_DUP_NAME, id);
            Nobjects[TIMEPATTERN]++;
        }
        break;

      case s_CURVE:
        // --- a Curve can span several lines
        if ( project_findObject(CURVE, id) < 0 )
        {
            if ( !project_addObject(CURVE, id, Nobjects[CURVE]) )
                errcode = error_setInpError(ERR_DUP_NAME, id);
            Nobjects[CURVE]++;

            // --- check for a conduit shape curve
            id = strtok(null, SEPSTR);
            if ( findmatch(id, CurveTypeWords) == SHAPE_CURVE )
                Nobjects[SHAPE]++;
        }
        break;

      case s_TIMESERIES:
        // --- a Time Series can span several lines
        if ( project_findObject(TSERIES, id) < 0 )
        {
            if ( !project_addObject(TSERIES, id, Nobjects[TSERIES]) )
                errcode = error_setInpError(ERR_DUP_NAME, id);
            Nobjects[TSERIES]++;
        }
        break;

      case s_CONTROL:
        if ( match(id, w_RULE) ) Nobjects[CONTROL]++;
        break;

      case s_TRANSECT:
        // --- for TRANSECTS, ID name appears as second entry on X1 line
        if ( match(id, "X1") )
        {
            id = strtok(null, SEPSTR);
            if ( id ) 
            {
                if ( !project_addObject(TRANSECT, id, Nobjects[TRANSECT]) )
                    errcode = error_setInpError(ERR_DUP_NAME, id);
                Nobjects[TRANSECT]++;
            }
        }
        break;

      case s_LID_CONTROL:
        // --- an LID object can span several lines
        if ( project_findObject(LID, id) < 0 )
        {
            if ( !project_addObject(LID, id, Nobjects[LID]) )
            {
                errcode = error_setInpError(ERR_DUP_NAME, id);
            }
            Nobjects[LID]++;
        }
        break;

      case s_EVENT: NumEvents++; break;
    }
    return errcode;
}

//=============================================================================
//int sect, char *line
 parseLine(sect, line)
//
//  Input:   sect  = current section of input file
//           *line = line of text read from input file
//  Output:  returns error code or 0 if no error found
//  Purpose: parses contents of a tokenized line of text read from input file.
//
{
    let j, err;
    switch (sect)
    {
      case s_TITLE:
        return readTitle(line);

      case s_RAINGAGE:
        j = Mobjects[GAGE];
        err = gage_readParams(j, Tok, Ntokens);
        Mobjects[GAGE]++;
        return err;

      case s_TEMP:
        return climate_readParams(Tok, Ntokens);

      case s_EVAP:
        return climate_readEvapParams(Tok, Ntokens);

      case s_ADJUST:
        return climate_readAdjustments(Tok, Ntokens);

      case s_SUBCATCH:
        j = Mobjects[SUBCATCH];
        err = subcatch_readParams(j, Tok, Ntokens);
        Mobjects[SUBCATCH]++;
        return err;

      case s_SUBAREA:
        return subcatch_readSubareaParams(Tok, Ntokens);

      case s_INFIL:
        return infil_readParams(InfilModel, Tok, Ntokens);                     //(5.1.015)

      case s_AQUIFER:
        j = Mobjects[AQUIFER];
        err = gwater_readAquiferParams(j, Tok, Ntokens);
        Mobjects[AQUIFER]++;
        return err;

      case s_GROUNDWATER:
        return gwater_readGroundwaterParams(Tok, Ntokens);

      case s_GWF:
        return gwater_readFlowExpression(Tok, Ntokens);

      case s_SNOWMELT:
        return snow_readMeltParams(Tok, Ntokens);

      case s_JUNCTION:
        return readNode(JUNCTION);

      case s_OUTFALL:
        return readNode(OUTFALL);

      case s_STORAGE:
        return readNode(STORAGE);

      case s_DIVIDER:
        return readNode(DIVIDER);

      case s_CONDUIT:
        return readLink(CONDUIT);

      case s_PUMP:
        return readLink(PUMP);

      case s_ORIFICE:
        return readLink(ORIFICE);

      case s_WEIR:
        return readLink(WEIR);

      case s_OUTLET:
        return readLink(OUTLET);

      case s_XSECTION:
        return link_readXsectParams(Tok, Ntokens);

      case s_TRANSECT:
        return transect_readParams(Mobjects[TRANSECT], Tok, Ntokens);

      case s_LOSSES:
        return link_readLossParams(Tok, Ntokens);

      case s_POLLUTANT:
        j = Mobjects[POLLUT];
        err = landuse_readPollutParams(j, Tok, Ntokens);
        Mobjects[POLLUT]++;
        return err;

      case s_LANDUSE:
        j = Mobjects[LANDUSE];
        err = landuse_readParams(j, Tok, Ntokens);
        Mobjects[LANDUSE]++;
        return err;

      case s_BUILDUP:
        return landuse_readBuildupParams(Tok, Ntokens);

      case s_WASHOFF:
        return landuse_readWashoffParams(Tok, Ntokens);

      case s_COVERAGE:
        return subcatch_readLanduseParams(Tok, Ntokens);

      case s_INFLOW:
        return inflow_readExtInflow(Tok, Ntokens);

      case s_DWF:
        return inflow_readDwfInflow(Tok, Ntokens);

      case s_PATTERN:
        return inflow_readDwfPattern(Tok, Ntokens);

      case s_RDII:
        return rdii_readRdiiInflow(Tok, Ntokens);

      case s_UNITHYD:
        return rdii_readUnitHydParams(Tok, Ntokens);

      case s_LOADING:
        return subcatch_readInitBuildup(Tok, Ntokens);

      case s_TREATMENT:
        return treatmnt_readExpression(Tok, Ntokens);

      case s_CURVE:
        return table_readCurve(Tok, Ntokens);

      case s_TIMESERIES:
        return table_readTimeseries(Tok, Ntokens);

      case s_CONTROL:
        return readControl(Tok, Ntokens);

      case s_REPORT:
        return report_readOptions(Tok, Ntokens);

      case s_FILE:
        return iface_readFileParams(Tok, Ntokens);

      case s_LID_CONTROL:
        return lid_readProcParams(Tok, Ntokens);

      case s_LID_USAGE:
        return lid_readGroupParams(Tok, Ntokens);

      case s_EVENT:
        return readEvent(Tok, Ntokens);

      default: return 0;
    }
}

//=============================================================================
//char* tok[], int ntoks
readControl(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns error code
//  Purpose: reads a line of input for a control rule.
//
{
    let index;
    let keyword;

    // --- check for minimum number of tokens
    if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");

    // --- get index of control rule keyword
    keyword = findmatch(tok[0], RuleKeyWords);
    if ( keyword < 0 ) return error_setInpError(ERR_KEYWORD, tok[0]);

    // --- if line begins a new control rule, add rule ID to the database
    if ( keyword == 0 )
    {
        if ( !project_addObject(CONTROL, tok[1], Mobjects[CONTROL]) )
        {
            return error_setInpError(ERR_DUP_NAME, Tok[1]);
        }
        Mobjects[CONTROL]++;
    }

    // --- get index of last control rule processed
    index = Mobjects[CONTROL] - 1;
    if ( index < 0 ) return error_setInpError(ERR_RULE, "");

    // --- add current line as a new clause to the control rule
    return controls_addRuleClause(index, keyword, Tok, Ntokens);
}

//=============================================================================
//char* line
readOption(line)
//
//  Input:   line = line of input data
//  Output:  returns error code
//  Purpose: reads an input line containing a project option.
//
{
    Ntokens = getTokens(line);
    if ( Ntokens < 2 ) return 0;
    return project_readOption(Tok[0], Tok[1]);
}

//=============================================================================

readTitle(line)
//
//  Input:   line = line from input file
//  Output:  returns error code
//  Purpose: reads project title from line of input.
//
{
    let i, n;
    for (i = 0; i < MAXTITLE; i++)
    {
        // --- find next empty Title entry
        if ( Title[i].length == 0 )
        {
            // --- strip line feed character from input line
            n = line.length;
            if (line[n-1] == 10) line[n-1] = ' ';

            // --- copy input line into Title entry
            Title[i] = line;
            break;
        }
    }
    return 0;
}

//=============================================================================
// int type
readNode(type)
//
//  Input:   type = type of node
//  Output:  returns error code
//  Purpose: reads data for a node from a line of input.
//
{
    let j = Mobjects[NODE];
    let k = Mnodes[type];
    let err = node_readParams(j, type, k, Tok, Ntokens);
    Mobjects[NODE]++;
    Mnodes[type]++;
    return err;
}

//=============================================================================
// int type
readLink(type)
//
//  Input:   type = type of link
//  Output:  returns error code
//  Purpose: reads data for a link from a line of input.
//
{
    let j = Mobjects[LINK];
    let k = Mlinks[type];
    let err = link_readParams(j, type, k, Tok, Ntokens);
    Mobjects[LINK]++;
    Mlinks[type]++;
    return err;
}

//=============================================================================
//char* tok[], int ntoks
 readEvent(tok, ntoks)
{
    //DateTime x[4];
    let x = new Array(4);
    let returnObj;
    let returnVal;

    if ( ntoks < 4 ) return error_setInpError(ERR_ITEMS, "");
    ////////////////////////////////////
    returnObj = {d: x[0]}
    returnVal = datetime_strToDate(tok[0], returnObj);
    x[0] = returnObj.d;
    ////////////////////////////////////
    //if ( !datetime_strToDate(tok[0], x[0]) )
    if ( !returnVal )
        return error_setInpError(ERR_DATETIME, tok[0]);
    ////////////////////////////////////
    returnObj = {t: x[1]}
    returnVal = datetime_strToTime(tok[1], returnObj);
    x[1] = returnObj.t;
    ////////////////////////////////////
    //if ( !datetime_strToTime(tok[1], x[1]) )
    if ( !returnVal )
        return error_setInpError(ERR_DATETIME, tok[1]);
    ////////////////////////////////////
    returnObj = {d: x[2]}
    returnVal = datetime_strToDate(tok[2], returnObj);
    x[2] = returnObj.d;
    ////////////////////////////////////
    //if ( !datetime_strToDate(tok[2], x[2]) )
    if ( !returnVal )
        return error_setInpError(ERR_DATETIME, tok[2]);
    ////////////////////////////////////
    returnObj = {t: x[3]}
    returnVal = datetime_strToTime(tok[3], returnObj);
    x[3] = returnObj.t;
    ////////////////////////////////////
    //if ( !datetime_strToTime(tok[3], x[3]) )
    if(!returnVal)
        return error_setInpError(ERR_DATETIME, tok[3]);

    swmm_Event[Mevents].start = x[0] + x[1];
    swmm_Event[Mevents].end = x[2] + x[3];
    if ( swmm_Event[Mevents].starswmm_swmm_EventEvent[Mevents].end )
       return error_setInpError(ERR_DATETIME, " - start date exceeds end date");
    Mevents++;
    return 0;
}

//=============================================================================
// char *s, char *keyword[]
 findmatch(s, keyword)
//
//  Input:   s = character string
//           keyword = array of keyword strings
//  Output:  returns index of matching keyword or -1 if no match found  
//  Purpose: finds match between string and array of keyword strings.
//
{
   let i = 0;
   while (keyword[i] != null)
   {
      if (match(s, keyword[i])) return(i);
      i++;
   }
   return(-1);
}

//=============================================================================
// char *str, char *substr
  match(str, substr)
//
//  Input:   str = character string being searched
//           substr = sub-string being searched for
//  Output:  returns 1 if sub-string found, 0 if not
//  Purpose: sees if a sub-string of characters appears in a string
//           (not case sensitive).
//
{
    let i,j;

    // --- fail if substring is empty
    if (!substr[0]) return(0);

    // --- skip leading blanks of str
    for (i = 0; str[i]; i++)
    {
        if (str[i] != ' ') break;
    }

    // --- check if substr matches remainder of str
    //for (i = i,j = 0; substr[j] !== undefined && str[i] !== undefined; i++,j++)
    for (i = i,j = 0; j < substr.length && i < str.length; i++,j++)
    {
        if (!str[i] || str[i].toUpperCase() != substr[j].toUpperCase()) return 0;
    }
    return 1;
}

//=============================================================================
// char *s, int *y
 getInt(s)
//
//  Input:   s = a character string
//  Output:  y = converted value of s,
//           returns 1 if conversion successful, 0 if not
//  Purpose: converts a string to an integer number.
//
{
    /*let x;
    if ( getDouble(s, x) )
    {
        if ( x < 0.0 ) x -= 0.01;
        else x += 0.01;
        y = x;
        return 1;
    }
    y = 0;
    return 0;*/
    return parseInt(s);
}

//=============================================================================
// char *s, float *y
 getFloat(s)
//
//  Input:   s = a character string
//  Output:  y = converted value of s,
//           returns 1 if conversion successful, 0 if not
//  Purpose: converts a string to a single precision floating point number.
//
{
    /*let endptr;
    y = strtod(s, endptr);
    if (endptr > 0) return(0);
    return(1);
    return 1;*/
    return parseFloat(s);
}

//=============================================================================
////////////////////////////////////
//let returnObj = {y: val1}
//let returnVal = getDouble(s, returnObj);
//val1 = returnObj.y;
////////////////////////////////////
 getDouble(s, inObj)
//int  getDouble(char *s, double *y)
//
//  Input:   s = a character string
//  Output:  y = converted value of s,
//           returns 1 if conversion successful, 0 if not
//  Purpose: converts a string to a double precision floating point number.
//
{
    inObj.y = parseFloat(s);
    if(isNaN(inObj.y)){
      return 0;
    }
    return 1;
}

//=============================================================================
// char *s
 getTokens(s)
//
//  Input:   s = a character string
//  Output:  returns number of tokens found in s
//  Purpose: scans a string for tokens, saving pointers to them
//           in shared variable Tok[].
//
//  Notes:   Tokens can be separated by the characters listed in SEPSTR
//           (spaces, tabs, newline, carriage return) which is defined
//           in CONSTS.H. Text between quotes is treated as a single token.
//
{
    let  len, fullLen, m, n;
    let  c;
    // copy of s
    let s_full = (' ' + s).slice(1);

    // --- begin with no tokens
    for (n = 0; n < MAXTOKS; n++) Tok[n] = null;
    n = 0;

    // --- truncate s at start of comment 
    c = s.indexOf(';');
    if (c >= 0) c = '\0';
    len = s.length;
    fullLen = len;

    // --- scan s for tokens until nothing left
    while (len > 0 && n < MAXTOKS)
    {
        // Remove leading spaces
        while(s[0] == ' '){
          len--;
          s = s.substring(1);
        }       
        let x = s.split(/[\s\t\n\r]+/g);
        if(s.split(/[\s\t\n\r]+/)[n]){
          m = s.split(/[\s\t\n\r]+/)[n].length    // find token length             
          if (m == 0){                           // no token found
            len--;                                // reduce the size of the string
            s = s.substring(1);                  // Remove the first letter
          }
          else
          {
              if (s[0] == '"')                  // token begins with quote
              {
                  s = s.subtstring(1);          // start token after quote
                  len--;                        // reduce length of s
                  //m = strcspn(s,"\"\n");      // find end quote or new line
                  m = s.split(/["\n]+/)[n].length
              }
              Tok[n] = s.split(/["\s\t\n\r]+/)[n];
              len = fullLen - (s_full.indexOf(Tok[n]) + Tok[n].length)
              n++;                            // update token count
          }
        } else {
          len--;                                // reduce the size of the string
          s = s.substring(1);                  // Remove the first letter
        }
        //len -= m+1;                           // indicate how many letters are left in the line
    }
    return(n);
}

//=============================================================================


//-----------------------------------------------------------------------------
//  odesolve.h
//
//  Header file for ODE solver contained in odesolve.c
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//   odesolve.c
//
//   Fifth-order Runge-Kutta integration with adaptive step size control
//   based on code from Numerical Recipes in C (Cambridge University
//   Press, 1992).
//
//   Date:     11/15/06
//   Author:   L. Rossman
//-----------------------------------------------------------------------------

MAXSTP = 10000
TINY   = 1.0e-30
SAFETY = 0.9
PGROW  = -0.2
PSHRNK = -0.25
ERRCON = 1.89e-4    // = (5/SAFETY)^(1/PGROW)


//-----------------------------------------------------------------------------
//    Local declarations
//-----------------------------------------------------------------------------
     nmax;      // max. number of equations
 y = [];         // dependent variable
 yscal = [];     // scaling factors
 yerr = [];      // integration errors
 ytemp = [];     // temporary values of y
 dydx = [];      // derivatives of y
 ak = [];        // derivatives at intermediate points

//-----------------------------------------------------------------------------
//    open the ODE solver to solve system of n equations
//    (return 1 if successful, 0 if not)
//-----------------------------------------------------------------------------
// int n
odesolve_open(n)
{
    nmax  = 0;
    y     = new Array(n).fill(0);
    yscal = new Array(n).fill(0);
    dydx  = new Array(n).fill(0);
    yerr  = new Array(n).fill(0);
    ytemp = new Array(n).fill(0);
    ak    = new Array(5*n).fill(0);
    if ( !y || !yscal || !dydx || !yerr || !ytemp || !ak ) return 0;
    nmax = n;
    return 1;
}


//-----------------------------------------------------------------------------
//    close the ODE solver
//-----------------------------------------------------------------------------
odesolve_close()
{
    /*if ( y ) free(y);
    if (y) { y = []; }
    y = null;
    if ( yscal ) free(yscal);
    yscal = null;
    if ( dydx ) free(dydx);
    dydx = null;
    if ( yerr ) free(yerr);
    yerr = null;
    if ( ytemp ) free(ytemp);
    ytemp = null;
    if ( ak ) free(ak);
    ak = null;*/
    y = [];
    yscal = [];
    dydx = [];
    yerr = [];
    ytemp = [];
    ak = [];
    nmax = 0;
}


odesolve_integrate(ystart, n, x1, x2, eps, h1, derivs)
//int odesolve_integrate(double ystart[], int n, double x1, double x2,
//    double eps, double h1, void (*derivs)(double, double*, double*))
//---------------------------------------------------------------
//   Driver for Runge-Kutta integration with adaptive
//   stepsize control. Integrates starting n values in ystart[]
//   from x1 to x2 with accuracy eps. h1 is the initial stepsize
//   guess and derivs is a user-supplied that computes
//   derivatives dy/dx of y. On completion, ystart[] contains the
//   new values of y at the end of the integration interval.
//---------------------------------------------------------------
{
    let i, errcode, nstp;
    let hdid, hnext;
    let x = x1;
    let h = h1;

    // ret facil
    let returnObj;
    let returnVal;

    if (nmax < n) return 1;
    for (i=0; i<n; i++){
        y[i] = ystart[i];
    } 
    for (nstp=1; nstp<=MAXSTP; nstp++)
    {
        ////////////////////////////////////
        returnObj = {v1: y, v2: dydx}
        returnVal = derivs(x, returnObj);
        y = returnObj.v1;
        dydx = returnObj.v2;
        ////////////////////////////////////
        //derivs(x,y,dydx);
        for (i=0; i<n; i++)
            yscal[i] = Math.abs(y[i]) + Math.abs(dydx[i]*h) + TINY;
        if ((x+h-x2)*(x+h-x1) > 0.0) h = x2 - x;

        ////////////////////////////////////
        returnObj = {x: x, hdid: hdid, hnext: hnext}
        returnVal = rkqs(n, h, eps, returnObj , derivs)
        x = returnObj.x;
        hdid = returnObj.hdid;
        hnext = returnObj.hnext;
        ////////////////////////////////////
        errcode = returnVal;
        //errcode = rkqs(&x,n,h,eps,&hdid,&hnext,derivs);
        if (errcode) break;
        if ((x-x2)*(x2-x1) >= 0.0)
        {
            for (i=0; i<n; i++) {
                ystart[i] = y[i];
            }
            return 0;
        }
        if (Math.abs(hnext) <= 0.0) return 2;
        h = hnext;
    }
    return 3;
}


////////////////////////////////////
//let returnObj = {x: val1; hdid: val2, hnext: val3}
//let returnVal = rkqs(n, htry, eps, returnObj , derivs)
//val1 = returnObj.x;
//val2 = returnObj.hdid;
//val3 = returnObj.hnext;
////////////////////////////////////
rkqs(n, htry, eps, inObj , derivs)
//int rkqs(double* x, int n, double htry, double eps, double* hdid,
//   double* hnext, void (*derivs)(double, double*, double*))
//---------------------------------------------------------------
//   Fifth-order Runge-Kutta integration step with monitoring of
//   local truncation error to assure accuracy and adjust stepsize.
//   Inputs are current value of x, trial step size (htry), and
//   accuracy (eps). Outputs are stepsize taken (hdid) and estimated
//   next stepsize (hnext). Also updated are the values of y[].
//---------------------------------------------------------------
{
    let i;
    let err, errmax, h, htemp, xnew, xold = inObj.x;

    // --- set initial stepsize
    h = htry;
    for (;;)
    {
        // --- take a Runge-Kutta-Cash-Karp step
        rkck(xold, n, h, derivs);

        // --- compute scaled maximum error
        errmax = 0.0;
        for (i=0; i<n; i++)
        {
            err = Math.abs(yerr[i]/yscal[i]);
            if (err > errmax) errmax = err;
        }
        errmax /= eps;

        // --- error too large; reduce stepsize & repeat
        if (errmax > 1.0)
        {
            htemp = SAFETY*h*Math.pow(errmax,PSHRNK);
            if (h >= 0)
            {
                if (htemp > 0.1*h) h = htemp;
                else h = 0.1*h;
            }
            else
            {
                if (htemp < 0.1*h) h = htemp;
                else h = 0.1*h;
            }
            xnew = xold + h;
            if (xnew == xold) return 2;
            continue;
        }

        // --- step succeeded; compute size of next step
        else
        {
            if (errmax > ERRCON) inObj.hnext = SAFETY*h*Math.pow(errmax,PGROW);
            else inObj.hnext = 5.0*h;
            inObj.x += (inObj.hdid=h);
            for (i=0; i<n; i++) y[i] = ytemp[i];
            return 0;
        }
    }
}


rkck(x, n, h, derivs)
//void rkck(double x, int n, double h, void (*derivs)(double, double*, double*))
//----------------------------------------------------------------------
//   Uses the Runge-Kutta-Cash-Karp method to advance y[] at x
//   over stepsize h.
//----------------------------------------------------------------------
{
    let a2=0.2, a3=0.3, a4=0.6, a5=1.0, a6=0.875,
           b21=0.2, b31=3.0/40.0, b32=9.0/40.0, b41=0.3, b42= -0.9, b43=1.2,
           b51= -11.0/54.0, b52=2.5, b53= -70.0/27.0, b54=35.0/27.0,
           b61=1631.0/55296.0, b62=175.0/512.0, b63=575.0/13824.0,
           b64=44275.0/110592.0, b65=253.0/4096.0, c1=37.0/378.0,
           c3=250.0/621.0, c4=125.0/594.0, c6=512.0/1771.0,
           dc5= -277.0/14336.0;
    let dc1=c1-2825.0/27648.0, dc3=c3-18575.0/48384.0,
           dc4=c4-13525.0/55296.0, dc6=c6-0.25;
    let i;
    //let ak2 = (ak);
    //let ak3 = ((ak)+(n));
    //let ak4 = ((ak)+(2*n));
    //let ak5 = ((ak)+(3*n));
    //let ak6 = ((ak)+(4*n));
    let ak2 = ak;
    let ak3 = ak.slice(n);
    let ak4 = ak.slice(2*n);
    let ak5 = ak.slice(3*n);
    let ak6 = ak.slice(4*n);

    // ret facil
    let returnObj;
    let returnVal;

    for (i=0; i<n; i++)
        ytemp[i] = y[i] + b21*h*dydx[i];
    ////////////////////////////////////
    returnObj = {v1: ytemp, v2: ak2}
    returnVal = derivs(x+a2*h, returnObj)
    ytemp = returnObj.v1;
    ak2 = returnObj.v2
    ////////////////////////////////////
    //derivs(x+a2*h,ytemp,ak2);

    for (i=0; i<n; i++)
        ytemp[i] = y[i] + h*(b31*dydx[i]+b32*ak2[i]);
    ////////////////////////////////////
    returnObj = {v1: ytemp, v2: ak3}
    returnVal = derivs(x+a3*h, returnObj)
    ytemp = returnObj.v1;
    ak3 = returnObj.v2
    ////////////////////////////////////
    //derivs(x+a3*h,ytemp,ak3);

    for (i=0; i<n; i++)
        ytemp[i] = y[i] + h*(b41*dydx[i]+b42*ak2[i] + b43*ak3[i]);
    ////////////////////////////////////
    returnObj = {v1: ytemp, v2: ak4}
    returnVal = derivs(x+a4*h, returnObj)
    ytemp = returnObj.v1;
    ak4 = returnObj.v2
    ////////////////////////////////////
    //derivs(x+a4*h,ytemp,ak4);

    for (i=0; i<n; i++)
        ytemp[i] = y[i] + h*(b51*dydx[i]+b52*ak2[i] + b53*ak3[i] + b54*ak4[i]);
    ////////////////////////////////////
    returnObj = {v1: ytemp, v2: ak5}
    returnVal = derivs(x+a5*h, returnObj)
    ytemp = returnObj.v1;
    ak5 = returnObj.v2
    ////////////////////////////////////
    //derivs(x+a5*h,ytemp,ak5);

    for (i=0; i<n; i++)
        ytemp[i] = y[i] + h*(b61*dydx[i]+b62*ak2[i] + b63*ak3[i] + b64*ak4[i]
                   + b65*ak5[i]);
    ////////////////////////////////////
    returnObj = {v1: ytemp, v2: ak6}
    returnVal = derivs(x+a6*h, returnObj)
    ytemp = returnObj.v1;
    ak6 = returnObj.v2
    ////////////////////////////////////
    //derivs(x+a6*h,ytemp,ak6);

    for (i=0; i<n; i++)
        ytemp[i] = y[i] + h*(c1*dydx[i] + c3*ak3[i] + c4*ak4[i] + c6*ak6[i]);

    for (i=0; i<n; i++)
        yerr[i] = h*(dc1*dydx[i] +dc3*ak3[i] + dc4*ak4[i] + dc5*ak5[i] + dc6*ak6[i]);
}

//-----------------------------------------------------------------------------
//   hotstart.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14  (Build 5.1.001)
//             03/28/14  (Build 5.1.002)
//             04/23/14  (Build 5.1.005)
//             03/19/15  (Build 5.1.008)
//             08/01/16  (Build 5.1.011)
//             04/01/20  (Build 5.1.015)
//   Author:   L. Rossman (EPA)
//
//   Hot Start file functions.

//   A SWMM hot start file contains the state of a SWMM project after
//   a simulation has been run, allowing it to be used to initialize
//   a subsequent simulation that picks up where the previous run ended.
//
//   An abridged version of the hot start file (version 2) is available 
//   that contains only variables that appear in the binary output file 
//   (groundwater upper moisture and water table elevation, node depth,
//   lateral inflow, and quality, and link flow, depth, setting and quality).
//
//   When reading a previously saved hot start file checks are made to
//   insure the the current SWMM project has the same number of major
//   components (subcatchments, land uses, nodes, links, and pollutants)
//   and unit system as does the hot start file. No test is made to
//   insure that these components are of the same sub-type and maintain
//   the same order as when the hot start file was created.
//
//   Build 5.1.008:
//   - Storage node hydraulic residence time (HRT) was added to the file.
//   - Link control settings are now applied when reading a hot start file.
//   - Runoff read from file assigned to newRunoff property instead of oldRunoff.
//   - Array indexing bug when reading snowpack state from file fixed.
//
//   Build 5.1.011:
//   - Link control setting bug when reading a hot start file fixed.    
//
//   Build 5.1.015:
//   - Support added for multiple infiltration methods within a project.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Local Variables
//-----------------------------------------------------------------------------
fileVersion;

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
// hotstart_open                          (called by swmm_start in swmm5.c)
// hotstart_close                         (called by swmm_end in swmm5.c)


//=============================================================================

hotstart_open()
{
    // --- open hot start files
    if ( !openHotstartFile1() ) return FALSE;       //input hot start file
    if ( !openHotstartFile2() ) return FALSE;       //output hot start file
    return TRUE;
}

//=============================================================================

hotstart_close()
{
    if ( Fhotstart2.file )
    {
        saveRunoff();
        saveRouting();
        fclose(Fhotstart2.file);
    }
}

//=============================================================================

openHotstartFile1()
//
//  Input:   none
//  Output:  none
//  Purpose: opens a previously saved routing hotstart file.
//
{
    let   nSubcatch;
    let   nNodes;
    let   nLinks;
    let   nPollut;
    let   nLandUses;
    let   flowUnits;
    let  fStamp     = "SWMM5-HOTSTART";
    let  fileStamp  = "SWMM5-HOTSTART";
    let  fStampx    = "SWMM5-HOTSTARTx";
    let  fileStamp2 = "SWMM5-HOTSTART2";
    let  fileStamp3 = "SWMM5-HOTSTART3";
    let  fileStamp4 = "SWMM5-HOTSTART4";

    // --- try to open the file
    if ( Fhotstart1.mode != USE_FILE ) return TRUE;
    if ( (Fhotstart1.file = fopen(Fhotstart1.name, "r+b")) == NULL)
    {
        report_writeErrorMsg(ERR_HOTSTART_FILE_OPEN, Fhotstart1.name);
        return FALSE;
    }

    // --- check that file contains proper header records
    fread(fStampx, sizeof(char), fileStamp2.length, Fhotstart1.file);
    if      ( strcmp(fStampx, fileStamp4) == 0 ) fileVersion = 4;
    else if ( strcmp(fStampx, fileStamp3) == 0 ) fileVersion = 3;
    else if ( strcmp(fStampx, fileStamp2) == 0 ) fileVersion = 2;
    else
    {
        rewind(Fhotstart1.file);
        fread(fStamp, sizeof(char), fileStamp.length, Fhotstart1.file);
        if ( strcmp(fStamp, fileStamp) != 0 )
        {
            report_writeErrorMsg(ERR_HOTSTART_FILE_FORMAT, "");
            return FALSE;
        }
        fileVersion = 1;
    }

    nSubcatch = -1;
    nNodes = -1;
    nLinks = -1;
    nPollut = -1;
    nLandUses = -1;
    flowUnits = -1;
    if ( fileVersion >= 2 )
    {    
        fread(nSubcatch, sizeof(int), 1, Fhotstart1.file);
    }
    else nSubcatch = Nobjects[SUBCATCH];
    if ( fileVersion >= 3 )
    {
        fread(nLandUses, sizeof(int), 1, Fhotstart1.file);
    }
    else nLandUses = Nobjects[LANDUSE];
    fread(nNodes, sizeof(int), 1, Fhotstart1.file);
    fread(nLinks, sizeof(int), 1, Fhotstart1.file);
    fread(nPollut, sizeof(int), 1, Fhotstart1.file);
    fread(flowUnits, sizeof(int), 1, Fhotstart1.file);
    if ( nSubcatch != Nobjects[SUBCATCH] 
    ||   nLandUses != Nobjects[LANDUSE]
    ||   nNodes    != Nobjects[NODE]
    ||   nLinks    != Nobjects[LINK]
    ||   nPollut   != Nobjects[POLLUT]
    ||   flowUnits != FlowUnits )
    {
         report_writeErrorMsg(ERR_HOTSTART_FILE_FORMAT, "");
         return FALSE;
    }

    // --- read contents of the file and close it
    if ( fileVersion >= 3 ) readRunoff();
    readRouting();
    fclose(Fhotstart1.file);
    if ( ErrorCode ) return FALSE;
    else return TRUE;
}

//=============================================================================

openHotstartFile2()
//
//  Input:   none
//  Output:  none
//  Purpose: opens a new routing hotstart file to save results to.
//
{
    let   nSubcatch;
    let   nLandUses;
    let   nNodes;
    let   nLinks;
    let   nPollut;
    let   flowUnits;
    let  fileStamp = "SWMM5-HOTSTART4";

    // --- try to open file
    if ( Fhotstart2.mode != SAVE_FILE ) return TRUE;
    if ( (Fhotstart2.file = fopen(Fhotstart2.name, "w+b")) == NULL)
    {
        report_writeErrorMsg(ERR_HOTSTART_FILE_OPEN, Fhotstart2.name);
        return FALSE;
    }

    // --- write file stamp & number of objects to file
    nSubcatch = Nobjects[SUBCATCH];
    nLandUses = Nobjects[LANDUSE];
    nNodes = Nobjects[NODE];
    nLinks = Nobjects[LINK];
    nPollut = Nobjects[POLLUT];
    flowUnits = FlowUnits;
    fwrite(fileStamp, sizeof(char), fileStamp.length, Fhotstart2.file);
    fwrite(nSubcatch, sizeof(int), 1, Fhotstart2.file);
    fwrite(nLandUses, sizeof(int), 1, Fhotstart2.file);
    fwrite(nNodes, sizeof(int), 1, Fhotstart2.file);
    fwrite(nLinks, sizeof(int), 1, Fhotstart2.file);
    fwrite(nPollut, sizeof(int), 1, Fhotstart2.file);
    fwrite(flowUnits, sizeof(int), 1, Fhotstart2.file);
    return TRUE;
}

//=============================================================================

 saveRouting()
//
//  Input:   none
//  Output:  none
//  Purpose: saves current state of all nodes and links to hotstart file.
//
{
    let   i, j;
    let x = new Array(3);

    for (i = 0; i < Nobjects[NODE]; i++)
    {
        x[0] = Node[i].newDepth;
        x[1] = Node[i].newLatFlow;
        fwrite(x, sizeof(float), 2, Fhotstart2.file);

        if ( Node[i].type == STORAGE )
        {
            j = Node[i].subIndex;
            x[0] = Storage[j].hrt;
            fwrite(x[0], sizeof(float), 1, Fhotstart2.file);
        }

        for (j = 0; j < Nobjects[POLLUT]; j++)
        {
            x[0] = Node[i].newQual[j];
            fwrite(x[0], sizeof(float), 1, Fhotstart2.file);
        }
    }
    for (i = 0; i < Nobjects[LINK]; i++)
    {
        x[0] = Link[i].newFlow;
        x[1] = Link[i].newDepth;
        x[2] = Link[i].setting;
        fwrite(x, sizeof(float), 3, Fhotstart2.file);
        for (j = 0; j < Nobjects[POLLUT]; j++)
        {
            x[0] = Link[i].newQual[j];
            fwrite(x[0], sizeof(float), 1, Fhotstart2.file);
        }
    }
}

//=============================================================================

readRouting()
//
//  Input:   none 
//  Output:  none
//  Purpose: reads initial state of all nodes, links and groundwater objects
//           from hotstart file.
//
{
    let   i, j;
    let x;
    let xgw = new Array(4);
    //FILE* f = Fhotstart1.file;
    let f = Fhotstart1.file;

    // --- for file format 2, assign GW moisture content and lower depth
    if ( fileVersion == 2 )
    {
        // --- flow and available upper zone volume not used
        xgw[2] = 0.0;
        xgw[3] = MISSING;
        for (i = 0; i < Nobjects[SUBCATCH]; i++)
        {
            // --- read moisture content and water table elevation as floats
            if ( !readFloat(x, f) ) return;
            xgw[0] = x;
            if ( !readFloat(x, f) ) return;
            xgw[1] = x;

            // --- set GW state
            if ( Subcatch[i].groundwater != NULL ) gwater_setState(i, xgw);
        }
    }

    // --- read node states
    for (i = 0; i < Nobjects[NODE]; i++)
    {
        if ( !readFloat(x, f) ) return;
        Node[i].newDepth = x;
        if ( !readFloat(x, f) ) return;
        Node[i].newLatFlow = x;

        if ( fileVersion >= 4 &&  Node[i].type == STORAGE )
        {
            if ( !readFloat(x, f) ) return;
            j = Node[i].subIndex;
            Storage[j].hrt = x;
        }

        for (j = 0; j < Nobjects[POLLUT]; j++)
        {
            if ( !readFloat(x, f) ) return;
            Node[i].newQual[j] = x;
        }

        // --- read in zeros here for backwards compatibility
        if ( fileVersion <= 2 )
        {
            for (j = 0; j < Nobjects[POLLUT]; j++)
            {
                if ( !readFloat(x, f) ) return;
            }
        }
    }

    // --- read link states
    for (i = 0; i < Nobjects[LINK]; i++)
    {
        if ( !readFloat(x, f) ) return;
        Link[i].newFlow = x;
        if ( !readFloat(x, f) ) return;
        Link[i].newDepth = x;
        if ( !readFloat(x, f) ) return;
        Link[i].setting = x;

        // --- set link's target setting to saved setting 
        Link[i].targetSetting = x;
        link_setTargetSetting(i);
        link_setSetting(i, 0.0);

        for (j = 0; j < Nobjects[POLLUT]; j++)
        {
            if ( !readFloat(x, f) ) return;
            Link[i].newQual[j] = x;
        }

    }
}

//=============================================================================
// void
 saveRunoff()
//
//  Input:   none
//  Output:  none
//  Purpose: saves current state of all subcatchments to hotstart file.
//
{
    let   i, j, k, sizeX;
    let x = [];
    //FILE*  f = Fhotstart2.file;
    let f = Fhotstart2.file;

    sizeX = Math.max(6, Nobjects[POLLUT]+1);
    //x = (double *) calloc(sizeX, sizeof(double));
    x = new Array(sizeX);

    for (i = 0; i < Nobjects[SUBCATCH]; i++)
    {
        // Ponded depths for each sub-area & total runoff (4 elements)
        for (j = 0; j < 3; j++) x[j] = Subcatch[i].subArea[j].depth;
        x[3] = Subcatch[i].newRunoff;
        fwrite(x, sizeof(double), 4, f);

        // Infiltration state (max. of 6 elements)
        for (j=0; j<sizeX; j++) x[j] = 0.0;
        infil_getState(i, x);                                                  //(5.1.015)
        fwrite(x, sizeof(double), 6, f);

        // Groundwater state (4 elements)
        if ( Subcatch[i].groundwater != NULL )
        {
            gwater_getState(i, x);
            fwrite(x, sizeof(double), 4, f);
        }

        // Snowpack state (5 elements for each of 3 snow surfaces)
        if ( Subcatch[i].snowpack != NULL )
        {
            for (j=0; j<3; j++)
            {
                snow_getState(i, j, x);
                fwrite(x, sizeof(double), 5, f);
            }
        }

        // Water quality
        if ( Nobjects[POLLUT] > 0 )
        {
            // Runoff quality
            for (j=0; j<Nobjects[POLLUT]; j++) x[j] = Subcatch[i].newQual[j];
            fwrite(x, sizeof(double), Nobjects[POLLUT], f);

            // Ponded quality
            for (j=0; j<Nobjects[POLLUT]; j++) x[j] = Subcatch[i].pondedQual[j];
            fwrite(x, sizeof(double), Nobjects[POLLUT], f);
            
            // Buildup and when streets were last swept
            for (k=0; k<Nobjects[LANDUSE]; k++)
            {
                for (j=0; j<Nobjects[POLLUT]; j++)
                    x[j] = Subcatch[i].landFactor[k].buildup[j];
                fwrite(x, sizeof(double), Nobjects[POLLUT], f);
                x[0] = Subcatch[i].landFactor[k].lastSwept;
                fwrite(x, sizeof(double), 1, f);
            }
        }
    }
    x = null;
}

//=============================================================================

 readRunoff()
//
//  Input:   none
//  Output:  none
//  Purpose: reads saved state of all subcatchments from a hot start file.
//
{
    let    i, j, k;
    let x = new Array(6);
    //FILE*  f = Fhotstart1.file;
    let f = Fhotstart1.file;

    for (i = 0; i < Nobjects[SUBCATCH]; i++)
    {
        // Ponded depths & runoff (4 elements)
        for (j = 0; j < 3; j++)
        {
            if ( !readDouble(Subcatch[i].subArea[j].depth, f) ) return;
        }
        if ( !readDouble(Subcatch[i].newRunoff, f) ) return;

        // Infiltration state (max. of 6 elements)
        for (j=0; j<6; j++) if ( !readDouble(x[j], f) ) return;
        infil_setState(i, x);                                                  //(5.1.015)

        // Groundwater state (4 elements)
        if ( Subcatch[i].groundwater != NULL )
        {
            for (j=0; j<4; j++) if ( !readDouble(x[j], f) ) return;
            gwater_setState(i, x);
        }

        // Snowpack state (5 elements for each of 3 snow surfaces)
        if ( Subcatch[i].snowpack != NULL )
        {
            for (j=0; j<3; j++) 
            {
                for (k=0; k<5; k++) if ( !readDouble(x[k], f) ) return;
                snow_setState(i, j, x);
            }
        }

        // Water quality
        if ( Nobjects[POLLUT] > 0 ) 
        {
            // Runoff quality
            for (j=0; j<Nobjects[POLLUT]; j++)
                if ( ! readDouble(Subcatch[i].newQual[j], f) ) return;

            // Ponded quality
            for (j=0; j<Nobjects[POLLUT]; j++)
                if ( !readDouble(Subcatch[i].pondedQual[j], f) ) return;
            
            // Buildup and when streets were last swept
            for (k=0; k<Nobjects[LANDUSE]; k++)
            {
                for (j=0; j<Nobjects[POLLUT]; j++)
                {
                    if ( !readDouble(
                        Subcatch[i].landFactor[k].buildup[j], f) ) return;
                }
                if ( !readDouble(Subcatch[i].landFactor[k].lastSwept, f) )
                    return;
            }
        }
    }
}

//=============================================================================
// float *x, FILE* f
 readFloat(x, f)
//
//  Input:   none
//  Output:  x  = pointer to a float variable
//  Purpose: reads a floating point value from a hot start file
//
{
    // --- read a value from the file
    fread(x, sizeof(float), 1, f);

    // --- test if the value is NaN (not a number)
    if ( (x) != (x) )
    {
        report_writeErrorMsg(ERR_HOTSTART_FILE_READ, "");
        (x) = 0.0;
        return FALSE;
    }
    return TRUE;
}

//=============================================================================
// double* x, FILE* f
 readDouble(x, f)
//
//  Input:   none
//  Output:  x  = pointer to a double variable
//  Purpose: reads a floating point value from a hot start file
//
{
    // --- read a value from the file
    if ( feof(f) )
    {    
        (x) = 0.0;
        report_writeErrorMsg(ERR_HOTSTART_FILE_READ, "");
        return FALSE;
    }
    fread(x, sizeof(double), 1, f);

    // --- test if the value is NaN (not a number)
    if ( (x) != (x) )
    {
        (x) = 0.0;
        return FALSE;
    }
    return TRUE;
}
//-----------------------------------------------------------------------------
//   treatmnt.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             03/19/15   (Build 5.1.008)
//   Author:   L. Rossman
//
//   Pollutant treatment functions.
//
//   Build 5.1.008:
//   - A bug in evaluating recursive calls to treatment functions was fixed. 
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
PVMAX = 5;            // number of process variables
//enum   ProcessVarType {
pvHRT = 0          // hydraulic residence time
pvDT = 1           // time step duration
pvFLOW = 2         // flow rate
pvDEPTH = 3        // water height above invert
pvAREA = 4;        // storage surface area

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
ErrCode;                // treatment error code
J;                      // index of node being analyzed
Dt;                     // curent time step (sec)
Q;                      // node inflow (cfs)
V;                      // node volume (ft3)
R = [];                      // array of pollut. removals
Cin = [];                    // node inflow concentrations

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  treatmnt_open           (called from routing_open)
//  treatment_close         (called from routing_close)
//  treatmnt_readExpression (called from parseLine in input.c)
//  treatmnt_delete         (called from deleteObjects in project.c)
//  treatmnt_setInflow      (called from qualrout_execute)
//  treatmnt_treat          (called from findNodeQual in qualrout.c)


//=============================================================================
// void
 treatmnt_open()
//
//  Input:   none
//  Output:  returns true if successful, false if not
//  Purpose: allocates memory for computing pollutant removals by treatment.
//
{
    R = null;
    Cin = null;
    if ( Nobjects[POLLUT] > 0 )
    {
        // R = (double *) calloc(Nobjects[POLLUT], sizeof(double));
        R = new Array(Nobjects[POLLUT]);
        // Cin = (double *) calloc(Nobjects[POLLUT], sizeof(double));
        Cin = new Array(Nobjects[POLLUT]);
        if ( R == null || Cin == null)
        {
            report_writeErrorMsg(ERR_MEMORY, "");
            return false;
        }
    }
    return true;
}

//=============================================================================
// void
treatmnt_close()
//
//  Input:   none
//  Output:  returns an error code
//  Purpose: frees memory used for computing pollutant removals by treatment.
//
{
    FREE(R);
    FREE(Cin);
}

//=============================================================================
// char* tok[], int ntoks
 treatmnt_readExpression(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads a treatment expression from a tokenized line of input.
//
{
    let  s;
    let expr = '';
    let   i, j, k, p;
    //MathExpr* equation;                // ptr. to a math. expression
    let equation;

    // --- retrieve node & pollutant
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");
    j = project_findObject(NODE, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);
    p = project_findObject(POLLUT, tok[1]);
    if ( p < 0 ) return error_setInpError(ERR_NAME, tok[1]);

    // --- concatenate remaining tokens into a single string
    strcpy(s, tok[2]);
    for ( i=3; i<ntoks; i++)
    {
        strcat(s, " ");
        strcat(s, tok[i]);
    }

    // --- check treatment type
    if      ( UCHAR(s[0]) == 'R' ) k = 0;
    else if ( UCHAR(s[0]) == 'C' ) k = 1;
    else return error_setInpError(ERR_KEYWORD, tok[2]);

    // --- start treatment expression after equals sign
    expr = strchr(s, '=');
    if ( expr == null ) return error_setInpError(ERR_KEYWORD, "");
    else expr++;

    // --- create treatment objects at node j if they don't already exist
    if ( Node[j].treatment == null )
    {
        if ( !createTreatment(j) ) return error_setInpError(ERR_MEMORY, "");
    }

    // --- create a parsed expression tree from the string expr
    //     (getVariableIndex is the that converts a treatment
    //      variable's name into an index number) 
    equation = mathexpr_create(expr, getVariableIndex);
    if ( equation == null )
        return error_setInpError(ERR_TREATMENT_EXPR, "");

    // --- save the treatment parameters in the node's treatment object
    Node[j].treatment[p].treatType = k;
    Node[j].treatment[p].equation = equation;
    return 0;
}

//=============================================================================
// int j
treatmnt_delete(j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: deletes the treatment objects for each pollutant at a node.
//
{
    let p;
    if ( Node[j].treatment )
    {
        for (p=0; p<Nobjects[POLLUT]; p++)
            mathexpr_delete(Node[j].treatment[p].equation);
        Node[j].treatment = null;
    }
    Node[j].treatment = null;
}

//=============================================================================
// double qIn, double wIn[]
 treatmnt_setInflow(qIn, wIn)
//
//  Input:   j = node index
//           qIn = flow inflow rate (cfs)
//           wIn = pollutant mass inflow rate (mass/sec)
//  Output:  none
//  Purpose: computes and saves array of inflow concentrations to a node.
//
{
    let    p;
    if ( qIn > 0.0 )
        for (p = 0; p < Nobjects[POLLUT]; p++) Cin[p] = wIn[p]/qIn;
    else
        for (p = 0; p < Nobjects[POLLUT]; p++) Cin[p] = 0.0;
}

//=============================================================================
// int j, double q, double v, double tStep
 treatmnt_treat(j, q, v, tStep)
//
//  Input:   j     = node index
//           q     = inflow to node (cfs)
//           v     = volume of node (ft3)
//           tStep = routing time step (sec)
//  Output:  none
//  Purpose: updates pollutant concentrations at a node after treatment.
//
{
    let    p;                          // pollutant index
    let cOut;                       // concentration after treatment
    let massLost;                   // mass lost by treatment per time step
    //TTreatment* treatment;             // pointer to treatment object
    let treatment;

    // --- set locally shared variables for node j
    if ( Node[j].treatment == null ) return;
    ErrCode = 0;
    J  = j;                            // current node
    Dt = tStep;                        // current time step
    Q  = q;                            // current inflow rate
    V  = v;                            // current node volume

    // --- initialze each removal to indicate no value 
    for ( p = 0; p < Nobjects[POLLUT]; p++) R[p] = -1.0;

    // --- determine removal of each pollutant
    for ( p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- removal is zero if there is no treatment equation
        treatment = Node[j].treatment[p];
        if ( treatment.equation == null ) R[p] = 0.0;

        // --- no removal for removal-type expression when there is no inflow 
	    else if ( treatment.treatType == REMOVAL && q <= ZERO ) R[p] = 0.0;

        // --- otherwise evaluate the treatment expression to find R[p]
        else getRemoval(p);
    }

    // --- check for error condition
    if ( ErrCode == ERR_CYCLIC_TREATMENT )
    {
         report_writeErrorMsg(ERR_CYCLIC_TREATMENT, Node[J].ID);
    }

    // --- update nodal concentrations and mass balances
    else for ( p = 0; p < Nobjects[POLLUT]; p++ )
    {
        if ( R[p] == 0.0 ) continue;
        treatment = Node[j].treatment[p];

        // --- removal-type treatment equations get applied to inflow stream

        if ( treatment.treatType == REMOVAL )
        {
            // --- if no pollutant in inflow then cOut is current nodal concen.
            if ( Cin[p] == 0.0 ) cOut = Node[j].newQual[p];

            // ---  otherwise apply removal to influent concen.
            else cOut = (1.0 - R[p]) * Cin[p];

            // --- cOut can't be greater than mixture concen. at node
            //     (i.e., in case node is a storage unit) 
            cOut = MIN(cOut, Node[j].newQual[p]);
        }

        // --- concentration-type equations get applied to nodal concentration
        else
        {
            cOut = (1.0 - R[p]) * Node[j].newQual[p];
        }

        // --- mass lost must account for any initial mass in storage 
        massLost = (Cin[p]*q*tStep + Node[j].oldQual[p]*Node[j].oldVolume - 
                   cOut*(q*tStep + Node[j].oldVolume)) / tStep; 
        massLost = MAX(0.0, massLost); 

        // --- add mass loss to mass balance totals and revise nodal concentration
        massbal_addReactedMass(p, massLost);
        Node[j].newQual[p] = cOut;
    }
}

//=============================================================================
// int j
 createTreatment(j)
//
//  Input:   j = node index
//  Output:  returns true if successful, false if not
//  Purpose: creates a treatment object for each pollutant at a node.
//
{
    let p;
    //Node[j].treatment = (TTreatment *) calloc(Nobjects[POLLUT], sizeof(TTreatment));
    for(let i = 0; i < Nobjects[POLLUT]; i++){Node[j].treatment.push(new TTreatment())}
    
    if ( Node[j].treatment == null )
    {
        return false;
    }
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        Node[j].treatment[p].equation = null;
    }
    return true;
}

//=============================================================================
// char* s
 getVariableIndex(s)
//
//  Input:   s = name of a process variable or pollutant
//  Output:  returns index of process variable or pollutant
//  Purpose: finds position of process variable/pollutant in list of names.
//
{
    // --- check for a process variable first
    let k;
    let m = PVMAX;                     // PVMAX is number of process variables

    k = findmatch(s, ProcessVarWords);
    if ( k >= 0 ) return k;

    // --- then check for a pollutant concentration
    k = project_findObject(POLLUT, s);
    if ( k >= 0 ) return (k + m);

    // --- finally check for a pollutant removal
    if ( UCHAR(s[0]) == 'R' && s[1] == '_')
    {
        k = project_findObject(POLLUT, s+2);
        if ( k >= 0 ) return (Nobjects[POLLUT] + k + m);
    }
    return -1;
}

//=============================================================================
// int varCode
getVariableValue(varCode)
//
//  Input:   varCode = code number of process variable or pollutant
//  Output:  returns current value of variable
//  Purpose: finds current value of a process variable or pollutant concen.,
//           making reference to the node being evaluated which is stored in
//           shared variable J.
//
{
    let    p;
    let a1, a2, y;
    //TTreatment* treatment;
    let treatment;

    // --- variable is a process variable
    if ( varCode < PVMAX )
    {
        switch ( varCode )
        {
          case pvHRT:                                 // HRT in hours
            if ( Node[J].type == STORAGE )
            {
                return Storage[Node[J].subIndex].hrt / 3600.0;
            }
            else return 0.0;

          case pvDT:
            return Dt;                                // time step in seconds

          case pvFLOW:
            return Q * UCF(FLOW);                     // flow in user's units

          case pvDEPTH:
            y = (Node[J].oldDepth + Node[J].newDepth) / 2.0;
            return y * UCF(LENGTH);                   // depth in ft or m

          case pvAREA:
            a1 = node_getSurfArea(J, Node[J].oldDepth);
            a2 = node_getSurfArea(J, Node[J].newDepth);
            return (a1 + a2) / 2.0 * UCF(LENGTH) * UCF(LENGTH);
            
          default: return 0.0;
        }
    }

    // --- variable is a pollutant concentration
    else if ( varCode < PVMAX + Nobjects[POLLUT] )
    {
        p = varCode - PVMAX;
        treatment = Node[J].treatment[p];
        if ( treatment.treatType == REMOVAL ) return Cin[p];
        return Node[J].newQual[p];
    }

    // --- variable is a pollutant removal
    else
    {
        p = varCode - PVMAX - Nobjects[POLLUT];
        if ( p >= Nobjects[POLLUT] ) return 0.0;
        return getRemoval(p);
    }
}

//=============================================================================
// int p
 getRemoval(p)
//
//  Input:   p = pollutant index
//  Output:  returns fractional removal of pollutant
//  Purpose: computes removal of a specific pollutant
//
{
    let c0 = Node[J].newQual[p];    // initial node concentration
    let r;                          // removal value
    //TTreatment* treatment;
    let treatment;

    // return facilitators;
    let returnObj;
    let returnVal;

    // --- case where removal already being computed for another pollutant
    if ( R[p] > 1.0 || ErrCode )
    {
        ErrCode = 1;
        return 0.0;
    }

    // --- case where removal already computed
    if ( R[p] >= 0.0 && R[p] <= 1.0 ) return R[p];

    // --- set R[p] to value > 1 to show that value is being sought
    //     (prevents infinite recursive calls in case two removals
    //     depend on each other)
    R[p] = 10.0;

    // --- case where current concen. is zero
    if ( c0 == 0.0 )
    {
        R[p] = 0.0;
        return 0.0;
    }

    // --- apply treatment eqn.
    treatment = Node[J].treatment[p];
    ////////////////////////////////////
    returnObj = {expr: treatment.equation, getVariableValue: (varCode)
        //
        //  Input:   varCode = code number of process variable or pollutant
        //  Output:  returns current value of variable
        //  Purpose: finds current value of a process variable or pollutant concen.,
        //           making reference to the node being evaluated which is stored in
        //           shared variable J.
        //
        {
            let    p;
            let a1, a2, y;
            //TTreatment* treatment;
            let treatment;
        
            // --- variable is a process variable
            if ( varCode < PVMAX )
            {
                switch ( varCode )
                {
                  case pvHRT:                                 // HRT in hours
                    if ( Node[J].type == STORAGE )
                    {
                        return Storage[Node[J].subIndex].hrt / 3600.0;
                    }
                    else return 0.0;
        
                  case pvDT:
                    return Dt;                                // time step in seconds
        
                  case pvFLOW:
                    return Q * UCF(FLOW);                     // flow in user's units
        
                  case pvDEPTH:
                    y = (Node[J].oldDepth + Node[J].newDepth) / 2.0;
                    return y * UCF(LENGTH);                   // depth in ft or m
        
                  case pvAREA:
                    a1 = node_getSurfArea(J, Node[J].oldDepth);
                    a2 = node_getSurfArea(J, Node[J].newDepth);
                    return (a1 + a2) / 2.0 * UCF(LENGTH) * UCF(LENGTH);
                    
                  default: return 0.0;
                }
            }
        
            // --- variable is a pollutant concentration
            else if ( varCode < PVMAX + Nobjects[POLLUT] )
            {
                p = varCode - PVMAX;
                treatment = Node[J].treatment[p];
                if ( treatment.treatType == REMOVAL ) return Cin[p];
                return Node[J].newQual[p];
            }
        
            // --- variable is a pollutant removal
            else
            {
                p = varCode - PVMAX - Nobjects[POLLUT];
                if ( p >= Nobjects[POLLUT] ) return 0.0;
                return getRemoval(p);
            }
        }}
    returnVal = mathexpr_eval(returnObj);
    treatment.equation = returnObj.expr;
    ////////////////////////////////////
    r = returnVal;
    //r = mathexpr_eval(treatment.equation, getVariableValue);
    r = MAX(0.0, r);

    // --- case where treatment eqn. is for removal
    if ( treatment.treatType == REMOVAL )
    {
        r = MIN(1.0, r);
        R[p] = r;
    }

    // --- case where treatment eqn. is for effluent concen.
    else
    {
        r = MIN(c0, r);
        R[p] = 1.0 - r/c0;
    }
    return R[p];
}

//=============================================================================

//-----------------------------------------------------------------------------
//   routing.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/19/14  (Build 5.1.000)
//             09/15/14  (Build 5.1.007)
//             04/02/15  (Build 5.1.008)
//             08/05/15  (Build 5.1.010)
//             08/01/16  (Build 5.1.011)
//             03/14/17  (Build 5.1.012)
//             05/10/18  (Build 5.1.013)
//   Author:   L. Rossman (EPA)
//             M. Tryby (EPA)
//
//   Conveyance system routing functions.
//
//   Build 5.1.007:
//   - Nodal evap/seepage losses computed using conditions at start of time step.
//   - DWF pollutant concentrations ignored if DWF is negative.
//   - Separate mass balance accounting made for storage evap. & seepage.
//   - Nodal mass balance accounting for negative lateral inflows corrected.
//
//   Build 5.1.008:
//   - Initialization of flow and quality routing systems moved here from swmm5.c.
//   - Lateral inflows now evaluated at start (not end) of time step.
//   - Flows from LID drains included in lateral inflows.
//   - Conduit evap/seepage losses multiplied by number of barrels before
//     being added into mass balances.
//
//   Build 5.1.010:
//   - Time when a link's setting is changed is recorded.
//
//   Build 5.1.011:
//   - Support added for limiting flow routing to specific events.
//
//   Build 5.1.012:
//   - routing_execute() was re-written so that Routing Events and
//     Skip Steady Flow options work together correctly.
//
//   Build 5.1.013:
//   - Support added for evaluating controls rules at RuleStep time interval.
//   - Back flow through Outfall nodes now treated as External Inflows for
//     mass balance purposes.
//   - Global infiltration factor for storage seepage set in routing_execute.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Shared variables
//-----------------------------------------------------------------------------
SortedLinks = [];
 NextEvent;
 BetweenEvents;
NewRuleTime;                                                     //(5.1.013)

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
// routing_open            (called by swmm_start in swmm5.c)
// routing_getRoutingStep  (called by swmm_step in swmm5.c)
// routing_execute         (called by swmm_step in swmm5.c)
// routing_close           (called by swmm_end in swmm5.c)

//=============================================================================

routing_open()
//
//  Input:   none
//  Output:  returns an error code
//  Purpose: initializes the routing analyzer.
//
{
    // --- open treatment system
    if ( !treatmnt_open() ) return ErrorCode;

    // --- topologically sort the links
    SortedLinks = null;
    if ( Nobjects[LINK] > 0 )
    {
        //SortedLinks = (int *) calloc(Nobjects[LINK], sizeof(int));
        SortedLinks = new Array(Nobjects[LINK]);
        if ( !SortedLinks )
        {
            report_writeErrorMsg(ERR_MEMORY, "");
            return ErrorCode;
        }
        toposort_sortLinks(SortedLinks);
        if ( ErrorCode ) return ErrorCode;
    }

    // --- open any routing interface files
    iface_openRoutingFiles();

    // --- initialize flow and quality routing systems
    flowrout_init(RouteModel);
    if ( Fhotstart1.mode == NO_FILE ) qualrout_init();

    // --- initialize routing events
    if ( NumEvents > 0 ) sortEvents();
    NextEvent = 0;
    BetweenEvents = (NumEvents > 0);
    NewRuleTime = 0.0;                                                         //(5.1.013)
    return ErrorCode;
}

//=============================================================================
// int routingModel
routing_close(routingModel)
//
//  Input:   routingModel = routing method code
//  Output:  none
//  Purpose: closes down the routing analyzer.
//
{
    // --- close any routing interface files
    iface_closeRoutingFiles();

    // --- free allocated memory
    flowrout_close(routingModel);
    treatmnt_close();
    FREE(SortedLinks);
}

//=============================================================================

////  This was modified for release 5.1.013.  ////                    //(5.1.013)
// int routingModel, double fixedStep
routing_getRoutingStep(routingModel, fixedStep)
//
//  Input:   routingModel = routing method code
//           fixedStep = user-supplied time step (sec)
//  Output:  returns a routing time step (sec)
//  Purpose: determines time step used for flow routing at current time period.
//
{
    date1, date2, nextTime;
    routingStep = 0.0, nextRuleTime, nextRoutingTime;

    if ( Nobjects[LINK] == 0 ) return fixedStep;

    // --- find largest step possible if between routing events
    if ( NumEvents > 0 && BetweenEvents )
    {
        nextTime = MIN(NewRunoffTime, ReportTime);
        date1 = getDateTime(NewRoutingTime);
        date2 = getDateTime(nextTime);
        if ( date2 > date1 && date2 < Event[NextEvent].start )
        {
            routingStep = (nextTime - NewRoutingTime) / 1000.0;
        }
        else
        {
            date1 = getDateTime(NewRoutingTime + 1000.0 * fixedStep);
            if ( date1 < Event[NextEvent].start ) return fixedStep;
        }
    }

    // --- otherwise use a regular flow-routing based time step
    if (routingStep == 0.0)
    {
        routingStep = flowrout_getRoutingStep(routingModel, fixedStep);
    }

    // --- determine if control rule time interval reached
    if (RuleStep > 0)
    {
        nextRuleTime = NewRuleTime + 1000. * RuleStep;
        nextRoutingTime = NewRoutingTime + 1000. * routingStep;
        if (nextRoutingTime >= nextRuleTime)
        {
            routingStep = (nextRuleTime - NewRoutingTime) / 1000.0;
        }
    }
    return routingStep;
}

//=============================================================================
// int routingModel, double routingStep
routing_execute(routingModel, routingStep)
//
//  Input:   routingModel = routing method code
//           routingStep = routing time step (sec)
//  Output:  none
//  Purpose: executes the routing process at the current time period.
//
{
    let      j;
    let      stepCount = 1;
    let      actionCount = 0;
    let      inSteadyState = false;
    let currentDate;
    let   stepFlowError;

    // --- update continuity with current state
    //     applied over 1/2 of time step
    if ( ErrorCode ) return;
    massbal_updateRoutingTotals(routingStep/2.);

    // --- find new link target settings that are not related to
    // --- control rules (e.g., pump on/off depth limits)
    for (j=0; j<Nobjects[LINK]; j++) link_setTargetSetting(j);

    // --- find date of start of current time period                           //(5.1.013)
    currentDate = getDateTime(NewRoutingTime);                                 //
                                                                               //
    // --- evaluate control rules if next evluation time reached               //
    if (RuleStep == 0 || Math.abs(NewRoutingTime - NewRuleTime) < 1.0)             //
    {                                                                          //   
        controls_evaluate(currentDate, currentDate - StartDateTime,            //
            routingStep / SECperDAY);                                          //
    }                                                                          //

    // --- change each link's actual setting if it differs from its target
    for (j=0; j<Nobjects[LINK]; j++)
    {
        if ( Link[j].targetSetting != Link[j].setting )
        {
            // --- update time when link was switched between open & closed
            if ( Link[j].targetSetting * Link[j].setting == 0.0 )
                Link[j].timeLastSet = currentDate;

            // --- implement the change in the link's setting
            link_setSetting(j, routingStep);
            actionCount++;
        } 
    }

    // --- update value of elapsed routing time (in milliseconds)
    OldRoutingTime = NewRoutingTime;
    NewRoutingTime = NewRoutingTime + 1000.0 * routingStep;

    // --- see if control rule evaluation time should be advanced              //(5.1.013)
    if (Math.abs(NewRoutingTime - (NewRuleTime + 1000.0*RuleStep)) < 1)            //
        NewRuleTime += 1000.0 * RuleStep;                                      //

    // --- initialize mass balance totals for time step
    stepFlowError = massbal_getStepFlowError();
    massbal_initTimeStepTotals();

    // --- replace old water quality state with new state
    if ( Nobjects[POLLUT] > 0 )
    {
        for (j=0; j<Nobjects[NODE]; j++) node_setOldQualState(j);
        for (j=0; j<Nobjects[LINK]; j++) link_setOldQualState(j);
    }

    // --- set infiltration factor for storage unit seepage                    //(5.1.013)
    //     (-1 argument indicates global factor is used)                       //(5.1.013)
    infil_setInfilFactor(-1);                                                  //(5.1.013)

    // --- initialize lateral inflows at nodes
    for (j = 0; j < Nobjects[NODE]; j++)
    {
        Node[j].oldLatFlow  = Node[j].newLatFlow;
        Node[j].newLatFlow  = 0.0;
    }

    // --- check if can skip non-event periods
    if ( NumEvents > 0 )
    {
        if ( currentDate > Event[NextEvent].end )
        {
            BetweenEvents = true;
            NextEvent++;
        }
        else if ( currentDate >= Event[NextEvent].start && BetweenEvents == true )
        {
			BetweenEvents = false;
        }
    }

    // --- if not between routing events
    if ( BetweenEvents == false )
    {
        // --- find evap. & seepage losses from storage nodes
        for (j = 0; j < Nobjects[NODE]; j++)
        {
            Node[j].losses = node_getLosses(j, routingStep); 
        }

        // --- add lateral inflows and evap/seepage losses at nodes
        addExternalInflows(currentDate);
        addDryWeatherInflows(currentDate);
        addWetWeatherInflows(OldRoutingTime);
        addGroundwaterInflows(OldRoutingTime);
        addLidDrainInflows(OldRoutingTime);
        addRdiiInflows(currentDate);
        addIfaceInflows(currentDate);

        // --- check if can skip steady state periods based on flows
        if ( SkipSteadyState )
        {
            if ( OldRoutingTime == 0.0
            ||   actionCount > 0
            ||   Math.abs(stepFlowError) > SysFlowTol
            ||   inflowHasChanged() ) inSteadyState = false;
            else inSteadyState = true;
        }

        // --- find new hydraulic state if system has changed
        if ( inSteadyState == false )
        {
            // --- replace old hydraulic state values with current ones
            for (j = 0; j < Nobjects[LINK]; j++) link_setOldHydState(j);
            for (j = 0; j < Nobjects[NODE]; j++)
            {
                node_setOldHydState(j);
                node_initInflow(j, routingStep);
            }

            // --- route flow through the drainage network
            if ( Nobjects[LINK] > 0 )
            {
                stepCount = flowrout_execute(SortedLinks, routingModel, routingStep);
            }
        }

        // --- route quality through the drainage network
        if ( Nobjects[POLLUT] > 0 && !IgnoreQuality ) 
        {
            qualrout_execute(routingStep);
        }

        // --- remove evaporation, infiltration & outflows from system
        removeStorageLosses(routingStep);
        removeConduitLosses();
        removeOutflows(routingStep);
    }
    else inSteadyState = true;
	
    // --- update continuity with new totals
    //     applied over 1/2 of routing step
    massbal_updateRoutingTotals(routingStep/2.);

    // --- update summary statistics
    if ( RptFlags.flowStats && Nobjects[LINK] > 0 )
    {
        stats_updateFlowStats(routingStep, getDateTime(NewRoutingTime),
                              stepCount, inSteadyState);
    }
}

//=============================================================================
// DateTime currentDate
addExternalInflows(currentDate)
//
//  Input:   currentDate = current date/time
//  Output:  none
//  Purpose: adds direct external inflows to nodes at current date.
//
{
    let     j, p;
    let  q, w;
    //TExtInflow* inflow;
    inflow;

    // --- for each node with a defined external inflow
    for (j = 0; j < Nobjects[NODE]; j++)
    {
        inflow = Node[j].extInflow;
        if ( !inflow ) continue;

        // --- get flow inflow
        q = 0.0;
        while ( inflow )
        {
            if ( inflow.type == FLOW_INFLOW )
            {
                q = inflow_getExtInflow(inflow, currentDate);
                break;
            }
            else inflow = inflow.next;
        }
        if ( Math.abs(q) < FLOW_TOL ) q = 0.0;

        // --- add flow inflow to node's lateral inflow
        Node[j].newLatFlow += q;
        massbal_addInflowFlow(EXTERNAL_INFLOW, q);

        // --- add on any inflow (i.e., reverse flow) through an outfall
        if ( Node[j].type == OUTFALL && Node[j].oldNetInflow < 0.0 ) 
        {
            q = q - Node[j].oldNetInflow;
        }

        // --- get pollutant mass inflows
        inflow = Node[j].extInflow;
        while ( inflow )
        {
            if ( inflow.type != FLOW_INFLOW )
            {
                p = inflow.param;
                w = inflow_getExtInflow(inflow, currentDate);
                if ( inflow.type == CONCEN_INFLOW ) w *= q;
                Node[j].newQual[p] += w;
                massbal_addInflowQual(EXTERNAL_INFLOW, p, w);
            }
            inflow = inflow.next;
        }
    }
}

//=============================================================================
// DateTime currentDate
addDryWeatherInflows(currentDate)
//
//  Input:   currentDate = current date/time
//  Output:  none
//  Purpose: adds dry weather inflows to nodes at current date.
//
{
    let      j, p;
    let      month, day, hour;
    let   q, w;
    //TDwfInflow* inflow;
    let inflow;

    // ret facil
    let returnObj;
    let returnVal;

    // --- get month (zero-based), day-of-week (zero-based),
    //     & hour-of-day for routing date/time
    month = datetime_monthOfYear(currentDate) - 1;
    day   = datetime_dayOfWeek(currentDate) - 1;
    hour  = datetime_hourOfDay(currentDate);

    // --- for each node with a defined dry weather inflow
    for (j = 0; j < Nobjects[NODE]; j++)
    {
        inflow = Node[j].dwfInflow;
        if ( !inflow ) continue;

        // --- get flow inflow (i.e., the inflow whose param code is -1)
        q = 0.0;
        while ( inflow )
        {
            if ( inflow.param < 0 )
            {
                ////////////////////////////////////
                returnObj = {inflow: inflow}
                returnVal = inflow_getDwfInflow(inObj, month, day, hour)
                inflow = returnObj.inflow;
                ////////////////////////////////////
                q = returnVal;
                //q = inflow_getDwfInflow(inflow, month, day, hour);
                break;
            }
            inflow = inflow.next;
        }
        if ( Math.abs(q) < FLOW_TOL ) q = 0.0;

        // --- add flow inflow to node's lateral inflow
        Node[j].newLatFlow += q;
        massbal_addInflowFlow(DRY_WEATHER_INFLOW, q);

        // --- stop if inflow is non-positive
        if ( q <= 0.0 ) continue;

        // --- add default DWF pollutant inflows
        for ( p = 0; p < Nobjects[POLLUT]; p++)
        {
            if ( Pollut[p].dwfConcen > 0.0 )
            {
                w = q * Pollut[p].dwfConcen;
                Node[j].newQual[p] += w;
                massbal_addInflowQual(DRY_WEATHER_INFLOW, p, w);
            }
        }

        // --- get pollutant mass inflows
        inflow = Node[j].dwfInflow;
        while ( inflow )
        {
            if ( inflow.param >= 0 )
            {
                p = inflow.param;
                ////////////////////////////////////
                returnObj = {inflow: inflow}
                returnVal = inflow_getDwfInflow(inObj, month, day, hour)
                inflow = returnObj.inflow;
                ////////////////////////////////////
                w = q * returnVal
                //w = q * inflow_getDwfInflow(inflow, month, day, hour);
                Node[j].newQual[p] += w;
                massbal_addInflowQual(DRY_WEATHER_INFLOW, p, w);

                // --- subtract off any default inflow
                if ( Pollut[p].dwfConcen > 0.0 )
                {
                    w = q * Pollut[p].dwfConcen;
                    Node[j].newQual[p] -= w;
                    massbal_addInflowQual(DRY_WEATHER_INFLOW, p, -w);
                }
            }
            inflow = inflow.next;
        }
    }
}

//=============================================================================
// double routingTime
addWetWeatherInflows(routingTime)
//
//  Input:   routingTime = elasped time (millisec)
//  Output:  none
//  Purpose: adds runoff inflows to nodes at current elapsed time.
//
{
    let    i, j, p;
    let q, w;
    let f;

    // --- find where current routing time lies between latest runoff times
    if ( Nobjects[SUBCATCH] == 0 ) return;
    f = (routingTime - OldRunoffTime) / (NewRunoffTime - OldRunoffTime);
    if ( f < 0.0 ) f = 0.0;
    if ( f > 1.0 ) f = 1.0;

    // for each subcatchment outlet node,
    // add interpolated runoff flow & pollutant load to node's inflow
    for (i = 0; i < Nobjects[SUBCATCH]; i++)
    {
        j = Subcatch[i].outNode;
        if ( j >= 0)
        {
            // add runoff flow to lateral inflow
            q = subcatch_getWtdOutflow(i, f);     // current runoff flow
            Node[j].newLatFlow += q;
            massbal_addInflowFlow(WET_WEATHER_INFLOW, q);

            // add pollutant load
            for (p = 0; p < Nobjects[POLLUT]; p++)
            {
                w = surfqual_getWtdWashoff(i, p, f);
                Node[j].newQual[p] += w;
                massbal_addInflowQual(WET_WEATHER_INFLOW, p, w);
            }
        }
    }
}

//=============================================================================
// double routingTime
addGroundwaterInflows(routingTime)
//
//  Input:   routingTime = elasped time (millisec)
//  Output:  none
//  Purpose: adds groundwater inflows to nodes at current elapsed time.
//
{
    let    i, j, p;
    let q, w;
    let f;
    //TGroundwater* gw;
    let gw;

    // --- find where current routing time lies between latest runoff times
    if ( Nobjects[SUBCATCH] == 0 ) return;
    f = (routingTime - OldRunoffTime) / (NewRunoffTime - OldRunoffTime);
    if ( f < 0.0 ) f = 0.0;
    if ( f > 1.0 ) f = 1.0;

    // --- for each subcatchment
    for (i = 0; i < Nobjects[SUBCATCH]; i++)
    {
        // --- see if subcatch contains groundwater
        gw = Subcatch[i].groundwater;
        if ( gw )
        {
            // --- identify node receiving groundwater flow
            j = gw.node;
            if ( j >= 0 )
            {
                // add groundwater flow to lateral inflow
                q = ( (1.0 - f)*(gw.oldFlow) + f*(gw.newFlow) )
                    * Subcatch[i].area;
                if ( Math.abs(q) < FLOW_TOL ) continue;
                Node[j].newLatFlow += q;
                massbal_addInflowFlow(GROUNDWATER_INFLOW, q);

                // add pollutant load (for positive inflow)
                if ( q > 0.0 )
                {
                    for (p = 0; p < Nobjects[POLLUT]; p++)
                    {
                        w = q * Pollut[p].gwConcen;
                        Node[j].newQual[p] += w;
                        massbal_addInflowQual(GROUNDWATER_INFLOW, p, w);
                    }
                }
            }
        }
    }
}

//=============================================================================
// double routingTime
addLidDrainInflows(routingTime)
//
//  Input:   routingTime = elasped time (millisec)
//  Output:  none
//  Purpose: adds inflows to nodes receiving LID drain flow.
//
{
    let j;
    let f;

    // for each subcatchment
    if ( Nobjects[SUBCATCH] == 0 ) return;
    f = (routingTime - OldRunoffTime) / (NewRunoffTime - OldRunoffTime);
    if ( f < 0.0 ) f = 0.0;
    if ( f > 1.0 ) f = 1.0;
    for (j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        if ( Subcatch[j].area > 0.0 && Subcatch[j].lidArea > 0.0 )
            lid_addDrainInflow(j, f);
    }
}

//=============================================================================
// DateTime currentDate
addRdiiInflows(currentDate)
//
//  Input:   currentDate = current date/time
//  Output:  none
//  Purpose: adds RDII inflows to nodes at current date.
//
{
    let    i, j, p;
    let q, w;
    let    numRdiiNodes;

    // --- see if any nodes have RDII at current date
    numRdiiNodes = rdii_getNumRdiiFlows(currentDate);

    // --- add RDII flow to each node's lateral inflow
    for (i=0; i<numRdiiNodes; i++)
    {
        rdii_getRdiiFlow(i, j, q);
        if ( j < 0 ) continue;
        if ( Math.abs(q) < FLOW_TOL ) continue;
        Node[j].newLatFlow += q;
        massbal_addInflowFlow(RDII_INFLOW, q);

        // add pollutant load (for positive inflow)
        if ( q > 0.0 )
        {
            for (p = 0; p < Nobjects[POLLUT]; p++)
            {
                w = q * Pollut[p].rdiiConcen;
                Node[j].newQual[p] += w;
                massbal_addInflowQual(RDII_INFLOW, p, w);
            }
        }
    }
}

//=============================================================================
// DateTime currentDate
addIfaceInflows(currentDate)
//
//  Input:   currentDate = current date/time
//  Output:  none
//  Purpose: adds inflows from routing interface file to nodes at current date.
//
{
    let    i, j, p;
    let q, w;
    let    numIfaceNodes;

    // --- see if any nodes have interface inflows at current date
    if ( Finflows.mode != USE_FILE ) return;
    numIfaceNodes = iface_getNumIfaceNodes(currentDate);

    // --- add interface flow to each node's lateral inflow
    for (i=0; i<numIfaceNodes; i++)
    {
        j = iface_getIfaceNode(i);
        if ( j < 0 ) continue;
        q = iface_getIfaceFlow(i);
        if ( Math.abs(q) < FLOW_TOL ) continue;
        Node[j].newLatFlow += q;
        massbal_addInflowFlow(EXTERNAL_INFLOW, q);

        // add pollutant load (for positive inflow)
        if ( q > 0.0 )
        {
            for (p = 0; p < Nobjects[POLLUT]; p++)
            {
                w = q * iface_getIfaceQual(i, p);
                Node[j].newQual[p] += w;
                massbal_addInflowQual(EXTERNAL_INFLOW, p, w);
            }
        }
    }
}



//=============================================================================

 inflowHasChanged()
//
//  Input:   none
//  Output:  returns true if external inflows or outfall flows have changed
//           from the previous time step
//  Purpose: checks if the hydraulic state of the system has changed from
//           the previous time step.
//
{
    let    j;
    let diff, qOld, qNew;

    // --- check if external inflows or outfall flows have changed 
    for (j = 0; j < Nobjects[NODE]; j++)
    {
        qOld = Node[j].oldLatFlow;
        qNew = Node[j].newLatFlow;
        if      ( Math.abs(qOld) > TINY ) diff = (qNew / qOld) - 1.0;
        else if ( Math.abs(qNew) > TINY ) diff = 1.0;
        else                    diff = 0.0;
        if ( Math.abs(diff) > LatFlowTol ) return true;
        if ( Node[j].type == OUTFALL || Node[j].degree == 0 )
        {
            qOld = Node[j].oldFlowInflow;
            qNew = Node[j].inflow;
            if      ( Math.abs(qOld) > TINY ) diff = (qNew / qOld) - 1.0;
            else if ( Math.abs(qNew) > TINY ) diff = 1.0;
            else                          diff = 0.0;
            if ( Math.abs(diff) > LatFlowTol ) return true;
        }
    }
    return false;
}

//=============================================================================
// double tStep
removeStorageLosses(tStep)
//
//  Input:   tStep = routing time step (sec)
//  Output:  none
//  Purpose: adds flow rate lost from all storage nodes due to evaporation
//           & seepage in current time step to overall mass balance totals.
//
{
    let    i;
    let evapLoss = 0.0,
           exfilLoss = 0.0;

    // --- check each storage node
    for ( i = 0; i < Nobjects[NODE]; i++ )
    {
        if (Node[i].type == STORAGE)
        {
            // --- update total system storage losses
            evapLoss += Storage[Node[i].subIndex].evapLoss;
            exfilLoss += Storage[Node[i].subIndex].exfilLoss;
        }
    }

    // --- add loss rates (ft3/sec) to time step's mass balance 
    massbal_addNodeLosses(evapLoss/tStep, exfilLoss/tStep);
}

//=============================================================================

removeConduitLosses()
//
//  Input:   none
//  Output:  none
//  Purpose: adds flow rate lost from all conduits due to evaporation
//           & seepage over current time step to overall mass balance.
//
{
    let i, k;
    let barrels,
           evapLoss = 0.0,
	       seepLoss = 0.0;

    for ( i = 0; i < Nobjects[LINK]; i++ )
    {
	    if (Link[i].type == CONDUIT)
        {
            // --- retrieve number of barrels
            k = Link[i].subIndex;
            barrels = Conduit[k].barrels;

            // --- update total conduit losses
            evapLoss += Conduit[k].evapLossRate * barrels;
            seepLoss += Conduit[k].seepLossRate * barrels;
        }
    }
    massbal_addLinkLosses(evapLoss, seepLoss);
}

//=============================================================================
// double tStep
removeOutflows(tStep)
//
//  Input:   none
//  Output:  none
//  Purpose: finds flows that leave the system and adds these to mass
//           balance totals.
//
{
    let    i, p, k;
    let    isFlooded;
    let q, w, v;

    for ( i = 0; i < Nobjects[NODE]; i++ )
    {
        // --- accumulate inflow volume & pollut. load at outfalls
        if ( Node[i].type == OUTFALL && Node[i].inflow > 0.0 )
        {
            k = Node[i].subIndex;
            if ( Outfall[k].routeTo >= 0 )
            {
                v = Node[i].inflow * tStep;
                Outfall[k].vRouted += v;
                for (p = 0; p < Nobjects[POLLUT]; p++)
                    Outfall[k].wRouted[p] += Node[i].newQual[p] * v;
            }
        }

        // --- update mass balance with flow and mass leaving the system
        //     through outfalls and flooded interior nodes
        q = node_getSystemOutflow(i, isFlooded);
        if ( q > 0.0 )                                                         //(5.1.013)
        {
            massbal_addOutflowFlow(q, isFlooded);
            for ( p = 0; p < Nobjects[POLLUT]; p++ )
            {
                w = q * Node[i].newQual[p];
                massbal_addOutflowQual(p, w, isFlooded);
            }
        }
        else massbal_addInflowFlow(EXTERNAL_INFLOW, -q);                       //(5.1.013)

        // --- update mass balance with mass leaving system through negative
        //     lateral inflows (lateral flow was previously accounted for)
        q = Node[i].newLatFlow;
        if ( q < 0.0 )
        {
            for ( p = 0; p < Nobjects[POLLUT]; p++ )
            {
                w = -q * Node[i].newQual[p];
                massbal_addOutflowQual(p, w, false);
            }
        }

    }
}

//=============================================================================

sortEvents()
//
//  Input:   none
//  Output:  none
//  Purpose: sorts the entries of the Event array in chronological order.
//
{
    let i, j;
    //TEvent temp;
    let temp;

    // Apply simple exchange sort to event list
    for (i = 0; i < NumEvents-1; i++)
    {
        for (j = i+1; j < NumEvents; j++)
        {
            if ( Event[i].start > Event[j].start )
            {
                temp = Event[j];
                Event[j] = Event[i];
                Event[i] = temp;
            }
        }
    }

    // Adjust for overlapping events
    for (i = 0; i < NumEvents-1; i++)
    {
        if ( Event[i].end > Event[i+1].start ) Event[i].end = Event[i+1].start;
    }
}

//=============================================================================

//-----------------------------------------------------------------------------
//   flowrout.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/19/14  (Build 5.1.001)
//             09/15/14  (Build 5.1.007)
//             03/19/15  (Build 5.1.008)
//             03/14/17  (Build 5.1.012)
//             03/01/20  (Build 5.1.014)
//   Author:   L. Rossman (EPA)
//             M. Tryby (EPA)
//
//   Flow routing functions.
//
//
//   Build 5.1.007:
//   - updateStorageState() modified in response to node outflow being 
//     initialized with current evap & seepage losses in routing_execute().
//
//   Build 5.1.008:
//   - Determination of node crown elevations moved to dynwave.c.
//   - Support added for new way of recording conduit's fullness state.
//
//   Build 5.1.012:
//   - Overflow computed in updateStorageState() must be non-negative.
//   - Terminal storage nodes now updated corectly.
//
//   Build 5.1.014:
//   - Arguments to link_getLossRate changed.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
OMEGA   = 0.55;    // under-relaxation parameter
MAXITER = 10;      // max. iterations for storage updating
STOPTOL = 0.005;   // storage updating stopping tolerance

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  flowrout_init            (called by routing_open)
//  flowrout_close           (called by routing_close)
//  flowrout_getRoutingStep  (called routing_getRoutingStep)
//  flowrout_execute         (called routing_execute)


//=============================================================================
// int routingModel
flowrout_init(routingModel)
//
//  Input:   routingModel = routing model code
//  Output:  none
//  Purpose: initializes flow routing system.
//
{
    // --- initialize for dynamic wave routing 
    if ( routingModel == DW )
    {
        // --- check for valid conveyance network layout
        validateGeneralLayout();
        dynwave_init();

        // --- initialize node & link depths if not using a hotstart file
        if ( Fhotstart1.mode == NO_FILE )
        {
            initNodeDepths();
            initLinkDepths();
        }
    }

    // --- validate network layout for kinematic wave routing
    else validateTreeLayout();

    // --- initialize node & link volumes
    initNodes();
    initLinks(routingModel);
}

//=============================================================================
// int routingModel
 flowrout_close(routingModel)
//
//  Input:   routingModel = routing method code
//  Output:  none
//  Purpose: closes down routing method used.
//
{
    if ( routingModel == DW ) dynwave_close();
}

//=============================================================================
// int routingModel, double fixedStep
flowrout_getRoutingStep(routingModel, fixedStep)
//
//  Input:   routingModel = type of routing method used
//           fixedStep = user-assigned max. routing step (sec)
//  Output:  returns adjusted value of routing time step (sec)
//  Purpose: finds variable time step for dynamic wave routing.
//
{
    if ( routingModel == DW )
    {
        return dynwave_getRoutingStep(fixedStep);
    }
    return fixedStep;
}

//=============================================================================
// int links[], int routingModel, double tStep
flowrout_execute(links, routingModel, tStep)
//
//  Input:   links = array of link indexes in topo-sorted order
//           routingModel = type of routing method used
//           tStep = routing time step (sec)
//  Output:  returns number of computational steps taken
//  Purpose: routes flow through conveyance network over current time step.
//
{
    let   i, j;
    let   n1;                          // upstream node of link
    let qin;                        // link inflow (cfs)
    let qout;                       // link outflow (cfs)
    let steps;                      // computational step count
    let returnObj;
    let returnVal;

    // --- set overflows to drain any ponded water
    if ( ErrorCode ) return 0;
    for (j = 0; j < Nobjects[NODE]; j++)
    {
        Node[j].updated = FALSE;
        Node[j].overflow = 0.0;
        if ( Node[j].type != STORAGE
        &&   Node[j].newVolume > Node[j].fullVolume )
        {
            Node[j].overflow = (Node[j].newVolume - Node[j].fullVolume)/tStep;
        }
    }

    // --- execute dynamic wave routing if called for
    if ( routingModel == DW )
    {
        return dynwave_execute(tStep);
    }

    // --- otherwise examine each link, moving from upstream to downstream
    steps = 0.0;
    for (i = 0; i < Nobjects[LINK]; i++)
    {
        // --- see if upstream node is a storage unit whose state needs updating
        j = links[i];
        n1 = Link[j].node1;
        if ( Node[n1].type == STORAGE ) {
            updateStorageState(n1, i, links, tStep);
        }

        // --- retrieve inflow at upstream end of link
        qin  = getLinkInflow(j, tStep);

        // route flow through link
        if ( routingModel == SF ){
            ////////////////////////////////////
            returnObj = {qinflow: qin, qoutflow: qout}
            returnVal = steadyflow_execute(j, returnObj, tStep);
            qin  = returnObj.qinflow;
            qout = returnObj.qoutflow;
            ////////////////////////////////////
            //steps += steadyflow_execute(j, qin, qout, tStep);
        }
        else {
            ////////////////////////////////////
            returnObj = {qinflow: qin, qoutflow: qout}
            returnVal = kinwave_execute(j, returnObj, tStep);
            qin  = returnObj.qinflow;
            qout = returnObj.qoutflow;
            ////////////////////////////////////
            //steps += kinwave_execute(j, qin, qout, tStep);
            steps += returnVal;
        }
        Link[j].newFlow = qout;

        // adjust outflow at upstream node and inflow at downstream node
        Node[ Link[j].node1 ].outflow += qin;
        Node[ Link[j].node2 ].inflow += qout;
    }
    if ( Nobjects[LINK] > 0 ) steps /= Nobjects[LINK];

    // --- update state of each non-updated node and link
    for ( j=0; j<Nobjects[NODE]; j++) setNewNodeState(j, tStep);
    for ( j=0; j<Nobjects[LINK]; j++) setNewLinkState(j);
    return steps+0.5;
}

//=============================================================================

validateTreeLayout()
//
//  Input:   none
//  Output:  none
//  Purpose: validates tree-like conveyance system layout used for Steady
//           and Kinematic Wave flow routing
//
{
    let    j;

    // --- check nodes
    for ( j = 0; j < Nobjects[NODE]; j++ )
    {
        switch ( Node[j].type )
        {
          // --- dividers must have only 2 outlet links
          case DIVIDER:
            if ( Node[j].degree > 2 )
            {
                report_writeErrorMsg(ERR_DIVIDER, Node[j].ID);
            }
            break;

          // --- outfalls cannot have any outlet links
          case OUTFALL:
            if ( Node[j].degree > 0 )
            {
                report_writeErrorMsg(ERR_OUTFALL, Node[j].ID);
            }
            break;

          // --- storage nodes can have multiple outlets
          case STORAGE: break;

          // --- all other nodes allowed only one outlet link
          default:
            if ( Node[j].degree > 1 )
            {
                report_writeErrorMsg(ERR_MULTI_OUTLET, Node[j].ID);
            }
        }
    }

    // ---  check links 
    for (j=0; j<Nobjects[LINK]; j++)
    {
        switch ( Link[j].type )
        {
          // --- non-dummy conduits cannot have adverse slope
          case CONDUIT:
              if ( Conduit[Link[j].subIndex].slope < 0.0 &&
                   Link[j].xsect.type != DUMMY )
              {
                  report_writeErrorMsg(ERR_SLOPE, Link[j].ID);
              }
              break;

          // --- regulator links must be outlets of storage nodes
          case ORIFICE:
          case WEIR:
          case OUTLET:
            if ( Node[Link[j].node1].type != STORAGE )
            {
                report_writeErrorMsg(ERR_REGULATOR, Link[j].ID);
            }
        }
    }
}

//=============================================================================

validateGeneralLayout()
//
//  Input:   none
//  Output:  nonw
//  Purpose: validates general conveyance system layout.
//
{
    let i, j;
    let outletCount = 0;

    // --- use node inflow attribute to count inflow connections
    for ( i=0; i<Nobjects[NODE]; i++ ) Node[i].inflow = 0.0;

    // --- examine each link
    for ( j = 0; j < Nobjects[LINK]; j++ )
    {
        // --- update inflow link count of downstream node
        i = Link[j].node1;
        if ( Node[i].type != OUTFALL ) i = Link[j].node2;
        Node[i].inflow += 1.0;

        // --- if link is dummy link or ideal pump then it must
        //     be the only link exiting the upstream node 
        if ( (Link[j].type == CONDUIT && Link[j].xsect.type == DUMMY) ||
             (Link[j].type == PUMP &&
              Pump[Link[j].subIndex].type == IDEAL_PUMP) )
        {
            i = Link[j].node1;
            if ( Link[j].direction < 0 ) i = Link[j].node2;
            if ( Node[i].degree > 1 )
            {
                report_writeErrorMsg(ERR_DUMMY_LINK, Node[i].ID);
            }
        }
    }

    // --- check each node to see if it qualifies as an outlet node
    //     (meaning that degree = 0)
    for ( i = 0; i < Nobjects[NODE]; i++ )
    {
        // --- if node is of type Outfall, check that it has only 1
        //     connecting link (which can either be an outflow or inflow link)
        if ( Node[i].type == OUTFALL )
        {
            if ( Node[i].degree + Node[i].inflow > 1 )
            {
                report_writeErrorMsg(ERR_OUTFALL, Node[i].ID);
            }
            else outletCount++;
        }
    }
    if ( outletCount == 0 ) report_writeErrorMsg(ERR_NO_OUTLETS, "");

    // --- reset node inflows back to zero
    for ( i = 0; i < Nobjects[NODE]; i++ )
    {
        if ( Node[i].inflow == 0.0 ) Node[i].degree = -Node[i].degree;
        Node[i].inflow = 0.0;
    }
}

//=============================================================================
// void
initNodeDepths()
//
//  Input:   none
//  Output:  none
//  Purpose: sets initial depth at nodes for Dynamic Wave flow routing.
//
{
    let   i;                           // link or node index
    let   n;                           // node index
    let y;                          // node water depth (ft)

    // --- use Node[].inflow as a temporary accumulator for depth in 
    //     connecting links and Node[].outflow as a temporary counter
    //     for the number of connecting links
    for (i = 0; i < Nobjects[NODE]; i++)
    {
        Node[i].inflow  = 0.0;
        Node[i].outflow = 0.0;
    }

    // --- total up flow depths in all connecting links into nodes
    for (i = 0; i < Nobjects[LINK]; i++)
    {
        if ( Link[i].newDepth > FUDGE ) y = Link[i].newDepth + Link[i].offset1;
        else y = 0.0;
        n = Link[i].node1;
        Node[n].inflow += y;
        Node[n].outflow += 1.0;
        n = Link[i].node2;
        Node[n].inflow += y;
        Node[n].outflow += 1.0;
    }

    // --- if no user-supplied depth then set initial depth at non-storage/
    //     non-outfall nodes to average of depths in connecting links
    for ( i = 0; i < Nobjects[NODE]; i++ )
    {
        if ( Node[i].type == OUTFALL ) continue;
        if ( Node[i].type == STORAGE ) continue;
        if ( Node[i].initDepth > 0.0 ) continue;
        if ( Node[i].outflow > 0.0 )
        {
            Node[i].newDepth = Node[i].inflow / Node[i].outflow;
        }
    }

    // --- compute initial depths at all outfall nodes
    for ( i = 0; i < Nobjects[LINK]; i++ ) link_setOutfallDepth(i);
}

//=============================================================================
         
initLinkDepths()
//
//  Input:   none
//  Output:  none
//  Purpose: sets initial flow depths in conduits under Dyn. Wave routing.
//
{
    let    i;                          // link index
    let y, y1, y2;                  // depths (ft)

    // --- examine each link
    for (i = 0; i < Nobjects[LINK]; i++)
    {
        // --- examine each conduit
        if ( Link[i].type == CONDUIT )
        {
            // --- skip conduits with user-assigned initial flows
            //     (their depths have already been set to normal depth)
            if ( Link[i].q0 != 0.0 ) continue;

            // --- set depth to average of depths at end nodes
            y1 = Node[Link[i].node1].newDepth - Link[i].offset1;
            y1 = MAX(y1, 0.0);
            y1 = MIN(y1, Link[i].xsect.yFull);
            y2 = Node[Link[i].node2].newDepth - Link[i].offset2;
            y2 = MAX(y2, 0.0);
            y2 = MIN(y2, Link[i].xsect.yFull);
            y = 0.5 * (y1 + y2);
            y = MAX(y, FUDGE);
            Link[i].newDepth = y;
        }
    }
}

//=============================================================================

initNodes()
//
//  Input:   none
//  Output:  none
//  Purpose: sets initial inflow/outflow and volume for each node
//
{
    let i;

    for ( i = 0; i < Nobjects[NODE]; i++ )
    {
        // --- initialize node inflow and outflow
        Node[i].inflow = Node[i].newLatFlow;
        Node[i].outflow = 0.0;

        // --- initialize node volume
        Node[i].newVolume = 0.0;
        if ( AllowPonding &&
             Node[i].pondedArea > 0.0 &&
             Node[i].newDepth > Node[i].fullDepth )
        {
            Node[i].newVolume = Node[i].fullVolume +
                                (Node[i].newDepth - Node[i].fullDepth) *
                                Node[i].pondedArea;
        }
        else Node[i].newVolume = node_getVolume(i, Node[i].newDepth);
    }

    // --- update nodal inflow/outflow at ends of each link
    //     (needed for Steady Flow & Kin. Wave routing)
    for ( i = 0; i < Nobjects[LINK]; i++ )
    {
        if ( Link[i].newFlow >= 0.0 )
        {
            Node[Link[i].node1].outflow += Link[i].newFlow;
            Node[Link[i].node2].inflow  += Link[i].newFlow;
        }
        else
        {
            Node[Link[i].node1].inflow   -= Link[i].newFlow;
            Node[Link[i].node2].outflow  -= Link[i].newFlow;
        }
    }
}

//=============================================================================
// int routingModel
initLinks(routingModel)
//
//  Input:   none
//  Output:  none
//  Purpose: sets initial upstream/downstream conditions in links.
//
{
    let    i;                          // link index
    let    k;                          // conduit or pump index

    // --- examine each link
    for ( i = 0; i < Nobjects[LINK]; i++ )
    {
        if ( routingModel == SF) Link[i].newFlow = 0.0;

        // --- otherwise if link is a conduit
        else if ( Link[i].type == CONDUIT )
        {
            // --- assign initial flow to both ends of conduit
            k = Link[i].subIndex;
            Conduit[k].q1 = Link[i].newFlow / Conduit[k].barrels;
            Conduit[k].q2 = Conduit[k].q1;

            // --- find areas based on initial flow depth
            Conduit[k].a1 = xsect_getAofY(Link[i].xsect, Link[i].newDepth);
            Conduit[k].a2 = Conduit[k].a1;

            // --- compute initial volume from area
            {
                Link[i].newVolume = Conduit[k].a1 * link_getLength(i) *
                                    Conduit[k].barrels;
            }
            Link[i].oldVolume = Link[i].newVolume;
        }
    }
}

//=============================================================================
// int j, double dt
getLinkInflow(j, dt)
//
//  Input:   j  = link index
//           dt = routing time step (sec)
//  Output:  returns link inflow (cfs)
//  Purpose: finds flow into upstream end of link at current time step under
//           Steady or Kin. Wave routing.
//
{
    let   n1 = Link[j].node1;
    let q;
    if ( Link[j].type == CONDUIT ||
         Link[j].type == PUMP ||
         Node[n1].type == STORAGE ) q = link_getInflow(j);
    else q = 0.0;
    return node_getMaxOutflow(n1, q, dt);
}

//=============================================================================
// int i, int j, int links[], double dt
updateStorageState(i, j, links, dt)
//
//  Input:   i = index of storage node
//           j = current position in links array
//           links = array of topo-sorted link indexes
//           dt = routing time step (sec)
//  Output:  none
//  Purpose: updates depth and volume of a storage node using successive
//           approximation with under-relaxation for Steady or Kin. Wave
//           routing.
//
{
    let    iter;                       // iteration counter
    let    stopped;                    // TRUE when iterations stop
    let vFixed;                     // fixed terms of flow balance eqn.
    let v2;                         // new volume estimate (ft3)
    let d1;                         // initial value of storage depth (ft)
    let d2;                         // updated value of storage depth (ft)

    // --- see if storage node needs updating
    if ( Node[i].type != STORAGE ) return;
    if ( Node[i].updated ) return;

    // --- compute terms of flow balance eqn.
    //       v2 = v1 + (inflow - outflow)*dt
    //     that do not depend on storage depth at end of time step
    vFixed = Node[i].oldVolume + 
             0.5 * (Node[i].oldNetInflow + Node[i].inflow - 
                    Node[i].outflow) * dt;
    d1 = Node[i].newDepth;

    // --- iterate finding outflow (which depends on depth) and subsequent
    //     new volume and depth until negligible depth change occurs
    iter = 1;
    stopped = FALSE;
    while ( iter < MAXITER && !stopped )
    {
        // --- find new volume from flow balance eqn.
        v2 = vFixed - 0.5 * getStorageOutflow(i, j, links, dt) * dt;

        // --- limit volume to full volume if no ponding
        //     and compute overflow rate
        v2 = MAX(0.0, v2);
        Node[i].overflow = 0.0;
        if ( v2 > Node[i].fullVolume )
        {
            Node[i].overflow = (v2 - MAX(Node[i].oldVolume,
                                         Node[i].fullVolume)) / dt;
            if ( Node[i].overflow < FUDGE ) Node[i].overflow = 0.0;
            if ( !AllowPonding || Node[i].pondedArea == 0.0 )
                v2 = Node[i].fullVolume;
        }

        // --- update node's volume & depth 
        Node[i].newVolume = v2;
        d2 = node_getDepth(i, v2);
        Node[i].newDepth = d2;

        // --- use under-relaxation to estimate new depth value
        //     and stop if close enough to previous value
        d2 = (1.0 - OMEGA)*d1 + OMEGA*d2;
        if ( Math.abs(d2 - d1) <= STOPTOL ) stopped = TRUE;

        // --- update old depth with new value and continue to iterate
        Node[i].newDepth = d2;
        d1 = d2;
        iter++;
    }

    // --- mark node as being updated
    Node[i].updated = TRUE;
}

//=============================================================================
// int i, int j, int links[], double dt
getStorageOutflow(i, j, links, dt)
//
//  Input:   i = index of storage node
//           j = current position in links array
//           links = array of topo-sorted link indexes
//           dt = routing time step (sec)
//  Output:  returns total outflow from storage node (cfs)
//  Purpose: computes total flow released from a storage node.
//
{
    let   k, m;
    let outflow = 0.0;

    for (k = j; k < Nobjects[LINK]; k++)
    {
        m = links[k];
        if ( Link[m].node1 != i ) break;
        outflow += getLinkInflow(m, dt);
    }
    return outflow;        
}

//=============================================================================
// int j, double dt
setNewNodeState(j, dt)
//
//  Input:   j  = node index
//           dt = time step (sec)
//  Output:  none
//  Purpose: updates state of node after current time step
//           for Steady Flow or Kinematic Wave flow routing.
//
{
    let   canPond;                     // TRUE if ponding can occur at node  
    let newNetInflow;               // inflow - outflow at node (cfs)

    // --- update terminal storage nodes
    if ( Node[j].type == STORAGE )
    {
    if ( Node[j].updated == FALSE )
        updateStorageState(j, Nobjects[LINK], NULL, dt);
        return; 
    }

    // --- update stored volume using mid-point integration
    newNetInflow = Node[j].inflow - Node[j].outflow - Node[j].losses;
    Node[j].newVolume = Node[j].oldVolume +
                        0.5 * (Node[j].oldNetInflow + newNetInflow) * dt;
    if ( Node[j].newVolume < FUDGE ) Node[j].newVolume = 0.0;

    // --- determine any overflow lost from system
    Node[j].overflow = 0.0;
    canPond = (AllowPonding && Node[j].pondedArea > 0.0);
    if ( Node[j].newVolume > Node[j].fullVolume )
    {
        Node[j].overflow = (Node[j].newVolume - MAX(Node[j].oldVolume,
                            Node[j].fullVolume)) / dt;
        if ( Node[j].overflow < FUDGE ) Node[j].overflow = 0.0;
        if ( !canPond ) Node[j].newVolume = Node[j].fullVolume;
    }

    // --- compute a depth from volume
    //     (depths at upstream nodes are subsequently adjusted in
    //     setNewLinkState to reflect depths in connected conduit)
    Node[j].newDepth = node_getDepth(j, Node[j].newVolume);
}

//=============================================================================
// int j
setNewLinkState(j)
//
//  Input:   j = link index
//  Output:  none
//  Purpose: updates state of link after current time step under
//           Steady Flow or Kinematic Wave flow routing
//
{
    let   k;
    let a, y1, y2;

    Link[j].newDepth = 0.0;
    Link[j].newVolume = 0.0;

    if ( Link[j].type == CONDUIT )
    {
        // --- find avg. depth from entry/exit conditions
        k = Link[j].subIndex;
        a = 0.5 * (Conduit[k].a1 + Conduit[k].a2);
        Link[j].newVolume = a * link_getLength(j) * Conduit[k].barrels;
        y1 = xsect_getYofA(Link[j].xsect, Conduit[k].a1);
        y2 = xsect_getYofA(Link[j].xsect, Conduit[k].a2);
        Link[j].newDepth = 0.5 * (y1 + y2);

        // --- update depths at end nodes
        updateNodeDepth(Link[j].node1, y1 + Link[j].offset1);
        updateNodeDepth(Link[j].node2, y2 + Link[j].offset2);

        // --- check if capacity limited
        if ( Conduit[k].a1 >= Link[j].xsect.aFull )
        {
             Conduit[k].capacityLimited = TRUE;
             Conduit[k].fullState = ALL_FULL;
        }
        else
        {    
            Conduit[k].capacityLimited = FALSE;
            Conduit[k].fullState = 0;
        }
    }
}

//=============================================================================
// int i, double y
updateNodeDepth(i, y)
//
//  Input:   i = node index
//           y = flow depth (ft)
//  Output:  none
//  Purpose: updates water depth at a node with a possibly higher value.
//
{
    // --- storage nodes were updated elsewhere
    if ( Node[i].type == STORAGE ) return;

    // --- if non-outfall node is flooded, then use full depth
    if ( Node[i].type != OUTFALL &&
         Node[i].overflow > 0.0 ) y = Node[i].fullDepth;

    // --- if current new depth below y
    if ( Node[i].newDepth < y )
    {
        // --- update new depth
        Node[i].newDepth = y;

        // --- depth cannot exceed full depth (if value exists)
        if ( Node[i].fullDepth > 0.0 && y > Node[i].fullDepth )
        {
            Node[i].newDepth = Node[i].fullDepth;
        }
    }
}

//=============================================================================
////////////////////////////////////
//let returnObj = {qinflow: qin, qoutflow: qout}
//let returnVal = steadyflow_execute(j, returnObj, tStep);
//qin  = returnObj.qinflow;
//qout = returnObj.qoutflow;
////////////////////////////////////
steadyflow_execute(j, inObj, tStep)
//int steadyflow_execute(int j, double* qin, double* qout, double tStep)
//
//  Input:   j = link index
//           qin = inflow to link (cfs)
//           tStep = time step (sec)
//  Output:  qin = adjusted inflow to link (limited by flow capacity) (cfs)
//           qout = link's outflow (cfs)
//           returns 1 if successful
//  Purpose: performs steady flow routing through a single link.
//
{
    let   k;
    let s;
    let q;

    // --- use Manning eqn. to compute flow area for conduits
    if ( Link[j].type == CONDUIT )
    {
        k = Link[j].subIndex;
        q = inObj.qin / Conduit[k].barrels;
        if ( Link[j].xsect.type == DUMMY ) Conduit[k].a1 = 0.0;
        else 
        {
            // --- adjust flow for evap and infil losses
            q -= link_getLossRate(j, q);                                       //(5.1.014)
         
            // --- flow can't exceed full flow 
            if ( q > Link[j].qFull )
            {
                q = Link[j].qFull;
                Conduit[k].a1 = Link[j].xsect.aFull;
                inObj.qin = q * Conduit[k].barrels;
            }

            // --- infer flow area from flow rate 
            else
            {
                s = q / Conduit[k].beta;
                Conduit[k].a1 = xsect_getAofS(Link[j].xsect, s);
            }
        }
        Conduit[k].a2 = Conduit[k].a1;
        
        Conduit[k].q1Old = Conduit[k].q1;
        Conduit[k].q2Old = Conduit[k].q2;
        
        Conduit[k].q1 = q;
        Conduit[k].q2 = q;
        inObj.qout = q * Conduit[k].barrels;
    }
    else inObj.qout = inObj.qin;
    return 1;
}

//=============================================================================

//-----------------------------------------------------------------------------
//   qualrout.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             04/02/15   (Build 5.1.008)
//             04/30/15   (Build 5.1.009)
//             08/05/15   (Build 5.1.010)
//             04/01/20   (Build 5.1.015)
//   Author:   L. Rossman
//
//   Water quality routing functions.
//
//   Build 5.1.008:
//   - Pollutant mass lost to seepage flow added to mass balance totals.
//   - Pollutant concen. increased when evaporation occurs.
//
//   Build 5.1.009:
//   - Criterion for dry link/storage node changed to avoid concen. blowup.
//
//   Build 5.1.010:
//   - Entire module re-written to be more compact and easier to follow.
//   - Neglible depth limit replaced with a negligible volume limit.
//
//   Build 5.1.015:
//   - Fixed mass balance issue for empty storage nodes that flood.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
ZeroVolume = 0.0353147; // 1 liter in ft3

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  qualrout_init            (called by swmm_start)
//  qualrout_execute         (called by routing_execute)

//=============================================================================

   qualrout_init()
//
//  Input:   none
//  Output:  none
//  Purpose: initializes water quality concentrations in all nodes and links.
//
{
    let     i, p, isWet;
    let  c;

    for (i = 0; i < Nobjects[NODE]; i++)
    {
        isWet = ( Node[i].newDepth > FUDGE );
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            c = 0.0;
            if ( isWet ) c = Pollut[p].initConcen;
            Node[i].oldQual[p] = c;
            Node[i].newQual[p] = c;
        }
    }

    for (i = 0; i < Nobjects[LINK]; i++)
    {
        isWet = ( Link[i].newDepth > FUDGE );
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            c = 0.0;
            if ( isWet ) c = Pollut[p].initConcen;
            Link[i].oldQual[p] = c;
            Link[i].newQual[p] = c;
        }
    }
}

//=============================================================================
// double tStep
qualrout_execute(tStep)
//
//  Input:   tStep = routing time step (sec)
//  Output:  none
//  Purpose: routes water quality constituents through the drainage
//           network over the current time step.
//
{
    let    i, j;
    let qIn, vAvg;

    // --- find mass flow each link contributes to its downstream node
    for ( i = 0; i < Nobjects[LINK]; i++ ) findLinkMassFlow(i, tStep);

    // --- find new water quality concentration at each node  
    for (j = 0; j < Nobjects[NODE]; j++)
    {
        // --- get node inflow and average volume
        qIn = Node[j].inflow;
        vAvg = (Node[j].oldVolume + Node[j].newVolume) / 2.0;
        
        // --- save inflow concentrations if treatment applied
        if ( Node[j].treatment )
        {
            if ( qIn < ZERO ) qIn = 0.0;
            treatmnt_setInflow(qIn, Node[j].newQual);
        }
       
        // --- find new quality at the node 
        if ( Node[j].type == STORAGE || Node[j].oldVolume > FUDGE )
        {
            findStorageQual(j, tStep);
        }
        else findNodeQual(j);

        // --- apply treatment to new quality values
        if ( Node[j].treatment ) treatmnt_treat(j, qIn, vAvg, tStep);
    }

    // --- find new water quality in each link
    for ( i = 0; i < Nobjects[LINK]; i++ ) findLinkQual(i, tStep);
}

//=============================================================================
// double c, double v1, double wIn, double qIn, double tStep
getMixedQual(c, v1, wIn, qIn, tStep)
//
//  Input:   c = concentration in reactor at start of time step (mass/ft3)
//           v1 = volume in reactor at start of time step (ft3)
//           wIn = mass inflow rate (mass/sec)
//           qIn = flow inflow rate (cfs)
//           tStep = time step (sec)
//  Output:  returns pollutant concentration at end of time step (mass/ft3)
//  Purpose: finds pollutant concentration within a completely mixed reactor.
//
{
    let vIn, cIn, cMax;

    // --- if no inflow then reactor concentration is unchanged
    if ( qIn <= ZERO ) return c;

    // --- compute concentration of any inflow
    vIn = qIn * tStep;
    cIn = wIn * tStep / vIn;

    // --- mixture concen. can't exceed either original or inflow concen.
    cMax = MAX(c, cIn);

    // --- mix inflow with current reactor contents
    c = (c*v1 + wIn*tStep) / (v1 + vIn);
    c = MIN(c, cMax);
    c = MAX(c, 0.0);
    return c;
}


//=============================================================================
// int i, double tStep
findLinkMassFlow(i, tStep)
//
//  Input:   i = link index
//           tStep = time step (sec)
//  Output:  none
//  Purpose: adds constituent mass flow out of link to the total
//           accumulation at the link's downstream node.
//
//  Note:    Node[].newQual[], the accumulator variable, already contains
//           contributions from runoff and other external inflows from
//           calculations made in routing_execute().
{
    let    j, p;
    let qLink, w;

    // --- find inflow to downstream node
    qLink = Link[i].newFlow;

    // --- identify index of downstream node
    j = Link[i].node2;
    if ( qLink < 0.0 ) j = Link[i].node1;
    qLink = Math.abs(qLink);

    // --- examine each pollutant
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- temporarily accumulate inflow load in Node[j].newQual
        w = qLink * Link[i].oldQual[p];
        Node[j].newQual[p] += w;

        // --- update total load transported by link
        Link[i].totalLoad[p] += w * tStep;
    }
}

//=============================================================================
// int j
findNodeQual(j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: finds new quality in a node with no storage volume.
//
{
    let    p;
    let qNode;

    // --- if there is flow into node then concen. = mass inflow/node flow
    qNode = Node[j].inflow;
    if ( qNode > ZERO )
    {
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            Node[j].newQual[p] /= qNode;
        }
    }

    // --- otherwise concen. is 0
    else for (p = 0; p < Nobjects[POLLUT]; p++) Node[j].newQual[p] = 0.0;
}

//=============================================================================
// int i, double tStep
findLinkQual(i, tStep)
//
//  Input:   i = link index
//           tStep = routing time step (sec)
//  Output:  none
//  Purpose: finds new quality in a link at end of the current time step.
//
{
    let    j,                // upstream node index
           k,                // conduit index
           p;                // pollutant index
    let wIn,              // pollutant mass inflow rate (mass/sec)
           qIn,              // inflow rate (cfs)
           qSeep,            // rate of seepage loss (cfs)
           v1,               // link volume at start of time step (ft3)
           v2,               // link volume at end of time step (ft3)
           c1,               // current concentration within link (mass/ft3)
           c2,               // new concentration within link (mass/ft3)
           vEvap,            // volume lost to evaporation (ft3)
           vLosses,          // evap. + seepage volume loss (ft3)
           fEvap,            // evaporation concentration factor
           barrels;          // number of barrels in conduit

    // --- identify index of upstream node
    j = Link[i].node1;
    if ( Link[i].newFlow < 0.0 ) j = Link[i].node2;

    // --- link quality is that of upstream node when
    //     link is not a conduit or is a dummy link
    if ( Link[i].type != CONDUIT || Link[i].xsect.type == DUMMY )
    {
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            Link[i].newQual[p] = Node[j].newQual[p];
        }
        return;
    }

    // --- get flow rates and evaporation loss
    k = Link[i].subIndex;
    barrels = Conduit[k].barrels;
    qIn  = Math.abs(Conduit[k].q1) * barrels;
    qSeep = Conduit[k].seepLossRate * barrels;
    vEvap = Conduit[k].evapLossRate * barrels * tStep;

    // --- get starting and ending volumes
    v1 = Link[i].oldVolume;
    v2 = Link[i].newVolume;
    vLosses = qSeep*tStep + vEvap;

    // --- compute factor by which concentrations are increased due to
    //     evaporation loss 
    fEvap = 1.0;
    if ( vEvap > 0.0 && v1 > ZeroVolume ) fEvap += vEvap / v1;

    // --- Steady Flow routing requires special treatment
    if ( RouteModel == SF )
    {
        findSFLinkQual(i, qSeep, fEvap, tStep);
        return;
    }

    // --- adjust inflow to compensate for volume change under Dynamic
    //     Wave routing (which produces just a single (out)flow rate
    //     for a conduit)
    if ( RouteModel == DW )
    {
        qIn = qIn + (v2 + vLosses - v1) / tStep; 
        qIn = Math.max(qIn, 0.0);
    }

    // --- examine each pollutant
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- start with concen. at start of time step
        c1 = Link[i].oldQual[p];

        // --- update mass balance accounting for seepage loss
        massbal_addSeepageLoss(p, qSeep*c1);

        // --- increase concen. by evaporation factor
        c1 *= fEvap;

        // --- reduce concen. by 1st-order reaction
        c2 = getReactedQual(p, c1, v1, tStep);

        // --- mix resulting contents with inflow from upstream node
        wIn = Node[j].newQual[p]*qIn;
        c2 = getMixedQual(c2, v1, wIn, qIn, tStep);

        // --- set concen. to zero if remaining volume is negligible
        if ( v2 < ZeroVolume )
        {
            massbal_addToFinalStorage(p, c2 * v2);
            c2 = 0.0;
        }

        // --- assign new concen. to link
        Link[i].newQual[p] = c2;
    }
}

//=============================================================================
// int i, double qSeep, double fEvap, double tStep
 findSFLinkQual(i, qSeep, fEvap, tStep)
//
//  Input:   i = link index
//           tStep = routing time step (sec)
//  Output:  none
//  Purpose: finds new quality in a link at end of the current time step for
//           Steady Flow routing.
//
{
    let j = Link[i].node1;
    let p;
    let c1, c2;
    let lossRate;

    // --- examine each pollutant
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- conduit's quality equals upstream node quality
        c1 = Node[j].newQual[p];

        // --- update mass balance accounting for seepage loss
        massbal_addSeepageLoss(p, qSeep*c1);

        // --- increase concen. by evaporation factor
        c1 *= fEvap;

        // --- apply first-order decay over travel time
        c2 = c1;
        if ( Pollut[p].kDecay > 0.0 )
        {
            c2 = c1 * exp(-Pollut[p].kDecay * tStep);
            c2 = MAX(0.0, c2);
            lossRate = (c1 - c2) * Link[i].newFlow;
            massbal_addReactedMass(p, lossRate);
        }
        Link[i].newQual[p] = c2;
    }
}

//=============================================================================
// int j, double tStep
 findStorageQual(j, tStep)
//
//  Input:   j = node index
//           tStep = routing time step (sec)
//  Output:  none
//  Purpose: finds new quality in a node with storage volume.
//  
{
    let    p,                // pollutant index
           k;                // storage unit index
    let qIn,              // inflow rate (cfs)
           wIn,              // pollutant mass inflow rate (mass)
           v1,               // volume at start of time step (ft3)
           c1,               // initial pollutant concentration (mass/ft3)
           c2,               // final pollutant concentration (mass/ft3)
           qExfil = 0.0,     // exfiltration rate from storage unit (cfs)
           vEvap = 0.0,      // evaporation loss from storage unit (ft3)
           fEvap = 1.0;      // evaporation concentration factor

    // --- get inflow rate & initial volume
    qIn = Node[j].inflow;
    v1 = Node[j].oldVolume;

    // -- for storage nodes
    if ( Node[j].type == STORAGE )
    {    
        // --- update hydraulic residence time
        //     (HRT can be used in treatment functions)
        updateHRT(j, Node[j].oldVolume, qIn, tStep);

        // --- get exfiltration rate and evaporation loss
        k = Node[j].subIndex;
        qExfil = Storage[k].exfilLoss / tStep;
        vEvap = Storage[k].evapLoss;

        // --- compute factor by which concentrations are increased due to
        //     evaporation loss (avoiding huge factors as storage unit
        //     dries out completely)
        if ( vEvap > 0.0 && v1 > ZeroVolume ) fEvap += vEvap / v1;
    }

    // --- for each pollutant
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- start with concen. at start of time step 
        c1 = Node[j].oldQual[p];

        // --- update mass balance accounting for exfiltration loss
        massbal_addSeepageLoss(p, qExfil*c1);

        // --- increase concen. by evaporation factor
        c1 *= fEvap;

        // --- apply first order reaction only if no separate treatment function
        if ( Node[j].treatment == NULL ||
             Node[j].treatment[p].equation == NULL )
        {
            c1 = getReactedQual(p, c1, v1, tStep);
        }

        // --- mix resulting contents with inflow from all sources
        //     (temporarily accumulated in Node[j].newQual)
        wIn = Node[j].newQual[p];
        c2 = getMixedQual(c1, v1, wIn, qIn, tStep);

// --- set concen. to zero if remaining volume & inflow is negligible          //(5.1.015)
        if (Node[j].newVolume <= ZeroVolume && qIn <= FLOW_TOL)                //(5.1.015)
        {
            massbal_addToFinalStorage(p, c2 * Node[j].newVolume);
            c2 = 0.0;
        }

        // --- assign new concen. to node
        Node[j].newQual[p] = c2;
    }
}

//=============================================================================
// int j, double v, double q, double tStep
updateHRT(j, v, q, tStep)
//
//  Input:   j = node index
//           v = storage volume (ft3)
//           q = inflow rate (cfs)
//           tStep = time step (sec)
//  Output:  none
//  Purpose: updates hydraulic residence time (i.e., water age) at a 
//           storage node.
//
{
    let    k = Node[j].subIndex;
    let hrt = Storage[k].hrt;
    if ( v < ZERO ) hrt = 0.0;
    else hrt = (hrt + tStep) * v / (v + q*tStep);
    Storage[k].hrt = MAX(hrt, 0.0);
}

//=============================================================================
// int p, double c, double v1, double tStep
getReactedQual(p, c, v1, tStep)
//
//  Input:   p = pollutant index
//           c = initial concentration (mass/ft3)
//           v1 = initial volume (ft3)
//           tStep = time step (sec)
//  Output:  none
//  Purpose: applies a first order reaction to a pollutant over a given
//           time step.
//
{
    let c2, lossRate;
    let kDecay = Pollut[p].kDecay;

    if ( kDecay == 0.0 ) return c;
    c2 = c * (1.0 - kDecay * tStep);
    c2 = Math.max(0.0, c2);
    lossRate = (c - c2) * v1 / tStep;
    massbal_addReactedMass(p, lossRate);
    return c2;
}
 
//-----------------------------------------------------------------------------
//   massbal.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/19/14  (Build 5.1.001)
//             09/15/14  (Build 5.1.007)
//             04/02/15  (Build 5.1.008)
//             08/05/15  (Build 5.1.010)
//             08/01/16  (Build 5.1.011)
//             03/14/17  (Build 5.1.012)
//             05/10/18  (Build 5.1.013)
//   Author:   L. Rossman (EPA)
//             M. Tryby (EPA)
//
//   Mass balance functions
//
//   Build 5.1.007:
//   - Mass balances modified to to correctly handle negative external inflows.
//   - Volume from minimum surface area at nodes included in mass balances.
//
//   Build 5.1.008:
//   - massbal_updateRunoffTotals() modified.
//   - LID drain flows and returned outfall flows added to components of
//     runoff mass balance.
//   - Seepage pollutant loss added into mass balances.
//
//   Build 5.1.010:
//   - Remaining pollutant mass in "dry" elements now added to final storage.
//
//   Build 5.1.011:
//   - Final stored pollutant mass in links ignored for Steady Flow routing.
//
//   Build 5.1.012:
//   - Terminal storage nodes no longer treated as non-storage terminal
//     nodes are when updating total outflow volume.
//
//   Build 5.1.013:
//   - Volume from MinSurfArea no longer included in initial & final storage.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants   
//-----------------------------------------------------------------------------
MAX_RUNOFF_BALANCE_ERR = 10.0;
MAX_FLOW_BALANCE_ERR   = 10.0;

//-----------------------------------------------------------------------------
//  Shared variables   
//-----------------------------------------------------------------------------
/*TRunoffTotals    RunoffTotals;    // overall surface runoff continuity totals
TLoadingTotals*  LoadingTotals;   // overall WQ washoff continuity totals
TGwaterTotals    GwaterTotals;    // overall groundwater continuity totals 
TRoutingTotals   FlowTotals;      // overall routed flow continuity totals 
TRoutingTotals*  QualTotals;      // overall routed WQ continuity totals 
TRoutingTotals   StepFlowTotals;  // routed flow totals over time step
TRoutingTotals   OldStepFlowTotals;
TRoutingTotals*  StepQualTotals;  // routed WQ totals over time step
*/
 RunoffTotals = new TRunoffTotals();    // overall surface runoff continuity totals
 LoadingTotals = [];   // overall WQ washoff continuity totals
 GwaterTotals = new TGwaterTotals();    // overall groundwater continuity totals 
 FlowTotals = new TRoutingTotals();      // overall routed flow continuity totals 
 QualTotals = [];      // overall routed WQ continuity totals 
 StepFlowTotals = new TRoutingTotals();  // routed flow totals over time step
 OldStepFlowTotals = new TRoutingTotals();
 StepQualTotals = [];  // routed WQ totals over time step

//-----------------------------------------------------------------------------
//  Exportable variables
//-----------------------------------------------------------------------------
 NodeInflow = [];              // total inflow volume to each node (ft3)
 NodeOutflow = [];             // total outflow volume from each node (ft3)
 TotalArea;               // total drainage area (ft2)

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  massbal_open                (called from swmm_start in swmm5.c)
//  massbal_close               (called from swmm_end in swmm5.c)
//  massbal_report              (called from swmm_end in swmm5.c)
//  massbal_updateRunoffTotals  (called from subcatch_getRunoff)
//  massbal_updateDrainTotals   (called from evalLidUnit in lid.c)
//  massbal_updateLoadingTotals (called from subcatch_getBuildup)
//  massbal_updateGwaterTotals  (called from updateMassBal in gwater.c)
//  massbal_updateRoutingTotals (called from routing_execute)
//  massbal_initTimeStepTotals  (called from routing_execute)
//  massbal_addInflowFlow       (called from routing.c)
//  massbal_addInflowQual       (called from routing.c)
//  massbal_addOutflowFlow      (called from removeOutflows in routing.c)
//  massbal_addOutflowQual      (called from removeOutflows in routing.c)
//  massbal_addNodeLosses       (called from removeStorageLosses in routing.c)
//  massbal_addLinkLosses       (called from removeConduitLosses in routing.c)
//  massbal_addReactedMass      (called from qualrout.c & treatmnt.c)
//  massbal_addSeepageLoss      (called from routing.c)
//  massbal_addToFinalStorage   (called from qualrout.c)
//  massbal_getStepFlowError    (called from routing.c)



//=============================================================================

massbal_open()
//
//  Input:   none
//  Output:  returns error code
//  Purpose: opens and initializes mass balance continuity checking.
//
{
    let j, n;

    // --- initialize global continuity errors
    RunoffError = 0.0;
    GwaterError = 0.0;
    FlowError   = 0.0;
    QualError   = 0.0;

    // --- initialize runoff totals
    RunoffTotals.rainfall    = 0.0;
    RunoffTotals.evap        = 0.0;
    RunoffTotals.infil       = 0.0;
    RunoffTotals.runoff      = 0.0;
    RunoffTotals.runon       = 0.0;
    RunoffTotals.drains      = 0.0;
    RunoffTotals.snowRemoved = 0.0;
    RunoffTotals.initStorage = 0.0;
    RunoffTotals.initSnowCover = 0.0;
    TotalArea = 0.0;
    for (j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        RunoffTotals.initStorage += subcatch_getStorage(j);
        RunoffTotals.initSnowCover += snow_getSnowCover(j);
        TotalArea += Subcatch[j].area;
    }

    // --- initialize groundwater totals
    GwaterTotals.infil        = 0.0;
    GwaterTotals.upperEvap    = 0.0;
    GwaterTotals.lowerEvap    = 0.0;
    GwaterTotals.lowerPerc    = 0.0;
    GwaterTotals.gwater       = 0.0;
    GwaterTotals.initStorage  = 0.0;
    GwaterTotals.finalStorage = 0.0;
    for ( j = 0; j < Nobjects[SUBCATCH]; j++ )
    {
        GwaterTotals.initStorage += gwater_getVolume(j) * Subcatch[j].area;
    }

    // --- initialize node flow & storage totals
    FlowTotals.dwInflow = 0.0;
    FlowTotals.wwInflow = 0.0;
    FlowTotals.gwInflow = 0.0;
    FlowTotals.iiInflow = 0.0;
    FlowTotals.exInflow = 0.0;
    FlowTotals.flooding = 0.0;
    FlowTotals.outflow  = 0.0;
    FlowTotals.evapLoss = 0.0; 
    FlowTotals.seepLoss = 0.0;
    FlowTotals.reacted  = 0.0;
    FlowTotals.initStorage = 0.0;
    for (j = 0; j < Nobjects[NODE]; j++)
        FlowTotals.initStorage += Node[j].newVolume;
    for (j = 0; j < Nobjects[LINK]; j++)
        FlowTotals.initStorage += Link[j].newVolume;
    StepFlowTotals = FlowTotals;

    // --- initialize arrays to null
    LoadingTotals = [];
    QualTotals = [];
    StepQualTotals = [];
    NodeInflow = [];
    NodeOutflow = [];

    // --- allocate memory for WQ washoff continuity totals
    n = Nobjects[POLLUT];
    if ( n > 0 )
    {
        //LoadingTotals = (TLoadingTotals *) calloc(n, sizeof(TLoadingTotals));
        for(let i = 0; i < n; i++){LoadingTotals.push(new TLoadingTotals())}
        if ( LoadingTotals == null )
        {
             report_writeErrorMsg(ERR_MEMORY, "");
             return ErrorCode;
        }
        for (j = 0; j < n; j++)
        {
            LoadingTotals[j].initLoad      = massbal_getBuildup(j);
            LoadingTotals[j].buildup       = 0.0;
            LoadingTotals[j].deposition    = 0.0;
            LoadingTotals[j].sweeping      = 0.0;
            LoadingTotals[j].infil         = 0.0;
            LoadingTotals[j].bmpRemoval    = 0.0;
            LoadingTotals[j].runoff        = 0.0;
            LoadingTotals[j].finalLoad     = 0.0;
        }
    }

    // --- allocate memory for nodal WQ continuity totals
    if ( n > 0 )
    {
         //QualTotals = (TRoutingTotals *) calloc(n, sizeof(TRoutingTotals));
         //StepQualTotals = (TRoutingTotals *) calloc(n, sizeof(TRoutingTotals));
        for(let i = 0; i < n; i++){QualTotals.push(new TRoutingTotals())}
        for(let i = 0; i < n; i++){StepQualTotals.push(new TRoutingTotals())}
         if ( QualTotals == null || StepQualTotals == null )
         {
             report_writeErrorMsg(ERR_MEMORY, "");
             return ErrorCode;
         }
     }

    // --- initialize WQ totals
    for (j = 0; j < n; j++)
    {
        QualTotals[j].dwInflow = 0.0;
        QualTotals[j].wwInflow = 0.0;
        QualTotals[j].gwInflow = 0.0;
        QualTotals[j].exInflow = 0.0;
        QualTotals[j].flooding = 0.0;
        QualTotals[j].outflow  = 0.0;
        QualTotals[j].evapLoss = 0.0;
        QualTotals[j].seepLoss = 0.0; 
        QualTotals[j].reacted  = 0.0;
        QualTotals[j].initStorage = massbal_getStoredMass(j);
    }

    // --- initialize totals used over a single time step
    massbal_initTimeStepTotals();

    // --- allocate memory for nodal flow continuity
    if ( Nobjects[NODE] > 0 )
    {
        //NodeInflow = (double *) calloc(Nobjects[NODE], sizeof(double));
        NodeInflow = new Array(Nobjects[NODE])
        if ( NodeInflow == null )
        {
             report_writeErrorMsg(ERR_MEMORY, "");
             return ErrorCode;
        }
        //NodeOutflow = (double *) calloc(Nobjects[NODE], sizeof(double));
        NodeOutflow = new Array(Nobjects[NODE])
        if ( NodeOutflow == null )
        {
             report_writeErrorMsg(ERR_MEMORY, "");
             return ErrorCode;
        }
        for (j = 0; j < Nobjects[NODE]; j++) NodeInflow[j] = Node[j].newVolume;
    }
    return ErrorCode;
}

//=============================================================================

massbal_close()
//
//  Input:   none
//  Output:  none
//  Purpose: frees memory used by mass balance system.
//
{
    FREE(LoadingTotals);
    FREE(QualTotals);
    FREE(StepQualTotals);
    FREE(NodeInflow);
    FREE(NodeOutflow);
}

//=============================================================================

massbal_report()
//
//  Input:   none
//  Output:  none
//  Purpose: reports mass balance results.
//
{
    let    j;
    let gwArea = 0.0;

    if ( Nobjects[SUBCATCH] > 0 )
    {
        if ( massbal_getRunoffError() > MAX_RUNOFF_BALANCE_ERR ||
             RptFlags.continuity == true
           ) report_writeRunoffError(RunoffTotals, TotalArea);

        if ( Nobjects[POLLUT] > 0 && !IgnoreQuality )
        {
            if ( massbal_getLoadingError() > MAX_RUNOFF_BALANCE_ERR ||
                 RptFlags.continuity == true
               ) report_writeLoadingError(LoadingTotals);
        }
    }

    if ( Nobjects[AQUIFER] > 0  && !IgnoreGwater )
    {
        if ( massbal_getGwaterError() > MAX_RUNOFF_BALANCE_ERR ||
             RptFlags.continuity == true )
        {
            for ( j = 0; j < Nobjects[SUBCATCH]; j++ )
            {
                if ( Subcatch[j].groundwater ) gwArea += Subcatch[j].area;
            }
            if ( gwArea > 0.0 ) report_writeGwaterError(GwaterTotals, gwArea);
       }
    }

    if ( Nobjects[NODE] > 0 && !IgnoreRouting )
    {
        if ( massbal_getFlowError() > MAX_FLOW_BALANCE_ERR ||
             RptFlags.continuity == true
           ) report_writeFlowError(FlowTotals);
    
        if ( Nobjects[POLLUT] > 0 && !IgnoreQuality )
        {
            if ( massbal_getQualError() > MAX_FLOW_BALANCE_ERR ||
                 RptFlags.continuity == true
               ) report_writeQualError(QualTotals);
        }
    }
}

//=============================================================================
// int p
massbal_getBuildup(p)
//
//  Input:   p = pollutant index
//  Output:  returns total pollutant buildup (lbs or kg)
//  Purpose: computes current total buildup of a pollutant over study area.
//
{
    let    i, j;
    let load = 0.0;

    for (j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        for (i = 0; i < Nobjects[LANDUSE]; i++)
        {
            load += Subcatch[j].landFactor[i].buildup[p];
        }
        load += Subcatch[j].pondedQual[p] * Pollut[p].mcf;
    }
    return load;
}

//=============================================================================
// int flowType, double v
massbal_updateRunoffTotals(flowType, v)
//
//  Input:   flowType = type of flow
//           v = flow volume (ft3)
//  Output:  none
//  Purpose: updates runoff totals after current time step.
//
{
    switch(flowType)
    {
    case RUNOFF_RAINFALL: RunoffTotals.rainfall += v; break;
    case RUNOFF_EVAP:     RunoffTotals.evap     += v; break;
    case RUNOFF_INFIL:    RunoffTotals.infil    += v; break;
    case RUNOFF_RUNOFF:   RunoffTotals.runoff   += v; break;
    case RUNOFF_DRAINS:   RunoffTotals.drains   += v; break;
    case RUNOFF_RUNON:    RunoffTotals.runon    += v; break;
    }
}

//=============================================================================
// double vInfil, double vUpperEvap, double vLowerEvap,
//    double vLowerPerc, double vGwater
massbal_updateGwaterTotals(vInfil, vUpperEvap, vLowerEvap,
                             vLowerPerc,  vGwater)
//
//  Input:   vInfil = volume depth of infiltrated water (ft)
//           vUpperEvap = volume depth of upper evaporation (ft)
//           vLowerEvap = volume depth of lower evaporation (ft)
//           vLowerPerc = volume depth of percolation to deep GW (ft)
//           vGwater = volume depth of groundwater outflow (ft)
//  Output:  none
//  Purpose: updates groundwater totals after current time step.
//
{
    GwaterTotals.infil     += vInfil;
    GwaterTotals.upperEvap += vUpperEvap;
    GwaterTotals.lowerEvap += vLowerEvap;
    GwaterTotals.lowerPerc += vLowerPerc;
    GwaterTotals.gwater    += vGwater;
}

//=============================================================================

massbal_initTimeStepTotals()
//
//  Input:   none
//  Output:  none
//  Purpose: initializes routing totals for current time step.
//
{
    let j;
    OldStepFlowTotals = StepFlowTotals;
    StepFlowTotals.dwInflow  = 0.0;
    StepFlowTotals.wwInflow  = 0.0;
    StepFlowTotals.gwInflow  = 0.0;
    StepFlowTotals.iiInflow  = 0.0;
    StepFlowTotals.exInflow  = 0.0;
    StepFlowTotals.flooding  = 0.0;
    StepFlowTotals.outflow   = 0.0;
    StepFlowTotals.evapLoss  = 0.0;
    StepFlowTotals.seepLoss  = 0.0;
    StepFlowTotals.reacted   = 0.0;
    for (j=0; j<Nobjects[POLLUT]; j++)
    {
        StepQualTotals[j].dwInflow  = 0.0;
        StepQualTotals[j].wwInflow  = 0.0;
        StepQualTotals[j].gwInflow  = 0.0;
        StepQualTotals[j].iiInflow  = 0.0;
        StepQualTotals[j].exInflow  = 0.0;
        StepQualTotals[j].flooding  = 0.0;
        StepQualTotals[j].outflow   = 0.0;
        StepQualTotals[j].reacted   = 0.0;
        StepQualTotals[j].seepLoss  = 0.0;
        StepQualTotals[j].initStorage = 0.0;
        StepQualTotals[j].finalStorage = 0.0;
    }
}

//=============================================================================
// int type, double q
massbal_addInflowFlow(type, q)
//
//  Input:   type = type of inflow
//           q    = inflow rate (cfs)
//  Output:  none
//  Purpose: adds flow inflow to routing totals for current time step.
//
{
    switch (type)
    {
      case DRY_WEATHER_INFLOW: StepFlowTotals.dwInflow += q; break;
      case WET_WEATHER_INFLOW: StepFlowTotals.wwInflow += q; break;
      case GROUNDWATER_INFLOW: StepFlowTotals.gwInflow += q; break;
      case RDII_INFLOW:        StepFlowTotals.iiInflow += q; break;
      case EXTERNAL_INFLOW:    StepFlowTotals.exInflow += q; break;
    }
}

//=============================================================================
// int type, int p, double w
massbal_updateLoadingTotals(type, p, w)
//
//  Input:   type = type of inflow
//           p    = pollutant index
//           w    = mass loading
//  Output:  none
//  Purpose: adds inflow mass loading to loading totals for current time step.
//
{
    switch (type)
    {
      case BUILDUP_LOAD:     LoadingTotals[p].buildup    += w; break;
      case DEPOSITION_LOAD:  LoadingTotals[p].deposition += w; break;
      case SWEEPING_LOAD:    LoadingTotals[p].sweeping   += w; break;
      case INFIL_LOAD:       LoadingTotals[p].infil      += w; break;
      case BMP_REMOVAL_LOAD: LoadingTotals[p].bmpRemoval += w; break;
      case RUNOFF_LOAD:      LoadingTotals[p].runoff     += w; break;
      case FINAL_LOAD:       LoadingTotals[p].finalLoad  += w; break;
    }
}

//=============================================================================
// int type, int p, double w
massbal_addInflowQual(type, p, w)
//
//  Input:   type = type of inflow
//           p    = pollutant index
//           w    = mass flow rate (mass/sec)
//  Output:  none
//  Purpose: adds quality inflow to routing totals for current time step.
//
{
    if ( p < 0 || p >= Nobjects[POLLUT] ) return;
    switch (type)
    {
      case DRY_WEATHER_INFLOW: StepQualTotals[p].dwInflow += w; break;
      case WET_WEATHER_INFLOW: StepQualTotals[p].wwInflow += w; break;
      case GROUNDWATER_INFLOW: StepQualTotals[p].gwInflow += w; break;
      case EXTERNAL_INFLOW:    StepQualTotals[p].exInflow += w; break;
      case RDII_INFLOW:        StepQualTotals[p].iiInflow += w; break;
   }
}

//=============================================================================
// double q, int isFlooded
massbal_addOutflowFlow(q, isFlooded)
//
//  Input:   q = outflow flow rate (cfs)
//           isFlooded = true if outflow represents internal flooding
//  Output:  none
//  Purpose: adds flow outflow over current time step to routing totals.
//
{
    if ( isFlooded ) StepFlowTotals.flooding += q;
    else             StepFlowTotals.outflow += q;
}

//=============================================================================
// int p, double w, int isFlooded
massbal_addOutflowQual(p, w, isFlooded)
//
//  Input:   p = pollutant index
//           w = mass outflow rate (mass/sec)
//           isFlooded = true if outflow represents internal flooding
//  Output:  none
//  Purpose: adds pollutant outflow over current time step to routing totals.
//
{
    if ( p < 0 || p >= Nobjects[POLLUT] ) return;
    if ( w >= 0.0 )
    {
        if ( isFlooded ) StepQualTotals[p].flooding += w;
        else             StepQualTotals[p].outflow += w;
    }
    else StepQualTotals[p].exInflow -= w;
}

//=============================================================================
// int p, double w
massbal_addReactedMass(p, w)
//
//  Input:   p = pollutant index
//           w = rate of mass reacted (mass/sec)
//  Output:  none
//  Purpose: adds mass reacted during current time step to routing totals.
//
{
    if ( p < 0 || p >= Nobjects[POLLUT] ) return;
    StepQualTotals[p].reacted += w;
}

//=============================================================================
// int p, double w
massbal_addSeepageLoss(p, w)
//
//  Input:   p = pollutant index
//           w = mass seepage rate (mass/sec)
//  Output:  none
//  Purpose: adds mass lost to seepage during current time step to routing totals.
//
{
    if ( p < 0 || p >= Nobjects[POLLUT] ) return;
    StepQualTotals[p].seepLoss += w;
}

//=============================================================================
// int p, double w
massbal_addToFinalStorage(p, w)
//
//  Input:   p = pollutant index
//           w = pollutant mass
//  Output:  none
//  Purpose: adds mass remaining on dry surface to routing totals.
//
{
    if ( p < 0 || p >= Nobjects[POLLUT] ) return;
    StepQualTotals[p].finalStorage += w;
}

//=============================================================================
// double evapLoss, double seepLoss
massbal_addNodeLosses(evapLoss, seepLoss)
//
//  Input:   evapLoss = evaporation loss from all nodes (ft3/sec)
//           seepLoss = seepage loss from all nodes (ft3/sec)
//  Output:  none
//  Purpose: adds node losses over current time step to routing totals.
//
{
    StepFlowTotals.evapLoss += evapLoss;
    StepFlowTotals.seepLoss += seepLoss;
}

//=============================================================================
// double evapLoss, double seepLoss
massbal_addLinkLosses(evapLoss, seepLoss)
//
//  Input:   evapLoss = evaporation loss from all links (ft3/sec)
//           infilLoss = infiltration loss from all links (ft3/sec)
//  Output:  none
//  Purpose: adds link losses over current time step to routing totals.
//
{
    StepFlowTotals.evapLoss += evapLoss;
    StepFlowTotals.seepLoss += seepLoss;
}

//=============================================================================
// double tStep
massbal_updateRoutingTotals(tStep)
//
//  Input:   tStep = time step (sec)
//  Output:  none
//  Purpose: updates overall routing totals with totals from current time step.
//
{
    let j;
    FlowTotals.dwInflow += StepFlowTotals.dwInflow * tStep;
    FlowTotals.wwInflow += StepFlowTotals.wwInflow * tStep;
    FlowTotals.gwInflow += StepFlowTotals.gwInflow * tStep;
    FlowTotals.iiInflow += StepFlowTotals.iiInflow * tStep;
    FlowTotals.exInflow += StepFlowTotals.exInflow * tStep;
    FlowTotals.flooding += StepFlowTotals.flooding * tStep;
    FlowTotals.outflow  += StepFlowTotals.outflow * tStep;
    FlowTotals.evapLoss += StepFlowTotals.evapLoss * tStep;
    FlowTotals.seepLoss += StepFlowTotals.seepLoss * tStep;

    for (j = 0; j < Nobjects[POLLUT]; j++)
    {
        QualTotals[j].dwInflow += StepQualTotals[j].dwInflow * tStep;
        QualTotals[j].wwInflow += StepQualTotals[j].wwInflow * tStep;
        QualTotals[j].gwInflow += StepQualTotals[j].gwInflow * tStep;
        QualTotals[j].iiInflow += StepQualTotals[j].iiInflow * tStep;
        QualTotals[j].exInflow += StepQualTotals[j].exInflow * tStep;
        QualTotals[j].flooding += StepQualTotals[j].flooding * tStep;
        QualTotals[j].outflow  += StepQualTotals[j].outflow * tStep;
        QualTotals[j].reacted  += StepQualTotals[j].reacted * tStep;
        QualTotals[j].seepLoss += StepQualTotals[j].seepLoss * tStep;
        QualTotals[j].finalStorage += StepQualTotals[j].finalStorage;
    }

    for ( j = 0; j < Nobjects[NODE]; j++)
    {
        NodeInflow[j] += Node[j].inflow * tStep;
        if ( Node[j].type == OUTFALL || 
            (Node[j].degree == 0 && Node[j].type != STORAGE) )
        {
            NodeOutflow[j] += Node[j].inflow * tStep;
        }
        else
        {
            NodeOutflow[j] += Node[j].outflow * tStep; 
            if ( Node[j].newVolume <= Node[j].fullVolume ) 
                NodeOutflow[j] += Node[j].overflow * tStep; 
        }
    }
}

//=============================================================================
// char isFinalStorage
massbal_getStorage(isFinalStorage)
//
//  Input:   isFinalStorage = true if at final time period
//  Output:  returns storage volume used (ft3)
//  Purpose: computes total system storage (nodes + links) filled
//
{
    let    j;
    let totalStorage = 0.0;
    let nodeStorage;

    // --- get volume in nodes
    for (j = 0; j < Nobjects[NODE]; j++)
    {
        nodeStorage = Node[j].newVolume;
        if ( isFinalStorage ) NodeOutflow[j] += nodeStorage;
        totalStorage += nodeStorage;
    }

    // --- skip final link storage for Steady Flow routing 
    if ( isFinalStorage && RouteModel == SF ) return totalStorage;

    // --- add on volume stored in links
    for (j = 0; j < Nobjects[LINK]; j++)
    {
        totalStorage += Link[j].newVolume;
    }
    return totalStorage;
}

//=============================================================================
// double f, double sysFlows[]
massbal_getSysFlows(f, sysFlows)
//
//  Input:   f = time weighting factor
//  Output:  sysFlows = array of total system flows
//  Purpose: retrieves time-weighted average of old and new system flows.
//
{
    let f1 = 1.0 - f;
    sysFlows[SYS_DWFLOW] = (f1 * OldStepFlowTotals.dwInflow +
                             f * StepFlowTotals.dwInflow) * UCF(FLOW);
    sysFlows[SYS_GWFLOW] = (f1 * OldStepFlowTotals.gwInflow +
                             f * StepFlowTotals.gwInflow) * UCF(FLOW);
    sysFlows[SYS_IIFLOW] = (f1 * OldStepFlowTotals.iiInflow +
                             f * StepFlowTotals.iiInflow) * UCF(FLOW);
    sysFlows[SYS_EXFLOW] = (f1 * OldStepFlowTotals.exInflow +
                             f * StepFlowTotals.exInflow) * UCF(FLOW);
    sysFlows[SYS_FLOODING] = (f1 * OldStepFlowTotals.flooding +
                               f * StepFlowTotals.flooding) * UCF(FLOW);
    sysFlows[SYS_OUTFLOW] = (f1 * OldStepFlowTotals.outflow +
                              f * StepFlowTotals.outflow) * UCF(FLOW);
    sysFlows[SYS_STORAGE] = (f1 * OldStepFlowTotals.finalStorage +
                              f * StepFlowTotals.finalStorage) * UCF(VOLUME);
}

//=============================================================================

massbal_getRunoffError()
//
//  Input:   none
//  Output:  none
//  Purpose: computes runoff mass balance error.
//
{
    let    j;
    let totalInflow;
    let totalOutflow;

    // --- find final storage on all subcatchments
    RunoffTotals.finalStorage = 0.0;
    RunoffTotals.finalSnowCover = 0.0;
    for (j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        RunoffTotals.finalStorage += subcatch_getStorage(j);
        RunoffTotals.finalSnowCover += snow_getSnowCover(j);
    }

    // --- get snow removed from system
    RunoffTotals.snowRemoved = Snow.removed;

    // --- compute % difference between total inflow and outflow
    totalInflow  = RunoffTotals.rainfall +
                   RunoffTotals.runon +
                   RunoffTotals.initStorage +
                   RunoffTotals.initSnowCover;
    totalOutflow = RunoffTotals.evap +
                   RunoffTotals.infil +
                   RunoffTotals.runoff +
                   RunoffTotals.drains +
                   RunoffTotals.snowRemoved +
                   RunoffTotals.finalStorage +
                   RunoffTotals.finalSnowCover;
    RunoffTotals.pctError = 0.0;
    if ( Math.abs(totalInflow - totalOutflow) < 1.0 )
    {
        RunoffTotals.pctError = TINY;
    }
    else if ( totalInflow > 0.0 )
    {
        RunoffTotals.pctError = 100.0 * (1.0 - totalOutflow / totalInflow);
    }
    else if ( totalOutflow > 0.0 )
    {
        RunoffTotals.pctError = 100.0 * (totalInflow / totalOutflow - 1.0);
    }
    RunoffError = RunoffTotals.pctError;
    return RunoffTotals.pctError;
}

//=============================================================================

massbal_getLoadingError()
//
//  Input:   none
//  Output:  none
//  Purpose: computes runoff load mass balance error.
//
{
    let    j;
    let loadIn;
    let loadOut;
    let maxError = 0.0;

    for (j = 0; j < Nobjects[POLLUT]; j++)
    {
        // --- get final pollutant loading remaining on land surface
        LoadingTotals[j].finalLoad += massbal_getBuildup(j); 

        // --- compute total load added to study area
        loadIn = LoadingTotals[j].initLoad +
                 LoadingTotals[j].buildup +
                 LoadingTotals[j].deposition;
    
        // --- compute total load removed from study area
        loadOut = LoadingTotals[j].sweeping +
                  LoadingTotals[j].infil +
                  LoadingTotals[j].bmpRemoval +
                  LoadingTotals[j].runoff +
                  LoadingTotals[j].finalLoad;

        // --- compute mass balance error
        LoadingTotals[j].pctError = 0.0;
        if ( Math.abs(loadIn - loadOut) < 0.001 )
        {
            LoadingTotals[j].pctError = TINY;
        }
        else if ( loadIn > 0.0 )
        {
            LoadingTotals[j].pctError = 100.0 * (1.0 - loadOut / loadIn);
        }
        else if ( loadOut > 0.0 )
        {
            LoadingTotals[j].pctError = 100.0 * (loadIn / loadOut - 1.0);
        }
        maxError = MAX(maxError, LoadingTotals[j].pctError);

        // --- report total counts as log10
        if ( Pollut[j].units == COUNT )
        {
            LoadingTotals[j].initLoad   = LOG10(LoadingTotals[j].initLoad);
            LoadingTotals[j].buildup    = LOG10(LoadingTotals[j].buildup);
            LoadingTotals[j].deposition = LOG10(LoadingTotals[j].deposition);
            LoadingTotals[j].sweeping   = LOG10(LoadingTotals[j].sweeping);
            LoadingTotals[j].infil      = LOG10(LoadingTotals[j].infil);
            LoadingTotals[j].bmpRemoval = LOG10(LoadingTotals[j].bmpRemoval);
            LoadingTotals[j].runoff     = LOG10(LoadingTotals[j].runoff);
            LoadingTotals[j].finalLoad  = LOG10(LoadingTotals[j].finalLoad);
        }
    }
    return maxError;
}

//=============================================================================

massbal_getGwaterError()
//
//  Input:   none
//  Output:  none
//  Purpose: computes groundwater mass balance error.
//
{
    let    j;
    let totalInflow;
    let totalOutflow;

    // --- find final storage in groundwater
    GwaterTotals.finalStorage = 0.0;
    for ( j = 0; j < Nobjects[SUBCATCH]; j++ )
    {
        GwaterTotals.finalStorage += gwater_getVolume(j) * Subcatch[j].area;
    }

    // --- compute % difference between total inflow and outflow
    totalInflow  = GwaterTotals.infil +
                   GwaterTotals.initStorage;
    totalOutflow = GwaterTotals.upperEvap +
                   GwaterTotals.lowerEvap +
                   GwaterTotals.lowerPerc +
                   GwaterTotals.gwater +
                   GwaterTotals.finalStorage;
    GwaterTotals.pctError = 0.0;
    if ( Math.abs(totalInflow - totalOutflow) < 1.0 )
    {
        GwaterTotals.pctError = TINY;
    }
    else if ( totalInflow > 0.0 )
    {
        GwaterTotals.pctError = 100.0 * (1.0 - totalOutflow / totalInflow);
    }
    else if ( totalOutflow > 0.0 )
    {
        GwaterTotals.pctError = 100.0 * (totalInflow / totalOutflow - 1.0);
    }
    GwaterError = GwaterTotals.pctError;
    return GwaterTotals.pctError;
}

//=============================================================================

massbal_getFlowError()
//
//  Input:   none
//  Output:  none
//  Purpose: computes flow routing mass balance error.
//
{
    let totalInflow;
    let totalOutflow;

    // --- get final volume of nodes and links
    FlowTotals.finalStorage = massbal_getStorage(true);

    // --- add contributions to total inflow and outflow that are always positive
    totalInflow = FlowTotals.initStorage + FlowTotals.wwInflow  + FlowTotals.iiInflow;
    totalOutflow = FlowTotals.finalStorage + FlowTotals.flooding + FlowTotals.evapLoss +
                   FlowTotals.seepLoss + FlowTotals.reacted;

    // --- add on contributions that might be either positive or negative
    if ( FlowTotals.dwInflow >= 0.0 ) totalInflow += FlowTotals.dwInflow;
    else                              totalOutflow -= FlowTotals.dwInflow;
    if ( FlowTotals.gwInflow >= 0.0 ) totalInflow += FlowTotals.gwInflow;
    else                              totalOutflow -= FlowTotals.gwInflow;
    if ( FlowTotals.exInflow >= 0.0 ) totalInflow += FlowTotals.exInflow;
    else                              totalOutflow -= FlowTotals.exInflow;
    if ( FlowTotals.outflow >= 0.0 )  totalOutflow += FlowTotals.outflow;
    else                              totalInflow -= FlowTotals.outflow;

    // --- find percent difference between total inflow and outflow
    FlowTotals.pctError = 0.0;
    if ( Math.abs(totalInflow - totalOutflow) < 1.0 )
    {
        FlowTotals.pctError = TINY;
    }
    else if ( Math.abs(totalInflow) > 0.0 )
    {
        FlowTotals.pctError = 100.0 * (1.0 - totalOutflow / totalInflow);
    }
    else if ( Math.abs(totalOutflow) > 0.0 )
    {
        FlowTotals.pctError = 100.0 * (totalInflow / totalOutflow - 1.0);
    }
    FlowError = FlowTotals.pctError;
    return FlowTotals.pctError;
}

//=============================================================================

massbal_getQualError()
//
//  Input:   none
//  Output:  none
//  Purpose: computes water quality routing mass balance error.
//
{
    let    p;
    let maxQualError = 0.0;
    let totalInflow;
    let totalOutflow;
    let cf;

    // --- analyze each pollutant
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- get final mass stored in nodes and links
        QualTotals[p].finalStorage += massbal_getStoredMass(p);

        // --- compute % difference between total inflow and outflow
        totalInflow  = QualTotals[p].dwInflow +
                       QualTotals[p].wwInflow +
                       QualTotals[p].gwInflow +
                       QualTotals[p].iiInflow +
                       QualTotals[p].exInflow +
                       QualTotals[p].initStorage;
        totalOutflow = QualTotals[p].flooding +
                       QualTotals[p].outflow +
                       QualTotals[p].reacted +
                       QualTotals[p].seepLoss +
                       QualTotals[p].finalStorage;
        QualTotals[p].pctError = 0.0;
        if ( Math.abs(totalInflow - totalOutflow) < 0.001 )
        {
            QualTotals[p].pctError = TINY;
        }
        else if ( totalInflow > 0.0 )
        {
            QualTotals[p].pctError = 100.0 * (1.0 - totalOutflow / totalInflow);
        }
        else if ( totalOutflow > 0.0 )
        {
            QualTotals[p].pctError = 100.0 * (totalInflow / totalOutflow - 1.0);
        }

        // --- update max. error among all pollutants
        if ( Math.abs(QualTotals[p].pctError) > Math.abs(maxQualError) )
        {
            maxQualError = QualTotals[p].pctError;
        }

        // --- convert totals to reporting units (lbs, kg, or Log(Count))
        cf = LperFT3;
        if ( Pollut[p].units == COUNT )
        {
            QualTotals[p].dwInflow     = LOG10(cf * QualTotals[p].dwInflow);
            QualTotals[p].wwInflow     = LOG10(cf * QualTotals[p].wwInflow);
            QualTotals[p].gwInflow     = LOG10(cf * QualTotals[p].gwInflow);
            QualTotals[p].iiInflow     = LOG10(cf * QualTotals[p].iiInflow);
            QualTotals[p].exInflow     = LOG10(cf * QualTotals[p].exInflow);
            QualTotals[p].flooding     = LOG10(cf * QualTotals[p].flooding);
            QualTotals[p].outflow      = LOG10(cf * QualTotals[p].outflow);
            QualTotals[p].reacted      = LOG10(cf * QualTotals[p].reacted);
            QualTotals[p].seepLoss     = LOG10(cf * QualTotals[p].seepLoss);
            QualTotals[p].initStorage  = LOG10(cf * QualTotals[p].initStorage);
            QualTotals[p].finalStorage = LOG10(cf * QualTotals[p].finalStorage);
        }
        else
        {
            cf = cf * UCF(MASS);
            if ( Pollut[p].units == UG ) cf /= 1000.0;
            QualTotals[p].dwInflow     *= cf;
            QualTotals[p].wwInflow     *= cf; 
            QualTotals[p].gwInflow     *= cf; 
            QualTotals[p].iiInflow     *= cf; 
            QualTotals[p].exInflow     *= cf; 
            QualTotals[p].flooding     *= cf; 
            QualTotals[p].outflow      *= cf; 
            QualTotals[p].reacted      *= cf; 
            QualTotals[p].seepLoss     *= cf; 
            QualTotals[p].initStorage  *= cf; 
            QualTotals[p].finalStorage *= cf; 
        }
    }
    QualError = maxQualError;
    return maxQualError;
}
//=============================================================================

massbal_getStepFlowError()
//
//  Input:   none
//  Output:  returns fractional difference between total inflow and outflow.
//  Purpose: computes flow routing mass balance error at current time step.
//
{
    let totalInflow;
    let totalOutflow;

    // --- compute % difference between total inflow and outflow
    totalInflow  = StepFlowTotals.dwInflow +
                   StepFlowTotals.wwInflow +
                   StepFlowTotals.gwInflow +
                   StepFlowTotals.iiInflow +
                   StepFlowTotals.exInflow;
    totalOutflow = StepFlowTotals.flooding +
                   StepFlowTotals.outflow +
                   StepFlowTotals.evapLoss +
                   StepFlowTotals.seepLoss +
                   StepFlowTotals.reacted;
    if ( Math.abs(totalInflow) > 0.0 )
        return 1.0 - totalOutflow / totalInflow;
    else if ( Math.abs(totalOutflow) > 0.0 )
        return totalInflow / totalOutflow - 1.0;
    else return 0.0;
}

//=============================================================================
// int p
massbal_getStoredMass(p)
//
//  Input:   p = pollutant index
//  Output:  returns mass of pollutant.
//  Purpose: computes mass of pollutant stored in conveyance network.
//
{
    let j;
    let storedMass = 0.0;

    // --- get mass stored in nodes
    for (j = 0; j < Nobjects[NODE]; j++)
        storedMass += Node[j].newVolume * Node[j].newQual[p];

    // --- get mass stored in links (except for Steady Flow routing)
    if ( RouteModel != SF )
    {
        for (j = 0; j < Nobjects[LINK]; j++)
            storedMass += Link[j].newVolume * Link[j].newQual[p];
    }
    return storedMass;
}

//-----------------------------------------------------------------------------
//   inflow.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14  (Build 5.1.001)
//   Author:   L. Rossman
//
//   Manages any Direct External or Dry Weather Flow inflows
//   that have been assigned to nodes of the drainage system.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  External Functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  inflow_initDwfPattern   (called createObjects in project.c)
//  inflow_readExtInflow    (called by input_readLine)
//  inflow_readDwfInflow    (called by input_readLine)
//  inflow_deleteExtInflows (called by deleteObjects in project.c)
//  inflow_deleteDwfInflows (called by deleteObjects in project.c)
//  inflow_getExtInflow     (called by addExternalInflows in routing.c)
//  inflow_getDwfInflow     (called by addDryWeatherInflows in routing.c)
//  inflow_getPatternFactor

//=============================================================================

inflow_readExtInflow(tok, ntoks)
//int inflow_readExtInflow(char* tok[], int ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error message
//  Purpose: reads parameters of a direct external inflow from a line of input.
//
//  Formats of data line are:
//     nodeID  FLOW      tSeriesID  (FLOW         1.0          scaleFactor  baseline  basePat)
//     nodeID  pollutID  tSeriesID  (CONCEN/MASS  unitsFactor  scaleFactor  baseline  basePat)
//
{
    let    j;                          // object index
    let    param;                      // FLOW (-1) or pollutant index
    let    type = CONCEN_INFLOW;       // FLOW, CONCEN or MASS inflow
    let    tseries = -1;               // time series index
    let    basePat = -1;               // baseline pattern
    let cf = 1.0;                   // units conversion factor
    let sf = 1.0;                   // scaling factor
    let baseline = 0.0;             // baseline value

    // return facilitators
    let returnObj;
    let returnVal;

    // --- find index of node receiving the inflow
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");
    j = project_findObject(NODE, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- find index of inflow pollutant or use -1 for FLOW
    param = project_findObject(POLLUT, tok[1]);
    if ( param < 0 )
    {
        if ( match(tok[1], w_FLOW) === 1){
            param = -1;
        }
        else{
            return error_setInpError(ERR_NAME, tok[1]);
        } 
    }

    // --- find index of inflow time series (if supplied) in data base
    if ( tok[2].length > 0 )
    {
        tseries = project_findObject(TSERIES, tok[2]);
        if ( tseries < 0 ) return error_setInpError(ERR_NAME, tok[2]);
        Tseries[tseries].refersTo = EXTERNAL_INFLOW;
    }

    // --- assign type & cf values for a FLOW inflow
    if (param == -1)
    {
        type = FLOW_INFLOW;
    }

    // --- do the same for a pollutant inflow
    if ( ntoks >= 4 && param > -1)
    {
        if      ( match(tok[3], w_CONCEN) ) type = CONCEN_INFLOW;
        else if ( match(tok[3], w_MASS) )   type = MASS_INFLOW;
        else    return error_setInpError(ERR_KEYWORD, tok[3]);
        if ( ntoks >= 5 && type == MASS_INFLOW )
        {
            ////////////////////////////////////
            returnObj = {y: cf}
            returnVal = getDouble(tok[4], returnObj);
            cf = returnObj.y;
            ////////////////////////////////////
            if(!returnVal)
            //if ( ! getDouble(tok[4], &cf) )
            {
                return error_setInpError(ERR_NUMBER, tok[4]);
            }
            if ( cf <= 0.0 ) return error_setInpError(ERR_NUMBER, tok[4]);
        }
    }

    // --- get sf and baseline values
    if ( ntoks >= 6 )
    {
        ////////////////////////////////////
        returnObj = {y: sf}
        returnVal = getDouble(tok[5], returnObj);
        sf = returnObj.y;
        ////////////////////////////////////
        if(!returnVal)
        //if ( ! getDouble(tok[5], &sf) )
        {
            return error_setInpError(ERR_NUMBER, tok[5]);
        }
    }
    if ( ntoks >= 7 )
    {
        ////////////////////////////////////
        returnObj = {y: baseline}
        returnVal = getDouble(tok[6], returnObj);
        baseline = returnObj.y;
        ////////////////////////////////////
        if(!returnVal)
        //if ( ! getDouble(tok[6], &baseline) )
        {
            return error_setInpError(ERR_NUMBER, tok[6]);
        }
    }

    // --- get baseline time pattern
    if ( ntoks >= 8 )
    {
        basePat = project_findObject(TIMEPATTERN, tok[7]);
        if ( basePat < 0 ) return error_setInpError(ERR_NAME, tok[7]);
    }

    return(inflow_setExtInflow(j, param, type, tseries, basePat,
        cf, baseline, sf));
}


////////////////////////////////////
//let returnObj = {cf: val1}
//let returnVal = inflow_validate(param, type, tseries, basePat, inObj)
//val1 = returnObj.cf;
////////////////////////////////////
inflow_validate(param, type, tseries, basePat, inObj)
//int inflow_validate(int param, int type, int tseries, int basePat, double *cf)
// 
// Purpose: Validates Inflow
// Input:  param = -1 for Flow or Index of Pollutant
//         type = FLOW_INFLOW, CONCEN_INFLOW or MASS_INFLOW
//         tSeries = Time Series Index
//         basePat = Base Pattern Index
// Output: cf = Unit Conversion
// Return: returns Error Code
{
    let errcode = 0;

    // Validate param
    if (param >= Nobjects[POLLUT])
    {
        errcode = ERR_API_POLLUT_INDEX;
    }
    // Validate Type
    else if (type != FLOW_INFLOW 
             && type != CONCEN_INFLOW 
             && type != MASS_INFLOW)
    {
        errcode = ERR_KEYWORD;
    }
    // Validate Timeseries Index
    else if (tseries >= Nobjects[TSERIES])
    {
        errcode = ERR_API_TSERIES_INDEX;
    }
    // Validate Timepattern Index
    else if (basePat >= Nobjects[TIMEPATTERN])
    {
        errcode = ERR_API_PATTERN_INDEX;
    }
    else
    {
        // --- assign type & cf values for a FLOW inflow
        if ( type == FLOW_INFLOW )
        {
            inObj.cf = 1.0/UCF(FLOW);
        }
        // --- include LperFT3 term in conversion factor for MASS_INFLOW
        else if ( type == MASS_INFLOW ) 
        {
            inObj.cf /= LperFT3;		
        }
    }

    return(errcode);
}


inflow_setExtInflow(j, param, type, tseries, basePat, cf, baseline, sf)
//int inflow_setExtInflow(int j, int param, int type, int tseries, int basePat,
//                        double cf, double baseline, double sf)
// Purpose:  This assigns property values to the inflow object 
// Inputs:   j = Node index
//           param = FLOW (-1) or pollutant index
//           type = FLOW, CONCEN or MASS inflow
//           tSeries = time series index
//           basePat = baseline pattern
//           cf = units conversion factor
//           baseline = baseline inflow value
//           sf = scaling factor
// Return:   returns Error Code

{
    let errcode = 0;
    //TExtInflow* inflow;            // external inflow object
    let inflow 
    
    // return facilitators
    let returnObj;
    let returnVal;

    // Validate Inflow
    ////////////////////////////////////
    returnObj = {cf: cf}
    returnVal = inflow_validate(param, type, tseries, basePat, returnObj)
    cf = returnObj.cf;
    ////////////////////////////////////
    errcode = returnVal
    //errcode = inflow_validate(param, type, tseries, basePat, &cf);

    if (errcode == 0)
    {

        // --- check if an external inflow object for this constituent already exists
        inflow = Node[j].extInflow;
        while ( inflow )
        {
            if ( inflow.param == param ) break;
            inflow = inflow.next;
        }

        // --- if it doesn't exist, then create it
        if ( inflow == null )
        {
            //inflow = (TExtInflow *) malloc(sizeof(TExtInflow));
            inflow = new TExtInflow();
            if ( inflow == null ) 
            {
                return error_setInpError(ERR_MEMORY, "");
            }
            inflow.next = Node[j].extInflow;
            Node[j].extInflow = inflow;
        }

        // Assigning Values to the inflow object 
        inflow.param    = param;
        inflow.type     = type;
        inflow.tSeries  = tseries;
        inflow.cFactor  = cf;
        inflow.sFactor  = sf;
        inflow.baseline = baseline;
        inflow.basePat  = basePat;
        inflow.extIfaceInflow = 0.0;
    }
    return(errcode);
}

//=============================================================================

inflow_deleteExtInflows(j)
//void inflow_deleteExtInflows(int j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: deletes all time series inflow data for a node.
//
{
    //TExtInflow* inflow1;
    //TExtInflow* inflow2;
    let inflow1;
    let inflow2;

    inflow1 = Node[j].extInflow;
    while ( inflow1 )
    {
        inflow2 = inflow1.next;
        //free(inflow1);
        inflow1 = null;
        inflow1 = inflow2; 
    }
}

//=============================================================================
inflow_getExtInflow(inflow, aDate)
//double inflow_getExtInflow(TExtInflow* inflow, DateTime aDate)
//
//  Input:   inflow = external inflow data structure
//           aDate = current simulation date/time
//  Output:  returns current value of external inflow parameter
//  Purpose: retrieves the value of an external inflow at a specific
//           date and time.
//
{
    let month, day, hour;
    let p = inflow.basePat;      // baseline pattern
    let k = inflow.tSeries;      // time series index
    let cf = inflow.cFactor;     // units conversion factor
    let sf = inflow.sFactor;     // scaling factor
    let blv = inflow.baseline;   // baseline value
    let tsv = 0.0;                // time series value
    let extIfaceInflow = inflow.extIfaceInflow;// external interfacing inflow

    // ret facil
    let returnObj;
    let returnVal;

    if ( p >= 0 )
    {
        month = datetime_monthOfYear(aDate) - 1;
        day   = datetime_dayOfWeek(aDate) - 1;
        hour  = datetime_hourOfDay(aDate);
        blv  *= inflow_getPatternFactor(p, month, day, hour);
    }
    if ( k >= 0 ) {
        ////////////////////////////////////
        returnObj = {table: Tseries[k]}
        returnVal = table_tseriesLookup(returnObj, aDate, false);
        Tseries[k] = returnObj.table;
        ////////////////////////////////////
        tsv = returnVal;
        //tsv = table_tseriesLookup(&Tseries[k], aDate, false) * sf;
    }
    return cf * (tsv + blv) + cf * extIfaceInflow;
}

//=============================================================================

inflow_readDwfInflow(tok, ntoks)
//int inflow_readDwfInflow(char* tok[], int ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error message
//  Purpose: reads dry weather inflow parameters from line of input data.
//
//  Format of data line is:
//    nodeID  FLOW/pollutID  avgValue  (pattern1 pattern2  ... pattern4)
//
{
    let    i;
    let    j;                          // node index
    let    k;                          // pollutant index (-1 for flow)
    let    m;                          // time pattern index
    let    pats = new Array(4);                    // time pattern index array
    let    x;                          // avg. DWF value
    //TDwfInflow* inflow;                // dry weather flow inflow object
    let inflow

    // return facilitators
    let returnObj;
    let returnVal;

    // --- find index of node receiving the inflow
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");
    j = project_findObject(NODE, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- find index of inflow pollutant (-1 for FLOW) 
    k = project_findObject(POLLUT, tok[1]);
    if ( k < 0 )
    {
        if ( match(tok[1], w_FLOW) ) k = -1;
        else return error_setInpError(ERR_NAME, tok[1]);
    }

    // --- get avg. value of DWF inflow
    ////////////////////////////////////
    returnObj = {y: x}
    returnVal = getDouble(tok[2], returnObj);
    x = returnObj.y;
    ////////////////////////////////////
    if(!returnVal)
    //if ( !getDouble(tok[2], &x) )
        return error_setInpError(ERR_NUMBER, tok[2]);
    if ( k == -1 ) x /= UCF(FLOW);

    // --- get time patterns assigned to the inflow
    for (i=0; i<4; i++) pats[i] = -1;
    for (i=3; i<7; i++)
    {
        if ( i >= ntoks ) break;
        if ( tok[i].length == 0 ) continue;
        m = project_findObject(TIMEPATTERN, tok[i]);
        if ( m < 0 ) return error_setInpError(ERR_NAME, tok[i]);
        pats[i-3] = m;
    }

    // --- check if inflow for this constituent already exists
    inflow = Node[j].dwfInflow;
    while ( inflow )
    {
        if ( inflow.param == k ) break;
        inflow = inflow.next;
    }

    // --- if it doesn't exist, then create it
    if ( inflow == null )
    {
        //inflow = (TDwfInflow *) malloc(sizeof(TDwfInflow));
        inflow = new TDwfInflow();
        if ( inflow == null ) return error_setInpError(ERR_MEMORY, "");
        inflow.next = Node[j].dwfInflow;
        Node[j].dwfInflow = inflow;
    }

    // --- assign property values to the inflow object
    inflow.param = k;
    inflow.avgValue = x;
    for (i=0; i<4; i++) inflow.patterns[i] = pats[i];
    return 0;
}

//=============================================================================

inflow_deleteDwfInflows(j)
//void inflow_deleteDwfInflows(int j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: deletes all dry weather inflow data for a node.
//
{
    //TDwfInflow* inflow1;
    //TDwfInflow* inflow2;
    let inflow1;
    let inflow2;

    inflow1 = Node[j].dwfInflow;
    while ( inflow1 )
    {
        inflow2 = inflow1.next;
        inflow1 = null;
        //free(inflow1);
        inflow1 = inflow2; 
    }
}

//=============================================================================
////////////////////////////////////
//let returnObj = {inflow: val1}
//let returnVal = inflow_initDwfInflow(returnObj)
//val1 = returnObj.inflow;
////////////////////////////////////
  inflow_initDwfInflow(inObj)
//void   inflow_initDwfInflow(TDwfInflow* inflow)
//
//  Input:   inflow = dry weather inflow data structure
//  Output:  none
//  Purpose: initialzes a dry weather inflow by ordering its time patterns.
//
//  This sorts the user-supplied time patterns for a dry weather
//  inflow in the order of the PatternType enumeration (monthly, daily,
//  weekday hourly, weekend hourly) to help speed up pattern processing.
//
{
    let i, p;
    let tmpPattern = new Array(4);  // index of each type of DWF pattern

    // --- assume no patterns were supplied
    for (i=0; i<4; i++) tmpPattern[i] = -1;

    // --- assign supplied patterns to proper position (by type) in tmpPattern
    for (i=0; i<4; i++)
    {
        p = inObj.inflow.patterns[i];
        if ( p >= 0 ) tmpPattern[Pattern[p].type] = p;
    }

    // --- re-fill inflow pattern array by pattern type
    for (i=0; i<4; i++) inObj.inflow.patterns[i] = tmpPattern[i];
}

//=============================================================================
////////////////////////////////////
//let returnObj = {inflow: val1}
//let returnVal = inflow_getDwfInflow(inObj, month, day, hour)
//val1 = returnObj.inflow;
////////////////////////////////////
inflow_getDwfInflow(inObj, month, day, hour)
//double inflow_getDwfInflow(TDwfInflow* inflow, int month, int day, int hour)
//
//  Input:   inflow = dry weather inflow data structure
//           month = current month of year of simulation
//           day = current day of week of simulation
//           hour = current hour of day of simulation
//  Output:  returns value of dry weather inflow parameter
//  Purpose: computes dry weather inflow value at a specific point in time.
//
{
    let p1, p2;                     // pattern index
    let f = 1.0;                    // pattern factor

    p1 = inObj.inflow.patterns[MONTHLY_PATTERN];
    if ( p1 >= 0 ) f *= inflow_getPatternFactor(p1, month, day, hour);
    p1 = inObj.inflow.patterns[DAILY_PATTERN];
    if ( p1 >= 0 ) f *= inflow_getPatternFactor(p1, month, day, hour);
    p1 = inObj.inflow.patterns[HOURLY_PATTERN];
    p2 = inObj.inflow.patterns[WEEKEND_PATTERN];
    if ( p2 >= 0 )
    {
        if ( day == 0 || day == 6 )
            f *= inflow_getPatternFactor(p2, month, day, hour);
        else if ( p1 >= 0 )
            f *= inflow_getPatternFactor(p1, month, day, hour);
    }
    else if ( p1 >= 0 ) f *= inflow_getPatternFactor(p1, month, day, hour);
    return f * inObj.inflow.avgValue;

}

//=============================================================================

inflow_initDwfPattern(j)
//void inflow_initDwfPattern(int j)
//
//  Input:   j = time pattern index
//  Output:  none
//  Purpose: initialzes a dry weather inflow time pattern.
//
{
    let i;
    for (i=0; i<24; i++) Pattern[j].factor[i] = 1.0;
    Pattern[j].count = 0;
    Pattern[j].type  = -1;
    Pattern[j].ID    = null;
}

//=============================================================================

inflow_readDwfPattern(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error message
//  Purpose: reads values of a time pattern from a line of input data.
//
//  Format of data line is:
//    patternID  patternType  value(1) value(2) ...
//    patternID  value(n)  value(n+1) ....          (for continuation lines)
{
    let i, j, k, n = 1;

    // return faciliators
    let returnObj;
    let returnVal;

    // --- check for minimum number of tokens
    if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that pattern exists in database
    j = project_findObject(TIMEPATTERN, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- check if this is first line of pattern
    //     (ID pointer will not have been assigned yet)
    if ( Pattern[j].ID == null )
    {
        // --- assign ID pointer & pattern type
        Pattern[j].ID = project_findID(TIMEPATTERN, tok[0]);
        k = findmatch(tok[1], PatternTypeWords);
        if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);
        Pattern[j].type = k;
        n = 2;
    }

    // --- start reading pattern factors from rest of line
    while ( ntoks > n && Pattern[j].count < 24 )
    {
        i = Pattern[j].count;
        ////////////////////////////////////
        returnObj = {y: Pattern[j].factor[i]}
        returnVal = getDouble(tok[n], returnObj);
        Pattern[j].factor[i] = returnObj.y;
        ////////////////////////////////////
        if(!returnVal)
        //if ( !getDouble(tok[n], &Pattern[j].factor[i]) )
            return error_setInpError(ERR_NUMBER, tok[n]);
        Pattern[j].count++;
        n++;
    }
    return 0;
}

//=============================================================================

inflow_getPatternFactor(p, month, day, hour)
//double inflow_getPatternFactor(int p, int month, int day, int hour)
//
//  Input:   p = time pattern index
//           month = current month of year of simulation
//           day = current day of week of simulation
//           hour = current hour of day of simulation
//  Output:  returns value of a time pattern multiplier
//  Purpose: computes time pattern multiplier for a specific point in time.
{
    switch ( Pattern[p].type )
    {
      case MONTHLY_PATTERN:
        if ( month >= 0 && month < 12 ) return Pattern[p].factor[month];
        break;
      case DAILY_PATTERN:
        if ( day >= 0 && day < 7 ) return Pattern[p].factor[day];
        break;
      case HOURLY_PATTERN:
        if ( hour >= 0 && hour < 24 ) return Pattern[p].factor[hour];
        break;
      case WEEKEND_PATTERN:
        if ( day == 0 || day == 6 )
        {
            if ( hour >= 0 && hour < 24 ) return Pattern[p].factor[hour];
        }
        break;
    }
    return 1.0;
}

//=============================================================================

//-----------------------------------------------------------------------------
//   snow.c
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/14   (Build 5.1.001)
//            03/19/15   (Build 5.1.008)
//   Author:  L. Rossman
//
//   Models snow melt processes.
//
//   Build 5.1.008:
//   - Adjustment of snowmelt and subcatchment's net precipitation for area
//     covered by snow was corrected. 
//   - Area covered by snow now included in calculation of rate that liquid
//     water leaves a snowpack.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Constants 
//-----------------------------------------------------------------------------
// These symbolize the keywords listed in SnowmeltWords in keywords.c
//enum SnowKeywords {SNOW_PLOWABLE, SNOW_IMPERV, SNOW_PERV, SNOW_REMOVAL};
SNOW_PLOWABLE = 0
SNOW_IMPERV = 1 
SNOW_PERV = 2 
SNOW_REMOVAL = 3

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  snow_createSnowpack  (called from subcatch_setParams)
//  snow_initSnowpack    (called from subcatch_initState)
//  snow_initSnowmelt    (called from createObjects in project.c)
//  snow_validateSnowmelt(called from project_validate)
//  snow_readMeltParams  (called from parseLine in input.c)
//  snow_setMeltCoeffs   (called from setTemp in climate.c)
//  snow_plowSnow        (called from runoff_execute)
//  snow_getSnowMelt     (called from subcatch_getRunoff)
//  snow_getSnowCover    (called from massbal_open)
//  snow_getState        (called from saveRunoff in hotstart.c)


//=============================================================================
// char* tok[], int ntoks
snow_readMeltParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns error code
//  Purpose: reads snow melt parameters from a tokenized line of input data.
//
//  Format of data are:
//   Name  SubArea   Cmin  Cmax  Tbase  FWF  SD0  FW0  SNN0/SD100
//	 Name  REMOVAL   SDplow Fout Fimperv Fperv Fimelt Fsubcatch (Subcatch)
//
{
    let i, j, k, m, n;
    let x= new Array(7);
    if ( ntoks < 8 ) return error_setInpError(ERR_ITEMS, "");

    // --- save snow melt parameter set name if not already done so
    j = project_findObject(SNOWMELT, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);
    if ( Snowmelt[j].ID == null )
        Snowmelt[j].ID = project_findID(SNOWMELT, tok[0]);

    // --- identify data keyword
    k = findmatch(tok[1], SnowmeltWords);
    if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);

    // --- number of parameters to read
    n = 7;                             // 7 for subareas
    if ( k == SNOW_REMOVAL ) n = 6;    // 6 for Removal
    if ( ntoks < n + 2 ) return error_setInpError(ERR_ITEMS, "");
    for (i=0; i<7; i++) x[i] = 0.0;

    // --- parse each parameter
    for (i=0; i<n; i++)
    {
        ////////////////////////////////////
        returnObj = {y: x[i]}
        returnVal = getDouble(tok[i+2], returnObj);
        x[i] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( ! getDouble(tok[i+2], x[i]) )
            return error_setInpError(ERR_NUMBER, tok[i+2]);
    }

    // --- parse name of subcatch receiving snow plowed from current subcatch
    if ( k == SNOW_REMOVAL )
    {
        x[6] = -1.0;
        if ( ntoks >= 9 )
        {
            m = project_findObject(SUBCATCH, tok[8]);
            if ( m < 0 ) return error_setInpError(ERR_NAME, tok[8]);
            x[6] = m;
        }
    }

    // --- save snow melt parameters
    setMeltParams(j, k, x);
    return 0;
}

//=============================================================================
// int j, int k
snow_createSnowpack(j, k)
//
//  Input:   j = subcatchment index
//           k = snow melt parameter set index
//  Output:  returns true if successful
//  Purpose: creates a snowpack object for a subcacthment.
//
{
    //TSnowpack* snowpack;
    //snowpack = (TSnowpack *) malloc(sizeof(TSnowpack));
    snowpack = new TSnowpack();
    if ( !snowpack ) return false;
    Subcatch[j].snowpack = snowpack;
    snowpack.snowmeltIndex = k;
    return true;
}

//=============================================================================
// int j
snow_initSnowpack(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: initializes state of a subcatchment's snow pack.
//
{
    let    i;                          // snow sub-area index
    let    k;                          // snowmelt parameter set index
    let f;                          // fraction of impervious area plowable
    let snowDepth = 0.0;            // snow depth on entire subcatchment (ft)
    //TSnowpack* snowpack;               // ptr. to snow pack object
    let snowpack;

    // --- get ptr. to subcatchment's snow pack object
    snowpack = Subcatch[j].snowpack;
    if ( snowpack == null ) return;

    // --- identify index of snow melt data set used by snow pack
    k = Subcatch[j].snowpack.snowmeltIndex;

    // --- find fractional area of each snow surface
    f = Snowmelt[k].snn;
    snowpack.fArea[SNOW_PLOWABLE] = f * Subcatch[j].fracImperv;
    snowpack.fArea[SNOW_IMPERV]   = (1.0 - f) * Subcatch[j].fracImperv;
    snowpack.fArea[SNOW_PERV]     = 1.0 - Subcatch[j].fracImperv;

    // --- initialize state of snow pack on each snow surface
    for (i=SNOW_PLOWABLE; i<=SNOW_PERV; i++)
    {
        if ( snowpack.fArea[i] > 0.0 )
        {
            snowpack.wsnow[i] = Snowmelt[k].wsnow[i];
            snowpack.fw[i]    = Snowmelt[k].fwnow[i];
        }
        else
        {
            snowpack.wsnow[i] = 0.0;
            snowpack.fw[i]    = 0.0;
        }
        snowpack.coldc[i] = 0.0;
        snowpack.ati[i]   = Snowmelt[k].tbase[i];
        snowpack.awe[i]   = 1.0;
        snowDepth += snowpack.wsnow[i] * snowpack.fArea[i];
    }
    Subcatch[j].newSnowDepth = snowDepth;
}

//=============================================================================
// int j
 snow_initSnowmelt(j)
//
//  Input:   j = snowmelt parameter set index
//  Output:  none
//  Purpose: initializes values in a snow melt parameter set.
//
{
    let i, k;
    for (i=0; i<3; i++)
    {
        Snowmelt[j].snn       = 0.0;
        Snowmelt[j].si[i]     = 0.0;
        Snowmelt[j].dhmin[i]  = 0.0;
        Snowmelt[j].dhmax[i]  = 0.0;
        Snowmelt[j].tbase[i]  = 0.0;
        Snowmelt[j].fwfrac[i] = 0.0;
        Snowmelt[j].wsnow[i]  = 0.0;
        Snowmelt[j].fwnow[i]  = 0.0;
        Snowmelt[j].weplow    = 1.0e6;
        for (k=0; k<5; k++) Snowmelt[j].sfrac[k] = 0.0;
        Snowmelt[j].toSubcatch   = -1;
    }
}

//=============================================================================
// int j
snow_validateSnowmelt(j)
//
//  Input:   j = snowmelt parameter set index
//  Output:  none
//  Purpose: checks for valid values in a snow melt parameter set.
//
{
    let    k;
    let   err = false;
    let sum = 0.0;

    for ( k = SNOW_PLOWABLE; k <= SNOW_PERV; k++ )
    {
        // --- check melt coeffs.
        if ( Snowmelt[j].dhmin[k] > Snowmelt[j].dhmax[k] ) err = true; 

        // --- check free water fraction
        if ( Snowmelt[j].fwfrac[k] < 0.0 ||
             Snowmelt[j].fwfrac[k] > 1.0) err = true;
    }

    // --- check fraction of imperv. area plowable
    if ( Snowmelt[j].snn < 0.0 || Snowmelt[j].snn > 1.0 ) err = true;

    // --- check that removal fractions sum <= 1.0
    for ( k=0; k<5; k++ ) sum += Snowmelt[j].sfrac[k];
    if ( sum > 1.01 ) err = true;
    if ( err ) report_writeErrorMsg(ERR_SNOWPACK_PARAMS, Snowmelt[j].ID);
}

//=============================================================================
// int i, int j, double x[]
snow_getState(i, j, x)
//
//  Input:   i = subcatchment index
//           j = snow pack sub-area index
//  Output:  updates array of snow pack state variables x
//  Purpose: retrieves the current state of a snow pack object.
//
{
    let snowpack = Subcatch[i].snowpack;
    if ( snowpack == null ) return;
    x[0] = snowpack.wsnow[j];
    x[1] = snowpack.fw[j];
    x[2] = snowpack.coldc[j];
    x[3] = snowpack.ati[j];
    x[4] = snowpack.awe[j];
}

//=============================================================================
// int i, int j, double x[]
snow_setState(i, j, x)
//
//  Input:   i = subcatchment index
//           j = snow pack sub-area index
//           x = array of snow pack state variables
//  Output:  none
//  Purpose: sets the current state of a snow pack object.
//
{
    let snowpack = Subcatch[i].snowpack;
    if ( snowpack == null ) return;
    snowpack.wsnow[j] = x[0];
    snowpack.fw[j]    = x[1];
    snowpack.coldc[j] = x[2];
    snowpack.ati[j]   = x[3];
    snowpack.awe[j]   = x[4];
}

//=============================================================================
// int j, int k, double x[]
setMeltParams(j, k, x)
//
//  Input:   j = snowmelt parameter set index
//           k = data category index
//           x = array of snow parameter values
//  Output:  none
//  Purpose: assigns values to parameters in a snow melt data set.
//
{
    let i;

    // --- snow pack melt parameters
    if ( k >= SNOW_PLOWABLE && k <= SNOW_PERV )
    {
        // --- min/max melt coeffs.
        Snowmelt[j].dhmin[k]     = x[0] * UCF(TEMPERATURE) / UCF(RAINFALL);
        Snowmelt[j].dhmax[k]     = x[1] * UCF(TEMPERATURE) / UCF(RAINFALL); 

        // --- base melt temp (deg F)
        Snowmelt[j].tbase[k]     = x[2];
        if ( UnitSystem == SI )
            Snowmelt[j].tbase[k] =  (9./5.) * Snowmelt[j].tbase[k] + 32.0;

        // --- free water fractions
        Snowmelt[j].fwfrac[k]    = x[3];

        // --- initial snow depth & free water depth
        Snowmelt[j].wsnow[k]     = x[4] / UCF(RAINDEPTH);
        x[5] = MIN(x[5], (x[3]*x[4]));
        Snowmelt[j].fwnow[k]     = x[5] / UCF(RAINDEPTH);

        // --- fraction of impervious area that is plowable
        if ( k == SNOW_PLOWABLE ) Snowmelt[j].snn = x[6];

        // --- min. depth for 100% areal coverage on remaining
        //     impervious area or total pervious area
        else Snowmelt[j].si[k] = x[6] / UCF(RAINDEPTH);
    }

    // --- removal parameters
    else if ( k == SNOW_REMOVAL )
    {
        Snowmelt[j].weplow = x[0] / UCF(RAINDEPTH);
        for (i=0; i<=4; i++) Snowmelt[j].sfrac[i] = x[i+1];
        if ( x[6] >= 0.0 ) Snowmelt[j].toSubcatch = (int)(x[6] + 0.01);
        else               Snowmelt[j].toSubcatch = -1;
    }
}

//=============================================================================
// int j, double s
snow_setMeltCoeffs(j, s)
//
//  Input:   j = snowmelt parameter set index
//           s = snow season of year
//  Output:  none
//  Purpose: sets values of snow melt coeffs. for particular time of year.
//
{
    let k;                             // snow sub-area index

    for (k=SNOW_PLOWABLE; k<=SNOW_PERV; k++)
    {
        Snowmelt[j].dhm[k] = 0.5 * (Snowmelt[j].dhmax[k] * (1.0 + s)
                             + Snowmelt[j].dhmin[k] * (1.0 - s));
    }
}

//=============================================================================
// int j, double tStep
snow_plowSnow(j, tStep)
//
//  Input:   j     = subcatchment index
//           tStep = time step (sec)
//  Output:  none
//  Purpose: adds new snow to subcatchment and plows it between sub-areas.
//
{
    let    i;                          // snow sub-area index
    let    k;                          // snowmelt parameter set index
    let    m;                          // subcatchment index
    let rainfall;                   // rainfall (not used)
    let snowfall;                   // snowfall (ft/sec)
    let exc;                        // excess snow depth (ft)
    let f;                          // area ratio
    let sfracTotal;                 // total fraction of snow moved
    //TSnowpack* snowpack;               // ptr. to snow pack object
    let snowpack;

    // ret facil
    let returnObj;
    let returnVal;

    snowpack = Subcatch[j].snowpack;
    if ( !snowpack ) return;

    // --- see if there's any snowfall
    ////////////////////////////////////
    returnObj = {rainfall: rainfall, snowfall: snowfall}
    returnVal = gage_getPrecip(Subcatch[j].gage, returnObj)
    rainfall = returnObj.rainfall;
    snowfall = returnObj.snowfall;
    ////////////////////////////////////
    //gage_getPrecip(Subcatch[j].gage, rainfall, snowfall);

    // --- add snowfall to snow pack
    for (i=SNOW_PLOWABLE; i<=SNOW_PERV; i++)
    {
        if ( snowpack.fArea[i] > 0.0 )
        {
            snowpack.wsnow[i] += snowfall * tStep;
            snowpack.imelt[i] = 0.0;
        }
    }

    // --- see if there is excess snow on plowable area to remove
    if ( snowpack.fArea[SNOW_PLOWABLE] > 0.0 )
    {
        k = snowpack.snowmeltIndex;
        if ( snowpack.wsnow[SNOW_PLOWABLE] >= Snowmelt[k].weplow ) 
        {
            // --- excess snow to be reomoved
            exc = snowpack.wsnow[SNOW_PLOWABLE];

            // --- plow out of system
            f = snowpack.fArea[SNOW_PLOWABLE] * Subcatch[j].area;
            Snow.removed += Snowmelt[k].sfrac[0] * exc * f;
            sfracTotal = Snowmelt[k].sfrac[0];

            // --- plow onto non-plowable impervious area
            if ( snowpack.fArea[SNOW_IMPERV] > 0.0 )
            {
                f = snowpack.fArea[SNOW_PLOWABLE] /
                    snowpack.fArea[SNOW_IMPERV];
                snowpack.wsnow[SNOW_IMPERV] += Snowmelt[k].sfrac[1] * exc * f;
                sfracTotal += Snowmelt[k].sfrac[1];
            }

            // --- plow onto pervious area
            if ( snowpack.fArea[SNOW_PERV] > 0.0 )
            {
                f = snowpack.fArea[SNOW_PLOWABLE] /
                    snowpack.fArea[SNOW_PERV];
                snowpack.wsnow[SNOW_PERV] += Snowmelt[k].sfrac[2] * exc * f;
                sfracTotal += Snowmelt[k].sfrac[2];
            }

            // --- convert to immediate melt
            snowpack.imelt[SNOW_PLOWABLE] = Snowmelt[k].sfrac[3] * exc / tStep;
            sfracTotal += Snowmelt[k].sfrac[3];

            // --- send to another subcatchment
            if ( Snowmelt[k].sfrac[4] > 0.0 )
            {
                m = Snowmelt[k].toSubcatch;
                if ( Subcatch[m].snowpack )
                {
                    f = Subcatch[m].snowpack.fArea[SNOW_PERV];
                } 
                else f = 0.0; 
                if ( f > 0.0 )
                {
                    f = snowpack.fArea[SNOW_PLOWABLE] / f;
                    Subcatch[m].snowpack.wsnow[SNOW_PERV] +=
                        Snowmelt[k].sfrac[4] * exc * f;
                    sfracTotal += Snowmelt[k].sfrac[4];
                }
            }

            // --- reduce snow depth by amount plowed
            sfracTotal = Math.min(sfracTotal, 1.0);
            snowpack.wsnow[SNOW_PLOWABLE] = exc * (1.0 - sfracTotal);
        }
    }
}

//=============================================================================
// int j, double rainfall, double snowfall, double tStep,
//    double netPrecip[]
snow_getSnowMelt(j, rainfall, snowfall, tStep,
                     netPrecip)
//
//  Input:   j = subcatchment index
//           rainfall = rainfall (ft/sec)
//           snowfall = snowfall (ft/sec)
//           tStep = time step (sec)
//  Output:  netPrecip = rainfall + snowmelt on each runoff sub-area (ft/sec),
//           returns new snow depth over subcatchment
//  Purpose: modifies rainfall input to subcatchment's sub-areas based on
//           possible snow melt and updates snow depth over entire subcatchment.
//
{
    let     i;                         // snow sub-area index
    let  rmelt;                     // melt rate when rain falling (ft/sec)
    let  smelt;                     // snow melt from sub-area (ft/sec)
    let  asc;                       // frac. of sub-area snow covered
    let  snowDepth = 0.0;           // snow depth on entire subcatchment (ft)
    let  impervPrecip;              // net precip. on imperv. area (ft/sec)
    //TSnowpack* snowpack;               // ptr. to snow pack object
    let snowpack;

    // --- get ptr. to subcatchment's snowpack
    snowpack = Subcatch[j].snowpack;

    // --- compute snowmelt over entire subcatchment when rain falling
    rmelt = getRainmelt(rainfall);

    // --- compute snow melt from each type of subarea
    for (i=SNOW_PLOWABLE; i<=SNOW_PERV; i++)
    {
        // --- completely melt pack if its depth is < 0.001 inch
        if ( snowpack.wsnow[i] <= 0.001 / 12.0 )
        {
            asc   = 0.0;
            smelt = 0.0;
            snowpack.imelt[i] += (snowpack.wsnow[i] + snowpack.fw[i])
                                  / tStep;
            snowpack.wsnow[i] = 0.0;
            snowpack.fw[i]    = 0.0;
            snowpack.coldc[i] = 0.0;
        }

        // --- otherwise compute areal depletion, find snow melt
        //     and route it through pack
        else
        {
            asc   = getArealDepletion(snowpack, i, snowfall, tStep);
            smelt = meltSnowpack(snowpack, i, rmelt, asc, snowfall, tStep);
            smelt = routeSnowmelt(snowpack, i, smelt, asc, rainfall, tStep);
        }

        // --- find net precip. over entire subcatch area
        netPrecip[i] = smelt + snowpack.imelt[i]     // snow pack melt
                       + rainfall*(1.0 - asc);        // rainfall on non-snow area

        // --- add to total snow depth on subcatchment
        snowDepth += snowpack.wsnow[i] * snowpack.fArea[i];
    }

    // --- combine netPrecip on plowable & non-plowable imperv. areas
    if ( Subcatch[j].fracImperv > 0.0 )
    {
        impervPrecip =
            (netPrecip[SNOW_PLOWABLE] * snowpack.fArea[SNOW_PLOWABLE] +
             netPrecip[SNOW_IMPERV] * snowpack.fArea[SNOW_IMPERV]) /
             Subcatch[j].fracImperv;
        netPrecip[IMPERV0] = impervPrecip;
        netPrecip[IMPERV1] = impervPrecip;
    }
    return snowDepth;
}

//=============================================================================
// int j
snow_getSnowCover(j)
//
//  Input:   j = subcatchment index
//  Output:  returns volume of snow cover (ft3)
//  Purpose: computes volume of snow on a subcatchment.
//
{
    let     i;
    let  snowCover = 0.0;           // snow cover volume (ft3)
    //TSnowpack* snowpack;               // ptr. to snowpack object
    let snowpack;

    snowpack = Subcatch[j].snowpack;
    if ( !snowpack ) return 0.0;
    for (i=SNOW_PLOWABLE; i<=SNOW_PERV; i++)
    {
        snowCover += (snowpack.wsnow[i] + snowpack.fw[i]) * 
                      snowpack.fArea[i];
    }
    return snowCover * Subcatch[j].area;
}

//=============================================================================
// TSnowpack* snowpack, int i, double snowfall, double tStep
getArealDepletion(snowpack, i, snowfall, tStep)
//
//  Input:   snowpack = ptr. to snow pack object
//           i = snow sub-area index
//           snowfall = snow fall rate (ft/sec)
//           tStep = time step (sec)
//  Output:  returns fraction of sub-area with snow cover
//  Purpose: depletes snow covered area as snow pack melts.
//
{
    let   k;                           // index of snow melt parameter set
    let asc;                        // fraction of area with 100% cover
    let si;                         // snow depth at 100% cover
    let awesi;                      // depth relative to depth at 100% cover
    let awe;
    let sba;
    let sbws;

    // --- plowable sub-area not subject to areal depletion
    if ( i == SNOW_PLOWABLE ) return 1.0;
    k = snowpack.snowmeltIndex;
    si = Snowmelt[k].si[i];

    // --- no depletion if depth zero or above SI
    if ( si == 0.0 || snowpack.wsnow[i] >= si )
    {
        snowpack.awe[i] = 1.0;
        return 1.0;
    }
    if ( snowpack.wsnow[i] == 0.0 )
    {
        snowpack.awe[i] = 1.0;
        return 0.0;
    }

    // --- case of new snowfall
    if ( snowfall > 0.0 )
    {
        awe = (snowpack.wsnow[i] - snowfall*tStep) / si;
        awe = Math.max(awe, 0.0);
        sba = getArealSnowCover(i, awe);
        sbws = awe + (0.75*snowfall*tStep) / si;
        sbws = Math.max(sbws, 1.0);
        snowpack.awe[i] = awe;
        snowpack.sba[i] = sba;
        snowpack.sbws[i] = sbws;
        return 1.0;
    }

    // --- case of no new snow
    else
    {
        awe = snowpack.awe[i];
        sba = snowpack.sba[i];
        sbws = snowpack.sbws[i];
        awesi = snowpack.wsnow[i] / si;

        // --- relative snow depth is below start of new snow ADC
        if ( awesi < snowpack.awe[i] )
        {
            snowpack.awe[i] = 1.0;
            asc = getArealSnowCover(i, awesi);
        }
        
        // --- relative snow depth is above end of new snow ADC
        else if ( awesi >= snowpack.sbws[i] )
        {
            asc = 1.0;
        }

        // --- relative snow depth is on new snow ADC
        else
        {
            asc = sba + (1.0 - sba) / (sbws - awe) * (awesi - awe);
        }
        return asc;
    }
}

//=============================================================================
// int i, double awesi
getArealSnowCover(i, awesi)
//
//  Input:   i = snow sub-area index
//           awesi = snow depth relative to depth at 100% snow cover
//  Output:  returns fraction of sub-area with snow cover
//  Purpose: finds x-value on areal depletion curve (ADC) for given y-value.
//
//  Note:    Areal depletion curves are associated with a project's Snow
//           data structure. They plot relative snow depth (awesi)
//           as a of snow covererd area fraction (asc) in 10 equal
//           awesi increments between 0 and 1.0.
//
{
    let     k;                         // type of ADC (impervious or pervious)
    let     m;                         // interval on ADC
    let  asc1, asc2;                // asc values at ends of interval

    // --- determine which ADC to use
    if      ( i == SNOW_IMPERV ) k = 0;
    else if ( i == SNOW_PERV   ) k = 1;
    else return 1.0;

    // --- locate interval on ADC that bounds awesi
    if ( awesi <= 0.0 ) return 0.0;
    if ( awesi >= 0.9999 ) return 1.0;
    m = (int)(awesi*10.0 + 0.00001);

    // --- get asc values for either end of interval
    asc1 = Snow.adc[k][m];
    if ( m >= 9) asc2 = 1.0;
    else asc2 = Snow.adc[k][m+1];

    // --- return with interpolated asc value
    return asc1 + (asc2 - asc1) / 0.1 * (awesi - 0.1*m);
}    

//=============================================================================
//  TSnowpack* snowpack, int i, double rmelt, double asc,
//      double snowfall, double tStep
meltSnowpack(snowpack, i, rmelt, asc,
                     snowfall, tStep)
//
//  Input:   snowpack = ptr. to snow pack object
//           i        = snow sub-area index
//           rmelt    = melt rate if raining (ft/sec)
//           asc      = fraction of area covered with snow
//           snowfall = rate of snow fall (ft/sec)
//           tStep    = time step (sec)
//  Output:  returns snow melt rate (ft/sec)
//  Purpose: computes rate of snow melt from snow sub-area.
//
{
    let   k;                           // snowmelt parameter set index
    let smelt;                      // melt rate over sub-area (ft/sec)
    let ccFactor;                   // cold content conversion factor

    // --- if raining then use result found from getRainMelt
    k = snowpack.snowmeltIndex;
    if ( rmelt > 0.0 ) smelt = rmelt;

    // --- else if air temp. >= base melt temp. then use degree-day eqn.
    else if ( Temp.ta >= Snowmelt[k].tbase[i] )
    {
         smelt = Snowmelt[k].dhm[i] * (Temp.ta - Snowmelt[k].tbase[i]);
    }

    // --- otherwise alter cold content and return 0
    else
    {
        updateColdContent(snowpack, i, asc, snowfall, tStep);
        return 0.0;
    }

    // --- adjust snowmelt for area of snow cover
    smelt *= asc;

    // --- reduce cold content of melting pack
    ccFactor = tStep * Snow.rnm * asc;
    smelt = reduceColdContent(snowpack, i, smelt, ccFactor);
    snowpack.ati[i] = Snowmelt[k].tbase[i];
    return smelt;
}

//=============================================================================
// double rainfall
getRainmelt(rainfall)
//
//  Input:   rainfall = rainfall rate (ft/sec)
//  Output:  returns snow melt rate (ft/sec)
//  Purpose: computes rate of snow melt when rainfall occurs.
//
{
    let uadj;                       // adjusted wind speed
    let t1, t2, t3;
    let smelt;                      // snow melt in in/hr

    rainfall = rainfall * 43200.0;     // convert rain to in/hr
    if ( rainfall > 0.02 )
    {
        uadj = 0.006 * Wind.ws;
        t1 = Temp.ta - 32.0;
        t2 = 7.5 * Temp.gamma * uadj;
        t3 = 8.5 * uadj * (Temp.ea - 0.18);
        smelt =  t1 * (0.001167 + t2 +  0.007 * rainfall) + t3;
        return smelt / 43200.0;
    }
    else return 0.0;
}

//=============================================================================
// TSnowpack* snowpack, int i, double asc, double snowfall,
//     double tStep
updateColdContent(snowpack, i, asc, snowfall,
                        tStep)
//
//  Input:   snowpack = ptr. to snow pack object
//           i        = snow sub-area index
//           asc      = fraction of area snow covered
//           snowfall = snow fall rate (ft/sec)
//           tStep    = time step (sec)
//  Output:  none
//  Purpose: updates cold content of snow pack under non-melting conditions.
//
{
    let    k;                          // snowmelt parameter set index
    let ati;                        // antecdent temperature index (deg F)
    let cc;                         // snow pack cold content (ft)
    let ccMax;                      // max. possible cold content (ft)
    let tipm;                       // adjusted ATI weighting factor

    // --- retrieve ATI & CC from snow pack object
    ati = snowpack.ati[i];
    cc = snowpack.coldc[i];

    // --- if snowing, ATI = snow (air) temperature
    if ( snowfall * 43200.0 > 0.02) ati = Temp.ta;
	else
	{
	    // convert ATI weighting factor from 6-hr to tStep time basis
	    tipm = 1.0 - pow(1.0 - Snow.tipm, tStep / (6.0*3600.0));
		
		// update ATI
		ati += tipm * (Temp.ta - ati);
	}

    // --- ATI cannot exceed snow melt base temperature
    k = snowpack.snowmeltIndex;
    ati = Math.min(ati, Snowmelt[k].tbase[i]);

    // --- update cold content
    cc += Snow.rnm * Snowmelt[k].dhm[i] * (ati - Temp.ta) * tStep * asc;
    cc = Math.max(cc, 0.0);

    // --- maximum cold content based on assumed specific heat of snow
    //     of 0.007 in. water equiv. per deg. F
    ccMax = snowpack.wsnow[i] * 0.007 / 12.0 * (Snowmelt[k].tbase[i] - ati);
    cc = Math.min(cc, ccMax);

    // --- assign updated values to snowpack
    snowpack.coldc[i] = cc;
    snowpack.ati[i] = ati;
}  

//=============================================================================
// TSnowpack* snowpack, int i, double smelt, double ccFactor
reduceColdContent(snowpack, i, smelt, ccFactor)
//
//  Input:   snowpack = ptr. to snowpack object
//           i        = snow sub-area index
//           smelt    = potential melt rate (ft/sec)
//           ccFactor = cold content conversion factor
//  Output:  returns snow melt rate (ft/sec)
//  Purpose: reduces cold content of snow pack adjusting melt rate accordingly.
//
{
    let cc;                         // cold content of snow pack (ft)

    cc = snowpack.coldc[i];
    if ( smelt * ccFactor > cc )
    {
        smelt -= cc / ccFactor;
        cc = 0.0;
    }
    else
    {
        cc -= smelt * ccFactor;
        smelt = 0.0;
    }
    snowpack.coldc[i] = cc;
    return smelt;
}

//=============================================================================
// TSnowpack* snowpack, int i, double smelt, double asc,
//  double rainfall, double tStep
routeSnowmelt(snowpack, i, smelt, asc,
                      rainfall, tStep)
//
//  Input:   snowpack = ptr. to snowpack object
//           i        = snow sub-area index
//           smelt    = snow melt rate (ft/sec)
//           asc      = fraction of area snow covered
//           rainfall = rainfall rate (ft/sec)
//           tStep    = time step (sec)
//  Output:  returns rate of liquid snow melt leaving a snow pack (ft/sec)
//  Purpose: routes snow melt through free water holding capacity of snow pack.
//
{
    let     k;          // snowmelt parameter set index
    let  vmelt;      // snow melt volume (ft)

    // --- get volume of snowmelt over time step
    k = snowpack.snowmeltIndex;
    vmelt = smelt * tStep;
    vmelt = Math.min(vmelt, snowpack.wsnow[i]);

    // --- reduce snow depth by volume of snowmelt
    snowpack.wsnow[i] -= vmelt;

    // --- add snowmelt volume and any rainfall on snow
    //     covered area of sub-area to snow pack's free water content
    snowpack.fw[i] += vmelt + rainfall * tStep * asc;

    // --- excess free water becomes liquid melt that leaves the pack 
    vmelt = snowpack.fw[i] - Snowmelt[k].fwfrac[i] * snowpack.wsnow[i];
    vmelt = Math.max(vmelt, 0.0);

    // --- reduce free water by liquid melt volume and return liquid melt rate
    snowpack.fw[i] -= vmelt;
    return vmelt / tStep;
}

//=============================================================================
//-----------------------------------------------------------------------------
//   toposort.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//   Author:   L. Rossman
//
//   Topological sorting of conveyance network links
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
///enum AdjListType {UNDIRECTED, DIRECTED};    // type of nodal adjacency list
UNDIRECTED = 0;
DIRECTED = 1;

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
InDegree = [];                  // number of incoming links to each node
StartPos = [];                  // start of a node's outlinks in AdjList
AdjList = [];                   // list of outlink indexes for each node
Stack = [];                     // array of nodes "reached" during sorting
 First;                     // position of first node in stack
 Last;                      // position of last node added to stack

Examined;                 // true if node included in spanning tree
InTree;                   // state of each link in spanning tree:
                                       // 0 = unexamined,
                                       // 1 = in spanning tree,
                                       // 2 = chord of spanning tree
LoopLinks = [];                // list of links which forms a loop
LoopLinksLast;            // number of links in a loop

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)   
//-----------------------------------------------------------------------------
//  toposort_sortLinks (called by routing_open)

//=============================================================================
// int sortedLinks[]
toposort_sortLinks(sortedLinks)
//
//  Input:   none
//  Output:  sortedLinks = array of link indexes in sorted order
//  Purpose: sorts links from upstream to downstream.
//
{
    let i, n = 0;

    // --- no need to sort links for Dyn. Wave routing
    for ( i=0; i<Nobjects[LINK]; i++) sortedLinks[i] = i;
    if ( RouteModel == DW )
    {

        // --- check for nodes with both incoming and outgoing
        //     dummy links (creates ambiguous ordering)
        checkDummyLinks();
        if ( ErrorCode ) return;

        // --- find number of outflow links for each node
        for ( i=0; i<Nobjects[NODE]; i++ ) Node[i].degree = 0;
        for ( i=0; i<Nobjects[LINK]; i++ )
        {
            // --- if upstream node is an outfall, then increment outflow
            //     count for downstream node, otherwise increment count
            //     for upstream node
            n = Link[i].node1;
            if ( Link[i].direction < 0 ) n = Link[i].node2;
            if ( Node[n].type == OUTFALL )
            {
                if ( Link[i].direction < 0 ) n = Link[i].node1;
                else n = Link[i].node2;
                Node[n].degree++;
            }
            else Node[n].degree++;
        }
        return;
    }

    // --- allocate arrays used for topo sorting
    if ( ErrorCode ) return;
    //InDegree = (int *) calloc(Nobjects[NODE], sizeof(int));
    //StartPos = (int *) calloc(Nobjects[NODE], sizeof(int));
    //AdjList  = (int *) calloc(Nobjects[LINK], sizeof(int));
    //Stack    = (int *) calloc(Nobjects[NODE], sizeof(int));
    InDegree = new Array(Nobjects[NODE]);
    StartPos = new Array(Nobjects[NODE]);
    AdjList = new Array(Nobjects[LINK]);
    Stack = new Array(Nobjects[NODE]);
    if ( InDegree == null || StartPos == null ||
         AdjList == null || Stack == null )
    {
        report_writeErrorMsg(ERR_MEMORY, "");
    }
    else
    {
        // --- create a directed adjacency list of links leaving each node
        createAdjList(DIRECTED);

        // --- adjust adjacency list for DIVIDER nodes
        adjustAdjList();

        // --- find number of links entering each node
        for (i = 0; i < Nobjects[NODE]; i++) InDegree[i] = 0;
        for (i = 0; i < Nobjects[LINK]; i++) InDegree[ Link[i].node2 ]++;

        // --- topo sort the links
        n = topoSort(sortedLinks);
    }   

    // --- free allocated memory
    FREE(InDegree);
    FREE(StartPos);
    FREE(AdjList);
    FREE(Stack);

    // --- check that all links are included in SortedLinks
    if ( !ErrorCode &&  n != Nobjects[LINK] )
    {
        report_writeErrorMsg(ERR_LOOP, "");
        findCycles();
    }
}

//=============================================================================
// int listType
createAdjList(listType)
//
//  Input:   lsitType = DIRECTED or UNDIRECTED
//  Output:  none
//  Purpose: creates listing of links incident on each node.
//
{
    let i, j, k;

    // --- determine degree of each node
    //     (for DIRECTED list only count link at its upstream node;
    //      for UNDIRECTED list count link at both end nodes)
    for (i = 0; i < Nobjects[NODE]; i++) Node[i].degree = 0;
    for (j = 0; j < Nobjects[LINK]; j++)
    {
        Node[ Link[j].node1 ].degree++;
        if ( listType == UNDIRECTED ) Node[ Link[j].node2 ].degree++;
    }

    // --- determine start position of each node in the adjacency list
    //     (the adjacency list, AdjList, is one long vector containing
    //      the individual node lists one after the other)
    StartPos[0] = 0;
    for (i = 0; i < Nobjects[NODE]-1; i++)
    {
        StartPos[i+1] = StartPos[i] + Node[i].degree;
        Node[i].degree = 0;
    }
    Node[Nobjects[NODE]-1].degree = 0;

    // --- traverse the list of links once more,
    //     adding each link's index to the proper 
    //     position in the adjacency list
    for (j = 0; j < Nobjects[LINK]; j++)
    {
        i = Link[j].node1;
        k = StartPos[i] + Node[i].degree;
        AdjList[k] = j;
        Node[i].degree++;
        if ( listType == UNDIRECTED )
        {
            i = Link[j].node2;
            k = StartPos[i] + Node[i].degree;
            AdjList[k] = j;
            Node[i].degree++;
        }
    }
}

//=============================================================================

adjustAdjList()
//
//  Input:   none
//  Output:  none
//  Purpose: adjusts adjacency list for Divider nodes so that non-
//           diversion link appears before diversion link.
//
{
    let i, j, k, m;

    // --- check each node
    for (i=0; i<Nobjects[NODE]; i++)
    {
        // --- skip nodes that are not Dividers
        if ( Node[i].type != DIVIDER ) continue;
        if ( Node[i].degree != 2 ) continue;

        // --- switch position of outgoing links at the node if the
        //     diversion link appears first in the adjacency list
        k = Node[i].subIndex;
        m = StartPos[i];
        j = AdjList[m];
        if ( j == Divider[k].link )
        {
            AdjList[m] = AdjList[m+1];
            AdjList[m+1] = j;
        }
    }
}

//=============================================================================
// int sortedLinks[]
topoSort(sortedLinks)
//
//  Input:   none
//  Output:  sortedLinks = array of sorted link indexes,
//           returns number of links successfully sorted
//  Purpose: performs a stack-based topo sort of the drainage network's links.
//
{
    let i, j, k, n;
    let i1, i2, k1, k2;

    // --- initialize a stack which contains nodes with zero in-degree
    First = 0;
    Last = -1;
    for (i = 0; i < Nobjects[NODE]; i++)
    {
        if ( InDegree[i] == 0 )
        {
            Last++;
            Stack[Last] = i;
        }
    }

    // --- traverse the stack, adding each node's outgoing link indexes
    //     to the SortedLinks array in the order processed
    n = 0;
    while ( First <= Last )
    {
        // --- determine range of adjacency list indexes belonging to 
        //     first node remaining on the stack
        i1 = Stack[First];
        k1 = StartPos[i1];
        k2 = k1 + Node[i1].degree;

        // --- for each outgoing link from first node on stack
        for (k = k1; k < k2; k++)
        {
            // --- add link index to current position in SortedLinks
            j = AdjList[k];
            sortedLinks[n] = j;
            n++;

            // --- reduce in-degree of link's downstream node
            i2 = Link[j].node2;
            InDegree[i2]--;

            // --- add downstream node to stack if its in-degree is zero
            if ( InDegree[i2] == 0 )
            {
                Last++;
                Stack[Last] = i2;
            }  
        }
        First++;
    }
    return n;
}

//=============================================================================

 findCycles()
//
//  Input:   none
//  Output:  none
//  Purpose: finds all cycles in the drainage network (i.e., closed loops that
//           start and end at the same node).
//
{
    let i;

    // --- allocate arrays
    //AdjList  = (int *) calloc(2*Nobjects[LINK], sizeof(int));
    //StartPos = (int *) calloc(Nobjects[NODE], sizeof(int));
    //Stack    = (int *) calloc(Nobjects[NODE], sizeof(int));
    //Examined = (char *) calloc(Nobjects[NODE], sizeof(char));
    //InTree   = (char *) calloc(Nobjects[LINK], sizeof(char));
    //LoopLinks = (int *) calloc(Nobjects[LINK], sizeof(int));
    AdjList = new Array(2*Nobjects[LINK])
    StartPos = new Array(Nobjects[NODE])
    Stack = new Array(Nobjects[NODE])
    Examined = new Array(Nobjects[NODE])
    InTree = new Array(Nobjects[LINK])
    LoopLinks = new Array(Nobjects[LINK])
    if ( StartPos && AdjList && Stack && Examined && InTree && LoopLinks )
    {
        // --- create an undirected adjacency list for the nodes
        createAdjList(UNDIRECTED);

        // --- set to empty the list of nodes examined and the list
        //     of links in the spanning tree
        for ( i=0; i<Nobjects[NODE]; i++) Examined[i] = 0;
        for ( i=0; i<Nobjects[LINK]; i++) InTree[i] = 0;

        // --- find a spanning tree for each unexamined node
        //     (cycles are identified as tree is constructed)
        for ( i=0; i<Nobjects[NODE]; i++)
        {
            if ( Examined[i] ) continue;
            Last = -1;
            findSpanningTree(i);
        }
    }
    FREE(StartPos);
    FREE(AdjList);
    FREE(Stack);
    FREE(Examined);
    FREE(InTree);
    FREE(LoopLinks);
}

//=============================================================================
// int startNode
 findSpanningTree(startNode)
//
//  Input:   i = index of starting node of tree
//  Output:  none
//  Purpose: finds continuation of network's spanning tree of links.
//
{
    let nextNode, j, k, m;

    // --- examine each link connected to node i
    for ( m = StartPos[startNode];
          m < StartPos[startNode]+Node[startNode].degree; m++ )
    {
        // --- find which node (j) connects link k from start node
        k = AdjList[m];
        if ( Link[k].node1 == startNode ) j = Link[k].node2;
        else j = Link[k].node1;

        // --- if link k is not in the tree
        if ( InTree[k] == 0 )
        {
            // --- if connecting node already examined,
            //     then link k forms a loop; mark it as a chord
            //     and check if loop forms a cycle
            if ( Examined[j] )
            {
                InTree[k] = 2;
                evalLoop(k);
            }

            // --- otherwise mark connected node as being examined,
            //     add it to the node stack, and mark the connecting
            //     link as being in the spanning tree
            else
            {
                Examined[j] = 1;
                Last++;
                Stack[Last] = j;
                InTree[k] = 1;
            }
        }
    }

    // --- continue to grow the spanning tree from
    //     the last node added to the stack
    if ( Last >= 0 )
    {
        nextNode = Stack[Last];
        Last--;
        findSpanningTree(nextNode);
    }
}

//=============================================================================
// int startLink
evalLoop(startLink)
//
//  Input:   startLink = index of starting link of a loop
//  Output:  none
//  Purpose: checks if loop starting with a given link forms a closed cycle.
//
{
    let i;                             // loop list index
    let i1, i2;                        // start & end node indexes
    let j;                             // index of link in loop
    let kount;                         // items per line counter
    let isCycle;                       // true if loop forms a cycle

    // --- make startLink the first link in the loop
    LoopLinksLast = 0;
    LoopLinks[0] = startLink;

    // --- trace a path on the spanning tree that starts at the
    //     tail node of startLink and ends at its head node
    i1 = Link[startLink].node1;
    i2 = Link[startLink].node2;
    if ( !traceLoop(i1, i2, startLink) ) return;

    // --- check if all links on the path are oriented head-to-tail
    isCycle = true;
    j = LoopLinks[0];
    i2 = Link[j].node2;
    for (i=1; i<=LoopLinksLast; i++)
    {
        j = LoopLinks[i];
        i1 = Link[j].node1;
        if ( i1 == i2 ) i2 = Link[j].node2;
        else
        {
            isCycle = false;
            break;
        }
    }

    // --- print cycle to report file
    if ( isCycle )
    {
        kount = 0;
        for (i = 0; i <= LoopLinksLast; i++)
        {
            if ( kount % 5 == 0 ) fprintf(Frpt.file, "\n");
            kount++;
            fprintf(Frpt.file, "  %s", Link[LoopLinks[i]].ID);
            if ( i < LoopLinksLast ) fprintf(Frpt.file, "  -->");
        }
    }
}

//=============================================================================
// int i1, int i2, int k1
traceLoop(i1, i2, k1)
//
//  Input:   i1 = index of current node reached while tracing a loop
//           i2 = index of final node on the loop
//           k1 = index of link which extends loop to node i1
//  Output:  returns true if loop can be extended through node i1
//  Purpose: tries to extend closed loop through current node.
//
{
    let j, k, m;

    // --- if current node equals final node then return with loop found
    if ( i1 == i2 ) return true;

    // --- examine each link connected to current node
    for (m = StartPos[i1]; m < StartPos[i1] + Node[i1].degree; m++)
    {
        // --- ignore link if it comes from predecessor node or if
        //     it is not on the spanning tree
        k = AdjList[m];
        if ( k == k1 || InTree[k] != 1 ) continue;

        // --- identify other node that link is connected to
        if ( Link[k].node1 == i1 ) j = Link[k].node2;
        else                       j = Link[k].node1;

        // --- try to continue tracing the loop from this node;
        //     if successful, then add link to loop and return
        if ( traceLoop(j, i2, k) )
        {
            LoopLinksLast++;
            LoopLinks[LoopLinksLast] = k;
            return true;
        }
    }

    // --- return false if loop cannot be continued from current node
    return false;
}

//=============================================================================

checkDummyLinks()
//
//  Input:   none
//  Output:  none
//  Purpose: checks for nodes that have both incoming and outgoing dummy links.
//
{
    let   i, j;
    let marked = [];

    // --- create an array that marks nodes
    //     (calloc initializes the array to 0)
    //marked = (int *) calloc(Nobjects[NODE], sizeof(int));
    marked = new Array(Nobjects[NODE])
    if ( marked == null )
    {
        report_writeErrorMsg(ERR_MEMORY, "");
        return;
    }

    // --- mark nodes that whose incoming links are all
    //     either dummy links or ideal pumps
    for ( i = 0; i < Nobjects[LINK]; i++ )
    {
        j = Link[i].node2;
        if ( Link[i].direction < 0 ) j = Link[i].node1;
        if ( (Link[i].type == CONDUIT && Link[i].xsect.type == DUMMY) ||
             (Link[i].type == PUMP &&
              Pump[Link[i].subIndex].type == IDEAL_PUMP) )
        {
            if ( marked[j] == 0 ) marked[j] = 1;
        }
        else marked[j] = -1;
    }

    // --- find marked nodes with outgoing dummy links or ideal pumps
    for ( i = 0; i < Nobjects[LINK]; i++ )
    {
        if ( (Link[i].type == CONDUIT && Link[i].xsect.type == DUMMY) ||
             (Link[i].type == PUMP && 
              Pump[Link[i].subIndex].type == IDEAL_PUMP) )
        {
            j = Link[i].node1;
            if ( marked[j] > 0 )
            {
                report_writeErrorMsg(ERR_DUMMY_LINK, Node[j].ID);
            }
        }
    }
    FREE(marked);
}

//=============================================================================

//-----------------------------------------------------------------------------
//  mempool.h
//
//  Header for mempool.c
//
//  The type alloc_handle_t provides an opaque reference to the
//  alloc pool - only the alloc routines know its structure.
//-----------------------------------------------------------------------------

//typedef struct
//{
//   long  dummy;
//}  alloc_handle_t;



//-----------------------------------------------------------------------------
//  mempool.c
//
//  A simple fast memory allocation package.
//
//  By Steve Hill in Graphics Gems III, David Kirk (ed.),
//    Academic Press, Boston, MA, 1992
//
//  Modified by L. Rossman, 8/13/94.
//
//  AllocInit()     - create an alloc pool, returns the old pool handle
//  Alloc()         - allocate memory
//  AllocReset()    - reset the current pool
//  AllocSetPool()  - set the current pool
//  AllocFree()     - free the memory used by the current pool.
//-----------------------------------------------------------------------------


/*
**  ALLOC_BLOCK_SIZE - adjust this size to suit your installation - it
**  should be reasonably large otherwise you will be mallocing a lot.
*/

ALLOC_BLOCK_SIZE  = 64000       /*(62*1024)*/

/*
**  alloc_hdr_t - Header for each block of memory.
*/

//typedef struct alloc_hdr_s
//{
//    struct alloc_hdr_s *next;   /* Next Block          */
//    char               *block,  /* Start of block      */
//                       *free,   /* Next free in block  */
//                       *end;    /* block + block size  */
//}  alloc_hdr_t;
class alloc_hd_s {
    constructor(){
        this.next;                /* Next Block          */
        this.block,  /* Start of block      */
        this.free,   /* Next free in block  */
        this.end;    /* block + block size  */
    }
}

class alloc_hdr_t {
    constructor(){
        this.next;                /* Next Block          */
        this.block,  /* Start of block      */
        this.free,   /* Next free in block  */
        this.end;    /* block + block size  */
    }
}


/*
**  alloc_root_t - Header for the whole pool.
*/

//typedef struct alloc_root_s
//{
//    alloc_hdr_t *first,    /* First header in pool */
//                *current;  /* Current header       */
//}  alloc_root_t;

class alloc_root_s
{
    constructor(){
        this.first,    // First header in pool 
        this.current;  // Current header       
    }
}  

class alloc_root_t
{
    constructor(){
        this.first = null,    // First header in pool 
        this.current = null;  // Current header       
    }
}

/*
**  root - Pointer to the current pool.
*/

//static alloc_root_t *root;
root;


/*
**  AllocHdr()
**
**  Private routine to allocate a header and memory block.
*/
                
AllocHdr()
{
    //alloc_hdr_t     *hdr;
    let hdr;
    let block = '';

    hdr   = new alloc_hdr_t();

    if (hdr == null || block == null) return(null);
    hdr.block = block;
    hdr.free  = block;
    hdr.next  = null;
    hdr.end   = block + ALLOC_BLOCK_SIZE;

    return hdr;
}


/*
**  AllocInit()
**
**  Create a new memory pool with one block.
**  Returns pointer to the new pool.
*/

AllocInit()
{
    //alloc_handle_t *newpool;
    let newpool;

    //root = (alloc_root_t *) malloc(sizeof(alloc_root_t));
    root = new alloc_root_t();
    if (root == null) return(null);
    if ( (root.first = AllocHdr()) == null) return(null);
    root.current = root.first;
    newpool = root;
    return(newpool);
}


/*
**  Alloc()
**
**  Use as a direct replacement for malloc().  Allocates
**  memory from the current pool.
*/
// long size
Alloc(size)
{
    //alloc_hdr_t  *hdr = root.current;
    let hdr = root.current;
    let ptr = '';

    /*
    **  Align to 4 byte boundary - should be ok for most machines.
    **  Change this if your machine has weird alignment requirements.
    */
    size = (size + 3) & 0xfffffffc;

    ptr = hdr.free;
    hdr.free += size;

    /* Check if the current block is exhausted. */

    if (hdr.free >= hdr.end)
    {
        /* Is the next block already allocated? */

        if (hdr.next != null)
        {
            /* re-use block */
            hdr.next.free = hdr.next.block;
            root.current = hdr.next;
        }
        else
        {
            /* extend the pool with a new block */
            if ( (hdr.next = AllocHdr()) == null) return(null);
            root.current = hdr.next;
        }

        /* set ptr to the first location in the next block */
        ptr = root.current.free;
        root.current.free += size;
    }

    /* Return pointer to allocated memory. */

    return(ptr);
}


/*
**  AllocSetPool()
**
**  Change the current pool.  Return the old pool.
*/
// alloc_handle_t *newpool
AllocSetPool(newpool)
{
    //alloc_handle_t *old = (alloc_handle_t *) root;
    let old = root;
    root = newpool;
    return(old);
}


/*
**  AllocReset()
**
**  Reset the current pool for re-use.  No memory is freed,
**  so this is very fast.
*/

 AllocReset()
{
    root.current = root.first;
    root.current.free = root.current.block;
}


/*
**  AllocFreePool()
**
**  Free the memory used by the current pool.
**  Don't use where AllocReset() could be used.
*/

 AllocFreePool()
{
    //alloc_hdr_t  *tmp,
    //             *hdr = root.first;
    let tmp;
    let hdr = root.first

    while (hdr != null)
    {
        tmp = hdr.next;
        //free((char *) hdr.block);
        //free((char *) hdr);
        hdr.block = null;
        hdr = tmp;
    }
    //free((char *) root);
    root = null;
}

//-----------------------------------------------------------------------------
//   output.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14  (Build 5.1.001)
//             03/19/15  (Build 5.1.008)
//             08/05/15  (Build 5.1.010)
//             05/10/18  (Build 5.1.013)
//             03/01/20  (Build 5.1.014)
//   Author:   L. Rossman (EPA)
//
//   Binary output file access functions.
//
//   Build 5.1.008:
//   - Possible divide by zero for reported system wide variables avoided.
//   - Updating of maximum node depth at reporting times added.
//
//   Build 5.1.010:
//   - Potentional ET added to list of system-wide variables saved to file.
//
//   Build 5.1.013:
//   - Names NsubcatchVars, NnodeVars & NlinkVars replaced with
//     NumSubcatchVars, NumNodeVars & NumLinkVars 
//   - Support added for saving average node & link routing results to
//     binary file in each reporting period.
//
//   Build 5.1.014:
//   - Incorrect loop limit fixed in output_saveAvgResults.
//
//-----------------------------------------------------------------------------

//enum InputDataType {
    INPUT_TYPE_CODE = 0 
    INPUT_AREA = 1 
    INPUT_INVERT = 2
    INPUT_MAX_DEPTH = 3
    INPUT_OFFSET = 4 
    INPUT_LENGTH = 5
    
    /*typedef struct                                                                 //(5.1.013)
    {                                                                              //
        REAL4* xAvg;                                                               //
    }   TAvgResults; */                                                              //
    TAvgResults = [];
    
    //-----------------------------------------------------------------------------
    //  Shared variables    
    //-----------------------------------------------------------------------------
    IDStartPos;           // starting file position of ID names
    InputStartPos;        // starting file position of input data
    OutputStartPos;       // starting file position of output data
    BytesPerPeriod;       // bytes saved per simulation time period
    NumSubcatchVars;      // number of subcatchment output variables
    NumNodeVars;          // number of node output variables
    NumLinkVars;          // number of link output variables
    NumSubcatch;          // number of subcatchments reported on
    NumNodes;             // number of nodes reported on
    NumLinks;             // number of links reported on
    NumPolluts;           // number of pollutants reported on
    SysResults = new Array(MAX_SYS_RESULTS);    // values of system output vars.
    
    //static TAvgResults* AvgLinkResults;                                            //(5.1.013)
    //static TAvgResults* AvgNodeResults;                                            //
    //static int          Nsteps;                                                    //
    AvgLinkResults = [];                                            //(5.1.013)
    AvgNodeResults = [];                                            //
    Nsteps;   
    
    //-----------------------------------------------------------------------------
    //  Exportable variables (shared with report.c)
    //-----------------------------------------------------------------------------
    SubcatchResults;
    NodeResults;
    LinkResults;
    
    //-----------------------------------------------------------------------------
    //  External functions (declared in funcs.h)
    //-----------------------------------------------------------------------------
    //  output_open                   (called by swmm_start in swmm5.c)
    //  output_end                    (called by swmm_end in swmm5.c)
    //  output_close                  (called by swmm_close in swmm5.c)
    //  output_updateAvgResults       (called by swmm_step in swmm5.c)             //(5.1.013)
    //  output_saveResults            (called by swmm_step in swmm5.c)
    //  output_checkFileSize          (called by swmm_report)
    //  output_readDateTime           (called by routines in report.c)
    //  output_readSubcatchResults    (called by report_Subcatchments)
    //  output_readNodeResults        (called by report_Nodes)
    //  output_readLinkResults        (called by report_Links)
    
    
    //=============================================================================
    
    output_open()
    //
    //  Input:   none
    //  Output:  returns an error code
    //  Purpose: writes basic project data to binary output file.
    //
    {
        let   j;
        let   m;
        let  k;
        let x;
        let z;
        let hexdata = ''; // Hexadecimal string that is translated to binary.
    
        // --- open binary output file
        output_openOutFile();
        if ( ErrorCode ) return ErrorCode;
    
        // --- ignore pollutants if no water quality analsis performed
        if ( IgnoreQuality ) NumPolluts = 0;
        else NumPolluts = Nobjects[POLLUT];
    
        // --- subcatchment results consist of Rainfall, Snowdepth, Evap, 
        //     Infil, Runoff, GW Flow, GW Elev, GW Sat, and Washoff
        NumSubcatchVars = MAX_SUBCATCH_RESULTS - 1 + NumPolluts;
    
        // --- node results consist of Depth, Head, Volume, Lateral Inflow,
        //     Total Inflow, Overflow and Quality
        NumNodeVars = MAX_NODE_RESULTS - 1 + NumPolluts;
    
        // --- link results consist of Depth, Flow, Velocity, Volume,              //(5.1.013)
        //     Capacity and Quality
        NumLinkVars = MAX_LINK_RESULTS - 1 + NumPolluts;
    
        // --- get number of objects reported on
        NumSubcatch = 0;
        NumNodes = 0;
        NumLinks = 0;
        for (j=0; j<Nobjects[SUBCATCH]; j++) if (Subcatch[j].rptFlag) NumSubcatch++;
        for (j=0; j<Nobjects[NODE]; j++) if (Node[j].rptFlag) NumNodes++;
        for (j=0; j<Nobjects[LINK]; j++) if (Link[j].rptFlag) NumLinks++;
    
        /*BytesPerPeriod = sizeof(REAL8)
            + NumSubcatch * NumSubcatchVars * sizeof(REAL4)
            + NumNodes * NumNodeVars * sizeof(REAL4)
            + NumLinks * NumLinkVars * sizeof(REAL4)
            + MAX_SYS_RESULTS * sizeof(REAL4);*/
        BytesPerPeriod = 8
            + NumSubcatch * NumSubcatchVars * 4
            + NumNodes * NumNodeVars * 4
            + NumLinks * NumLinkVars * 4
            + MAX_SYS_RESULTS * 4;
        Nperiods = 0;
    
        SubcatchResults = null;
        NodeResults = null;
        LinkResults = null;
        //SubcatchResults = (REAL4 *) calloc(NumSubcatchVars, sizeof(REAL4));
        //NodeResults = (REAL4 *) calloc(NumNodeVars, sizeof(REAL4));
        //LinkResults = (REAL4 *) calloc(NumLinkVars, sizeof(REAL4));
        SubcatchResults = new Array(NumSubcatchVars);
        NodeResults = new Array(NumNodeVars);
        LinkResults = new Array(NumLinkVars);
        if ( !SubcatchResults || !NodeResults || !LinkResults )
        {
            report_writeErrorMsg(ERR_MEMORY, "");
            return ErrorCode;
        }
    
        // --- allocate memory to store average node & link results per period     //(5.1.013)
        AvgNodeResults = null;                                                     //
        AvgLinkResults = null;                                                     //
        if ( RptFlags.averages && !output_openAvgResults() )                       //
        {                                                                          //
            report_writeErrorMsg(ERR_MEMORY, "");                                  //
            return ErrorCode;                                                      //
        }                                                                          //
    
        /*fseek(Fout.file, 0, SEEK_SET);
        k = MAGICNUMBER;
        fwrite(k, sizeof(INT4), 1, Fout.file);   // Magic number
        k = VERSION;
        fwrite(k, sizeof(INT4), 1, Fout.file);   // Version number
        k = FlowUnits;
        fwrite(k, sizeof(INT4), 1, Fout.file);   // Flow units
        k = NumSubcatch;
        fwrite(k, sizeof(INT4), 1, Fout.file);   // # subcatchments
        k = NumNodes;
        fwrite(k, sizeof(INT4), 1, Fout.file);   // # nodes
        k = NumLinks;
        fwrite(k, sizeof(INT4), 1, Fout.file);   // # links
        k = NumPolluts;
        fwrite(k, sizeof(INT4), 1, Fout.file);   // # pollutants*/
        // 
        
        // Write the data to a hexadecimal string
        k = MAGICNUMBER;
        hexdata = hexdata +  toBytes32(k);   // Magic number
        k = VERSION;
        hexdata = hexdata +  toBytes32(k);   // Version number
        k = FlowUnits;
        hexdata = hexdata +  toBytes32(k);   // Flow units
        k = NumSubcatch;
        hexdata = hexdata +  toBytes32(k);   // # subcatchments
        k = NumNodes;
        hexdata = hexdata +  toBytes32(k);   // # nodes
        k = NumLinks;
        hexdata = hexdata +  toBytes32(k);   // # links
        k = NumPolluts;
        hexdata = hexdata +  toBytes32(k);   // # pollutants
    
        /////////
        // This may need a little explanation:
        // Prior to this: create a hexadecimal text string var.
        //   name the hexadecimal string ""hexdata"" 
        // Use the following to translate the hexadecimal file into a binary file.
        byteArray = new Uint8Array(hexdata.match(/.{2}/g).map(e => parseInt(e, 16)));
    
    
        // --- save ID names of subcatchments, nodes, links, & pollutants 
        //IDStartPos = ftell(Fout.file);
        // This may go better if I keep on appending hex strings and then only 
        // translate to blob when it is imperative.
        IDStartPos = byteArray.length;
        for (j=0; j<Nobjects[SUBCATCH]; j++)
        {
            if ( Subcatch[j].rptFlag ) output_saveID(Subcatch[j].ID, Fout.file);
        }
        for (j=0; j<Nobjects[NODE];     j++)
        {
            if ( Node[j].rptFlag ) output_saveID(Node[j].ID, Fout.file);
        }
        for (j=0; j<Nobjects[LINK];     j++)
        {
            if ( Link[j].rptFlag ) output_saveID(Link[j].ID, Fout.file);
        }
        for (j=0; j<NumPolluts; j++) output_saveID(Pollut[j].ID, Fout.file);
    
        // --- save codes of pollutant concentration units
        for (j=0; j<NumPolluts; j++)
        {
            k = Pollut[j].units;
            //fwrite(k, sizeof(INT4), 1, Fout.file);
            hexdata = hexdata +  toBytes32(k);  
        }
    
        //InputStartPos = ftell(Fout.file);
        InputStartPos = hexdata.length;
    
        // --- save subcatchment area
        k = 1;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k);  
        k = INPUT_AREA;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k);  
        for (j=0; j<Nobjects[SUBCATCH]; j++)
        {
             if ( !Subcatch[j].rptFlag ) continue;
             SubcatchResults[0] = (Subcatch[j].area * UCF(LANDAREA));
             //fwrite(SubcatchResults[0], sizeof(REAL4), 1, Fout.file);
             hexdata = hexdata +  toBytes32f(SubcatchResults[0]);  
        }
    
        // --- save node type, invert, & max. depth
        k = 3;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        k = INPUT_TYPE_CODE;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k);  
        k = INPUT_INVERT;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k);  
        k = INPUT_MAX_DEPTH;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k);  
        for (j=0; j<Nobjects[NODE]; j++)
        {
            if ( !Node[j].rptFlag ) continue;
            k = Node[j].type;
            NodeResults[0] = (REAL4)(Node[j].invertElev * UCF(LENGTH));
            NodeResults[1] = (REAL4)(Node[j].fullDepth * UCF(LENGTH));
            //fwrite(k, sizeof(INT4), 1, Fout.file);
            hexdata = hexdata +  toBytes32(k);  
            //fwrite(NodeResults, sizeof(REAL4), 2, Fout.file);
            hexdata = hexdata +  toBytes32f(NodeResults[0]);  
            hexdata = hexdata +  toBytes32f(NodeResults[1]);  
        }
    
        // --- save link type, offsets, max. depth, & length
        k = 5;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = INPUT_TYPE_CODE;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = INPUT_OFFSET;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = INPUT_OFFSET;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = INPUT_MAX_DEPTH;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = INPUT_LENGTH;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
    
        for (j=0; j<Nobjects[LINK]; j++)
        {
            if ( !Link[j].rptFlag ) continue;
            k = Link[j].type;
            if ( k == PUMP )
            {
                for (m=0; m<4; m++) LinkResults[m] = 0.0;
            }
            else
            {
                LinkResults[0] = (Link[j].offset1 * UCF(LENGTH));
                LinkResults[1] = (Link[j].offset2 * UCF(LENGTH));
                if ( Link[j].direction < 0 )
                {
                    x = LinkResults[0];
                    LinkResults[0] = LinkResults[1];
                    LinkResults[1] = x;
                }
                if ( k == OUTLET ) LinkResults[2] = 0.0;
                else LinkResults[2] = (Link[j].xsect.yFull * UCF(LENGTH));
                if ( k == CONDUIT )
                {
                    m = Link[j].subIndex;
                    LinkResults[3] = (Conduit[m].length * UCF(LENGTH));
                }
                else LinkResults[3] = 0.0;
            }
            //fwrite(k, sizeof(INT4), 1, Fout.file);
            hexdata = hexdata +  toBytes32(k); 
            //fwrite(LinkResults, sizeof(REAL4), 4, Fout.file);
            for (let u=0; u<4; u++) hexdata = hexdata +  toBytes32f(LinkResults[u]);
             
        }
    
        // --- save number & codes of subcatchment result variables
        k = NumSubcatchVars;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = SUBCATCH_RAINFALL;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = SUBCATCH_SNOWDEPTH;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = SUBCATCH_EVAP;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = SUBCATCH_INFIL;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = SUBCATCH_RUNOFF;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = SUBCATCH_GW_FLOW;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = SUBCATCH_GW_ELEV;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = SUBCATCH_SOIL_MOIST;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
    
        for (j=0; j<NumPolluts; j++) 
        {
            k = SUBCATCH_WASHOFF + j;
            //fwrite(k, sizeof(INT4), 1, Fout.file);
            hexdata = hexdata +  toBytes32(k); 
        }
    
        // --- save number & codes of node result variables
        k = NumNodeVars;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = NODE_DEPTH;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = NODE_HEAD;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = NODE_VOLUME;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = NODE_LATFLOW;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = NODE_INFLOW;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = NODE_OVERFLOW;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        for (j=0; j<NumPolluts; j++)
        {
            k = NODE_QUAL + j;
            //fwrite(k, sizeof(INT4), 1, Fout.file);
            hexdata = hexdata +  toBytes32(k); 
        }
    
        // --- save number & codes of link result variables
        k = NumLinkVars;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = LINK_FLOW;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = LINK_DEPTH;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = LINK_VELOCITY;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = LINK_VOLUME;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        k = LINK_CAPACITY;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        for (j=0; j<NumPolluts; j++)
        {
            k = LINK_QUAL + j;
            //fwrite(k, sizeof(INT4), 1, Fout.file);
            hexdata = hexdata +  toBytes32(k); 
        }
    
        // --- save number & codes of system result variables
        k = MAX_SYS_RESULTS;
        //fwrite(k, sizeof(INT4), 1, Fout.file);
        hexdata = hexdata +  toBytes32(k); 
        for (k=0; k<MAX_SYS_RESULTS; k++) {
            //fwrite(k, sizeof(INT4), 1, Fout.file);
            hexdata = hexdata +  toBytes32(k); 
        }
    
        // --- save starting report date & report step
        //     (if reporting start date > simulation start date then
        //      make saved starting report date one reporting period
        //      prior to the date of the first reported result)
        z = ReportStep/86400.0;
        if ( StartDateTime + z > ReportStart ) z = StartDateTime;
        else
        {
            z = Math.floor((ReportStart - StartDateTime)/z) - 1.0;
            z = StartDateTime + z*ReportStep/86400.0;
        }
        //fwrite(z, sizeof(REAL8), 1, Fout.file);
        hexdata = hexdata +  z.toString(16); 
        k = ReportStep;
    
        /*if ( fwrite(k, sizeof(INT4), 1, Fout.file) < 1)
        {
            report_writeErrorMsg(ERR_OUT_WRITE, "");
            return ErrorCode;
        }*/
        hexdata = hexdata +  toBytes32(k); 
    
        //byteArray = new Uint8Array(hexdata.match(/.{2}/g).map(e => parseInt(e, 16)));
        //blob = new Blob([byteArray], {type: 'application/octet-stream'})
        //fout.contents = blob;
    
        Fout.contents = hexdata;
    
        OutputStartPos = hexdata.length;
        if ( Fout.mode == SCRATCH_FILE ) output_checkFileSize();
        return ErrorCode;
    }
    
    //=============================================================================
    
     output_checkFileSize()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: checks if the size of the binary output file will be too big
    //           to access using an integer file pointer variable.
    //
    {
        if ( RptFlags.subcatchments != NONE ||
             RptFlags.nodes != NONE ||
             RptFlags.links != NONE )
        {
            if ( OutputStartPos + BytesPerPeriod * TotalDuration
                 / 1000.0 / ReportStep >= MAXFILESIZE )
            {
                report_writeErrorMsg(ERR_FILE_SIZE, "");
            }
        }
    }
    
    
    //=============================================================================
    
    output_openOutFile()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: opens a project's binary output file.
    //
    {
        // --- close output file if already opened
        if (Fout.file != null) fclose(Fout.file); 
    
        // --- else if file name supplied then set file mode to SAVE
        else if (Fout.name.length != 0) Fout.mode = SAVE_FILE;
    
        // --- otherwise set file mode to SCRATCH & generate a name
        else
        {
            Fout.mode = SCRATCH_FILE;
            getTempFileName(Fout.name);
        }
    
        // --- try to open the file
        if ( (Fout.file = fopen(Fout.name, "w+b")) == null)
        {
            writecon(FMT14);
            ErrorCode = ERR_OUT_FILE;
        }
    }
    
    //=============================================================================
    // double reportTime
    output_saveResults(reportTime)
    //
    //  Input:   reportTime = elapsed simulation time (millisec)
    //  Output:  none
    //  Purpose: writes computed results for current report time to binary file.
    //
    {
        let i;
        //extern TRoutingTotals StepFlowTotals;  // defined in massbal.c             //(5.1.013)
        let reportDate = getDateTime(reportTime);
        let date;
    
        // --- initialize system-wide results
        if ( reportDate < ReportStart ) return;
        for (i=0; i<MAX_SYS_RESULTS; i++) SysResults[i] = 0.0;
    
        // --- save date corresponding to this elapsed reporting time
        date = reportDate;
        fwrite(date, sizeof(REAL8), 1, Fout.file);
    
        // --- save subcatchment results
        if (Nobjects[SUBCATCH] > 0)
            output_saveSubcatchResults(reportTime, Fout.file);
    
        // --- save average routing results over reporting period if called for    //(5.1.013)
        if ( RptFlags.averages ) output_saveAvgResults(Fout.file);                 //
    
        // --- otherwise save interpolated point routing results                   //(5.1.013)
        else                                                                       //
        {
            if (Nobjects[NODE] > 0)
                output_saveNodeResults(reportTime, Fout.file);
            if (Nobjects[LINK] > 0)
                output_saveLinkResults(reportTime, Fout.file);
        }
    
        // --- update & save system-wide flows 
        SysResults[SYS_FLOODING] = (REAL4)(StepFlowTotals.flooding * UCF(FLOW));
        SysResults[SYS_OUTFLOW] = (REAL4)(StepFlowTotals.outflow * UCF(FLOW));
        SysResults[SYS_DWFLOW] = (REAL4)(StepFlowTotals.dwInflow * UCF(FLOW));
        SysResults[SYS_GWFLOW] = (REAL4)(StepFlowTotals.gwInflow * UCF(FLOW));
        SysResults[SYS_IIFLOW] = (REAL4)(StepFlowTotals.iiInflow * UCF(FLOW));
        SysResults[SYS_EXFLOW] = (REAL4)(StepFlowTotals.exInflow * UCF(FLOW));
        SysResults[SYS_INFLOW] = SysResults[SYS_RUNOFF] +
                                 SysResults[SYS_DWFLOW] +
                                 SysResults[SYS_GWFLOW] +
                                 SysResults[SYS_IIFLOW] +
                                 SysResults[SYS_EXFLOW];
        fwrite(SysResults, sizeof(REAL4), MAX_SYS_RESULTS, Fout.file);
    
        // --- save outfall flows to interface file if called for
        if ( Foutflows.mode == SAVE_FILE && !IgnoreRouting ) 
            iface_saveOutletResults(reportDate, Foutflows.file);
        Nperiods++;
    }
    
    //=============================================================================
    
    output_end()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: writes closing records to binary file.
    //
    {
        let k;
        fwrite(IDStartPos, sizeof(INT4), 1, Fout.file);
        fwrite(InputStartPos, sizeof(INT4), 1, Fout.file);
        fwrite(OutputStartPos, sizeof(INT4), 1, Fout.file);
        k = Nperiods;
        fwrite(k, sizeof(INT4), 1, Fout.file);
        k = error_getCode(ErrorCode);
        fwrite(k, sizeof(INT4), 1, Fout.file);
        k = MAGICNUMBER;
        if (fwrite(k, sizeof(INT4), 1, Fout.file) < 1)
        {
            report_writeErrorMsg(ERR_OUT_WRITE, "");
        }
    }
    
    //=============================================================================
    
    output_close()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: frees memory used for accessing the binary file.
    //
    {
        FREE(SubcatchResults);
        FREE(NodeResults);
        FREE(LinkResults);
        output_closeAvgResults();                                                  //(5.1.013)
    }
    
    //=============================================================================
    // char* id, FILE* file
    // Changed FILE* file to an object that 
    // has the .contents attribute: hasContents
    output_saveID(id, hasContents)
    //
    //  Input:   id = name of an object
    //           file = ptr. to binary output file
    //  Output:  none
    //  Purpose: writes an object's name to the binary output file.
    //
    {
        let n = id.length;
        //fwrite(n, sizeof(INT4), 1, file);
        hasContents.contents = hasContents.contents +  toBytes32(n); 
        //fwrite(id, sizeof(char), n, file);
        hasContents.contents = hasContents.contents +  toBytes32a(id); 
    }
    
    //=============================================================================
    // double reportTime, FILE* file
    output_saveSubcatchResults(reportTime, file)
    //
    //  Input:   reportTime = elapsed simulation time (millisec)
    //           file = ptr. to binary output file
    //  Output:  none
    //  Purpose: writes computed subcatchment results to binary file.
    //
    {
        let      j;
        let   f;
        let   area;
        let    totalArea = 0.0; 
        let reportDate = getDateTime(reportTime);
    
        // ret facil
        let returnObj;
        let returnVal;
    
        // --- update reported rainfall at each rain gage
        for ( j=0; j<Nobjects[GAGE]; j++ )
        {
            gage_setReportRainfall(j, reportDate);
        }
    
        // --- find where current reporting time lies between latest runoff times
        f = (reportTime - OldRunoffTime) / (NewRunoffTime - OldRunoffTime);
    
        // --- write subcatchment results to file
        for ( j=0; j<Nobjects[SUBCATCH]; j++)
        {
            // --- retrieve interpolated results for reporting time & write to file
            ////////////////////////////////////
            returnObj = {x: SubcatchResults}
            returnVal = subcatch_getResults(j, f, returnObj)
            SubcatchResults = returnObj.x;
            ////////////////////////////////////
            //subcatch_getResults(j, f, SubcatchResults);
            if ( Subcatch[j].rptFlag )
                fwrite(SubcatchResults, sizeof(REAL4), NumSubcatchVars, file);
    
            // --- update system-wide results
            area = Subcatch[j].area * UCF(LANDAREA);
            totalArea += area;
            SysResults[SYS_RAINFALL] +=
                (REAL4)(SubcatchResults[SUBCATCH_RAINFALL] * area);
            SysResults[SYS_SNOWDEPTH] +=
                (REAL4)(SubcatchResults[SUBCATCH_SNOWDEPTH] * area);
            SysResults[SYS_EVAP] +=
                (REAL4)(SubcatchResults[SUBCATCH_EVAP] * area);
            if ( Subcatch[j].groundwater ) SysResults[SYS_EVAP] += 
                (REAL4)(Subcatch[j].groundwater.evapLoss * UCF(EVAPRATE) * area);
            SysResults[SYS_INFIL] +=
                (REAL4)(SubcatchResults[SUBCATCH_INFIL] * area);
            SysResults[SYS_RUNOFF] += SubcatchResults[SUBCATCH_RUNOFF];
        }
    
        // --- normalize system-wide results to catchment area
        if ( totalArea > 0.0 )
        {
            SysResults[SYS_EVAP]      /= totalArea;
            SysResults[SYS_RAINFALL]  /= totalArea;
            SysResults[SYS_SNOWDEPTH] /= totalArea;
            SysResults[SYS_INFIL]     /= totalArea;
        }
    
        // --- update system temperature and PET
        if ( UnitSystem == SI ) f = (5./9.) * (Temp.ta - 32.0);
        else f = Temp.ta;
        SysResults[SYS_TEMPERATURE] = f;
        f = Evap.rate * UCF(EVAPRATE);
        SysResults[SYS_PET] = f;
    
    }
    
    //=============================================================================
    
    ////  This was re-written for release 5.1.013.  ////                  //(5.1.013)
    // double reportTime, FILE* file
    output_saveNodeResults(reportTime, file)
    //
    //  Input:   reportTime = elapsed simulation time (millisec)
    //           file = ptr. to binary output file
    //  Output:  none
    //  Purpose: writes computed node results to binary file.
    //
    {
        let j;
    
        // --- find where current reporting time lies between latest routing times
        let f = (reportTime - OldRoutingTime) /
                   (NewRoutingTime - OldRoutingTime);
    
        // --- write node results to file
        for (j=0; j<Nobjects[NODE]; j++)
        {
            // --- retrieve interpolated results for reporting time & write to file
            node_getResults(j, f, NodeResults);
            if ( Node[j].rptFlag )
                fwrite(NodeResults, sizeof(REAL4), NumNodeVars, file);
            stats_updateMaxNodeDepth(j, NodeResults[NODE_DEPTH]);
    
            // --- update system-wide storage volume 
            SysResults[SYS_STORAGE] += NodeResults[NODE_VOLUME];
        }
    }
    
    //=============================================================================
    // double reportTime, FILE* file
    output_saveLinkResults(reportTime, file)
    //
    //  Input:   reportTime = elapsed simulation time (millisec)
    //           file = ptr. to binary output file
    //  Output:  none
    //  Purpose: writes computed link results to binary file.
    //
    {
        let j;
        let f;
        let z;
    
        // --- find where current reporting time lies between latest routing times
        f = (reportTime - OldRoutingTime) / (NewRoutingTime - OldRoutingTime);
    
        // --- write link results to file
        for (j=0; j<Nobjects[LINK]; j++)
        {
            // --- retrieve interpolated results for reporting time & write to file
            if (Link[j].rptFlag)
            {
                link_getResults(j, f, LinkResults);
                fwrite(LinkResults, sizeof(REAL4), NumLinkVars, file);
            }
    
            // --- update system-wide results
            z = ((1.0-f)*Link[j].oldVolume + f*Link[j].newVolume) * UCF(VOLUME);
            SysResults[SYS_STORAGE] += z;
        }
    }
    
    //=============================================================================
    // int period, DateTime* days
    output_readDateTime(period, days)
    //
    //  Input:   period = index of reporting time period
    //  Output:  days = date/time value
    //  Purpose: retrieves the date/time for a specific reporting period
    //           from the binary output file.
    //
    {
        let bytePos = OutputStartPos + (period-1)*BytesPerPeriod;
        fseek(Fout.file, bytePos, SEEK_SET);
        days = NO_DATE;
        fread(days, sizeof(REAL8), 1, Fout.file);
    }
    
    //=============================================================================
    // int period, int index
    output_readSubcatchResults(period, index)
    //
    //  Input:   period = index of reporting time period
    //           index = subcatchment index
    //  Output:  none
    //  Purpose: reads computed results for a subcatchment at a specific time
    //           period.
    //
    {
        let bytePos = OutputStartPos + (period-1)*BytesPerPeriod;
        bytePos += sizeof(REAL8) + index*NumSubcatchVars*sizeof(REAL4);
        fseek(Fout.file, bytePos, SEEK_SET);
        fread(SubcatchResults, sizeof(REAL4), NumSubcatchVars, Fout.file);
    }
    
    //=============================================================================
    // int period, int index
    output_readNodeResults(period, index)
    //
    //  Input:   period = index of reporting time period
    //           index = node index
    //  Output:  none
    //  Purpose: reads computed results for a node at a specific time period.
    //
    {
        let bytePos = OutputStartPos + (period-1)*BytesPerPeriod;
        bytePos += sizeof(REAL8) + NumSubcatch*NumSubcatchVars*sizeof(REAL4);
        bytePos += index*NumNodeVars*sizeof(REAL4);
        fseek(Fout.file, bytePos, SEEK_SET);
        fread(NodeResults, sizeof(REAL4), NumNodeVars, Fout.file);
    }
    
    //=============================================================================
    // int period, int index
    output_readLinkResults(period, index)
    //
    //  Input:   period = index of reporting time period
    //           index = link index
    //  Output:  none
    //  Purpose: reads computed results for a link at a specific time period.
    //
    {
        let bytePos = OutputStartPos + (period-1)*BytesPerPeriod;
        bytePos += sizeof(REAL8) + NumSubcatch*NumSubcatchVars*sizeof(REAL4);
        bytePos += NumNodes*NumNodeVars*sizeof(REAL4);
        bytePos += index*NumLinkVars*sizeof(REAL4);
        fseek(Fout.file, bytePos, SEEK_SET);
        fread(LinkResults, sizeof(REAL4), NumLinkVars, Fout.file);
        fread(SysResults, sizeof(REAL4), MAX_SYS_RESULTS, Fout.file);
    }
    
    ////  The following functions were added for release 5.1.013.  ////            //(5.1.013)
    
    //=============================================================================
    //  Functions for saving average results within a reporting period to file.
    //=============================================================================
    
    output_openAvgResults()
    {
        let i;
        
        // --- allocate memory for averages at reportable nodes
        //AvgNodeResults = (TAvgResults *)calloc(NumNodes, sizeof(TAvgResults));
        for(let i = 0; i < NumNodes; i++){AvgNodeResults.push(new TAvgResults())}
        
        if ( AvgNodeResults == null ) return false;
        for (i = 0; i < NumNodes; i++ ) AvgNodeResults[i].xAvg = null;
    
        // --- allocate memory for averages at reportable links
        //AvgLinkResults = (TAvgResults *)calloc(NumLinks, sizeof(TAvgResults));
        for(let i = 0; i < NumLinks; i++){AvgLinkResults.push(new TAvgResults())}
    
        if (AvgLinkResults == null)
        {
            output_closeAvgResults();
            return false;
        }
        for (i = 0; i < NumLinks; i++) AvgLinkResults[i].xAvg = null;
    
        // --- allocate memory for each reportable variable for each reportable node
        for (i = 0; i < NumNodes; i++)
        {
            //AvgNodeResults[i].xAvg = (REAL4*) calloc(NumNodeVars, sizeof(REAL4));
            AvgNodeResults[i].xAvg = new Array(NumNodeVars);
            if (AvgNodeResults[i].xAvg == null)
            {
                output_closeAvgResults();
                return false;
            }
        }
    
        // --- allocate memory for each reportable variable for each reportable link
        for (i = 0; i < NumLinks; i++)
        {
            //AvgLinkResults[i].xAvg = (REAL4*)calloc(NumLinkVars, sizeof(REAL4));
            AvgLinkResults[i].xAvg = new Array(NumLinkVars);
            if (AvgLinkResults[i].xAvg == null)
            {
                output_closeAvgResults();
                return false;
            }
        }
        return true;
    }
    
    //=============================================================================
    
    output_closeAvgResults()
    {
        let i;
        if (AvgNodeResults)
        {
            for (i = 0; i < NumNodes; i++)  FREE(AvgNodeResults[i].xAvg); 
            FREE(AvgNodeResults);
        }
        if (AvgLinkResults)
        {
            for (i = 0; i < NumLinks; i++)  FREE(AvgLinkResults[i].xAvg);
            FREE(AvgLinkResults);
        }
    }
    
    //=============================================================================
    
    output_initAvgResults()
    {
        let i, j;
        Nsteps = 0;
        for (i = 0; i < NumNodes; i++)
        {
            for (j = 0; j < NumNodeVars; j++) AvgNodeResults[i].xAvg[j] = 0.0;
        }
        for (i = 0; i < NumLinks; i++)
        {
            for (j = 0; j < NumLinkVars; j++) AvgLinkResults[i].xAvg[j] = 0.0;
        }
    }
    
    //=============================================================================
    
    output_updateAvgResults()
    {
        let i, j, k, sign;
    
        // --- update average accumulations for nodes
        k = 0;
        for (i = 0; i < Nobjects[NODE]; i++)
        {
            if ( !Node[i].rptFlag ) continue;
            node_getResults(i, 1.0, NodeResults);
            for (j = 0; j < NumNodeVars; j++)
            {
                AvgNodeResults[k].xAvg[j] += NodeResults[j];
            }
            k++;
        }
    
        // --- update average accumulations for links
        k = 0;
        for (i = 0; i < Nobjects[LINK]; i++)
        {
            if ( !Link[i].rptFlag ) continue;
            link_getResults(i, 1.0, LinkResults);
    
            // --- save sign of current flow rate
            sign = SGN(LinkResults[LINK_FLOW]);
    
            // --- add current results to average accumulation
            for (j = 0; j < NumLinkVars; j++)
            {
                // --- accumulate flow so its sign (+/-) will equal that of most
                //     recent flow result
                if ( j == LINK_FLOW )
                {
                    AvgLinkResults[k].xAvg[j] =
                        sign * (ABS(AvgLinkResults[k].xAvg[j]) + ABS(LinkResults[j]));
                }
    
                // --- link capacity is another special case
                else if (j == LINK_CAPACITY)
                {
                    // --- accumulate capacity (fraction full) for conduits 
                    if ( Link[i].type == CONDUIT )
                        AvgLinkResults[k].xAvg[j] += LinkResults[j];
    
                    // --- for other links capacity is pump speed or regulator
                    //     opening fraction which shouldn't be averaged
                    //     (multiplying by Nsteps+1 will preserve last value
                    //     when average results are taken in saveAvgResults())
                    else  
                        AvgLinkResults[k].xAvg[j] = LinkResults[j] * (Nsteps+1);
                }
    
                // --- accumulation for all other reported results
                else AvgLinkResults[k].xAvg[j] += LinkResults[j];
            }
            k++;
        }
        Nsteps++;
    }
    
    //=============================================================================
    // FILE* file
    output_saveAvgResults(file)
    {
        let i, j;
    
        // --- examine each reportable node
        for (i = 0; i < NumNodes; i++)
        {
            // --- determine the node's average results
            for (j = 0; j < NumNodeVars; j++)
            {
                NodeResults[j] = AvgNodeResults[i].xAvg[j] / Nsteps;
            }
    
            // --- save average results to file
            fwrite(NodeResults, sizeof(REAL4), NumNodeVars, file);
        }
    
        // --- update each node's max depth and contribution to system storage
        for (i = 0; i < Nobjects[NODE]; i++)
        {
            stats_updateMaxNodeDepth(i, Node[i].newDepth * UCF(LENGTH));
            SysResults[SYS_STORAGE] += (REAL4)(Node[i].newVolume * UCF(VOLUME));
        }
    
        // --- examine each reportable link
        for (i = 0; i < NumLinks; i++)
        {
            // --- determine the link's average results
            for (j = 0; j < NumLinkVars; j++)
            {
                LinkResults[j] = AvgLinkResults[i].xAvg[j] / Nsteps;
            }
    
            // --- save average results to file
            fwrite(LinkResults, sizeof(REAL4), NumLinkVars, file);
        }
     
        // --- add each link's volume to total system storage
        for (i = 0; i < Nobjects[LINK]; i++)                                       //(5.1.014)
        {
            SysResults[SYS_STORAGE] += (REAL4)(Link[i].newVolume * UCF(VOLUME));
        }
    
        // --- re-initialize average results for all nodes and links
        output_initAvgResults();
    }
    


//-----------------------------------------------------------------------------
//   surfqual.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/19/15  (Build 5.1.008)
//             03/01/20  (Build 5.1.014)
//   Author:   L. Rossman
//
//   Subcatchment water quality functions.
//
//   Build 5.1.008:
//   - Pollutant surface buildup and washoff functions were moved here from
//     subcatch.c.
//   - Support for separate accounting of LID drain flows included. 
//
//   Build 5.1.014:
//   - Fixed bug in computing effective BMP removal by LIDs.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Imported variables 
//-----------------------------------------------------------------------------
// Declared in RUNOFF.C
/*extern  double*    OutflowLoad;   // exported pollutant mass load

// Volumes (ft3) for a subcatchment over a time step declared in SUBCATCH.C
extern double      Vinfil;        // non-LID infiltration
extern double      Vinflow;       // non-LID precip + snowmelt + runon + ponded water
extern double      Voutflow;      // non-LID runoff to subcatchment's outlet
extern double      VlidIn;        // inflow to LID units
extern double      VlidInfil;     // infiltration from LID units
extern double      VlidOut;       // surface outflow from LID units
extern double      VlidDrain;     // drain outflow from LID units
extern double      VlidReturn;    // LID outflow returned to pervious area*/

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)   
//-----------------------------------------------------------------------------
//  surfqual_initState         (called from subcatch_initState)
//  surfqual_getWashoff        (called from runoff_execute)
//  surfqual_getBuildup        (called from runoff_execute)
//  surfqual_sweepBuildup      (called from runoff_execute)
//  surfqual_getWtdWashoff     (called from addWetWeatherInflows in routing.c)

//=============================================================================
// int j
surfqual_initState(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: initializes pollutant buildup, ponded mass, and washoff.
//
{
    let p;

    // --- initialize washoff quality
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        Subcatch[j].oldQual[p] = 0.0;
        Subcatch[j].newQual[p] = 0.0;
        Subcatch[j].pondedQual[p] = 0.0;
    }

    // --- initialize pollutant buildup
	landuse_getInitBuildup(Subcatch[j].landFactor,  Subcatch[j].initBuildup,
		Subcatch[j].area, Subcatch[j].curbLength);
}

//=============================================================================
// int j, double tStep
surfqual_getBuildup(j, tStep)
//
//  Input:   j = subcatchment index
//           tStep = time step (sec)
//  Output:  none
//  Purpose: adds to pollutant buildup on subcatchment surface.
//
{
    let     i;                         // land use index
    let     p;                         // pollutant index
    let  f;                         // land use fraction
    let  area;                      // land use area (acres or hectares)
    let  curb;                      // land use curb length (user units)
    let  oldBuildup;                // buildup at start of time step
    let  newBuildup;                // buildup at end of time step

    // --- consider each landuse
    for (i = 0; i < Nobjects[LANDUSE]; i++)
    {
        // --- skip landuse if not in subcatch
        f = Subcatch[j].landFactor[i].fraction;
        if ( f == 0.0 ) continue;

        // --- get land area (in acres or hectares) & curb length
        area = f * Subcatch[j].area * UCF(LANDAREA);
        curb = f * Subcatch[j].curbLength;

        // --- examine each pollutant
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            // --- see if snow-only buildup is in effect
            if (Pollut[p].snowOnly 
            && Subcatch[j].newSnowDepth < 0.001/12.0) continue;

            // --- use land use's buildup to update buildup amount
            oldBuildup = Subcatch[j].landFactor[i].buildup[p];        
            newBuildup = landuse_getBuildup(i, p, area, curb, oldBuildup,
                         tStep);
            newBuildup = MAX(newBuildup, oldBuildup);
            Subcatch[j].landFactor[i].buildup[p] = newBuildup;
            massbal_updateLoadingTotals(BUILDUP_LOAD, p, 
                                       (newBuildup - oldBuildup));
       }
    }
}

//=============================================================================
// int j, DateTime aDate
surfqual_sweepBuildup(j, aDate)
//
//  Input:   j = subcatchment index
//           aDate = current date/time
//  Output:  none
//  Purpose: reduces pollutant buildup over a subcatchment if sweeping occurs.
//
{
    let     i;                         // land use index
    let     p;                         // pollutant index
    let  oldBuildup;                // buildup before sweeping (lbs or kg)
    let  newBuildup;                // buildup after sweeping (lbs or kg)

    // --- no sweeping if there is snow on plowable impervious area
    if ( Subcatch[j].snowpack != null &&
         Subcatch[j].snowpack.wsnow[IMPERV0] > MIN_TOTAL_DEPTH ) return;

    // --- consider each land use
    for (i = 0; i < Nobjects[LANDUSE]; i++)
    {
        // --- skip land use if not in subcatchment 
        if ( Subcatch[j].landFactor[i].fraction == 0.0 ) continue;

        // --- see if land use is subject to sweeping
        if ( Landuse[i].sweepInterval == 0.0 ) continue;

        // --- see if sweep interval has been reached
        if ( aDate - Subcatch[j].landFactor[i].lastSwept >=
            Landuse[i].sweepInterval )
        {
            // --- update time when last swept
            Subcatch[j].landFactor[i].lastSwept = aDate;

            // --- examine each pollutant
            for (p = 0; p < Nobjects[POLLUT]; p++)
            {
                // --- reduce buildup by the fraction available
                //     times the sweeping effic.
                oldBuildup = Subcatch[j].landFactor[i].buildup[p];
                newBuildup = oldBuildup * (1.0 - Landuse[i].sweepRemoval *
                             Landuse[i].washoffFunc[p].sweepEffic);
                newBuildup = Math.min(oldBuildup, newBuildup);
                newBuildup = Math.max(0.0, newBuildup);
                Subcatch[j].landFactor[i].buildup[p] = newBuildup;

                // --- update mass balance totals
                massbal_updateLoadingTotals(SWEEPING_LOAD, p,
                                            oldBuildup - newBuildup);
            }
        }
    }
}

//=============================================================================
// int j, double runoff, double tStep
 surfqual_getWashoff(j, runoff, tStep)
//
//  Input:   j = subcatchment index
//           runoff = total subcatchment runoff before internal re-routing or
//                    LID controls (ft/sec)
//           tStep = time step (sec)
//  Output:  none
//  Purpose: computes new runoff quality for a subcatchment.
//
//  Considers three pollutant generating streams that are combined together:
//  1. washoff of pollutant buildup as described by the project's land use
//     washoff functions,
//  2. complete mix mass balance of pollutants in surface ponding on
//     non-LID area due to runon, wet deposition, infiltration, & evaporation,
//  3. wet deposition and runon over LID areas.
//
{
    let    p;                // pollutant index
    let    hasOutflow;       // true if subcatchment has outflow
    let cOut;             // final washoff concentration (mass/ft3)
    let massLoad;         // pollut. mass load (mass)
    let vLidRain;         // rainfall volume on LID area (ft3)
    let vLidRunon;        // external runon volume to LID area (ft3)
    let vSurfOut;         // surface runoff volume leaving subcatchment (ft3)
    let vOut1;            // runoff volume prior to LID treatment (ft3)
    let vOut2;            // runoff volume after LID treatment (ft3)
    let area;             // subcatchment area (ft2)

    // --- return if there is no area or no pollutants
    area = Subcatch[j].area;
    if ( Nobjects[POLLUT] == 0 || area == 0.0 ) return;

    // --- find contributions from washoff, runon and wet precip. to OutflowLoad
    for (p = 0; p < Nobjects[POLLUT]; p++) OutflowLoad[p] = 0.0;
    findWashoffLoads(j, runoff);
    findPondedLoads(j, tStep);
    findLidLoads(j, tStep);

    // --- contribution from direct rainfall on LID areas
    vLidRain = Subcatch[j].rainfall * Subcatch[j].lidArea * tStep;

    // --- contribution from upstream runon onto LID areas
    //     (only if LIDs occupy full subcatchment)
    vLidRunon = 0.0;
    if ( area == Subcatch[j].lidArea )
    {
        vLidRunon = Subcatch[j].runon * area * tStep;
    }

    // --- runoff volume before LID treatment (ft3)
    //     (Voutflow, computed in subcatch_getRunoff, is subcatchment
    //      runoff volume before LID treatment)
    vOut1 = Voutflow + vLidRain + vLidRunon;             

    // --- surface runoff + LID drain flow volume leaving the subcatchment
    //     (Subcatch.newRunoff, computed in subcatch_getRunoff, includes
    //      any surface runoff reduction from LID treatment)
    vSurfOut = Subcatch[j].newRunoff * tStep;
    vOut2 = vSurfOut + VlidDrain;

    // --- determine if subcatchment outflow is below a small cutoff
    hasOutflow = (vOut2 > MIN_RUNOFF * area * tStep);

    // --- for each pollutant
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- convert washoff load to a concentration
        cOut = 0.0;
        if ( vOut1 > 0.0 ) cOut = OutflowLoad[p] / vOut1;

        // --- assign any difference between pre- and post-LID
        //     subcatchment outflow loads to BMP removal
        if ( Subcatch[j].lidArea > 0.0 )
        {    
            massLoad = cOut * (vOut1 - vOut2) * Pollut[p].mcf;
            if (massLoad > 0.0)
                massbal_updateLoadingTotals(BMP_REMOVAL_LOAD, p, massLoad);
        }

        // --- update subcatchment's cumulative runoff load in lbs (or kg)
        massLoad = cOut * vOut2 * Pollut[p].mcf;
        Subcatch[j].totalLoad[p] += massLoad;

        // --- update mass balance for surface runoff load routed to a
        //     conveyance system node
        //     (loads from LID drains are accounted for below since they
        //     can go to different outlets than parent subcatchment)
        if ( (Subcatch[j].outNode >= 0 || Subcatch[j].outSubcatch == j) )
        {
            massLoad = cOut * vSurfOut * Pollut[p].mcf;
            massbal_updateLoadingTotals(RUNOFF_LOAD, p, massLoad);
        }
        
        // --- save new washoff concentration
        if ( !hasOutflow ) cOut = 0.0;
        Subcatch[j].newQual[p] = cOut / LperFT3;
    }

    // --- add contribution of LID drain flows to mass balance 
    if ( Subcatch[j].lidArea > 0.0 )
    {
        lid_addDrainLoads(j, Subcatch[j].newQual, tStep);
    }
}

//=============================================================================
// int j, int p, double f)
surfqual_getWtdWashoff(j, p, f)
//
//  Input:   j = subcatchment index
//           p = pollutant index
//           f = weighting factor
//  Output:  returns pollutant washoff value
//  Purpose: finds wtd. combination of old and new washoff for a pollutant.
//
{
    return (1.0 - f) * Subcatch[j].oldRunoff * Subcatch[j].oldQual[p] +
           f * Subcatch[j].newRunoff *Subcatch[j].newQual[p];
}

//=============================================================================
// int j, double tStep
findPondedLoads(j, tStep)
//
//  Input:   j = subcatchment index
//           tStep = time step (sec)
//  Output:  updates pondedQual and OutflowLoad 
//  Purpose: mixes wet deposition and runon pollutant loading with existing
//           ponded pollutant mass to compute an ouflow loading.
//
{
    let    p;           // pollutant index
    let    cPonded,     // ponded concentration (mass/ft3)
           wPonded,     // pollutant mass in ponded water (mass)
           bmpRemoval,  // load reduction by best mgt. practice (mass)
           vRain,       // volume of direct precipitation (ft3)
           wRain,       // wet deposition pollutant load (mass)
           wRunon,      // external runon pollutant load (mass)
           wInfil,      // pollutant load lost to infiltration (mass)
           wOutflow,    // ponded water contribution to runoff load (mass)
           fullArea,    // full subcatchment area (ft2)
           nonLidArea;  // non-LID area (ft2)

    // --- subcatchment and non-LID areas
    if ( Subcatch[j].area == Subcatch[j].lidArea ) return;
    fullArea = Subcatch[j].area;
    nonLidArea = fullArea - Subcatch[j].lidArea;

    // --- compute precip. volume over time step (ft3)
    vRain = Subcatch[j].rainfall * nonLidArea * tStep;

    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- update mass balance for wet deposition
        wRain = Pollut[p].pptConcen * LperFT3 * vRain;
        massbal_updateLoadingTotals(DEPOSITION_LOAD, p, wRain * Pollut[p].mcf);

        // --- surface is dry and has no runon -- add any remaining mass
        //     to overall mass balance's FINAL_LOAD category
        if ( Vinflow == 0.0 )
        {
            massbal_updateLoadingTotals(FINAL_LOAD, p,
                Subcatch[j].pondedQual[p] * Pollut[p].mcf);
            Subcatch[j].pondedQual[p] = 0.0;
        }
        else
        {
            // --- find concen. of ponded water
            //     (newQual[] temporarily holds runon mass loading)
            wRunon = Subcatch[j].newQual[p] * tStep;
            wPonded = Subcatch[j].pondedQual[p] + wRain + wRunon;
            cPonded = wPonded / Vinflow;

            // --- mass lost to infiltration
            wInfil = cPonded * Vinfil;
            wInfil = MIN(wInfil, wPonded);
            massbal_updateLoadingTotals(INFIL_LOAD, p, wInfil * Pollut[p].mcf);
            wPonded -= wInfil;

            // --- mass lost to runoff
            wOutflow = cPonded * Voutflow;
            wOutflow = MIN(wOutflow, wPonded);
            wPonded -= wOutflow;

            // --- reduce outflow load by average BMP removal
            bmpRemoval = landuse_getAvgBmpEffic(j, p) * wOutflow;
            massbal_updateLoadingTotals(BMP_REMOVAL_LOAD, p,
                bmpRemoval*Pollut[p].mcf);
            wOutflow -= bmpRemoval;

            // --- update ponded mass (using newly computed ponded depth)
            Subcatch[j].pondedQual[p] = cPonded * subcatch_getDepth(j) * nonLidArea;
            OutflowLoad[p] += wOutflow;
        }
    }
}

//=============================================================================
// int j, double runoff
 findWashoffLoads(j, runoff)
//
//  Input:   j = subcatchment index
//           runoff = subcatchment runoff before internal re-routing or
//                    LID controls (ft/sec)
//  Output:  updates OutflowLoad array
//  Purpose: computes pollutant washoff loads for each land use and adds these
//           to the subcatchment's total outflow loads.
//
{
    let    i,                          // land use index
           p,                          // pollutant index
           k;                          // co-pollutant index
    let w,                          // co-pollutant load (mass)
           area = Subcatch[j].area;    // subcatchment area (ft2)
    
    // --- examine each land use
    if ( runoff < MIN_RUNOFF ) return;
    for (i = 0; i < Nobjects[LANDUSE]; i++)
    {
        if ( Subcatch[j].landFactor[i].fraction > 0.0 )
        {
            // --- compute load generated by washoff function
            for (p = 0; p < Nobjects[POLLUT]; p++)
            {
                OutflowLoad[p] += landuse_getWashoffLoad(
                    i, p, area, Subcatch[j].landFactor, runoff, Voutflow);
            }
        }
    }

    // --- compute contribution from any co-pollutant
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- check if pollutant p has a co-pollutant k
        k = Pollut[p].coPollut;
        if ( k >= 0 )
        {
            // --- compute addition to washoff from co-pollutant
            w = Pollut[p].coFraction * OutflowLoad[k];

            // --- add this washoff to buildup mass balance totals
            //     so that things will balance
            massbal_updateLoadingTotals(BUILDUP_LOAD, p, w * Pollut[p].mcf);

            // --- then also add it to the total washoff load
            OutflowLoad[p] += w;
        }
    }
}

//=============================================================================
// int j, double tStep
 findLidLoads(j, tStep)
//
//  Input:   j = subcatchment index
//           tStep = time step (sec)
//  Output:  updates OutflowLoad array
//  Purpose: finds addition to subcatchment pollutant loads from wet deposition 
//           and upstream runon to LID areas.
//
{
    let    p;                // pollutant index
    let    useRunon;         // = 1 if LIDs receive upstream runon loads
    let    lidArea,          // area occupied by LID units (ft2)
           vLidRain,         // direct precip. falling on LID areas (ft3)
           wLidRain,         // wet deposition pollut. load on LID areas (mass)
           wLidRunon;        // runon pollut. load seen by LID areas (mass)

    // --- find rainfall volume seen by LIDs
    lidArea = Subcatch[j].lidArea;
    if ( lidArea == 0.0 ) return;
    vLidRain = Subcatch[j].rainfall * lidArea * tStep;

    // --- use upstream runon load only if LIDs occupy full subcatchment
    //     (for partial LID coverage, runon loads were directed onto non-LID area)
    useRunon = (lidArea == Subcatch[j].area);

    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        // --- wet deposition load on LID area
        wLidRain = Pollut[p].pptConcen * vLidRain * LperFT3;
        massbal_updateLoadingTotals(DEPOSITION_LOAD, p, wLidRain * Pollut[p].mcf);

        // --- runon load to LID area from other subcatchments
        if ( useRunon ) wLidRunon = Subcatch[j].newQual[p] * tStep;
        else            wLidRunon = 0.0;

        // --- update total outflow pollutant load (mass)
        OutflowLoad[p] += wLidRain + wLidRunon;
    }
}

//-----------------------------------------------------------------------------
//   rdii.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             04/04/14   (Build 5.1.003)
//             04/14/14   (Build 5.1.004)
//             09/15/14   (Build 5.1.007)
//             03/01/20   (Build 5.1.014)
//   Author:   L. Rossman (EPA)
//             R. Dickinson (CDM)
//
//   RDII processing functions.
//
//   Note: RDII means rainfall dependent infiltration/inflow,
//         UH means unit hydrograph.
//
//   Build 5.1.007:
//   - Ignore RDII option implemented.
//   - Rainfall climate adjustment implemented.
//
//   Build 5.1.014:
//   - Fixes bug related to isUsed property of a unit hydrograph's rain gage.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Definition of 4-byte integer, 4-byte real and 8-byte real types
//-----------------------------------------------------------------------------
INT4  
//#define REAL4 float
//#define REAL8 double
FILE_STAMP = "SWMM5-RDII"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
ZERO_RDII = 0.0001;       // Minimum non-zero RDII inflow (cfs)
FileStamp = FILE_STAMP;

//-----------------------------------------------------------------------------
// Data Structures
//-----------------------------------------------------------------------------
// enum FileTypes {BINARY, TEXT};         // File mode types
BINARY = 0
TEXT = 1

class TUHData                         // Data for a single unit hydrograph
{                                      // -------------------------------------
   constructor(){
    this.pastRain = [];                 // array of past rainfall values
    this.pastMonth;                // month in which past rainfall occurred
    this.period;                   // current UH time period
    this.hasPastRain;              // true if > 0 past periods with rain
    this.maxPeriods;               // max. past rainfall periods
    this.drySeconds;               // time since last nonzero rainfall
    this.iaUsed;                   // initial abstraction used (in or mm)
   }
} ;

class TUHGroup                         // Data for a unit hydrograph group
{                                      //---------------------------------
    constructor(){
        this.isUsed;                   // true if UH group used by any nodes
        this.rainInterval;             // time interval for RDII processing (sec)
        this.area;                     // sewered area covered by UH's gage (ft2)
        this.rdii;                     // rdii flow (in rainfall units)
        this.ageDate;                 // calendar date of rain gage period
        this.lastDate;                 // date of last rdii computed
        this.uh = [new TUHData(), new TUHData(), new TUHData()] // uh[3]; // data for each unit hydrograph
    }
} ;

//-----------------------------------------------------------------------------
// Shared Variables
//-----------------------------------------------------------------------------
//static TUHGroup*  UHGroup;             // processing data for each UH group
 UHGroup = [];             // processing data for each UH group
RdiiStep;            // RDII time step (sec)
NumRdiiNodes;        // number of nodes w/ RDII data
RdiiNodeIndex = [];       // indexes of nodes w/ RDII data
 RdiiNodeFlow = [];        // inflows for nodes with RDII
 RdiiFlowUnits;       // RDII flow units code
 RdiiStartDate;       // start date of RDII inflow period
RdiiEndDate;         // end date of RDII inflow period
TotalRainVol;        // total rainfall volume (ft3)
TotalRdiiVol;        // total RDII volume (ft3)
RdiiFileType;        // type (binary/text) of RDII file


//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  rdii_readRdiiInflow     (called from parseLine in input.c)
//  rdii_deleteRdiiInflow   (called from deleteObjects in project.c)
//  rdii_initUnitHyd        (called from createObjects in project.c)
//  rdii_readUnitHydParams  (called from parseLine in input.c)
//  rdii_openRdii           (called from rain_open)
//  rdii_closeRdii          (called from rain_close)
//  rdii_getNumRdiiFlows    (called from addRdiiInflows in routing.c)
//  rdii_getRdiiFlow        (called from addRdiiInflows in routing.c)

//=============================================================================
//                   Management of RDII-Related Data
//=============================================================================
// char* tok[], int ntoks
rdii_readRdiiInflow(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads properties of an RDII inflow from a line of input.
//
{
    let j, k;
    let a;
    //TRdiiInflow* inflow;
    let inflow;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check for proper number of items
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that node receiving RDII exists
    j = project_findObject(NODE, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- check that RDII unit hydrograph exists
    k = project_findObject(UNITHYD, tok[1]);
    if ( k < 0 ) return error_setInpError(ERR_NAME, tok[1]);

    // --- read in sewer area value
    ////////////////////////////////////
    returnObj = {y: a}
    returnVal = getDouble(tok[2], returnObj);
    a = returnObj.y;
    ////////////////////////////////////
    if ( !returnVal || a < 0.0 )
    //if ( null == (a = getDouble(tok[2])) || a < 0.0 )
        return error_setInpError(ERR_NUMBER, tok[2]);

    // --- create the RDII inflow object if it doesn't already exist
    inflow = Node[j].rdiiInflow;
    if ( inflow == null )
    {
        inflow = new TRdiiInflow();
        //inflow = (TRdiiInflow *) malloc(sizeof(TRdiiInflow));
        if ( !inflow ) return error_setInpError(ERR_MEMORY, "");
    }

    // --- assign UH & area to inflow object
    inflow.unitHyd = k;
    inflow.area = a / UCF(LANDAREA);

    // --- assign inflow object to node
    Node[j].rdiiInflow = inflow;
    return 0;
}

//=============================================================================
// int j
rdii_initUnitHyd(j)
//
//  Input:   j = UH group index
//  Output:  none
//  Purpose: initializes properties of a unit hydrograph group.
//
{
    let i;                             // individual UH index
    let m;                             // month index

    for ( m=0; m<12; m++)
    {
        for (i=0; i<3; i++)
        {
            UnitHyd[j].iaMax[m][i]   = 0.0;
            UnitHyd[j].iaRecov[m][i] = 0.0;
            UnitHyd[j].iaInit[m][i]  = 0.0;
            UnitHyd[j].r[m][i]       = 0.0;
            UnitHyd[j].tPeak[m][i]   = 0;
            UnitHyd[j].tBase[m][i]   = 0;
        }
    }
}

//=============================================================================
// char* tok[], int ntoks
rdii_readUnitHydParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads parameters of an RDII unit hydrograph from a line of input.
//
{
    let i, j, k, m, g;
    let x = new Array(6);

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check that RDII UH object exists in database
    j = project_findObject(UNITHYD, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- assign UH ID to name in hash table
    if ( UnitHyd[j].ID == null )
        UnitHyd[j].ID = project_findID(UNITHYD, tok[0]);

    // --- line has 2 tokens; assign rain gage to UH object
    if ( ntoks == 2 )
    {
        g = project_findObject(GAGE, tok[1]);
        if ( g < 0 ) return error_setInpError(ERR_NAME, tok[1]);
        UnitHyd[j].rainGage = g;
        Gage[g].isUsed = true;
        return 0;
    }
    else if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");

    // --- find which month UH params apply to
    m = datetime_findMonth(tok[1]);
    if ( m == 0 )
    {
        if ( !match(tok[1], w_ALL) )
            return error_setInpError(ERR_KEYWORD, tok[1]);
    }

    // --- find type of UH being specified
    k = findmatch(tok[2], UHTypeWords);

    // --- if no type match, try using older UH line format
    if ( k < 0 ) return readOldUHFormat(j, m, tok, ntoks);

    // --- read the R-T-K parameters
    for ( i = 0; i < 3; i++ )
    {
        ////////////////////////////////////
        returnObj = {y: x[i]}
        returnVal = getDouble(tok[i+3], returnObj);
        x[i] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( ! getDouble(tok[i+3], x[i]) )
            return error_setInpError(ERR_NUMBER, tok[i+3]);
    }

    // --- read the IA parameters if present
    for (i = 3; i < 6; i++)
    {
        x[i] = 0.0;
        if ( ntoks > i+3 )
        {
            ////////////////////////////////////
            returnObj = {y: x[i]}
            returnVal = getDouble(tok[i+3], returnObj);
            x[i] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal )
            //if ( ! getDouble(tok[i+3], x[i]) )
                return error_setInpError(ERR_NUMBER, tok[i+2]);
        }
    }

    // --- save UH params
    setUnitHydParams(j, k, m, x);
    return 0;
}

//=============================================================================
// int j, int m, char* tok[], int ntoks
readOldUHFormat(j, m, tok, ntoks)
//
//  Input:   j = unit hydrograph index
//           m = month of year (0 = all months)
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads parameters of a set of RDII unit hydrographs from a line of
//           input.
//
{
    let    i, k;
    let  p = new Array(9), x = new Array(6);

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check for proper number of tokens
    if ( ntoks < 11 ) return error_setInpError(ERR_ITEMS, "");

    // --- read 3 sets of r-t-k values
    for ( i = 0; i < 9; i++ )
    {
        ////////////////////////////////////
        returnObj = {y: p[i]}
        returnVal = getDouble(tok[i+2], returnObj);
        p[i] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( ! getDouble(tok[i+2], p[i]) )
            return error_setInpError(ERR_NUMBER, tok[i+2]);
    }

    // --- read initial abstraction parameters
    for (i = 0; i < 3; i++)
    {
        x[i+3] = 0.0;
        if ( ntoks > i+11 )
        {
            ////////////////////////////////////
            returnObj = {y: x[i+3]}
            returnVal = getDouble(tok[i+11], returnObj);
            x[i+3] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal )
            //if ( ! getDouble(tok[i+11], x[i+3]) )
                return error_setInpError(ERR_NUMBER, tok[i+11]);
        }
    }

    // --- save UH parameters
    for ( k = 0; k < 3; k++)
    {
        for ( i = 0; i < 3; i++)
        {
            x[i] = p[3*k + i];
            setUnitHydParams(j, k, m, x);
        }
    }
    return 0;
}

//=============================================================================
// int j, int i, int m, double x[]
setUnitHydParams(j, i, m, x)
//
//  Input:   j = unit hydrograph index
//           i = type of UH response (short, medium or long term)
//           m = month of year (0 = all months)
//           x = array of UH parameters
//  Output:  none
//  Purpose: assigns parameters to a unit hydrograph for a specified month of year.
//
{
    let    m1, m2;                     // start/end month indexes
    let    t,                          // UH time to peak (hrs)
           k,                          // UH k-value
           tBase;                      // UH base time (hrs)

    // --- find range of months that share same parameter values
    if ( m == 0 )
    {
        m1 = 0;
        m2 = 11;
    }
    else
    {
        m1 = m-1;
        m2 = m1;
    }

    // --- for each month in the range
    for (m=m1; m<=m2; m++)
    {
        // --- set UH response ratio, time to peak, & base time
        UnitHyd[j].r[m][i] = x[0];
        t = x[1];
        k = x[2];
        tBase = t * (1.0 + k);                              // hours
        UnitHyd[j].tPeak[m][i] = (long)(t * 3600.);         // seconds
        UnitHyd[j].tBase[m][i] = (long)(tBase * 3600.);     // seconds

        // -- set initial abstraction parameters
        UnitHyd[j].iaMax[m][i]   = x[3];
        UnitHyd[j].iaRecov[m][i] = x[4];
        UnitHyd[j].iaInit[m][i]  = x[5];
    }
}

//=============================================================================
// int j
rdii_deleteRdiiInflow(j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: deletes the RDII inflow object for a node.
//
{
    if ( Node[j].rdiiInflow )
    {
        Node[j].rdiiInflow = null;
    }
}


//=============================================================================
//                 Reading Inflow Data From a RDII File
//=============================================================================

rdii_openRdii()
//
//  Input:   none
//  Output:  none
//  Purpose: opens an exisiting RDII interface file or creates a new one.
//
{
    let  fStamp = FILE_STAMP;

    RdiiNodeIndex = null;
    RdiiNodeFlow = null;
    NumRdiiNodes = 0;
    RdiiStartDate = NO_DATE;

    // --- create the RDII file if existing file not being used
    if ( IgnoreRDII ) return;
    if ( Frdii.mode != USE_FILE ) createRdiiFile();
    if ( Frdii.mode == NO_FILE || ErrorCode ) return;

    // --- try to open the RDII file in binary mode
    Frdii.file = fopen(Frdii.name, "rb");
    if ( Frdii.file == null)
    {
        if ( Frdii.mode == SCRATCH_FILE )
        {
            report_writeErrorMsg(ERR_RDII_FILE_SCRATCH, "");
        }
        else
        {
            report_writeErrorMsg(ERR_RDII_FILE_OPEN, Frdii.name);
        }
        return;
    }

    // --- check for valid file stamp
    fread(fStamp, sizeof(char), FileStamp.length, Frdii.file);
    if ( strcmp(fStamp, FileStamp) == 0 )
    {
        RdiiFileType = BINARY;
        ErrorCode = readRdiiFileHeader();
    }

    // --- if stamp invalid try to open the file in text mode
    else
    {
        fclose(Frdii.file);
        RdiiFileType = TEXT;
        openRdiiTextFile();
    }

    // --- catch any error
    if ( ErrorCode )
    {
        report_writeErrorMsg(ErrorCode, Frdii.name);
    }

    // --- read the first set of RDII flows form the file
    else readRdiiFlows();
}

//=============================================================================

openRdiiTextFile()
{
    // --- try to open the RDII file in text mode
    Frdii.file = fopen(Frdii.name, "rt");
    if ( Frdii.file == null)
    {
        if ( Frdii.mode == SCRATCH_FILE )
        {
            report_writeErrorMsg(ERR_RDII_FILE_SCRATCH, "");
        }
        else
        {
            report_writeErrorMsg(ERR_RDII_FILE_OPEN, Frdii.name);
        }
        return;
    }

    // --- read header records from file
    ErrorCode = readRdiiTextFileHeader();
    if ( ErrorCode )
    {
        report_writeErrorMsg(ErrorCode, Frdii.name);
    }
}

//=============================================================================

rdii_closeRdii()
//
//  Input:   none
//  Output:  none
//  Purpose: closes the RDII interface file.
//
{
    if ( Frdii.file ) fclose(Frdii.file);
    if ( Frdii.mode == SCRATCH_FILE ) remove(Frdii.name);
    FREE(RdiiNodeIndex);
    FREE(RdiiNodeFlow);
}

//=============================================================================
// DateTime aDate
rdii_getNumRdiiFlows(aDate)
//
//  Input:   aDate = current date/time
//  Output:  returns 0 if no RDII flow or number of nodes with RDII inflows
//  Purpose: finds number of RDII inflows at a specified date.
//
{
    // --- default result is 0 indicating no RDII inflow at specified date
    if ( NumRdiiNodes == 0 ) return 0;
    if ( !Frdii.file ) return 0;

    // --- keep reading RDII file as need be
    while ( !feof(Frdii.file) )
    {
        // --- return if date of current RDII inflow not reached yet
        if ( RdiiStartDate == NO_DATE ) return 0;
        if ( aDate < RdiiStartDate ) return 0;

        // --- return RDII node count if specified date falls
        //     within time interval of current RDII inflow
        if ( aDate < RdiiEndDate ) return NumRdiiNodes;

        // --- otherwise get next date and RDII flow values from file
        else readRdiiFlows();
    }
    return 0;
}

//=============================================================================
// int i, int* j, double* q
rdii_getRdiiFlow(i, j, q)
//
//  Input:   i = RDII node index
//           j = pointer to project node index
//           q = pointer to RDII flow rate
//  Output:  sets node index and RDII inflow for node
//  Purpose: finds index and current RDII inflow for an RDII node.
//
{
    if ( i >= 0 && i < NumRdiiNodes )
    {
        j = RdiiNodeIndex[i];
        q = RdiiNodeFlow[i];
    }
}

//=============================================================================

readRdiiFileHeader()
//
//  Input:   none
//  Output:  returns error code
//  Purpose: reads header information from a binary RDII file.
//
{
    let i, j;

    // --- extract time step and number of RDII nodes
    fread(RdiiStep, sizeof(INT4), 1, Frdii.file);
    if ( RdiiStep <= 0 ) return ERR_RDII_FILE_FORMAT;
    fread(NumRdiiNodes, sizeof(INT4), 1, Frdii.file);
    if ( NumRdiiNodes <= 0 ) return ERR_RDII_FILE_FORMAT;

    // --- allocate memory for RdiiNodeIndex & RdiiNodeFlow arrays
    //RdiiNodeIndex = (int *) calloc(NumRdiiNodes, sizeof(int));
    RdiiNodeIndex = new Array(NumRdiiNodes);
    if ( !RdiiNodeIndex ) return ERR_MEMORY;
    //RdiiNodeFlow = (REAL4 *) calloc(NumRdiiNodes, sizeof(REAL4));
    RdiiNodeFlow = new Array(NumRdiiNodes);
    if ( !RdiiNodeFlow ) return ERR_MEMORY;

    // --- read indexes of RDII nodes
    if ( feof(Frdii.file) ) return ERR_RDII_FILE_FORMAT;
    fread(RdiiNodeIndex, sizeof(INT4), NumRdiiNodes, Frdii.file);
    for ( i=0; i<NumRdiiNodes; i++ )
    {
        j = RdiiNodeIndex[i];
        if ( Node[j].rdiiInflow == null ) return ERR_RDII_FILE_FORMAT;
    }
    if ( feof(Frdii.file) ) return ERR_RDII_FILE_FORMAT;
    return 0;
}

//=============================================================================

readRdiiTextFileHeader()
//
//  Input:   none
//  Output:  returns error code
//  Purpose: reads header information from a text RDII file.
//
{
    let  i;
    let  line;             // line from RDII data file
    let  s1;               // general string variable
    let  s2;

    // --- check for correct file type
    fgets(line, MAXLINE, Frdii.file);
    sscanf(line, "%s", s1);
    if ( strcmp(s1, "SWMM5") != 0 ) return ERR_RDII_FILE_FORMAT;

    // --- skip title line
    fgets(line, MAXLINE, Frdii.file);

    // --- read RDII UH time step interval (sec)
    RdiiStep = 0;
    fgets(line, MAXLINE, Frdii.file);
    sscanf(line, "%d", RdiiStep);
    if ( RdiiStep <= 0 ) return ERR_RDII_FILE_FORMAT;

    // --- skip over line with number of constituents (= 1 for RDII)
    fgets(line, MAXLINE, Frdii.file);

    // --- read flow units
    fgets(line, MAXLINE, Frdii.file);
    sscanf(line, "%s %s", s1, s2);
    RdiiFlowUnits = findmatch(s2, FlowUnitWords);
    if ( RdiiFlowUnits < 0 ) return ERR_RDII_FILE_FORMAT;

    // --- read number of RDII nodes
    fgets(line, MAXLINE, Frdii.file);
    if ( sscanf(line, "%d", NumRdiiNodes) < 1 ) return ERR_RDII_FILE_FORMAT;

    // --- allocate memory for RdiiNodeIndex & RdiiNodeFlow arrays
    //RdiiNodeIndex = calloc(NumRdiiNodes, sizeof(int));
    RdiiNodeIndex = new Array(NumRdiiNodes);
    if ( !RdiiNodeIndex ) return ERR_MEMORY;
    //RdiiNodeFlow = (REAL4 *) calloc(NumRdiiNodes, sizeof(REAL4));
    RdiiNodeFlow = new Array(NumRdiiNodes)
    if ( !RdiiNodeFlow ) return ERR_MEMORY;

    // --- read names of RDII nodes from file & save their indexes
    for ( i=0; i<NumRdiiNodes; i++ )
    {
        if ( feof(Frdii.file) ) return ERR_RDII_FILE_FORMAT;
        fgets(line, MAXLINE, Frdii.file);
        sscanf(line, "%s", s1);
        RdiiNodeIndex[i] = project_findObject(NODE, s1);
    }

    // --- skip column heading line
    if ( feof(Frdii.file) ) return ERR_RDII_FILE_FORMAT;
    fgets(line, MAXLINE, Frdii.file);
    return 0;
}

//=============================================================================

readRdiiFlows()
//
//  Input:   none
//  Output:  none
//  Purpose: reads date and flow values of next RDII inflows from RDII file.
//
{
    if ( RdiiFileType == TEXT ) readRdiiTextFlows();
    else
    {
        RdiiStartDate = NO_DATE;
        RdiiEndDate = NO_DATE;
        if ( feof(Frdii.file) ) return;
        fread(RdiiStartDate, sizeof(DateTime), 1, Frdii.file);
        if ( RdiiStartDate == NO_DATE ) return;
        if ( fread(RdiiNodeFlow, sizeof(REAL4), NumRdiiNodes, Frdii.file) < NumRdiiNodes ) RdiiStartDate = NO_DATE;
        else RdiiEndDate = datetime_addSeconds(RdiiStartDate, RdiiStep);
    }
}

//=============================================================================

readRdiiTextFlows()
//
//  Input:   none
//  Output:  none
//  Purpose: reads date and flow values of next RDII inflows from RDII file.
//
{
    let    i, n;
    let    yr = 0, mon = 0, day = 0,
		   hr = 0, min = 0, sec = 0;   // year, month, day, hour, minute, second
    let    x;                          // RDII flow in original units
    let    line;            // line from RDII data file
    let    s;               // node ID label (not used)

    RdiiStartDate = NO_DATE;
    for (i=0; i<NumRdiiNodes; i++)
    {
        if ( feof(Frdii.file) ) return;
        fgets(line, MAXLINE, Frdii.file);
        n = sscanf(line, "%s %d %d %d %d %d %d %lf",
            s, yr, mon, day, hr, min, sec, x);
        if ( n < 8 ) return;
        RdiiNodeFlow[i] = (REAL4)(x / Qcf[RdiiFlowUnits]);
    }
    RdiiStartDate = datetime_encodeDate(yr, mon, day) +
                    datetime_encodeTime(hr, min, sec);
    RdiiEndDate = datetime_addSeconds(RdiiStartDate, RdiiStep);
}


//=============================================================================
//                   Creation of a RDII Interface File
//=============================================================================

createRdiiFile()
//
//  Input:   none
//  Output:  none
//  Purpose: computes time history of RDII inflows and saves them to file.
//
{
    let hasRdii;                  // true when total RDII > 0
    let elapsedTime;              // current elapsed time (sec)
    let duration;                 // duration being analyzed (sec)
    let currentDate;              // current calendar date/time

    // --- set RDII reporting time step to Runoff wet step
    RdiiStep = WetStep;

    // --- count nodes with RDII data
    NumRdiiNodes = getNumRdiiNodes();

    // --- if no RDII nodes then re-set RDII file usage to NO_FILE
    if ( NumRdiiNodes == 0 )
    {
        Frdii.mode = NO_FILE;
        return;
    }

    // --- otherwise set file usage to SCRATCH if originally set to NO_FILE
    else if ( Frdii.mode == NO_FILE ) Frdii.mode = SCRATCH_FILE;

    // --- validate RDII data
    validateRdii();
    initGageData();
    if ( ErrorCode ) return;

    // --- open RDII processing system
    openRdiiProcessor();
    if ( !ErrorCode )
    {
        // --- initialize rain gage & UH processing data
        initUnitHydData();

        // --- convert total simulation duration from millisec to sec
        duration = TotalDuration / 1000.0;

        // --- examine rainfall record over each RdiiStep time step
        elapsedTime = 0.0;
        while ( elapsedTime <= duration && !ErrorCode )
        {
            // --- compute current calendar date/time
            currentDate = StartDateTime + elapsedTime / SECperDAY;

            // --- update rainfall at all rain gages
            getRainfall(currentDate);

            // --- compute convolutions of past rainfall with UH's
            getUnitHydRdii(currentDate);

            // --- find RDII at all nodes
            hasRdii = getNodeRdii();

            // --- save RDII at all nodes to file for current date
            if ( hasRdii ) saveRdiiFlows(currentDate);

            // --- advance one time step
            elapsedTime += RdiiStep;
        }
    }

    // --- close RDII processing system
    closeRdiiProcessor();
}

//=============================================================================

 getNumRdiiNodes()
//
//  Input:   none
//  Output:  returns node count
//  Purpose: counts number of nodes that receive RDII inflow.
//
{
    let j,                             // node index
        n;                             // node count

    n = 0;
    for (j=0; j<Nobjects[NODE]; j++)
    {
        if ( Node[j].rdiiInflow ) n++;
    }
    return n;
}

//=============================================================================

validateRdii()
//
//  Input:   none
//  Output:  none
//  Purpose: validates UH and RDII inflow object data.
//
{
    let    i,                          // node index
           j,                          // UH group index
           k,                          // individual UH index
           m;                          // month index
    let rsum;                       // sum of UH r-values
//  long   gageInterval;               // rain gage time interval

    // --- check each unit hydrograph for consistency
    for (j=0; j<Nobjects[UNITHYD]; j++)
    {
        for (m=0; m<12; m++)
        {
            rsum = 0.0;
            for (k=0; k<3; k++)
            {
                // --- if no base time then UH doesn't exist
                if ( UnitHyd[j].tBase[m][k] == 0 ) continue;

                // --- restriction on time to peak being less than the
                //     rain gage's recording interval no longer applies

                // --- can't have negative UH parameters
                if ( UnitHyd[j].tPeak[m][k] < 0.0 )
                {
                    report_writeErrorMsg(ERR_UNITHYD_TIMES, UnitHyd[j].ID);
                }

                // --- can't have negative UH response ratio
                if ( UnitHyd[j].r[m][k] < 0.0 )
                {
                    report_writeErrorMsg(ERR_UNITHYD_RATIOS, UnitHyd[j].ID);
                }
                else rsum += UnitHyd[j].r[m][k];
            }
            if ( rsum > 1.01 )
            {
                report_writeErrorMsg(ERR_UNITHYD_RATIOS, UnitHyd[j].ID);
            }
        }
    }

    // --- check each node's RDII inflow object
    for (i=0; i<Nobjects[NODE]; i++)
    {
        if ( Node[i].rdiiInflow )
        {
            // --- check that sewer area is non-negative
            if ( Node[i].rdiiInflow.area < 0.0 )
            {
                report_writeErrorMsg(ERR_RDII_AREA, Node[i].ID);
            }
        }
    }
}

//=============================================================================

openRdiiProcessor()
//
//  Input:   none
//  Output:  none
//  Purpose: opens RDII processing system.
//
{
    let j;                             // object index
    let n;                             // RDII node count

    // --- set RDII processing arrays to null
    UHGroup = null;
    RdiiNodeIndex = null;
    RdiiNodeFlow = null;
    TotalRainVol = 0.0;
    TotalRdiiVol = 0.0;

    // --- allocate memory used for RDII processing
    if ( !allocRdiiMemory() )
    {
        report_writeErrorMsg(ERR_MEMORY, "");
        return;
    }

    // --- open & initialize RDII file
    if ( !openNewRdiiFile() )
    {
        report_writeErrorMsg(ERR_RDII_FILE_SCRATCH, "");
        return;
    }

    // --- identify index of each node with RDII inflow
    n = 0;
    for (j=0; j<Nobjects[NODE]; j++)
    {
        if ( Node[j].rdiiInflow )
        {
            RdiiNodeIndex[n] = j;
            n++;
        }
    }
}

//=============================================================================

 allocRdiiMemory()
//
//  Input:   none
//  Output:  returns true if successful, false if not
//  Purpose: allocates memory used for RDII processing .
//
//
{
    let i;                             // UH group index
    let k;                             // UH index
    let n;                             // number of past rain periods

    // --- allocate memory for RDII processing data for UH groups
    // UHGroup = (TUHGroup *) calloc(Nobjects[UNITHYD], sizeof(TUHGroup));
    UHGroup = [];
    for(let u = 0; u < Nobjects[UNITHYD]; u++){UHGroup.push(new TUHGroup())}
    if ( !UHGroup ) return false;

    // --- allocate memory for past rainfall data for each UH in each group
    for (i=0; i<Nobjects[UNITHYD]; i++)
    {
        UHGroup[i].rainInterval = getRainInterval(i);
        for (k=0; k<3; k++)
        {
            UHGroup[i].uh[k].pastRain = null;
            UHGroup[i].uh[k].pastMonth = null;
            UHGroup[i].uh[k].maxPeriods = getMaxPeriods(i, k);
            n = UHGroup[i].uh[k].maxPeriods;
            if ( n > 0 )
            {
                UHGroup[i].uh[k].pastRain =
                    //(double *) calloc(n, sizeof(double));
                    new Array(n);
                if ( !UHGroup[i].uh[k].pastRain ) return false;
                UHGroup[i].uh[k].pastMonth =
                    //(char *) calloc(n, sizeof(char));
                    new Array(n)
                if ( !UHGroup[i].uh[k].pastMonth ) return false;
            }
        }
    }

    // --- allocate memory for RDII indexes & inflow at each node w/ RDII data
    //RdiiNodeIndex = (int *) calloc(NumRdiiNodes, sizeof(int));
    RdiiNodeIndex = new Array(NumRdiiNodes);
    if ( !RdiiNodeIndex ) return false;
    //RdiiNodeFlow = (REAL4 *) calloc(NumRdiiNodes, sizeof(REAL4));
    RdiiNodeFlow = new Array(NumRdiiNodes)
    if ( !RdiiNodeFlow ) return false;
    return true;
}

//=============================================================================
// int i
 getRainInterval(i)
//
//  Input:   i = UH group index
//  Output:  returns a time interval (sec)
//  Purpose: finds rainfall processing time interval for a unit hydrograph group.
//
{
    let ri;        // rainfal processing time interval for the UH group
    let tLimb;     // duration of a UH's rising & falling limbs
    let k, m;

    // --- begin with UH group time step equal to wet runoff step
    ri = WetStep;

    // --- examine each UH in the group
    for (m=0; m<12; m++)
    {
        for (k=0; k<3; k++)
        {
            // --- make sure the UH exists
            if ( UnitHyd[i].tPeak[m][k] > 0 )
            {
                // --- reduce time step if rising/falling limb is smaller
                tLimb = UnitHyd[i].tPeak[m][k];
                ri = MIN(ri, tLimb);
                tLimb = UnitHyd[i].tBase[m][k] - tLimb;
                if ( tLimb > 0 ) ri = MIN(ri, tLimb);
            }
        }
    }
    return ri;
}

//=============================================================================
// int i, int k
 getMaxPeriods(i, k)
//
//  Input:   i = UH group index
//           k = UH index
//  Output:  returns number of past rainfall values
//  Purpose: finds number of past rainfall values to save for a UH.
//
{
    let   m,                           // month index
          n,                           // number of time periods
          nMax,                        // maximum number of time periods
          rainInterval;                // rainfall processing interval (sec)

    // --- examine each monthly set of UHs
    rainInterval = UHGroup[i].rainInterval;
    nMax = 0;
    for (m=0; m<12; m++)
    {
        // --- compute number of time periods in UH base
        n = (UnitHyd[i].tBase[m][k] / rainInterval) + 1;

        // --- update number of time periods to be saved
        nMax = MAX(n, nMax);
    }
    return nMax;
}

//=============================================================================

initGageData()
//
//  Input:   none
//  Output:  none
//  Purpose: initializes state of Unit Hydrograph rain gages.
//
{
    let i;                             // unit hyd. index
    let g;                             // rain gage index

    // --- first initialize the state of each rain gage
    for (g=0; g<Nobjects[GAGE]; g++)
    {
        if ( Gage[g].tSeries >= 0 )
        {
            table_tseriesInit(Tseries[Gage[g].tSeries]);
        }
        gage_initState(g);
    }

    // --- then flag each gage that is used by a Unit Hydrograph set
    for (i=0; i<Nobjects[UNITHYD]; i++)
    {
        g = UnitHyd[i].rainGage;
        if ( g >= 0 )
        {
            // --- if UH's gage uses same time series as a previous gage,
            //     then assign the latter gage to the UH
            if ( Gage[g].coGage >= 0 )
            {
                UnitHyd[i].rainGage = Gage[g].coGage;
            }
        }
    }
}

//=============================================================================

initUnitHydData()
//
//  Input:   none
//  Output:  none
//  Purpose: initializes unit hydrograph processing data.
//
{
    let i,                             // UH group index
        j,                             // node index
        k,                             // UH index
        n;                             // RDII node index
//  int g,                             // rain gage index
    let month;                         // month index

    // --- initialize UHGroup entries for each Unit Hydrograph
    month = datetime_monthOfYear(StartDateTime) - 1;
    for (i=0; i<Nobjects[UNITHYD]; i++)
    {
        for (k=0; k<3; k++)
        {
            // --- make the first recorded rainfall begin a new RDII event
            // --- (new RDII event occurs when dry period > base of longest UH)
            UHGroup[i].uh[k].drySeconds =
                (UHGroup[i].uh[k].maxPeriods * UHGroup[i].rainInterval) + 1;
            UHGroup[i].uh[k].period = UHGroup[i].uh[k].maxPeriods + 1;
            UHGroup[i].uh[k].hasPastRain = false;

            // --- assign initial abstraction used
            UHGroup[i].uh[k].iaUsed = UnitHyd[i].iaInit[month][k];
        }

        // --- initialize gage date to simulation start date
        UHGroup[i].gageDate = StartDateTime;
        UHGroup[i].area = 0.0;
        UHGroup[i].rdii = 0.0;
    }

    // --- assume each UH group is not used
    for (i=0; i<Nobjects[UNITHYD]; i++) UHGroup[i].isUsed = false;

    // --- look at each node with RDII inflow
    for (n=0; n<NumRdiiNodes; n++)
    {
        // --- mark as used the UH group associated with the node
        j = RdiiNodeIndex[n];
        i = Node[j].rdiiInflow.unitHyd;
        UHGroup[i].isUsed = true;

        // --- add node's sewer area to UH group's area
        UHGroup[i].lastDate = StartDateTime;
        UHGroup[i].area += Node[j].rdiiInflow.area;
    }
}

//=============================================================================

openNewRdiiFile()
//
//  Input:   none
//  Output:  returns true if successful, false if not
//  Purpose: opens a new RDII interface file.
//
{
    let j;                             // node index

    // --- create a temporary file name if scratch file being used
    if ( Frdii.mode == SCRATCH_FILE ) getTempFileName(Frdii.name);

    // --- open the RDII file as a formatted text file
    Frdii.file = fopen(Frdii.name, "w+b");
    if ( Frdii.file == null )
    {
        return false;
    }

    // --- write file stamp to RDII file
    fwrite(FileStamp, sizeof(char), FileStamp.length, Frdii.file);

    // --- initialize the contents of the file with RDII time step (sec),
    //     number of RDII nodes, and index of each node
    fwrite(RdiiStep, sizeof(INT4), 1, Frdii.file);
    fwrite(NumRdiiNodes, sizeof(INT4), 1, Frdii.file);
    for (j=0; j<Nobjects[NODE]; j++)
    {
        if ( Node[j].rdiiInflow ) fwrite(j, sizeof(INT4), 1, Frdii.file);
    }
    return true;
}

//=============================================================================
// DateTime currentDate
getRainfall(currentDate)
//
//  Input:   currentDate = current calendar date/time
//  Output:  none
//  Purpose: determines rainfall at current RDII processing date.
//
//
{
    let      j;                        // UH group index
    let      k;                        // UH index
    let      g;                        // rain gage index
    let      i;                        // past rainfall index
    let      month;                    // month of current date
    let      rainInterval;             // rainfall interval (sec)
    let   rainDepth;                // rainfall depth (inches or mm)
    let   excessDepth;              // excess rainfall depth (inches or mm))
    let gageDate;                 // calendar date for rain gage

    // --- examine each UH group
    month = datetime_monthOfYear(currentDate) - 1;
    for (g = 0; g < Nobjects[GAGE]; g++) Gage[g].isCurrent = false;
    for (j = 0; j < Nobjects[UNITHYD]; j++)
    {
        // --- repeat until gage's date reaches or exceeds current date
        g = UnitHyd[j].rainGage;
        rainInterval = UHGroup[j].rainInterval;
        while ( UHGroup[j].gageDate < currentDate )
        {
            // --- get rainfall volume over gage's recording interval
            //     at gage'a current date (in original depth units)
            gageDate = UHGroup[j].gageDate;
            Adjust.rainFactor = Adjust.rain[datetime_monthOfYear(gageDate)-1];
            if (!Gage[g].isCurrent)
            {
                gage_setState(g, gageDate);
                Gage[g].isCurrent = true;
            }
            rainDepth = Gage[g].rainfall * rainInterval / 3600.0;

            // --- update amount of total rainfall volume (ft3)
            TotalRainVol += rainDepth / UCF(RAINDEPTH) * UHGroup[j].area;

            // --- compute rainfall excess for each UH in the group
            for (k=0; k<3; k++)
            {
                // --- adjust rainfall volume for any initial abstraction
                excessDepth = applyIA(j, k, gageDate, rainInterval, rainDepth);

                // --- adjust extent of dry period for the UH
                updateDryPeriod(j, k, excessDepth, rainInterval);

                // --- add rainfall to list of past values,
                //     wrapping array index if necessary
                i = UHGroup[j].uh[k].period;
                if ( i >= UHGroup[j].uh[k].maxPeriods ) i = 0;
                UHGroup[j].uh[k].pastRain[i] = excessDepth;
                UHGroup[j].uh[k].pastMonth[i] = month;
                UHGroup[j].uh[k].period = i + 1;
            }

            // --- advance rain date by gage recording interval
            UHGroup[j].gageDate = datetime_addSeconds(gageDate, rainInterval);
        }
    }
}

//=============================================================================
// int j, int k, DateTime aDate, double dt, double rainDepth
 applyIA(j, k, aDate, dt, rainDepth)
//
//  Input:   j = UH group index
//           k = unit hydrograph index
//           aDate = current date/time
//           dt = time interval (sec)
//           rainDepth = unadjusted rain depth (in or mm)
//  Output:  returns rainfall adjusted for initial abstraction (IA)
//  Purpose: adjusts rainfall for any initial abstraction and updates the
//           amount of available initial abstraction actually used.
//
{
    let m;
    let ia, netRainDepth;

    // --- determine amount of unused IA
    m = datetime_monthOfYear(aDate) - 1;
    ia = UnitHyd[j].iaMax[m][k] - UHGroup[j].uh[k].iaUsed;
    ia = Math.max(ia, 0.0);

    // --- case where there's some rainfall
    if ( rainDepth > 0.0 )
    {
        // --- reduce rain depth by unused IA
        netRainDepth = rainDepth - ia;
        netRainDepth = Math.max(netRainDepth, 0.0);

        // --- update amount of IA used up
        ia = rainDepth - netRainDepth;
        UHGroup[j].uh[k].iaUsed += ia;
    }

    // --- case where there's no rainfall
    else
    {
        // --- recover a portion of the IA already used
        UHGroup[j].uh[k].iaUsed -= dt / 86400. * UnitHyd[j].iaRecov[m][k];
        UHGroup[j].uh[k].iaUsed = Math.max(UHGroup[j].uh[k].iaUsed, 0.0);
        netRainDepth = 0.0;
    }
    return netRainDepth;
}

//=============================================================================
// int j, int k, double rainDepth, int rainInterval
updateDryPeriod(j, k, rainDepth, rainInterval)
//
//  Input:   j = UH group index
//           k = unit hydrograph index
//           rainDepth = excess rain depth (in or mm)
//           rainInterval = rainfall time interval (sec)
//  Output:  none
//  Purpose: adjusts the length of the dry period between rainfall events.
//
{
    let i;

    // --- if rainfall occurs
    if ( rainDepth > 0.0 )
    {
        // --- if previous dry period long enough then begin
        //     new RDII event with time period index set to 0
        if ( UHGroup[j].uh[k].drySeconds >= rainInterval *
            UHGroup[j].uh[k].maxPeriods )
        {
            for (i=0; i<UHGroup[j].uh[k].maxPeriods; i++)
            {
                UHGroup[j].uh[k].pastRain[i] = 0.0;
            }
            UHGroup[j].uh[k].period = 0;
        }
        UHGroup[j].uh[k].drySeconds = 0;
        UHGroup[j].uh[k].hasPastRain = true;
    }

    // --- if no rainfall, update duration of dry period
    else
    {
        UHGroup[j].uh[k].drySeconds += rainInterval;
        if ( UHGroup[j].uh[k].drySeconds >=
            rainInterval * UHGroup[j].uh[k].maxPeriods )
        {
            UHGroup[j].uh[k].hasPastRain = false;
        }
        else UHGroup[j].uh[k].hasPastRain = true;
    }
}

//=============================================================================
// DateTime currentDate
getUnitHydRdii(currentDate)
//
//  Input:   currentDate = current calendar date/time
//  Output:  none
//  Purpose: computes RDII generated by past rainfall for each UH group.
//
{
    let   j;                           // UH group index
    let   k;                           // UH index
    let   rainInterval;                // rainfall time interval (sec)

    // --- examine each UH group
    for (j=0; j<Nobjects[UNITHYD]; j++)
    {
        // --- skip calculation if group not used by any RDII node or if
        //     current date hasn't reached last date RDII was computed
        if ( !UHGroup[j].isUsed ) continue;
        if ( currentDate < UHGroup[j].lastDate ) continue;

        // --- update date RDII last computed
        UHGroup[j].lastDate = UHGroup[j].gageDate;

        // --- perform convolution for each UH in the group
        rainInterval = UHGroup[j].rainInterval;
        UHGroup[j].rdii = 0.0;
        for (k=0; k<3; k++)
        {
            if ( UHGroup[j].uh[k].hasPastRain )
            {
                UHGroup[j].rdii += getUnitHydConvol(j, k, rainInterval);
            }
        }
    }
}

//=============================================================================
// int j, int k, int rainInterval
getUnitHydConvol(j, k, rainInterval)
//
//  Input:   j = UH group index
//           k = UH index
//           rainInterval = rainfall time interval (sec)
//  Output:  returns a RDII flow value
//  Purpose: computes convolution of Unit Hydrographs with past rainfall.
//
{
    let    i;                          // previous rainfall period index
    let    m;                          // month of year index
    let    p;                          // UH time period index
    let    pMax;                       // max. number of periods
    let t;                          // UH time value (sec)
    let u;                          // UH ordinate
    let v;                          // rainfall volume
    let rdii;                       // RDII flow
    //TUHData* uh;                       // UH data
    let uh = [];

    // --- initialize RDII, rain period index and UH period index
    rdii = 0.0;
    uh = UHGroup[j].uh[k];
    i = uh.period - 1;
    if ( i < 0 ) i = uh.maxPeriods - 1;
    pMax = uh.maxPeriods;
    p = 1;

    // --- evaluate each time period of UH's
    while ( p < pMax )
    {
        // --- if rain period has rainfall
        v = uh.pastRain[i];
        m = uh.pastMonth[i];
        if ( v > 0.0 )
        {
            // --- find mid-point time of UH period in seconds
            t = ((p) - 0.5) * rainInterval;

            // --- convolute rain volume with UH ordinate
            u = getUnitHydOrd(j, m, k, t) * UnitHyd[j].r[m][k];
            rdii += u * v;
        }

        // --- move to next UH period & previous rainfall period
        p = p + 1;
        i = i - 1;
        if ( i < 0 ) i = uh.maxPeriods - 1;
    }
    return rdii;
}

//=============================================================================
// int h, int m, int k, double t
getUnitHydOrd(h, m, k, t)
//
//  Input:   h = index of UH group
//           m = month index
//           k = individual UH index
//           t = UH time (sec)
//  Output:  returns ordinate of a unit hydrograph
//  Purpose: gets ordinate of a particular unit hydrograph at specified time.
//
{
    let qPeak;                      // peak flow of unit hydrograph
    let f;                          // fraction of time to/from peak on UH
    let t1;                         // time to peak on UH (sec)
    let t2;                         // time after peak on UH (sec)
    let tBase;                      // base time of UH (sec)

    // --- return 0 if past end of UH time base
    tBase = UnitHyd[h].tBase[m][k];
    if ( t >= tBase ) return 0.0;

    // --- compute peak value of UH in original rainfall units (in/hr or mm/hr)
    qPeak = 2. / tBase * 3600.0;

    // --- break UH base into times before & after peak flow
    t1 = UnitHyd[h].tPeak[m][k];
    t2 = tBase - t1;

    // --- find UH flow at time t
    if ( t <= t1 ) f = t / t1;
    else           f = 1.0 - (t - t1) / t2;
    return Math.max(f, 0.0) * qPeak;
}

//=============================================================================

getNodeRdii()
//
//  Input:   none
//  Output:  returns true if any node has RDII inflow, false if not
//  Purpose: computes current RDII inflow at each node.
//
{
    let   hasRdii = false;             // true if any node has some RDII
    let   i;                           // UH group index
    let   j;                           // node index
    let   n;                           // number of nodes w/ RDII
    let rdii;                       // RDII flow (cfs)

    // --- examine each node w/ RDII data
    for (n = 0; n < NumRdiiNodes; n++)
    {
        // --- identify node's index in project's data base
        j = RdiiNodeIndex[n];

        // --- apply node's sewer area to UH RDII to get node RDII in CFS
        i = Node[j].rdiiInflow.unitHyd;
        rdii = UHGroup[i].rdii * Node[j].rdiiInflow.area / UCF(RAINFALL);
        if ( rdii < ZERO_RDII ) rdii = 0.0;
        else hasRdii = true;

        // --- update total RDII volume
        RdiiNodeFlow[n] = rdii;
        if ( rdii > 0.0 )
        {
            TotalRdiiVol += rdii * RdiiStep;
        }
    }
    return hasRdii;
}

//=============================================================================
// DateTime currentDate
saveRdiiFlows(currentDate)
//
//  Input:   currentDate = current calendar date/time
//  Output:  none
//  Purpose: saves current set of RDII inflows in current flow units to file.
//
{
    fwrite(currentDate, sizeof(DateTime), 1, Frdii.file);
    fwrite(RdiiNodeFlow, sizeof(REAL4), NumRdiiNodes, Frdii.file);
}

//=============================================================================

 closeRdiiProcessor()
//
//  Input:   none
//  Output:  none
//  Purpose: closes RDII processing system.
//
{
    // --- write rainfall & RDII totals to report file
    if ( !ErrorCode )
    {
        report_writeRdiiStats(TotalRainVol, TotalRdiiVol);
    }

    // --- free allocated memory and close RDII file
    freeRdiiMemory();
    if ( Frdii.file ) fclose(Frdii.file);
}

//=============================================================================

freeRdiiMemory()
//
//  Input:   none
//  Output:  none
//  Purpose: frees memory used for RDII processing.
//
{
    let i;
    let k;
    if ( UHGroup )
    {
        for (i = 0; i < Nobjects[UNITHYD]; i++)
        {
            for (k=0; k<3; k++)
            {
                FREE(UHGroup[i].uh[k].pastRain);
                FREE(UHGroup[i].uh[k].pastMonth);
            }
        }
        FREE(UHGroup);
    }
    FREE(RdiiNodeIndex);
    FREE(RdiiNodeFlow);
}


//-----------------------------------------------------------------------------
//   rain.c
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/14  (Build 5.1.001)
//            08/05/15  (Build 5.1.010)
//            08/22/16  (Build 5.1.011)
//            05/10/18  (Build 5.1.013)
//            03/01/20  (Build 5.1.014)
//   Author:  L. Rossman
//
//   Places rainfall data from external files into a SWMM rainfall
//   interface file.
//
//   The following types of external data files are supported:
//   NWS_TAPE:            NCDC NWS TD 3240 or 3260 data in fixed field widths
//   NWS_SPACE_DELIMITED: NCDC NWS TD (DSI) 3240 or 3260 data in space delimited
//                        format, with or without header lines, with or without
//                        station name
//   NWS_COMMA_DELIMITED: NCDC NWS TD (DSI) 3240 or 3260 data in comma delimited
//                        format, with or without header lines
//   NWS_ONLINE_60:       NCDC NWS hourly space delimited online format
//   NWS_ONLINE_15:       NCDC NWS fifteen minute space delimited online format
//   AES_HLY:             Canadian AES hourly data with 3-digit year
//   CMC_HLY:             Canadian CMC hourly data in HLY03 or HLY21 format
//   CMC_FIF:             Canadian CMC fifteen minute data in in FIF21 format
//   STD_SPACE_DELIMITED: standard SWMM space delimted format:
//                        StaID  Year  Month  Day  Hour  Minute  Rainfall
//
//   The layout of the SWMM binary rainfall interface file is:
//     File stamp ("SWMM5-RAIN") (10 bytes)
//     Number of SWMM rain gages in file (4-byte int)
//     Repeated for each rain gage:
//       recording station ID (not SWMM rain gage ID) (MAXMSG+1 (=80) bytes)
//       gage recording interval (seconds) (4-byte int)
//       starting byte of rain data in file (4-byte int)
//       ending byte+1 of rain data in file (4-byte int)
//     For each gage:
//       For each time period with non-zero rain:
//         Date/time for start of period (8-byte double)
//         Rain depth (inches) (4-byte float)
//
//   Release 5.1.010:
//   - Modified error message for records out of sequence in std. format file.
//
//   Release 5.1.011:
//   - Can now read decimal rainfall values in newer NWS online format.
//
//   Release 5.1.013:
//   - Variable x properly initialized with float value in readNwsOnlineValue().
//
//   Release 5.1.014:
//   - Fixed indexing bug in rainFileConflict() function.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
//enum RainFileFormat {
    UNKNOWN_FORMAT = 0 
    NWS_TAPE       = 1
    NWS_SPACE_DELIMITED = 2
    NWS_COMMA_DELIMITED = 3
    NWS_ONLINE_60 = 4
    NWS_ONLINE_15 = 5
    AES_HLY = 6 
    CMC_HLY = 7
    CMC_FIF = 8
    STD_SPACE_DELIMITED = 9
    
    
    //enum ConditionCodes {
    NO_CONDITION = 0 
    ACCUMULATED_PERIOD = 1 
    DELETED_PERIOD = 2
    MISSING_PERIOD = 3
    
    //-----------------------------------------------------------------------------
    //  Shared variables
    //-----------------------------------------------------------------------------
    RainStats = new TRainStats();      // TRainStats              // see objects.h for definition
           Condition;                  // rainfall condition code
           TimeOffset;                 // time offset of rainfall reading (sec)
           DataOffset;                 // start of data on line of input
           ValueOffset;                // start of rain value on input line
           RainType;                   // rain measurement type code
           Interval;                   // rain measurement interval (sec)
           UnitsFactor;                // units conversion factor
           RainAccum;                  // rainfall depth accumulation
           StationID;                  // station ID appearing in rain file
           AccumStartDate;             // date when accumulation begins
           PreviousDate;               // date of previous rainfall record
           GageIndex;                  // index of rain gage analyzed
           hasStationName;             // true if data contains station name
    
    //-----------------------------------------------------------------------------
    //  External functions (declared in funcs.h)
    //-----------------------------------------------------------------------------
    //  rain_open   (called by swmm_start in swmm5.c)
    //  rain_close  (called by swmm_end in swmm5.c)
    
    //=============================================================================
    // void
     rain_open()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: opens binary rain interface file and RDII processor.
    //
    {
        let i;
        let count;
    
        // --- see how many gages get their data from a file
        count = 0;
        for (i = 0; i < Nobjects[GAGE]; i++)
        {
            if ( Gage[i].dataSource == RAIN_FILE ) count++;
        }
        Frain.file = null;
        if ( count == 0 )
        {
            Frain.mode = NO_FILE;
        }
    
        // --- see what kind of rain interface file to open
        else switch ( Frain.mode )
        {
          case SCRATCH_FILE:
            getTempFileName(Frain.name);
            if ( (Frain.file = fopen(Frain.name, "w+b")) == null)
            {
                report_writeErrorMsg(ERR_RAIN_FILE_SCRATCH, "");
                return;
            }
            break;
    
          case USE_FILE:
            if ( (Frain.file = fopen(Frain.name, "r+b")) == null)
            {
                report_writeErrorMsg(ERR_RAIN_FILE_OPEN, Frain.name);
                return;
            }
            break;
    
          case SAVE_FILE:
            if ( (Frain.file = fopen(Frain.name, "w+b")) == null)
            {
                report_writeErrorMsg(ERR_RAIN_FILE_OPEN, Frain.name);
                return;
            }
            break;
        }
    
        // --- create new rain file if required
        if ( Frain.mode == SCRATCH_FILE || Frain.mode == SAVE_FILE )
        {
            createRainFile(count);
        }
    
        // --- initialize rain file
        if ( Frain.mode != NO_FILE ) initRainFile();
    
        // --- open RDII processor (creates/opens a RDII interface file)
        rdii_openRdii();
    }
    
    //=============================================================================
    // void
    rain_close()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: closes rain interface file and RDII processor.
    //
    {
        if ( Frain.file )
        {
            fclose(Frain.file);
            if ( Frain.mode == SCRATCH_FILE ) remove(Frain.name);
        }
        Frain.file = null;
        rdii_closeRdii();
    }
    
    //=============================================================================
    // int count
    createRainFile(count)
    //
    //  Input:   count = number of files to include in rain interface file
    //  Output:  none
    //  Purpose: adds rain data from all rain gage files to the interface file.
    //
    {
        let   i, k;
        let   kount = count;               // number of gages in data file
        let   filePos1;                    // starting byte of gage's header data
        let   filePos2;                    // starting byte of gage's rain data
        let   filePos3;                    // starting byte of next gage's data
        let   interval;                    // recording interval (sec)
        let   dummy = -1;
        let   staID;             // gage's ID name
        let   fileStamp = "SWMM5-RAIN";
    
        // --- make sure interface file is open and no error condition
        if ( ErrorCode || !Frain.file ) return;
    
        // --- write file stamp & # gages to file
        fwrite(fileStamp, sizeof(char), fileStamp.length, Frain.file);
        fwrite(kount, sizeof(int), 1, Frain.file);
        filePos1 = ftell(Frain.file);
    
        // --- write default fill-in header records to file for each gage
        //     (will be replaced later with actual records)
        if ( count > 0 ) report_writeRainStats(-1, RainStats);
        for ( i = 0;  i < count; i++ )
        {
            fwrite(staID, sizeof(char), MAXMSG+1, Frain.file);
            for ( k = 1; k <= 3; k++ )
                fwrite(dummy, sizeof(int), 1, Frain.file);
        }
        filePos2 = ftell(Frain.file);
    
        // --- loop through project's  rain gages,
        //     looking for ones using rain files
        for ( i = 0; i < Nobjects[GAGE]; i++ )
        {
            if ( ErrorCode || Gage[i].dataSource != RAIN_FILE ) continue;
            if ( rainFileConflict(i) ) break;
    
            // --- position rain file to where data for gage will begin
            fseek(Frain.file, filePos2, SEEK_SET);
    
            // --- add gage's data to rain file
            if ( addGageToRainFile(i) )
            {
                // --- write header records for gage to beginning of rain file
                filePos3 = ftell(Frain.file);
                fseek(Frain.file, filePos1, SEEK_SET);
                sstrncpy(staID, Gage[i].staID, MAXMSG);
                interval = Interval;
                fwrite(staID,      sizeof(char), MAXMSG+1, Frain.file);
                fwrite(interval,  sizeof(int), 1, Frain.file);
                fwrite(filePos2,  sizeof(int), 1, Frain.file);
                fwrite(filePos3,  sizeof(int), 1, Frain.file);
                filePos1 = ftell(Frain.file);
                filePos2 = filePos3;
                report_writeRainStats(i, RainStats);
            }
        }
    
        // --- if there was an error condition, then delete newly created file
        if ( ErrorCode )
        {
            fclose(Frain.file);
            Frain.file = null;
            remove(Frain.name);
        }
    }
    
    //=============================================================================
    // int i
    rainFileConflict(i)
    //
    //  Input:   i = rain gage index
    //  Output:  returns 1 if file conflict found, 0 if not
    //  Purpose: checks if a rain gage's station ID matches another gage's
    //           station ID but the two use different rain data files.
    //
    {
        let j;
        let staID = Gage[i].staID;
        let fname = Gage[i].fname;
        for (j = 0; j < i; j++)
        {
            if ( strcomp(Gage[j].staID, staID) && !strcomp(Gage[j].fname, fname) )
            {
                report_writeErrorMsg(ERR_RAIN_FILE_CONFLICT, Gage[i].ID);
                return 1;
            }
        }
        return 0;
    }
    
    //=============================================================================
    // int i
    addGageToRainFile(i)
    //
    //  Input:   i = rain gage index
    //  Output:  returns 1 if successful, 0 if not
    //  Purpose: adds a gage's rainfall record to rain interface file
    //
    {
        //FILE* f;                           // pointer to rain file
        let   f;
        let   fileFormat;                  // file format code
        let   hdrLines;                    // number of header lines skipped
    
        // --- let StationID point to null
        StationID = null;
    
        // --- check that rain file exists
        if ( (f = fopen(Gage[i].fname, "rt")) == null )
            report_writeErrorMsg(ERR_RAIN_FILE_DATA, Gage[i].fname);
        else
        {
            fileFormat = findFileFormat(f, i, hdrLines);
            if ( fileFormat == UNKNOWN_FORMAT )
            {
                report_writeErrorMsg(ERR_RAIN_FILE_FORMAT, Gage[i].fname);
            }
            else
            {
                GageIndex = i;
                readFile(f, fileFormat, hdrLines, Gage[i].startFileDate,
                         Gage[i].endFileDate);
            }
            fclose(f);
        }
        if ( ErrorCode ) return 0;
        else
        return 1;
    }
    
    //=============================================================================
    // void
    initRainFile()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: initializes rain interface file for reading.
    //
    {
        let  fileStamp = "SWMM5-RAIN";
        let  fStamp = "SWMM5-RAIN";
        let  i;
        let  kount;
        let  filePos;
    
        // --- make sure interface file is open and no error condition
        if ( ErrorCode || !Frain.file ) return;
    
        // --- check that interface file contains proper file stamp
        rewind(Frain.file);
        fread(fStamp, sizeof(char), fileStamp.length, Frain.file);
        if ( strcmp(fStamp, fileStamp) != 0 )
        {
            report_writeErrorMsg(ERR_RAIN_IFACE_FORMAT, "");
            return;
        }
        fread(kount, sizeof(int), 1, Frain.file);
        filePos = ftell(Frain.file);
    
        // --- locate information for each raingage in interface file
        for ( i = 0; i < Nobjects[GAGE]; i++ )
        {
            if ( ErrorCode || Gage[i].dataSource != RAIN_FILE ) continue;
    
            // --- match station ID for gage with one in file
            fseek(Frain.file, filePos, SEEK_SET);
            if ( !findGageInFile(i, kount) ||
                 Gage[i].startFilePos == Gage[i].endFilePos )
            {
                report_writeErrorMsg(ERR_RAIN_FILE_GAGE, Gage[i].ID);
            }
        }
    }
    
    //=============================================================================
    // int i, int kount
    findGageInFile(i, kount)
    //
    //  Input:   i     = rain gage index
    //           kount = number of rain gages stored on interface file
    //  Output:  returns true if successful, false if not
    //  Purpose: checks if rain gage's station ID appears in interface file.
    //
    {
        let  k;
        let  interval;
        let  filePos1, filePos2;
        let  staID;
    
        for ( k = 1; k <= kount; k++ )
        {
            fread(staID,      sizeof(char), MAXMSG+1, Frain.file);
            fread(interval,  sizeof(int), 1, Frain.file);
            fread(filePos1,  sizeof(int), 1, Frain.file);
            fread(filePos2,  sizeof(int), 1, Frain.file);
            if ( strcmp(staID, Gage[i].staID) == 0 )
            {
                // --- match found; save file parameters
                Gage[i].rainType     = RAINFALL_VOLUME;
                Gage[i].rainInterval = interval;
                Gage[i].startFilePos = filePos1;
                Gage[i].endFilePos   = filePos2;
                Gage[i].currentFilePos = Gage[i].startFilePos;
                return true;
            }
        }
        return false;
    }
    
    //=============================================================================
    // FILE *f, int i, int *hdrLines
    findFileFormat(f, i, hdrLines)
    //
    //  Input:   f = ptr. to rain gage's rainfall data file
    //           i = rain gage index
    //  Output:  hdrLines  = number of header lines found in data file;
    //           returns type of format used in a rainfall data file
    //  Purpose: finds the format of a gage's rainfall data file.
    //
    {
        let   fileFormat;
        let   lineCount;
        let   maxCount = 5;
        let   n;
        let   div;
        let  sn2;
        let  recdType;
        let  elemType;
        let  coopID;
        let  line;
        let   year, month, day, hour, minute;
        let   elem;
        let x;
    
        // --- check first few lines for known formats
        fileFormat = UNKNOWN_FORMAT;
        hasStationName = false;
        UnitsFactor = 1.0;
        Interval = 0;
        hdrLines = 0;
        for (lineCount = 1; lineCount <= maxCount; lineCount++)
        {
            if ( fgets(line, MAXLINE, f) == null ) return fileFormat;
    
            // --- check for NWS space delimited format
            n = sscanf(line, "%6ld %2d %4s", sn2, div, elemType);
            if ( n == 3 )
            {
                Interval = getNWSInterval(elemType);
                TimeOffset = Interval;
                if ( Interval > 0 )
                {
                    fileFormat = NWS_SPACE_DELIMITED;
                    break;
                }
            }
    
            // --- check for NWS space delimited format w/ station name
            n = sscanf(line[37], "%2d %4s %2s %4d", div, elemType, recdType, year);
            if ( n == 4 )
            {
                Interval = getNWSInterval(elemType);
                TimeOffset = Interval;
                if ( Interval > 0 )
                {
                    fileFormat = NWS_SPACE_DELIMITED;
                    hasStationName = true;
                    break;
                }
            }
    
            // --- check for NWS coma delimited format
            n = sscanf(line, "%6ld,%2d,%4s", sn2, div, elemType);
            if ( n == 3 )
            {
                Interval = getNWSInterval(elemType);
                TimeOffset = Interval;
                if ( Interval > 0 )
                {
                    fileFormat = NWS_COMMA_DELIMITED;
                    break;
                }
            }
    
            // --- check for NWS comma delimited format w/ station name
            n = sscanf(line[37], "%2d,%4s,%2s,%4d", div, elemType, recdType, year);
            if ( n == 4 )
            {
                Interval = getNWSInterval(elemType);
                TimeOffset = Interval;
                if ( Interval > 0 )
                {
                    fileFormat = NWS_COMMA_DELIMITED;
                    hasStationName = true;
                    break;
                }
            }
    
            // --- check for NWS TAPE format
            n = sscanf(line, "%3s%6ld%2d%4s", recdType, sn2, div, elemType);
            if ( n == 4 )
            {
                Interval = getNWSInterval(elemType);
                TimeOffset = Interval;
                if ( Interval > 0 )
                {
                    fileFormat = NWS_TAPE;
                    break;
                }
            }
    
            // --- check for NWS Online Retrieval format
            n = sscanf(line, "%5s%6ld", coopID, sn2);
            if ( n == 2 && strcmp(coopID, "COOP:") == 0 )
            {
                fileFormat = findNWSOnlineFormat(f, line);
                break;
            }
    
            // --- check for AES type
            n = sscanf(line, "%7ld%3d%2d%2d%3d", sn2, year, month, day, elem);
            if ( n == 5 )
            {
                if ( elem == 123 && line.length >= 185 )
                {
                    fileFormat = AES_HLY;
                    Interval = 3600;
                    TimeOffset = Interval;
                    UnitsFactor = 1.0/MMperINCH;
                    break;
                }
            }
    
            // --- check for CMC types
            n = sscanf(line, "%7ld%4d%2d%2d%3d", sn2, year, month, day, elem);
            if ( n == 5 )
            {
                if ( elem == 159 && line.length >= 691 )
                {
                    fileFormat = CMC_FIF;
                    Interval = 900;
                }
                else if ( elem == 123 && line.length >= 186 )
                {
                    fileFormat = CMC_HLY;
                    Interval = 3600;
                }
                if ( fileFormat == CMC_FIF || fileFormat == CMC_HLY )
                {
                    TimeOffset = Interval;
                    UnitsFactor = 1.0/MMperINCH;
                    break;
                }
            }
    
            // --- check for standard format
            if ( parseStdLine(line, year, month, day, hour, minute, x) )
            {
                fileFormat = STD_SPACE_DELIMITED;
                RainType = Gage[i].rainType;
                Interval = Gage[i].rainInterval;
                if ( Gage[i].rainUnits == SI ) UnitsFactor = 1.0/MMperINCH;
                TimeOffset = 0;
                StationID = Gage[i].staID;
                break;
            }
            (hdrLines)++;
    
        }
        if ( fileFormat != UNKNOWN_FORMAT ) Gage[i].rainInterval = Interval;
        return fileFormat;
    }
    
    //=============================================================================
    // FILE *f, char *line
    findNWSOnlineFormat(f, line)
    //
    //  Input:   f = pointer to rainfall data file
    //           line = line read from rainfall data file
    //  Output:
    //  Purpose: determines the file format for an NWS Online Retrieval data file.
    //
    {
        let n;
        let fileFormat = UNKNOWN_FORMAT;
        let str;
    
        // --- read in the first header line of the file
        rewind(f);
        fgets(line, MAXLINE, f);
    
        // --- if 'HPCP' appears then file is for hourly data
        if ( (str = strstr(line, "HPCP")) != null )
        {
            Interval = 3600;
            TimeOffset = Interval;
            ValueOffset = str - line;
            fileFormat = NWS_ONLINE_60;
        }
    
        // --- if 'QPCP" appears then file is for 15 minute data
        else if ( (str = strstr(line, "QPCP")) != null )
        {
            Interval = 900;
            TimeOffset = Interval;
            ValueOffset = str - line;
            fileFormat = NWS_ONLINE_15;
        }
        else return UNKNOWN_FORMAT;
    
        // --- find position in line where rainfall date begins
        //     (11 characters before last occurrence of ':')
        // --- read in first line of data
        for (n = 1; n <= 5; n++)
        {
            if ( fgets(line, MAXLINE, f) == null ) return UNKNOWN_FORMAT;
            if ( strstr(line, "COOP:") == null ) continue;
    
            // --- find pointer to last occurrence of time separator character (':')
            str = strrchr(line, ':');
            if ( str == null ) return UNKNOWN_FORMAT;
    
            // --- use pointer arithmetic to convert pointer to character position
            n = str - line;
            DataOffset = n - 11;
            return fileFormat;
        }
        return UNKNOWN_FORMAT;
    }
    
    //=============================================================================
    // char *elemType
    getNWSInterval(elemType)
    //
    //  Input:   elemType = code from NWS rainfall file
    //  Output:  returns rainfall recording interval (sec)
    //  Purpose: decodes NWS rain gage recording interval value
    //
    {
        if      ( strcmp(elemType, "HPCP") == 0 ) return 3600; // 1 hr rainfall
        else if ( strcmp(elemType, "QPCP") == 0 ) return 900;  // 15 min rainfall
        else if ( strcmp(elemType, "QGAG") == 0 ) return 900;  // 15 min rainfall
        else return 0;
    }
    
    //=============================================================================
    // FILE *f, int fileFormat, int hdrLines, DateTime day1,
    //    DateTime day2
    readFile(f, fileFormat, hdrLines, day1, day2)
    //
    //  Input:   f          = ptr. to gage's rainfall data file
    //           fileFormat = code of data file's format
    //           hdrLines   = number of header lines in data file
    //           day1       = starting day of record of interest
    //           day2       = ending day of record of interest
    //  Output:  none
    //  Purpose: reads rainfall records from gage's data file to interface file.
    //
    {
        let line;
        let  i, n;
    
        rewind(f);
        RainStats.startDate  = NO_DATE;
        RainStats.endDate    = NO_DATE;
        RainStats.periodsRain = 0;
        RainStats.periodsMissing = 0;
        RainStats.periodsMalfunc = 0;
        RainAccum = 0.0;
        AccumStartDate = NO_DATE;
        PreviousDate = NO_DATE;
    
        for (i = 1; i <= hdrLines; i++)
        {
            if ( fgets(line, MAXLINE, f) == null ) return;
        }
        while ( fgets(line, MAXLINE, f) != null )
        {
           switch (fileFormat)
           {
             case STD_SPACE_DELIMITED:
              n = readStdLine(line, day1, day2);
              break;
    
             case NWS_TAPE:
             case NWS_SPACE_DELIMITED:
             case NWS_COMMA_DELIMITED:
             case NWS_ONLINE_60:
             case NWS_ONLINE_15:
               n = readNWSLine(line, fileFormat, day1, day2);
               break;
    
             case AES_HLY:
             case CMC_FIF:
             case CMC_HLY:
               n = readCMCLine(line, fileFormat, day1, day2);
               break;
    
             default:
               n = -1;
               break;
           }
           if ( n < 0 ) break;
        }
    }
    
    //=============================================================================
    // char *line, int fileFormat, DateTime day1, DateTime day2
    readNWSLine(line, fileFormat, day1, day2)
    //
    //  Input:   line       = line of data from rainfall data file
    //           fileFormat = code of data file's format
    //           day1       = starting day of record of interest
    //           day2       = ending day of record of interest
    //  Output:  returns -1 if past end of desired record, 0 if data line could
    //           not be read successfully or 1 if line read successfully
    //  Purpose: reads a line of data from a rainfall data file and writes its
    //           data to the rain interface file.
    //
    {
        let      flag1, flag2, isMissing;
        let      date1;
        let      result = 1;
        let      k, y, m, d, n;
        let      hour, minute;
        let      v;
        let      x;
        let      lineLength = line.length-1;
        let      nameLength = 0;
    
        // --- get year, month, & day from line
        switch ( fileFormat )
        {
          case NWS_TAPE:
            if ( lineLength <= 30 ) return 0;
            if (sscanf(line[17], "%4d%2d%4d%3d", y, m, d, n) < 4) return 0;
            k = 30;
            break;
    
          case NWS_SPACE_DELIMITED:
            if ( hasStationName ) nameLength = 31;
            if ( lineLength <= 28 + nameLength ) return 0;
            k = 18 + nameLength;
            if (sscanf(line[k], "%4d %2d %2d", y, m, d) < 3) return 0;
            k = k + 10;
            break;
    
          case NWS_COMMA_DELIMITED:
            if ( lineLength <= 28 ) return 0;
            if ( sscanf(line[18], "%4d,%2d,%2d", y, m, d) < 3 ) return 0;
            k = 28;
            break;
    
          case NWS_ONLINE_60:
          case NWS_ONLINE_15:
            if ( lineLength <= DataOffset + 23 ) return 0;
            if ( sscanf(line[DataOffset], "%4d%2d%2d", y, m, d) < 3 ) return 0;
            k = DataOffset + 8;
            break;
    
          default: return 0;
        }
    
        // --- see if date is within period of record requested
        date1 = datetime_encodeDate(y, m, d);
        if ( day1 != NO_DATE && date1 < day1 ) return 0;
        if ( day2 != NO_DATE && date1 > day2 ) return -1;
    
        // --- read each recorded rainfall time, value, & codes from line
        while ( k < lineLength )
        {
            flag1 = 0;
            flag2 = 0;
            v = 99999;
            hour = 25;
            minute = 0;
            switch ( fileFormat )
            {
              case NWS_TAPE:
                n = sscanf(line[k], "%2d%2d%6ld%c%c",
                           hour, minute, v, flag1, flag2);
                k += 12;
                break;
    
              case NWS_SPACE_DELIMITED:
                n = sscanf(line[k], " %2d%2d %6ld %c %c",
                           hour, minute, v, flag1, flag2);
                k += 16;
                break;
    
              case NWS_COMMA_DELIMITED:
                n = sscanf(line[k], ",%2d%2d,%6ld,%c,%c",
                           hour, minute, v, flag1, flag2);
                k += 16;
                break;
    
              case NWS_ONLINE_60:
              case NWS_ONLINE_15:
                  n = sscanf(line[k], " %2d:%2d", hour, minute);
                  n += readNwsOnlineValue(line[ValueOffset], v, flag1);
    
                  // --- ending hour 0 is really hour 24 of previous day
                  if ( hour == 0 )
                  {
                      hour = 24;
                      date1 -= 1.0;
                  }
                  k += lineLength;
                  break;
    
              default: n = 0;
            }
    
            // --- check that we at least have an hour, minute & value
            //     (codes might be left off of the line)
            if ( n < 3 || hour >= 25 ) break;
    
            // --- set special condition code & update daily & hourly counts
    
            setCondition(flag1);
            if ( Condition == DELETED_PERIOD ||
                 Condition == MISSING_PERIOD ||
                 flag1 == 'M' ) isMissing = true;
            else if ( v >= 9999 ) isMissing = true;
            else isMissing = false;
    
            // --- handle accumulation codes
            if ( flag1 == 'a' )
            {
                AccumStartDate = date1 + datetime_encodeTime(hour, minute, 0);
            }
            else if ( flag1 == 'A' )
            {
                saveAccumRainfall(date1, hour, minute, v);
            }
    
            // --- handle all other conditions
            else
            {
                // --- convert rain measurement to inches & save it
                x = v / 100.0;
                if ( x > 0 || isMissing )
                    saveRainfall(date1, hour, minute, x, isMissing);
            }
    
            // --- reset condition code if special condition period ended
            if ( flag1 == 'A' || flag1 == '}' || flag1 == ']') Condition = 0;
        }
        return result;
    }
    
    //=============================================================================
    // char* s, long* v, char* flag
    readNwsOnlineValue(s, v, flag)
    //
    //  Input:   s = portion of rainfall record in NWS online format
    //  Output:  v = rainfall amount in hundreths of an inch
    //           flag = special condition flag
    //           returns number of items read from s.
    //  Purpose: reads rainfall value and condition flag from a NWS online
    //           rainfall record.
    //
    {
        let    n;
        let  x = 99.99;                                                         //(5.1.013)
    
        // --- check for newer format of decimal inches
        if ( strchr(s, '.') )
        {
            n = sscanf(s, "%f %c", x, flag);
    
            // --- convert to integer hundreths of an inch
            v = (100.0 * x + 0.5);
        }
    
        // --- older format of hundreths of an inch
        else n = sscanf(s, "%ld %c", v, flag);
        return n;
    }
    
    //=============================================================================
    // char flag
     setCondition(flag)
    {
        switch ( flag )
        {
          case 'a':
          case 'A':
            Condition = ACCUMULATED_PERIOD;
            break;
          case '{':
          case '}':
            Condition = DELETED_PERIOD;
            break;
          case '[':
          case ']':
            Condition = MISSING_PERIOD;
            break;
          default:
            Condition = NO_CONDITION;
        }
    }
    
    //=============================================================================
    // char *line, int fileFormat, DateTime day1, DateTime day2
    readCMCLine(line, fileFormat, day1, day2)
    //
    //  Input:   line = line of data from rainfall data file
    //           fileFormat = code of data file's format
    //           day1 = starting day of record of interest
    //           day2 = ending day of record of interest
    //  Output:  returns -1 if past end of desired record, 0 if data line could
    //           not be read successfully or 1 if line read successfully
    //  Purpose: reads a line of data from an AES or CMC rainfall data file and
    //           writes its data to the rain interface file.
    //
    {
        let     flag, isMissing;
        let     date1;
        let     sn, v;
        let     col, j, jMax, elem, y, m, d, hour, minute;
        let     x;
    
        // --- get year, month, day & element code from line
        if ( fileFormat == AES_HLY )
        {
            if ( sscanf(line, "%7ld%3d%2d%2d%3d", sn, y, m, d, elem) < 5 )
                return 0;
            if ( y < 100 ) y = y + 2000;
            else           y = y + 1000;
            col = 17;
        }
        else
        {
            if ( sscanf(line, "%7ld%4d%2d%2d%3d", sn, y, m, d, elem) < 5 )
                return 0;
            col = 18;
        }
    
        // --- see if date is within period of record requested
        date1 = datetime_encodeDate(y, m, d);
        if ( day1 != NO_DATE && date1 < day1 ) return 0;
        if ( day2 != NO_DATE && date1 > day2 ) return -1;
    
        // --- make sure element code is for rainfall
        if ( fileFormat == AES_HLY && elem != 123 ) return 0;
        else if ( fileFormat == CMC_FIF && elem != 159 ) return 0;
        else if ( fileFormat == CMC_HLY && elem != 123 ) return 0;
    
        // --- read rainfall from each recording interval
        hour = 0;                          // starting hour
        minute = 0;                        // starting minute
        jMax = 24;                         // # recording intervals
        if ( fileFormat == CMC_FIF ) jMax = 96;
        for (j=1; j<=jMax; j++)
        {
            if ( sscanf(line[col], "%6ld%c", v, flag) < 2 ) return 0;
            col += 7;
            if ( v == -99999 ) isMissing = true;
            else               isMissing = false;
    
            // --- convert rain measurement from 0.1 mm to inches and save it
            x = (float)( v / 10.0 / MMperINCH);
            if ( x > 0 || isMissing)
            {
                saveRainfall(date1, hour, minute, x, isMissing);
            }
    
            // --- update hour & minute for next interval
            if ( fileFormat == CMC_FIF )
            {
                minute += 15;
                if ( minute == 60 )
                {
                    minute = 0;
                    hour++;
                }
            }
            else hour++;
        }
        return 1;
    }
    
    //=============================================================================
    // char *line, DateTime day1, DateTime day2
    readStdLine(line, day1, day2)
    //
    //  Input:   line = line of data from a standard rainfall data file
    //           day1 = starting day of record of interest
    //           day2 = ending day of record of interest
    //  Output:  returns -1 if past end of desired record, 0 if data line could
    //           not be read successfully or 1 if line read successfully
    //  Purpose: reads a line of data from a standard rainfall data file and
    //           writes its data to the rain interface file.
    //
    {
        let date1;
        let date2;
        let      year, month, day, hour, minute;
        let    x;
    
        // --- parse data from input line
        if (!parseStdLine(line, year, month, day, hour, minute, x)) return 0;
    
        // --- see if date is within period of record requested
        date1 = datetime_encodeDate(year, month, day);
        if ( day1 != NO_DATE && date1 < day1 ) return 0;
        if ( day2 != NO_DATE && date1 > day2 ) return -1;
    
        // --- see if record is out of sequence
        date2 = date1 + datetime_encodeTime(hour, minute, 0);
        if ( date2 <= PreviousDate )
        {
            report_writeErrorMsg(ERR_RAIN_FILE_SEQUENCE, Gage[GageIndex].fname);
            report_writeLine(line);
            return -1;
        }
        PreviousDate = date2;
    
        switch (RainType)
        {
          case RAINFALL_INTENSITY:
            x = x * Interval / 3600.0;
            break;
    
          case CUMULATIVE_RAINFALL:
            if ( x >= RainAccum )
            {
                x = x - RainAccum;
                RainAccum += x;
            }
            else RainAccum = x;
            break;
        }
        x *= UnitsFactor;
    
        // --- save rainfall to binary interface file
        saveRainfall(date1, hour, minute, x, false);
        return 1;
    }
    
    //=============================================================================
    // char *line, int *year, int *month, int *day, int *hour,
    //    int *minute, float *value
    parseStdLine(line, year, month, day, hour, minute, value)
    //
    //  Input:   line = line of data from a standard rainfall data file
    //  Output:  *year = year when rainfall occurs
    //           *month = month of year when rainfall occurs
    //           *day = day of month when rainfall occurs
    //           *hour = hour of day when rainfall occurs
    //           *minute = minute of hour when rainfall occurs
    //           *value = rainfall value (user units);
    //           returns 0 if data line could not be parsed successfully or
    //           1 if line parsed successfully
    //  Purpose: parses a line of data from a standard rainfall data file.
    //
    {
        let n;
        let token;
    
        n = sscanf(line, "%s %d %d %d %d %d %f", token, year, month, day, hour, minute, value);
        if ( n < 7 ) return 0;
        if ( StationID != null && !strcomp(token, StationID) ) return 0;
        return 1;
    }
    
    //=============================================================================
    // DateTime date1, int hour, int minute, long v
    saveAccumRainfall(date1, hour, minute, v)
    //
    //  Input:   date1 = date of latest rainfall reading (in DateTime format)
    //           hour = hour of day of latest rain reading
    //           minute = minute of hour of latest rain reading
    //           v = accumulated rainfall reading in hundreths of inches
    //  Output:  none
    //  Purpose: divides accumulated rainfall evenly into individual recording
    //           periods over the accumulation period and writes each period's
    //           rainfall to the binary rainfall file.
    //
    {
        let date2;
        let n, j;
        let x;
    
        // --- return if accumulated start date is missing
        if ( AccumStartDate == NO_DATE ) return;
    
        // --- find number of recording intervals over accumulation period
        date2 = date1 + datetime_encodeTime(hour, minute, 0);
        n = (datetime_timeDiff(date2, AccumStartDate) / Interval) + 1;
    
        // --- update count of rain or missing periods
        if ( v == 99999 )
        {
            RainStats.periodsMissing += n;
            return;
        }
        RainStats.periodsRain += n;
    
        // --- divide accumulated amount evenly into each period
        x = v / n / 100.0;
    
        // --- save this amount to file for each period
        if ( x > 0.0 )
        {
            date2 = datetime_addSeconds(AccumStartDate, -TimeOffset);
            if ( RainStats.startDate == NO_DATE ) RainStats.startDate = date2;
            for (j = 0; j < n; j++)
            {
                fwrite(date2, sizeof(DateTime), 1, Frain.file);
                fwrite(x, sizeof(float), 1, Frain.file);
                date2 = datetime_addSeconds(date2, Interval);
                RainStats.endDate = date2;
            }
        }
    
        // --- reset start of accumulation period
        AccumStartDate = NO_DATE;
    }
    
    
    //=============================================================================
    // DateTime date1, int hour, int minute, float x, char isMissing
    saveRainfall(date1, hour, minute, x, isMissing)
    //
    //  Input:   date1 = date of rainfall reading (in DateTime format)
    //           hour = hour of day of current rain reading
    //           minute = minute of hour of current rain reading
    //           x = rainfall reading in inches
    //           isMissing = true if rainfall value is missing
    //  Output:  none
    //  Purpose: writes current rainfall reading from an external rainfall file
    //           to project's binary rainfall file.
    //
    {
        let date2;
        let seconds;
    
        if ( isMissing ) RainStats.periodsMissing++;
        else             RainStats.periodsRain++;
    
        // --- if rainfall not missing then save it to rainfall interface file
        if ( !isMissing )
        {
            seconds = 3600*hour + 60*minute - TimeOffset;
            date2 = datetime_addSeconds(date1, seconds);
    
            // --- write date & value (in inches) to interface file
            fwrite(date2, sizeof(DateTime), 1, Frain.file);
            fwrite(x, sizeof(float), 1, Frain.file);
    
            // --- update actual start & end of record dates
            if ( RainStats.startDate == NO_DATE ) RainStats.startDate = date2;
            RainStats.endDate = date2;
        }
    }
    //=============================================================================
    
//-----------------------------------------------------------------------------
//   landuse.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14  (Build 5.1.001)
//             03/19/15  (Build 5.1.008)
//   Author:   L. Rossman
//
//   Pollutant buildup and washoff functions.
//
//   Build 5.1.008:
//   - landuse_getWashoffMass() re-named to landuse_getWashoffQual() and
//     modified to return concentration instead of mass load.
//   - landuse_getRunoffLoad() re-named to landuse_getWashoffLoad() and
//     modified to work with landuse_getWashoffQual().
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  landuse_readParams        (called by parseLine in input.c)
//  landuse_readPollutParams  (called by parseLine in input.c)
//  landuse_readBuildupParams (called by parseLine in input.c)
//  landuse_readWashoffParams (called by parseLine in input.c)

//  landuse_getInitBuildup    (called by subcatch_initState)
//  landuse_getBuildup        (called by surfqual_getBuildup)
//  landuse_getWashoffLoad    (called by surfqual_getWashoff)
//  landuse_getCoPollutLoad   (called by surfqual_getwashoff));
//  landuse_getAvgBMPEffic    (called by updatePondedQual in surfqual.c)


//=============================================================================
// int j, char* tok[], int ntoks
 landuse_readParams(j, tok, ntoks)
//
//  Input:   j = land use index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads landuse parameters from a tokenized line of input.
//
//  Data format is:
//    landuseID  (sweepInterval sweepRemoval sweepDays0)
//
{
    let id;

    // return facilitators
    let returnObj;
    let returnVal;

    if ( ntoks < 1 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(LANDUSE, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);
    Landuse[j].ID = id;
    if ( ntoks > 1 )
    {
        if ( ntoks < 4 ) return error_setInpError(ERR_ITEMS, "");
        ////////////////////////////////////
        returnObj = {y: Landuse[j].sweepInterval}
        returnVal = getDouble(tok[1], returnObj);
        Landuse[j].sweepInterval = returnObj.y;
        ////////////////////////////////////
        if(!returnVal)
        //if ( null == (Landuse[j].sweepInterval = getDouble(tok[1]) ))
            return error_setInpError(ERR_NUMBER, tok[1]);
        ////////////////////////////////////
        returnObj = {y: Landuse[j].sweepRemoval}
        returnVal = getDouble(tok[2], returnObj);
        Landuse[j].sweepRemoval = returnObj.y;
        ////////////////////////////////////
        if(!returnVal)
        //if ( null == (Landuse[j].sweepRemoval = getDouble(tok[2])) )
            return error_setInpError(ERR_NUMBER, tok[2]);
        ////////////////////////////////////
        returnObj = {y: Landuse[j].sweepDays0}
        returnVal = getDouble(tok[3], returnObj);
        Landuse[j].sweepDays0 = returnObj.y;
        ////////////////////////////////////
        if(!returnVal)
        //if ( null == (Landuse[j].sweepDays0 = getDouble(tok[3])) )
            return error_setInpError(ERR_NUMBER, tok[3]);
    }
    else
    {
        Landuse[j].sweepInterval = 0.0;
        Landuse[j].sweepRemoval = 0.0;
        Landuse[j].sweepDays0 = 0.0;
    }
    if ( Landuse[j].sweepRemoval < 0.0
        || Landuse[j].sweepRemoval > 1.0 )
        return error_setInpError(ERR_NUMBER, tok[2]);
    return 0;
}

//=============================================================================
// int j, char* tok[], int ntoks
 landuse_readPollutParams(j, tok, ntoks)
//
//  Input:   j = pollutant index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads pollutant parameters from a tokenized line of input.
//
//  Data format is:
//    ID Units cRain cGW cRDII kDecay (snowOnly coPollut coFrac cDWF cInit)
//
{
    let i, k, coPollut, snowFlag;
    let x = new Array(4), coFrac, cDWF, cInit;
    let id;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- extract pollutant name & units
    if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(POLLUT, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);
    k = findmatch(tok[1], QualUnitsWords);
    if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);

    // --- extract concen. in rain, gwater, & I&I
    for ( i = 2; i <= 4; i++ )
    {
        ////////////////////////////////////
        returnObj = {y: x[i-2]}
        returnVal = getDouble(tok[i], returnObj);
        x[i-2] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[i-2] < 0.0 )
        //if ( null == (x[i-2] = getDouble(tok[i])) || x[i-2] < 0.0 )
        {
            return error_setInpError(ERR_NUMBER, tok[i]);
        }
    }

    // --- extract decay coeff. (which can be negative for growth)
    ////////////////////////////////////
    returnObj = {y: x[3]}
    returnVal = getDouble(tok[5], returnObj);
    x[3] = returnObj.y;
    ////////////////////////////////////
    if( !returnVal )
    //if ( null == (x[3] = getDouble(tok[5])) )
    {
        return error_setInpError(ERR_NUMBER, tok[5]);
    }

    // --- set defaults for snow only flag & co-pollut. parameters
    snowFlag = 0;
    coPollut = -1;
    coFrac = 0.0;
    cDWF = 0.0;
    cInit = 0.0;

    // --- check for snow only flag
    if ( ntoks >= 7 )
    {
        snowFlag = findmatch(tok[6], NoYesWords);             
        if ( snowFlag < 0 ) return error_setInpError(ERR_KEYWORD, tok[6]);
    }

    // --- check for co-pollutant
    if ( ntoks >= 9 )
    {
        if ( !strcomp(tok[7], "*") )
        {
            coPollut = project_findObject(POLLUT, tok[7]);
            if ( coPollut < 0 ) return error_setInpError(ERR_NAME, tok[7]);
            ////////////////////////////////////
            returnObj = {y: coFrac}
            returnVal = getDouble(tok[8], returnObj);
            coFrac = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || coFrac < 0.0 )
            //if ( null == (coFrac = getDouble(tok[8])) || coFrac < 0.0 )
                return error_setInpError(ERR_NUMBER, tok[8]);
        }
    }

    // --- check for DWF concen.
    if ( ntoks >= 10 )
    {
        ////////////////////////////////////
        returnObj = {y: cDWF}
        returnVal = getDouble(tok[9], returnObj);
        cDWF = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || cDWF < 0.0 )
        //if ( null == (cDWF = getDouble(tok[9])) || cDWF < 0.0)
            return error_setInpError(ERR_NUMBER, tok[9]);
    }

    // --- check for initial concen.
    if ( ntoks >= 11 ) 
    {
        ////////////////////////////////////
        returnObj = {y: cInit}
        returnVal = getDouble(tok[10], returnObj);
        cInit = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || cInit < 0.0 )
        //if ( null == (cInit = getDouble(tok[10])) || cInit < 0.0 )
            return error_setInpError(ERR_NUMBER, tok[9]);
    }

    // --- save values for pollutant object   
    Pollut[j].ID = id;
    Pollut[j].units = k;
    if      ( Pollut[j].units == MG ) Pollut[j].mcf = UCF(MASS);
    else if ( Pollut[j].units == UG ) Pollut[j].mcf = UCF(MASS) / 1000.0;
    else                              Pollut[j].mcf = 1.0;
    Pollut[j].pptConcen  = x[0];
    Pollut[j].gwConcen   = x[1];
    Pollut[j].rdiiConcen = x[2];
    Pollut[j].kDecay     = x[3]/SECperDAY;
    Pollut[j].snowOnly   = snowFlag;
    Pollut[j].coPollut   = coPollut;
    Pollut[j].coFraction = coFrac;
    Pollut[j].dwfConcen  = cDWF;
    Pollut[j].initConcen = cInit;
    return 0;
}

//=============================================================================

 landuse_readBuildupParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads pollutant buildup parameters from a tokenized line of input.
//
//  Data format is:
//    landuseID  pollutID  buildupType  c1  c2  c3  normalizerType
//
{
    let    i, j, k, n, p;
    let c= new Array(3), tmax;

    if ( ntoks < 3 ) return 0;
    j = project_findObject(LANDUSE, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);
    p = project_findObject(POLLUT, tok[1]);
    if ( p < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    k = findmatch(tok[2], BuildupTypeWords);
    if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[2]);
    Landuse[j].buildupFunc[p].funcType = k;
    if ( k > NO_BUILDUP )
    {
        if ( ntoks < 7 ) return error_setInpError(ERR_ITEMS, "");
        if ( k != EXTERNAL_BUILDUP ) for (i=0; i<3; i++)
        {
            ////////////////////////////////////
            returnObj = {y: c[i]}
            returnVal = getDouble(tok[i+3], returnObj);
            c[i] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || c[i] < 0.0 )
            //if ( null == (c[i] = getDouble(tok[i+3]))  || c[i] < 0.0  )
            {
                return error_setInpError(ERR_NUMBER, tok[i+3]);
            }
        }
        n = findmatch(tok[6], NormalizerWords);
        if (n < 0 ) return error_setInpError(ERR_KEYWORD, tok[6]);
        Landuse[j].buildupFunc[p].normalizer = n;
    }

    // Find time until max. buildup (or time series for external buildup)
    switch (Landuse[j].buildupFunc[p].funcType)
    {
      case POWER_BUILDUP:
        // --- check for too small or large an exponent
        if ( c[2] > 0.0 && (c[2] < 0.01 || c[2] > 10.0) )
            return error_setInpError(ERR_KEYWORD, tok[5]);

        // --- find time to reach max. buildup
        // --- use zero if coeffs. are 0        
        if ( c[1]*c[2] == 0.0 ) tmax = 0.0;

        // --- use 10 years if inverse power tends to blow up
        else if ( log10(c[0]) / c[2] > 3.5 ) tmax = 3650.0;

        // --- otherwise use inverse power function
        else tmax = Math.pow(c[0]/c[1], 1.0/c[2]);
        break;

      case EXPON_BUILDUP:
        if ( c[1] == 0.0 ) tmax = 0.0;
        else tmax = -log(0.001)/c[1];
        break;

      case SATUR_BUILDUP:
        tmax = 1000.0*c[2];
        break;

      case EXTERNAL_BUILDUP:
        ////////////////////////////////////
        returnObj = {y: c[0]}
        returnVal = getDouble(tok[3], returnObj);
        c[0] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || c[0] < 0.0 )
        //if ( null == (c[0] = getDouble(tok[3])) || c[0] < 0.0 )     //max. buildup
            return error_setInpError(ERR_NUMBER, tok[3]);
        ////////////////////////////////////
        returnObj = {y: c[1]}
        returnVal = getDouble(tok[4], returnObj);
        c[1] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || c[1] < 0.0 )
        //if ( null == (c[1] = getDouble(tok[4])) || c[1] < 0.0 )     //scaling factor
            return error_setInpError(ERR_NUMBER, tok[3]);
        n = project_findObject(TSERIES, tok[5]);           //time series
        if ( n < 0 ) return error_setInpError(ERR_NAME, tok[4]);
        Tseries[n].refersTo = EXTERNAL_BUILDUP;
        c[2] = n;
        tmax = 0.0;
        break;

      default:
        tmax = 0.0;
    }

    // Assign parameters to buildup object
    Landuse[j].buildupFunc[p].coeff[0]   = c[0];
    Landuse[j].buildupFunc[p].coeff[1]   = c[1];
    Landuse[j].buildupFunc[p].coeff[2]   = c[2];
    Landuse[j].buildupFunc[p].maxDays = tmax;
    return 0;
}

//=============================================================================
//  char* tok[], int ntoks
 landuse_readWashoffParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads pollutant washoff parameters from a tokenized line of input.
//
//  Data format is:
//    landuseID  pollutID  washoffType  c1  c2  sweepEffic  bmpRemoval
{
    let    i, j, p;
    let    func;
    let x = new Array(4);
    // return facilitators
    let returnObj;
    let returnVal;

    if ( ntoks < 3 ) return 0;
    for (i=0; i<4; i++) x[i] = 0.0;
    func = NO_WASHOFF;
    j = project_findObject(LANDUSE, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);
    p = project_findObject(POLLUT, tok[1]);
    if ( p < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    if ( ntoks > 2 )
    {
        func = findmatch(tok[2], WashoffTypeWords);
        if ( func < 0 ) return error_setInpError(ERR_KEYWORD, tok[2]);
        if ( func != NO_WASHOFF )
        {
            if ( ntoks < 5 ) return error_setInpError(ERR_ITEMS, "");
            ////////////////////////////////////
            returnObj = {y: x[0]}
            returnVal = getDouble(tok[3], returnObj);
            x[0] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal )
            //if ( null == ( x[0] = getDouble(tok[3])))
                    return error_setInpError(ERR_NUMBER, tok[3]);
            ////////////////////////////////////
            returnObj = {y: x[1]}
            returnVal = getDouble(tok[4], returnObj);
            x[1] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal )
            //if ( null == ( x[1] = getDouble(tok[4])))
                    return error_setInpError(ERR_NUMBER, tok[4]);
            if ( ntoks >= 6 )
            {
                ////////////////////////////////////
                returnObj = {y: x[2]}
                returnVal = getDouble(tok[5], returnObj);
                x[2] = returnObj.y;
                ////////////////////////////////////
                if( !returnVal )
                //if ( null == (x[2] = getDouble(tok[5])))
                        return error_setInpError(ERR_NUMBER, tok[5]);
            }
            if ( ntoks >= 7 )
            {
                ////////////////////////////////////
                returnObj = {y: x[3]}
                returnVal = getDouble(tok[6], returnObj);
                x[3] = returnObj.y;
                ////////////////////////////////////
                if( !returnVal )
                //if ( null == (x[3] = getDouble(tok[6])))
                        return error_setInpError(ERR_NUMBER, tok[6]);
            }
        }
    }

    // --- check for valid parameter values
    //     x[0] = washoff coeff.
    //     x[1] = washoff expon.
    //     x[2] = sweep effic.
    //     x[3] = BMP effic.
    if ( x[0] < 0.0 ) return error_setInpError(ERR_NUMBER, tok[3]);
    if ( x[1] < -10.0 || x[1] > 10.0 )
        return error_setInpError(ERR_NUMBER, tok[4]);;
    if ( x[2] < 0.0 || x[2] > 100.0 )
        return error_setInpError(ERR_NUMBER, tok[5]);
    if ( x[3] < 0.0 || x[3] > 100.0 )
        return error_setInpError(ERR_NUMBER, tok[6]);

    // --- convert units of washoff coeff.
    if ( func == EXPON_WASHOFF  ) x[0] /= 3600.0;
    if ( func == RATING_WASHOFF ) x[0] *= Math.pow(UCF(FLOW), x[1]);
    if ( func == EMC_WASHOFF    ) x[0] *= LperFT3;

    // --- assign washoff parameters to washoff object
    Landuse[j].washoffFunc[p].funcType = func;
    Landuse[j].washoffFunc[p].coeff = x[0];
    Landuse[j].washoffFunc[p].expon = x[1];
    Landuse[j].washoffFunc[p].sweepEffic = x[2] / 100.0;
    Landuse[j].washoffFunc[p].bmpEffic = x[3] / 100.0;
    return 0;
}

//=============================================================================
// TLandFactor* landFactor,  double* initBuildup,
//		double area, double curb
 landuse_getInitBuildup(landFactor, initBuildup,
		 area, curb)
//
//  Input:   landFactor = array of land use factors
//           initBuildup = total initial buildup of each pollutant
//           area = subcatchment's area (ft2)
//           curb = subcatchment's curb length (users units)
//  Output:  modifies each land use factor's initial pollutant buildup 
//  Purpose: determines the initial buildup of each pollutant on
//           each land use for a given subcatchment.
//
//  Notes:   Contributions from co-pollutants to initial buildup are not
//           included since the co-pollutant mechanism only applies to
//           washoff.
//
{
	let i, p;
	let startDrySeconds;       // antecedent dry period (sec)
	let f;                     // faction of total land area
    let fArea;                 // area of land use (ft2)
    let fCurb;                 // curb length of land use
	let buildup;               // pollutant mass buildup

    // --- convert antecedent dry days into seconds
    startDrySeconds = StartDryDays*SECperDAY;

    // --- examine each land use
    for (i = 0; i < Nobjects[LANDUSE]; i++)
    {
        // --- initialize date when last swept
        landFactor[i].lastSwept = StartDateTime - Landuse[i].sweepDays0;

        // --- determine area and curb length covered by land use
        f = landFactor[i].fraction;
        fArea = f * area * UCF(LANDAREA);
        fCurb = f * curb;

        // --- determine buildup of each pollutant
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            // --- if an initial loading was supplied, then use it to
            //     find the starting buildup over the land use
            buildup = 0.0;
            if ( initBuildup[p] > 0.0 ) buildup = initBuildup[p] * fArea;

            // --- otherwise use the land use's buildup to 
            //     compute a buildup over the antecedent dry period
            else buildup = landuse_getBuildup(i, p, fArea, fCurb, buildup,
                           startDrySeconds);
            landFactor[i].buildup[p] = buildup;
        }
    }
}

//=============================================================================
// int i, int p, double area, double curb, double buildup,
//      double tStep
 landuse_getBuildup(i, p, area, curb, buildup,
                            tStep)
//
//  Input:   i = land use index
//           p = pollutant index
//           area = land use area (ac or ha)
//           curb = land use curb length (users units)
//           buildup = current pollutant buildup (lbs or kg)
//           tStep = time increment for buildup (sec)
//  Output:  returns new buildup mass (lbs or kg)
//  Purpose: computes new pollutant buildup on a landuse after a time increment.
//
{
    let     n;                         // normalizer code
    let  days;                      // accumulated days of buildup
    let  perUnit;                   // normalizer value (area or curb length)

    // --- return current buildup if no buildup or time increment
    if ( Landuse[i].buildupFunc[p].funcType == NO_BUILDUP || tStep == 0.0 )
    {
        return buildup;
    }

    // --- see what buildup is normalized to
    n = Landuse[i].buildupFunc[p].normalizer;
    perUnit = 1.0;
    if ( n == PER_AREA ) perUnit = area;
    if ( n == PER_CURB ) perUnit = curb;
    if ( perUnit == 0.0 ) return 0.0;

    // --- buildup determined by loading time series
    if ( Landuse[i].buildupFunc[p].funcType == EXTERNAL_BUILDUP )
    {
        return landuse_getExternalBuildup(i, p, buildup/perUnit, tStep) *
               perUnit;
    }

    // --- determine equivalent days of current buildup
    days = landuse_getBuildupDays(i, p, buildup/perUnit);

    // --- compute buildup after adding on time increment
    days += tStep / SECperDAY;
    return landuse_getBuildupMass(i, p, days) * perUnit;
}

//=============================================================================
// int i, int p, double buildup
landuse_getBuildupDays(i, p, buildup)
//
//  Input:   i = land use index
//           p = pollutant index
//           buildup = amount of pollutant buildup
//  Output:  returns number of days it takes for buildup to reach a given level
//  Purpose: finds the number of days corresponding to a pollutant buildup.
//
{
    let c0 = Landuse[i].buildupFunc[p].coeff[0];
    let c1 = Landuse[i].buildupFunc[p].coeff[1];
    let c2 = Landuse[i].buildupFunc[p].coeff[2];

    if ( buildup == 0.0 ) return 0.0;
    if ( buildup >= c0 ) return Landuse[i].buildupFunc[p].maxDays;   
    switch (Landuse[i].buildupFunc[p].funcType)
    {
      case POWER_BUILDUP:
        if ( c1*c2 == 0.0 ) return 0.0;
        else return Math.pow( (buildup/c1), (1.0/c2) );

      case EXPON_BUILDUP:
        if ( c0*c1 == 0.0 ) return 0.0;
        else return -log(1. - buildup/c0) / c1;

      case SATUR_BUILDUP:
        if ( c0 == 0.0 ) return 0.0;
        else return buildup*c2 / (c0 - buildup);

      default:
        return 0.0;
    }
}

//=============================================================================
// int i, int p, double days
landuse_getBuildupMass(i, p, days)
//
//  Input:   i = land use index
//           p = pollutant index
//           days = time over which buildup has occurred (days)
//  Output:  returns mass of pollutant buildup (lbs or kg per area or curblength)
//  Purpose: finds amount of buildup of pollutant on a land use.
//
{
    let b;
    let c0 = Landuse[i].buildupFunc[p].coeff[0];
    let c1 = Landuse[i].buildupFunc[p].coeff[1];
    let c2 = Landuse[i].buildupFunc[p].coeff[2];

    if ( days == 0.0 ) return 0.0;
    if ( days >= Landuse[i].buildupFunc[p].maxDays ) return c0;
    switch (Landuse[i].buildupFunc[p].funcType)
    {
      case POWER_BUILDUP:
        b = c1 * Math.pow(days, c2);
        if ( b > c0 ) b = c0;
        break;

      case EXPON_BUILDUP:
        b = c0*(1.0 - Math.exp(-days*c1));
        break;

      case SATUR_BUILDUP:
        b = days*c0/(c2 + days);
        break;

      default: b = 0.0;
    }
    return b;
}

//=============================================================================
// int j, int p
landuse_getAvgBmpEffic(j, p)
//
//  Input:   j = subcatchment index
//           p = pollutant index
//  Output:  returns a BMP removal fraction for pollutant p
//  Purpose: finds the overall average BMP removal achieved for pollutant p
//           treated in subcatchment j.
//
{
    let    i;
    let r = 0.0;
    for (i = 0; i < Nobjects[LANDUSE]; i++)
    {
        r += Subcatch[j].landFactor[i].fraction *
             Landuse[i].washoffFunc[p].bmpEffic;
    }
    return r;
}

//=============================================================================
// int i, int p, double area,
//    TLandFactor landFactor[], double runoff, double vOutflow
landuse_getWashoffLoad(i, p, area,
    landFactor, runoff, vOutflow)
//
//  Input:   i = land use index
//           p = pollut. index
//           area = sucatchment area (ft2)
//           landFactor[] = array of land use data for subcatchment
//           runoff = runoff flow generated by subcatchment (ft/sec)
//           vOutflow = runoff volume leaving the subcatchment (ft3)
//  Output:  returns pollutant runoff load (mass)
//  Purpose: computes pollutant load generated by a land use over a time step.
//
{
    let landuseArea;      // area of current land use (ft2)
    let buildup;          // current pollutant buildup (lb or kg)
    let washoffQual;      // pollutant concentration in washoff (mass/ft3)
    let washoffLoad;      // pollutant washoff load over time step (lb or kg)
    let bmpRemoval;       // pollutant load removed by BMP treatment (lb or kg)

    // --- compute concen. of pollutant in washoff (mass/ft3)
    buildup = landFactor[i].buildup[p];
    landuseArea = landFactor[i].fraction * area;
    washoffQual = landuse_getWashoffQual(i, p, buildup, runoff, landuseArea);

    // --- compute washoff load exported (lbs or kg) from landuse
    //     (Pollut[].mcf converts from mg (or ug) mass units to lbs (or kg)
    washoffLoad = washoffQual * vOutflow * landuseArea / area * Pollut[p].mcf;

    // --- if buildup modelled, reduce it by amount of washoff
    if ( Landuse[i].buildupFunc[p].funcType != NO_BUILDUP ||
         buildup > washoffLoad )
    {
        washoffLoad = MIN(washoffLoad, buildup);
        buildup -= washoffLoad;
        landFactor[i].buildup[p] = buildup;
    }

    // --- otherwise add washoff to buildup mass balance totals
    //     so that things will balance
    else
    {
        massbal_updateLoadingTotals(BUILDUP_LOAD, p, washoffLoad);
        landFactor[i].buildup[p] = 0.0;
    }
	
    // --- apply any BMP removal to washoff
    bmpRemoval = Landuse[i].washoffFunc[p].bmpEffic * washoffLoad;
    if ( bmpRemoval > 0.0 )
    {
        massbal_updateLoadingTotals(BMP_REMOVAL_LOAD, p, bmpRemoval);
        washoffLoad -= bmpRemoval;
    }

    // --- return washoff load converted back to mass (mg or ug)
    return washoffLoad / Pollut[p].mcf;
}

//=============================================================================
// int i, int p, double buildup, double runoff,
//     double area
landuse_getWashoffQual(i, p, buildup, runoff,
                               area)
//
//  Input:   i = land use index
//           p = pollutant index
//           buildup = current buildup over land use (lbs or kg)
//           runoff = current runoff on subcatchment (ft/sec)
//           area = area devoted to land use (ft2)
//  Output:  returns pollutant concentration in washoff (mass/ft3)
//  Purpose: finds concentration of pollutant washed off a land use.
//
//  Notes:   "coeff" for each washoff was previously adjusted to
//           result in units of mass/sec
//
{
    let cWashoff = 0.0;
    let coeff = Landuse[i].washoffFunc[p].coeff;
    let expon = Landuse[i].washoffFunc[p].expon;
    let    func  = Landuse[i].washoffFunc[p].funcType;

    // --- if no washoff or no runoff, return 0
    if ( func == NO_WASHOFF || runoff == 0.0 ) return 0.0;
    
    // --- if buildup exists but no current buildup, return 0
    if ( Landuse[i].buildupFunc[p].funcType != NO_BUILDUP && buildup == 0.0 )
        return 0.0;

    // --- Exponential Washoff function
    if ( func == EXPON_WASHOFF )
    {
        // --- evaluate washoff eqn. with runoff in in/hr (or mm/hr)
        //     and buildup converted from lbs (or kg) to concen. mass units
        cWashoff = coeff * Math.pow(runoff * UCF(RAINFALL), expon) *
                  buildup / Pollut[p].mcf;
        cWashoff /= runoff * area;
    }

    // --- Rating Curve Washoff function
    else if ( func == RATING_WASHOFF )
    {
        cWashoff = coeff * Math.pow(runoff * area, expon-1.0);
    }

    // --- Event Mean Concentration Washoff
    else if ( func == EMC_WASHOFF )
    {
        cWashoff = coeff;     // coeff includes LperFT3 factor
    }
    return cWashoff;
}

//=============================================================================
// int p, double washoff[]
landuse_getCoPollutLoad(p, washoff)
//
//  Input:   p = pollutant index
//           washoff = pollut. washoff rate (mass/sec)
//  Output:  returns washoff mass added by co-pollutant relation (mass)
//  Purpose: finds washoff mass added by a co-pollutant of a given pollutant.
//
{
    let k;
    let w;

    // --- check if pollutant p has a co-pollutant k
    k = Pollut[p].coPollut;
    if ( k >= 0 )
    {
        // --- compute addition to washoff from co-pollutant
        w = Pollut[p].coFraction * washoff[k];

        // --- add washoff to buildup mass balance totals
        //     so that things will balance
        massbal_updateLoadingTotals(BUILDUP_LOAD, p, w * Pollut[p].mcf);
        return w;
    }
    return 0.0;
}

//=============================================================================
// int i, int p, double buildup, double tStep
landuse_getExternalBuildup(i, p, buildup, tStep)
//
//  Input:   i = landuse index
//           p = pollutant index
//           buildup = buildup at start of time step (mass/unit)
//           tStep = time step (sec)
//  Output:  returns pollutant buildup at end of time interval (mass/unit)
//  Purpose: finds pollutant buildup contributed by external loading over a
//           given time step.
//
{
    // ret facil
    let returnObj;
    let returnVal;

    let maxBuildup = Landuse[i].buildupFunc[p].coeff[0];
    let sf = Landuse[i].buildupFunc[p].coeff[1];              // scaling factor
    let    ts = floor(Landuse[i].buildupFunc[p].coeff[2]);  // time series index
    let rate = 0.0;

    // --- no buildup increment at start of simulation
    if (NewRunoffTime == 0.0) return 0.0;

    // --- get buildup rate (mass/unit/day) over the interval
    if ( ts >= 0 )
    {        
        ////////////////////////////////////
        returnObj = {table: Tseries[ts]}
        returnVal = table_tseriesLookup(returnObj, getDateTime(NewRunoffTime), false);
        Tseries[ts] = returnObj.table;
        ////////////////////////////////////
        //rate = sf * table_tseriesLookup(Tseries[ts], getDateTime(NewRunoffTime), false);
        rate = sf * returnVal;
    }

    // --- compute buildup at end of time interval
    buildup = buildup + rate * tStep / SECperDAY;
    buildup = Math.min(buildup, maxBuildup);
    return buildup;
}

//-----------------------------------------------------------------------------
//   findroot.c
//
//   Finds solution of func(x) = 0 using either the Newton-Raphson
//   method or Ridder's Method.
//   Based on code from Numerical Recipes in C (Cambridge University
//   Press, 1992).
//
//   Date:     11/19/13
//   Author:   L. Rossman
//-----------------------------------------------------------------------------

SIGN(a,b) {
    if(b >= 0.0) {
        return Math.abs(a);
     } else {
        return -Math.abs(a);
     } 
}
MAXIT = 60

////////////////////////////////////
//let returnObj = {rts: val1, p: val2}
//let returnVal = findroot_Newton(x1, x2, returnObj, xacc, func)
//val1 = returnObj.rts;
//val2 = returnObj.p
////////////////////////////////////
findroot_Newton(x1, x2, inObj, xacc, func)
//int findroot_Newton(double x1, double x2, double* rts, double xacc,
//                    void (*func) (double x, double* f, double* df, void* p),
//					void* p)
//
//  Using a combination of Newton-Raphson and bisection, find the root of a
//  func bracketed between x1 and x2. The root, returned in rts,
//  will be refined until its accuracy is known within +/-xacc. func is a
//  user-supplied routine, that returns both the value and the first
//  derivative of the function. p is a pointer to any auxilary data structure
//  that func may require. It can be NULL if not needed. The returns
//  the number of evaluations used or 0 if the maximum allowed
//  iterations were exceeded.
//
// NOTES:
// 1. The calling program must insure that the signs of func(x1) and func(x2)
//    are not the same, otherwise x1 and x2 do not bracket the root.
// 2. If func(x1) > func(x2) then the order of x1 and x2 should be
//    switched in the call to Newton.
//
{
    let j, n = 0;
    let df, dx, dxold, f, x;
    let temp, xhi, xlo;

    // ret facil
    let returnObj;
    let returnVal;

    // Initialize the "stepsize before last" and the last step.
    x = inObj.rts;
    xlo = x1;
    xhi = x2;
    dxold = Math.abs(x2-x1);
    dx = dxold;

    ////////////////////////////////////
    returnObj = {f: f, df: df, p: inObj.p}
    returnVal = func(x, returnObj)
    f = returnObj.f;
    df = returnObj.df;
    inObj.p = returnObj.p;
    ////////////////////////////////////
    //func(x, &f, &df, inObj.p);
    n++;

    // Loop over allowed iterations.
    for (j=1; j<=MAXIT; j++)
    {
        // Bisect if Newton out of range or not decreasing fast enough.
        if ( ( ( (x-xhi)*df-f)*((x-xlo)*df-f) >= 0.0
        || (Math.abs(2.0*f) > Math.abs(dxold*df) ) ) )
        {
            dxold = dx;
            dx = 0.5*(xhi-xlo);
            x = xlo + dx;
            if ( xlo == x ) break;
        }

        // Newton step acceptable. Take it.
        else
        {
            dxold = dx;
            dx = f/df;
            temp = x;
            x -= dx;
            if ( temp == x ) break;
        }

        // Convergence criterion.
        if ( Math.abs(dx) < xacc ) break;
 
        // Evaluate function. Maintain bracket on the root.
        ////////////////////////////////////
        returnObj = {f: f, df: df, p: inObj.p}
        returnVal = func(x, returnObj)
        f = returnObj.f;
        df = returnObj.df;
        inObj.p = returnObj.p;
        ////////////////////////////////////
        //func(x, &f, &df, inObj.p);
        n++;
        if ( f < 0.0 ) xlo = x;
        else           xhi = x;
    }
    inObj.rts = x;
    if ( n <= MAXIT) return n;
    else return 0;
};


////////////////////////////////////
//let returnObj = {p: val1}
//let returnVal = findroot_Ridder(x1, x2, xacc, func, returnObj)
//val1 = returnObj.p;
////////////////////////////////////
findroot_Ridder(x1, x2, xacc, func, inObj)
//double findroot_Ridder(double x1, double x2, double xacc,
//	double (*func)(double, void* p), void* p)
{
    let j;
    let ans, fhi, flo, fm, fnew, s, xhi, xlo, xm, xnew;

    // ret facil
    let returnObj;
    let returnVal;

    ////////////////////////////////////
    returnObj = {p: inObj.p}
    returnVal = func(x1, returnObj)
    inObj.p = returnObj.p;
    flo = returnVal;
    ////////////////////////////////////
    //flo = func(x1, inObj.p);
    ////////////////////////////////////
    returnObj = {p: inObj.p}
    returnVal = func(x2, returnObj)
    inObj.p = returnObj.p;
    fhi = returnVal;
    ////////////////////////////////////
    //fhi = func(x2, inObj.p);
    if ( flo == 0.0 ) return x1;
    if ( fhi == 0.0 ) return x2;
    ans = 0.5*(x1+x2);
    if ( (flo > 0.0 && fhi < 0.0) || (flo < 0.0 && fhi > 0.0) )
    {
        xlo = x1;
        xhi = x2;
        for (j=1; j<=MAXIT; j++) {
            xm = 0.5*(xlo + xhi);

            ////////////////////////////////////
            returnObj = {p: inObj.p}
            returnVal = func(xm, returnObj)
            inObj.p = returnObj.p;
            fm = returnVal;
            ////////////////////////////////////
            //fm = func(xm, inObj.p);
            s = sqrt( fm*fm - flo*fhi );
            if (s == 0.0) return ans;
            xnew = xm + (xm-xlo)*( (flo >= fhi ? 1.0 : -1.0)*fm/s );
            if ( Math.abs(xnew - ans) <= xacc ) break;
            ans = xnew;

            ////////////////////////////////////
            returnObj = {p: inObj.p}
            returnVal = func(ans, returnObj)
            inObj.p = returnObj.p;
            fnew = returnVal;
            ////////////////////////////////////
            //fnew = func(ans, inObj.p);
            if ( SIGN(fm, fnew) != fm)
            {
                xlo = xm;
                flo = fm;
                xhi = ans;
                fhi = fnew;
            }
            else if ( SIGN(flo, fnew) != flo )
            {
                xhi = ans;
                fhi = fnew;
            }
            else if ( SIGN(fhi, fnew) != fhi)
            {
                xlo = ans;
                flo = fnew;
            }
            else return ans;
            if ( Math.abs(xhi - xlo) <= xacc ) return ans;
        }
        return ans;
    }
    return -1.e20;
}

//-----------------------------------------------------------------------------
//   xsect.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             03/14/17   (Build 5.1.012)
//             05/10/18   (Build 5.1.013)
//   Author:   L. Rossman (EPA)
//             M. Tryby (EPA)
//
//   Cross section geometry functions.
//
//   The primary functions are:
//      getAofY   -- returns area given depth
//      getWofY   -- returns top width given depth
//      getRofY   -- returns hyd. radius given depth
//      getYofA   -- returns flow depth given area
//      getRofA   -- returns hyd. radius given area
//      getSofA   -- returns section factor given area
//      getAofS   -- returns area given section factor
//      getdSdA   -- returns derivative of section factor w.r.t. area
//   where
//      Y = flow depth
//      A = flow area
//      R = hyd. radius
//      S = section factor = A*R^(2/3)
//
//   Build 5.1.012:
//   - Height at max. width for Modified Baskethandle shape corrected.
//
//   Build 5.1.013:
//   - Width at full height set to 0 for closed rectangular shape.
//-----------------------------------------------------------------------------


//#include "xsect.dat"    // File containing geometry tables for rounded shapes
//-----------------------------------------------------------------------------
//   xsection.dat
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//   Author:   L. Rossman
//
//   Tables of relative geometric properties for rounded cross-sections.
//
//   Tables are named using the following convention:
//     A_xxx   = area / full area v. depth / full depth for shape xxx
//     Y_xxx   = depth / full depth v. area / full area for shape xxx
//     W_xxx   = width / max. width v. depth / full depth for shape xxx
//     R_xxx   = hyd. radius / hyd. radius at full depth v. depth /
//               full depth for shape xxx
//     S_xxx   = section factor / section factor at full depth v. area /
//               area at full depth for shape xxx
//     N_Z_xxx = number of equal intervals between 0.0 and 1.0 in the
//               table for parameter Z and shape xxx.
//-----------------------------------------------------------------------------

//=============================================================================
//  CIRCULAR SHAPE
//=============================================================================

   N_A_Circ   = 51;
A_Circ =     // A/Afull v. Y/Yfull
[0.0,.00471,.0134,.024446,.0374,.05208,.0680,.08505,.1033,.12236,
     .1423,.16310,.1845,.20665,.2292,.25236,.2759,.29985,.3242,.34874,
     .3736,.39878,.4237,.44907,.4745,.500,.5255,.55093,.5763,.60135,
     .6264,.65126,.6758,.70015,.7241,.74764,.7708,.79335,.8154,.83690,
     .8576,.87764,.8967,.91495,.9320,.94792,.9626,.97555,.9866,.99516,1.000];

   N_R_Circ   = 51;
R_Circ =    // R/Rfull v. Y/Yfull
[.0100,.0528,.1048,.1556,.2052,.254,.3016,.3484,.3944,.4388,
 .4824,.5248,.5664,.6064,.6456,.6836,.7204,.7564,.7912,.8244,
 .8568,.888,.9176,.9464,.9736,1.00,1.024,1.048,1.070,1.0912,1.110,1.1272,
 1.144,1.1596,1.174,1.1848,1.194,1.2024,1.210,1.2148,
 1.217,1.2172,1.215,1.2104,1.203,1.192,1.178,1.1584,1.132,1.094,1.000];

    N_Y_Circ   = 51;
 Y_Circ =    // Y/Yfull v. A/Afull
[0.0, 0.05236, 0.08369, 0.11025, 0.13423, 0.15643, 0.17755, 0.19772, 0.21704,
      0.23581, 0.25412, 0.27194, 0.28948, 0.30653, 0.32349, 0.34017, 0.35666,
      0.37298, 0.38915, 0.40521, 0.42117, 0.43704, 0.45284, 0.46858, 0.4843,
      0.50000, 0.51572, 0.53146, 0.54723, 0.56305, 0.57892, 0.59487, 0.61093,
      0.62710, 0.64342, 0.65991, 0.67659, 0.69350, 0.71068, 0.72816, 0.74602,
      0.76424, 0.78297, 0.80235, 0.82240, 0.84353, 0.86563, 0.88970, 0.91444,
      0.94749, 1.0];

   N_S_Circ   = 51;
S_Circ =    // S/Sfull v. A/Afull
[0.0, 0.00529, 0.01432, 0.02559, 0.03859, 0.05304, 0.06877, 0.08551, 0.10326,
      0.12195, 0.14144, 0.16162, 0.18251, 0.2041,  0.22636, 0.24918, 0.27246,
      0.29614, 0.32027, 0.34485, 0.36989, 0.39531, 0.42105, 0.44704, 0.47329,
      0.4998,  0.52658, 0.55354, 0.58064, 0.60777, 0.63499, 0.66232, 0.68995,
      0.7177,  0.74538, 0.77275, 0.79979, 0.82658, 0.8532,  0.87954, 0.90546,
      0.93095, 0.95577, 0.97976, 1.00291, 1.02443, 1.04465, 1.06135, 1.08208,
      1.07662, 1.0];

   N_W_Circ   = 51;
W_Circ =    // W/Wmax v. Y/Yfull
[0.0,   .2800,   .3919,   .4750,   .5426,   .6000,   .6499,   .6940,   .7332,
        .7684,   .8000,   .8285,   .8542,   .8773,   .8980,   .9165,   .9330, 
        .9474,   .9600,   .9708,   .9798,   .9871,   .9928,   .9968,   .9992,
        1.000,   .9992,   .9968,   .9928,   .9871,   .9798,   .9708,   .9600,
        .9474,   .9330,   .9165,   .8980,   .8773,   .8542,   .8285,   .8000,
        .7684,   .7332,   .6940,   .6499,   .6000,   .5426,   .4750,   .3919,
        .2800,   .0];

//=============================================================================
//  EGG SHAPE
//=============================================================================

   N_A_Egg   = 26;
A_Egg =
[.0000,.0150,.0400,.0550,.0850,.1200,.1555,.1900,.2250,.2750,
 .3200,.3700,.4200,.4700,.5150,.5700,.6200,.6800,.7300,.7800, 
 .8350,.8850,.9250,.9550,.9800,1.000];

   N_R_Egg   = 26;
R_Egg =
[.0100,.0970,.2160,.3020,.3860,.4650,.5360,.6110,.6760,.7350, 
 .7910,.8540,.9040,.9410,1.008,1.045,1.076,1.115,1.146,1.162, 
 1.186,1.193,1.186,1.162,1.107,1.000];

   N_Y_Egg   = 51;
Y_Egg = 
[0.0, 0.04912, 0.08101, 0.11128, 0.14161, 0.16622, 0.18811, 0.21356, 0.23742,
      0.25742, 0.27742, 0.29741, 0.31742, 0.33742, 0.35747, 0.37364, 0.4,
      0.41697, 0.43372, 0.45,    0.46374, 0.47747, 0.49209, 0.50989, 0.53015,
      0.55,    0.56429, 0.57675, 0.58834, 0.6,     0.61441, 0.62967, 0.64582,
      0.66368, 0.68209, 0.7,     0.71463, 0.72807, 0.74074, 0.75296, 0.765,
      0.77784, 0.79212, 0.80945, 0.82936, 0.85,    0.86731, 0.88769, 0.914,
      0.95,    1.0];

   N_S_Egg   = 51;
S_Egg = 
[0.0, 0.00295, 0.01331, 0.02629, 0.04,    0.05657, 0.075,   0.09432, 0.11473,
      0.13657, 0.15894, 0.1803,  0.20036, 0.22,    0.23919, 0.25896, 0.28,
      0.30504, 0.33082, 0.35551, 0.37692, 0.39809, 0.42,    0.44625, 0.47321,
      0.5,     0.52255, 0.54481, 0.56785, 0.59466, 0.62485, 0.65518, 0.68181,
      0.70415, 0.72585, 0.74819, 0.77482, 0.80515, 0.83534, 0.86193, 0.88465,
      0.9069,  0.93,    0.95866, 0.98673, 1.01238, 1.03396, 1.05,    1.06517,
      1.0538,  1.0];

   N_W_Egg   = 26;
W_Egg =
[.0,    .2980,   .4330,   .5080,   .5820,   .6420,   .6960,   .7460,   .7910,
        .8360,   .8660,   .8960,   .9260,   .9560,   .9700,   .9850,   1.000,
        .9850,   .9700,   .9400,   .8960,   .8360,   .7640,   .6420,   .3100,
	.0];


//=============================================================================
//  HORSESHOE SHAPE
//=============================================================================

   N_A_Horseshoe   = 26;
A_Horseshoe =
[.0000,.0181,.0508,.0908,.1326,.1757,.2201,.2655,.3118,.3587,
 .4064,.4542,.5023,.5506,.5987,.6462,.6931,.7387,.7829,.8253, 
 .8652,.9022,.9356,.9645,.9873,1.000];

   N_R_Horseshoe   = 26;
R_Horseshoe =
[.0100,.1040,.2065,.3243,.4322,.5284,.6147,.6927,.7636,.8268, 
 .8873,.9417,.9905,1.036,1.077,1.113,1.143,1.169,1.189,1.202, 
 1.208,1.206,1.195,1.170,1.126,1.000];

   N_Y_Horseshoe   = 51;
Y_Horseshoe =
[0.0, 0.04146, 0.07033, 0.09098, 0.10962, 0.12921, 0.14813, 0.16701, 0.18565,
      0.20401, 0.22211, 0.23998, 0.25769, 0.27524, 0.29265, 0.3099,  0.32704,
      0.34406, 0.36101, 0.3779,  0.39471, 0.41147, 0.42818, 0.44484, 0.46147,
      0.47807, 0.49468, 0.51134, 0.52803, 0.54474, 0.56138, 0.57804, 0.59478,
      0.61171, 0.62881, 0.64609, 0.6635,  0.68111, 0.69901, 0.71722, 0.73583,
      0.7549,  0.77447, 0.79471, 0.81564, 0.83759, 0.86067, 0.88557, 0.91159,
      0.9452,  1.0];

   N_S_Horseshoe   = 51;
S_Horseshoe =
[0.0, 0.00467, 0.01237, 0.02268, 0.03515, 0.04943, 0.06525, 0.08212, 0.10005,
      0.11891, 0.13856, 0.15896, 0.18004, 0.20172, 0.22397, 0.24677, 0.27006,
      0.2938,  0.3179,  0.34237, 0.3672,  0.39239, 0.41792, 0.44374, 0.46984,
      0.49619, 0.52276, 0.5495,  0.5764,  0.60345, 0.63065, 0.65795, 0.68531,
      0.71271, 0.74009, 0.76738, 0.79451, 0.82144, 0.84814, 0.8745,  0.90057,
      0.92652, 0.95244, 0.97724, 0.99988, 1.02048, 1.03989, 1.05698, 1.07694,
      1.07562, 1.0];

   N_W_Horseshoe   = 26;
W_Horseshoe =
[   .0,      .5878,   .8772,   .8900,   .9028,   .9156,   .9284,   .9412,
    .9540,   .9668,   .9798,   .9928,   .9992,   .9992,   .9928,   .9798,
    .9600,   .9330,   .8980,   .8542,   .8000,   .7332,   .6499,   .5426,
    .3919,   .0];


//=============================================================================
//  GOTHIC SHAPE
//=============================================================================

   N_Y_Gothic   = 51;
Y_Gothic =
[0.0, 0.04522, 0.07825, 0.10646, 0.12645, 0.14645, 0.16787, 0.18641, 0.20129,
      0.22425, 0.24129, 0.25624, 0.27344, 0.29097, 0.30529, 0.32607, 0.33755,
      0.35073, 0.36447, 0.37558, 0.4,     0.4181,  0.43648, 0.45374, 0.46805,
      0.48195, 0.49626, 0.51352, 0.5319,  0.55,    0.56416, 0.57787, 0.59224,
      0.6095,  0.62941, 0.65,    0.67064, 0.69055, 0.70721, 0.72031, 0.73286,
      0.74632, 0.76432, 0.78448, 0.80421, 0.82199, 0.84363, 0.87423, 0.90617,
      0.93827, 1.0];

   N_S_Gothic   = 51;
S_Gothic =
[0.0, 0.005,   0.0174,  0.03098, 0.04272, 0.055,   0.0698,  0.0862,  0.10461,
      0.12463, 0.145,   0.16309, 0.18118, 0.2,     0.22181, 0.24487, 0.26888,
      0.2938,  0.31901, 0.34389, 0.36564, 0.38612, 0.4072,  0.43,    0.45868,
      0.48895, 0.52,    0.55032, 0.5804,  0.61,    0.63762, 0.66505, 0.6929,
      0.72342, 0.75467, 0.785,   0.81165, 0.83654, 0.86,    0.88253, 0.90414,
      0.925,   0.94486, 0.96475, 0.98567, 1.00833, 1.03,    1.0536,  1.065,
      1.055,   1.0];

   N_W_Gothic   = 21;
W_Gothic =
[0.0,   0.286,   0.643,   0.762,   0.833,   0.905,   0.952,   0.976,   0.976,
        1.0,     1.0,     0.976,   0.976,   0.952,   0.905,   0.833,   0.762,
        0.667,   0.524,   0.357,   0.0];


//=============================================================================
//  CATENARY SHAPE
//=============================================================================

   N_Y_Catenary   = 51;
Y_Catenary =
[0.0, 0.02974, 0.06439, 0.08433, 0.10549, 0.12064, 0.13952, 0.1556,  0.17032,
      0.18512, 0.20057, 0.21995, 0.24011, 0.25892, 0.27595, 0.29214, 0.30802,
      0.32372, 0.33894, 0.35315, 0.36557, 0.37833, 0.3923,  0.4097,  0.42982,
      0.45,    0.46769, 0.48431, 0.5,     0.51466, 0.52886, 0.54292, 0.55729,
      0.57223, 0.5878,  0.60428, 0.62197, 0.64047, 0.6598,  0.67976, 0.7,
      0.71731, 0.73769, 0.76651, 0.8,     0.8209,  0.84311, 0.87978, 0.91576,
      0.95,    1.0];

   N_S_Catenary   = 51;
S_Catenary =
[0.0, 0.00605, 0.01455, 0.0254,  0.03863, 0.0543,  0.07127, 0.08778, 0.10372,
      0.12081, 0.14082, 0.16375, 0.18779, 0.21157, 0.23478, 0.25818, 0.28244,
      0.30741, 0.33204, 0.35505, 0.37465, 0.39404, 0.41426, 0.43804, 0.46531,
      0.49357, 0.52187, 0.54925, 0.57647, 0.60321, 0.62964, 0.65639, 0.68472,
      0.71425, 0.74303, 0.76827, 0.79168, 0.815,   0.84094, 0.86707, 0.89213,
      0.91607, 0.94,    0.96604, 0.99,    1.00714, 1.02158, 1.03814, 1.05,
      1.05,    1.0];

   N_W_Catenary   = 21;
W_Catenary =
[0.0,    0.6667,  0.8222,  0.9111,  0.9778,  1.0000,  1.0000,  0.9889,  0.9778,
         0.9556,  0.9333,  0.8889,  0.8444,  0.8000,  0.7556,  0.7000,  0.6333,
         0.5556,  0.4444,  0.3333,  0.0];


//=============================================================================
//  SEMI-ELLIPTICAL SHAPE
//=============================================================================

   N_Y_SemiEllip   = 51;
Y_SemiEllip =
[0.0, 0.03075, 0.05137, 0.07032, 0.09,    0.11323, 0.13037, 0.14519, 0.15968,
      0.18459, 0.19531, 0.21354, 0.22694, 0.23947, 0.25296, 0.265,   0.27784,
      0.29212, 0.3097,  0.32982, 0.35,    0.36738, 0.3839,  0.4,     0.41667,
      0.43333, 0.45,    0.46697, 0.48372, 0.5,     0.51374, 0.52747, 0.54209,
      0.5595,  0.57941, 0.6,     0.62,    0.64,    0.66,    0.68,    0.7,
      0.71843, 0.73865, 0.76365, 0.7926,  0.82088, 0.85,    0.88341, 0.90998,
      0.93871, 1.0];

   N_S_SemiEllip   = 51;
S_SemiEllip =
[0.0, 0.00438, 0.01227, 0.02312, 0.03638, 0.05145, 0.06783, 0.085,   0.10093,
      0.11752, 0.1353,  0.15626, 0.17917, 0.20296, 0.22654, 0.24962, 0.27269,
      0.29568, 0.31848, 0.34152, 0.365,   0.38941, 0.41442, 0.44,    0.46636,
      0.49309, 0.52,    0.54628, 0.57285, 0.6,     0.62949, 0.65877, 0.68624,
      0.71017, 0.73304, 0.75578, 0.77925, 0.80368, 0.83114, 0.8595,  0.88592,
      0.90848, 0.93,    0.95292, 0.97481, 0.99374, 1.01084, 1.02858, 1.04543,
      1.05,    1.0];

   N_W_SemiEllip   = 21;
W_SemiEllip =
[0.0,    0.7000,  0.9800,  1.0000,  1.0000,  1.0000,  0.9900,  0.9800,  0.9600,
         0.9400,  0.9100,  0.8800,  0.8400,  0.8000,  0.7500,  0.7000,  0.6400,
         0.5600,  0.4600,  0.3400,  0.0];


//=============================================================================
//  BASKETHANDLE SHAPE
//=============================================================================

   N_A_Baskethandle   = 26;
A_Baskethandle =
[.0000,.0173,.0457,.0828,.1271,.1765,.2270,.2775,.3280,.3780,
 .4270,.4765,.5260,.5740,.6220,.6690,.7160,.7610,.8030,.8390, 
 .8770,.9110,.9410,.9680,.9880,1.000];

   N_R_Baskethandle   = 26;
R_Baskethandle =
[.0100,.0952,.1890,.2730,.3690,.4630,.5600,.6530,.7430,.8220, 
 .8830,.9490,.9990,1.055,1.095,1.141,1.161,1.188,1.206,1.206, 
 1.206,1.205,1.196,1.168,1.127,1.000];

   N_Y_BasketHandle   = 51;
Y_BasketHandle =
[0.0, 0.04112, 0.0738,  0.1,     0.12236, 0.14141, 0.15857, 0.17462, 0.18946,
      0.20315, 0.21557, 0.22833, 0.2423,  0.25945, 0.27936, 0.3,     0.3204,
      0.34034, 0.35892, 0.37595, 0.39214, 0.40802, 0.42372, 0.43894, 0.45315,
      0.46557, 0.47833, 0.4923,  0.50945, 0.52936, 0.55,    0.57,    0.59,
      0.61023, 0.63045, 0.65,    0.66756, 0.68413, 0.7,     0.71481, 0.72984,
      0.74579, 0.76417, 0.78422, 0.80477, 0.82532, 0.85,    0.88277, 0.915,
      0.95,    1.0];

   N_S_BasketHandle   = 51;
S_BasketHandle =
[0.0, 0.00758, 0.01812, 0.03,    0.03966, 0.04957, 0.0623,  0.07849, 0.09618,
      0.11416, 0.13094, 0.14808, 0.16583, 0.18381, 0.20294, 0.225,   0.2547,
      0.28532, 0.31006, 0.32804, 0.34555, 0.36944, 0.40032, 0.43203, 0.46004,
      0.47849, 0.49591, 0.51454, 0.5381,  0.56711, 0.6,     0.64092, 0.68136,
      0.71259, 0.73438, 0.755,   0.78625, 0.8188,  0.85,    0.8679,  0.88483,
      0.90431, 0.9369,  0.97388, 1.00747, 1.033,   1.05,    1.05464, 1.06078,
      1.055,   1.0];

   N_W_BasketHandle   = 26;
W_BasketHandle =
[0.0, 0.49,    0.667,   0.82,    0.93,    1.00,    1.00,    1.00,    0.997,
      0.994,   0.988,   0.982,   0.967,   0.948,   0.928,   0.904,   0.874,
      0.842,   0.798,   0.75,    0.697,   0.637,   0.567,   0.467,   0.342,
      0.0];


//=============================================================================
//  SEMI-CIRCULAR SHAPE
//=============================================================================

   N_Y_SemiCirc   = 51;
Y_SemiCirc =
[0.0, 0.04102, 0.07407, 0.1,     0.11769, 0.13037, 0.14036, 0.15,    0.16546,
      0.18213, 0.2,     0.22018, 0.2403,  0.25788, 0.27216, 0.285,   0.29704,
      0.30892, 0.32128, 0.33476, 0.35,    0.36927, 0.38963, 0.41023, 0.43045,
      0.45,    0.46769, 0.48431, 0.5,     0.51443, 0.52851, 0.54271, 0.55774,
      0.57388, 0.59101, 0.60989, 0.63005, 0.65,    0.66682, 0.68318, 0.7,
      0.71675, 0.73744, 0.76651, 0.8,     0.8209,  0.84311, 0.87978, 0.91576,
      0.95, 1.0];

   N_S_SemiCirc   = 51;
S_SemiCirc =
[0.0, 0.00757, 0.01815, 0.03,    0.0358,  0.04037, 0.04601, 0.055,   0.07475,
      0.09834, 0.125,   0.1557,  0.18588, 0.20883, 0.223,   0.23472, 0.24667,
      0.26758, 0.29346, 0.32124, 0.35,    0.3772,  0.4054,  0.43541, 0.46722,
      0.5,     0.53532, 0.56935, 0.6,     0.61544, 0.62811, 0.6417,  0.66598,
      0.7001,  0.73413, 0.76068, 0.78027, 0.8,     0.82891, 0.85964, 0.89,
      0.9127,  0.93664, 0.96677, 1.0,     1.02661, 1.04631, 1.05726, 1.06637,
      1.06,    1.0];

   N_W_SemiCirc   = 21;
W_SemiCirc =
[0.0, 0.5488,  0.8537,  1.0000,  1.0000,  0.9939,  0.9878,  0.9756,  0.9634,
      0.9451,  0.9207,  0.8902,  0.8537,  0.8171,  0.7683,  0.7073,  0.6463,
      0.5732,  0.4756,  0.3354,  0.0];

//=============================================================================
//  SIZES FOR STANDARD ELLIPSE SHAPES
//=============================================================================

NumCodesEllipse = 23;

//  Minor  axis (inches)
MinorAxis_Ellipse =
[ 14,19,22,24,27,29,32,34,38,43,48,53,58,63,68,72,77,82,87,92,97,106,116];

//  Major axis (inches)
MajorAxis_Ellipse =
[ 23,30,34,38,42,45,49,53,60,68,76,83,91,98,106,113, 121,128,136,143,151,
  166,180];

//  Full area (sq.ft.)
Afull_Ellipse =
[ 1.80,3.30,4.10,5.10,6.30,7.40,8.80,10.20,12.90,16.60,20.50,24.80,29.50,34.60,
  40.10,46.10,52.40,59.20,66.40,74.00,82.00,99.20,118.60];

//  Full hydraulic radius (ft)
Rfull_Ellipse =
[ 0.367,0.490,0.546,0.613,0.686,0.736,0.812,0.875,0.969,1.106,1.229,1.352,
  1.475,1.598,1.721,1.845,1.967,2.091,2.215,2.340,2.461,2.707,2.968];

//=============================================================================
//  HORIZONTAL ELLIPSE SHAPE
//=============================================================================

   N_A_HorizEllipse   = 26;
A_HorizEllipse =
[ .0000,.0150,.0400,.0650,.0950,.1300,.1650,.2050,.2500,.3000,
  .3550,.4150,.4800,.5200,.5850,.6450,.7000,.7500,.7950,.8350,
  .8700,.9050,.9350,.9600,.9850,1.000];

   N_R_HorizEllipse   = 26;
R_HorizEllipse =
[ .0100,.0764,.1726,.2389,.3274,.4191,.5120,.5983,.6757,.7630,
  .8326,.9114,.9702,1.030,1.091,1.146,1.185,1.225,1.257,1.274,
  1.290,1.282,1.274,1.257,1.185,1.000];

   N_W_HorizEllipse   = 26;
W_HorizEllipse =
[ .0,.3919,.5426,.6499,.7332,.8000,.8542,.8980,.9330,.9600,
  .9798,.9928,.9992,.9992,.9928,.9798,.9600,.9330,.8980,.8542,
  .8000,.7332,.6499,.5426,.3919,.0];


//=============================================================================
//  VERTICAL ELLIPSE SHAPE
//=============================================================================

   N_A_VertEllipse   = 26;
A_VertEllipse =
[ .0000,.0100,.0400,.0700,.1000,.1400,.1850,.2300,.2800,.3300,
  .3800,.4300,.4800,.5200,.5700,.6200,.6700,.7200,.7700,.8150,
  .8600,.9000,.9300,.9600,.9900,1.000];

   N_R_VertEllipse   = 26;
R_VertEllipse =
[ .0100,.1250,.2436,.3536,.4474,.5484,.6366,.7155,.7768,.8396,
  .8969,.9480,.9925,1.023,1.053,1.084,1.107,1.130,1.154,1.170,
  1.177,1.177,1.170,1.162,1.122,1.000];

   N_W_VertEllipse   = 26;
W_VertEllipse =
[ .0,.3919,.5426,.6499,.7332,.8000,.8542,.8980,.9330,.9600,
  .9798,.9928,.9992,.9992,.9928,.9798,.9600,.9330,.8980,.8542,
  .8000,.7332,.6499,.5426,.3919,.0];


//=============================================================================
//  ARCH SHAPE
//=============================================================================

NumCodesArch = 102;

Yfull_Arch =     // NOTE: these are in inches
[    
     /* Concrete */
     11,13.5,15.5,18,22.5,26.625,31.3125,36,40,45,54,62,
     72,77.5,87.125,96.875,106.5,

     /* Corrugated Steel (2-2/3 x 1/2 inch Corrugation) */
     13,15,18,20,24,29,33,38,43,47,52,57,

     /* Corrugated Steel (3 x 1 inch Corrugation) */
     31,36,41,46,51,55,59,63,67,71,75,79,83,87,91,  // 2nd value corrected

     /* Structural Plate (6 x 2 inch Corrugation - Bolted Seams
        19-inch Corner Radius */
     55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,
     93,95,97,100,101,103,105,107,109,111,113,115,118,119,121,

     /* Structural Plate (6 x 2 inch Corrugation - Bolted Seams
        31-inch Corner Radius */
     112,114,116,118,120,122,124,126,128,130,132,134,
     136,138,140,142,144,146,148,150,152,154,156,158];

Wmax_Arch =      // NOTE: these are in inches
[
     /* Concrete */
     18,22,26,28.5,36.25,43.75,51.125,58.5,65,73,88,102,
     115,122,138,154,168.75,

     /* Corrugated Steel (2 2/3 x 1/2 inch corrugation) */
     17,21,24,28,35,42,49,57,64,71,77,83,

     /* Corrugated Steel (3 x 1 inch Corrugation) */
     40,46,53,60,66,73,81,87,95,103,112,117,128,137,142,


     /* Structural Plate (6 x 2 inch Corrugation - Bolted Seams
        19-inch Corner Radius */
     73,76,81,84,87, 92,95,98,103,106,112,114,117,123,128,131,137,139,
     142,148,150,152,154,161,167,169,171,178,184,186,188,190,197,199,

     /* Structural Plate (6 x 2 inch Corrugation - Bolted Seams
        31-inch Corner Radius */
     159,162,168,170,173,179,184,187,190,195,198,204,
     206,209,215,217,223,225,231,234,236,239,245,247];

Afull_Arch =
[    1.1,1.65,2.2,2.8,4.4,6.4,8.8,11.4,14.3,17.7,25.6,34.6,
     44.5,51.7,66,81.8,99.1,1.1,1.6,2.2,2.9,4.5,6.5,8.9,11.6,14.7,18.1,
     21.9,26,7,9.4,12.3,15.6,19.3,23.2,27.4,32.1,37,42.4,48,54.2,60.5,
     67.4,74.5,22,24,26,28,31,33,35,38,40,43,46,49,52,55,58,61,64,67,
     71,74,78,81,85,89,93,97,101,105,109,113,118,122,126,131,97,102,
     105,109,114,118,123,127,132,137,142,146,151,157,161,167,172,177,
     182,188,194,200,205,211];

Rfull_Arch =
[    0.25,0.3,0.36,0.45,0.56,0.68,0.8,0.9,1.01,1.13,1.35,
     1.57,1.77,1.92,2.17,2.42,2.65,0.324,0.374,0.449,0.499,0.598,0.723,
     0.823,0.947,1.072,1.171,1.296,1.421,0.773,0.773,1.022,1.147,1.271,
     1.371,1.471,1.570,1.670,1.770,1.869,1.969,2.069,2.168,2.268,1.371,
     1.421,1.471,1.520,1.570,1.620,1.670,1.720,1.770,1.820,1.869,1.919,
     1.969,2.019,2.069,2.119,2.168,2.218,2.268,2.318,2.368,2.418,2.493,
     2.517,2.567,2.617,2.667,2.717,2.767,2.817,2.866,2.941,2.966,3.016,
     2.792,2.841,2.891,2.941,2.991,3.041,3.091,3.141,3.190,3.240,3.290,
     3.340,3.390,3.440,3.490,3.539,3.589,3.639,3.689,3.739,3.789,3.838,
     3.888,3.938];

   N_A_Arch   = 26;
A_Arch =
[ .0000,.0200,.0600,.1000,.1400,.1900,.2400,.2900,.3400,.3900,
  .4400,.4900,.5400,.5900,.6400,.6900,.7350,.7800,.8200,.8600,
  .8950,.9300,.9600,.9850,.9950,1.000];

   N_R_Arch   = 26;
R_Arch =
[ .0100,.0983,.1965,.2948,.3940,.4962,.5911,.6796,.7615,.8364,
  .9044,.9640,1.018,1.065,1.106,1.142,1.170,1.192,1.208,1.217,
  1.220,1.213,1.196,1.168,1.112,1.000];

   N_W_Arch   = 26;
W_Arch =
[ .0,.6272,.8521,.9243,.9645,.9846,.9964,.9988,.9917,.9811,
  .9680,.9515,.9314,.9101,.8864,.8592,.8284,.7917,.7527,.7065,
  .6544,.5953,.5231,.4355,.3195,.0];

////////////////////////////////////////////////

 RECT_ALFMAX        = 0.97
 RECT_TRIANG_ALFMAX = 0.98
 RECT_ROUND_ALFMAX  = 0.98


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
// Ratio of area at max. flow to full area
// (= 1.0 for open shapes, < 1.0 for closed shapes)
 Amax = [
                     1.0,     //  DUMMY
                     0.9756,  //  CIRCULAR
                     0.9756,  //  FILLED_CIRCULAR
                     0.97,    //  RECT_CLOSED
                     1.0,     //  RECT_OPEN
                     1.0,     //  TRAPEZOIDAL
                     1.0,     //  TRIANGULAR
                     1.0,     //  PARABOLIC
                     1.0,     //  POWERFUNC
                     0.98,    //  RECT_TRIANG
                     0.98,    //  RECT_ROUND
                     0.96,    //  MOD_BASKET
                     0.96,    //  HORIZ_ELLIPSE
                     0.96,    //  VERT_ELLIPSE
                     0.92,    //  ARCH
                     0.96,    //  EGGSHAPED
                     0.96,    //  HORSESHOE
                     0.96,    //  GOTHIC
                     0.98,    //  CATENARY
                     0.98,    //  SEMIELLIPTICAL
                     0.96,    //  BASKETHANDLE
                     0.96,    //  SEMICIRCULAR
                     1.0,     //  IRREGULAR
                     0.96,    //  CUSTOM
                     0.9756]; //  FORCE_MAIN

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
class TXsectStar
{
    constructor(){
        this.s;                // section factor
        this.qc;               // critical flow
        this.xsect ;   // TXsect*          // pointer to a cross section object
    }
} ;

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  xsect_isOpen
//  xsect_setParams
//  xsect_setIrregXsectParams
//  xsect_setCustomXsectParams
//  xsect_getAmax
//  xsect_getSofA
//  xsect_getYofA
//  xsect_getRofA
//  xsect_getAofS
//  xsect_getdSdA
//  xsect_getAofY
//  xsect_getRofY
//  xsect_getWofY
//  xsect_getYcrit


//=============================================================================
// int type
xsect_isOpen(type)
//
//  Input:   type = type of xsection shape
//  Output:  returns 1 if xsection is open, 0 if not
//  Purpose: determines if a xsection type is open or closed.
//
{
    return ((Amax[type] >= 1.0) ? 1 : 0);
}

//=============================================================================
// TXsect *xsect, int type, double p[], double ucf
xsect_setParams(xsect, type, p, ucf)
//
//  Input:   xsect = ptr. to a cross section data structure
//           type = xsection shape type
//           p[] = vector or xsection parameters
//           ucf = units correction factor
//  Output:  returns TRUE if successful, FALSE if not
//  Purpose: assigns parameters to a cross section's data structure.
//
{
    let    index;
    let aMax, theta;

    if ( type != DUMMY && p[0] <= 0.0 ) return FALSE;
    xsect.type  = type;
    switch ( xsect.type )
    {
    case DUMMY:
        xsect.yFull = TINY;
        xsect.wMax  = TINY;
        xsect.aFull = TINY;
        xsect.rFull = TINY;
        xsect.sFull = TINY;
        xsect.sMax  = TINY;
        break;

    case CIRCULAR:
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = xsect.yFull;
        xsect.aFull = PI / 4.0 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.2500 * xsect.yFull;
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = 1.08 * xsect.sFull;
        xsect.ywMax = 0.5 * xsect.yFull;
        break;

    case FORCE_MAIN:
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = xsect.yFull;
        xsect.aFull = PI / 4.0 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.2500 * xsect.yFull;
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 0.63);
        xsect.sMax  = 1.06949 * xsect.sFull;
        xsect.ywMax = 0.5 * xsect.yFull;

        // --- save C-factor or roughness in rBot position
        xsect.rBot  = p[1];
        break;

    case FILLED_CIRCULAR:
        if ( p[1] >= p[0] ) return FALSE;

        // --- initially compute full values for unfilled pipe
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = xsect.yFull;
        xsect.aFull = PI / 4.0 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.2500 * xsect.yFull;

        // --- find:
        //     yBot = depth of filled bottom
        //     aBot = area of filled bottom
        //     sBot = width of filled bottom
        //     rBot = wetted perimeter of filled bottom
        xsect.yBot  = p[1]/ucf;
        xsect.aBot  = circ_getAofY(xsect, xsect.yBot);
        xsect.sBot  = xsect_getWofY(xsect, xsect.yBot);
        xsect.rBot  = xsect.aBot / (xsect.rFull *
                       lookup(xsect.yBot/xsect.yFull, R_Circ, N_R_Circ));

        // --- revise full values for filled bottom
        xsect.aFull -= xsect.aBot;
        xsect.rFull = xsect.aFull /
                       (PI*xsect.yFull - xsect.rBot + xsect.sBot);
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = 1.08 * xsect.sFull;
        xsect.yFull -= xsect.yBot;
        xsect.ywMax = 0.5 * xsect.yFull;
        break;

    case EGGSHAPED:
        xsect.yFull = p[0]/ucf;
        xsect.aFull = 0.5105 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.1931 * xsect.yFull;
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = 1.065 * xsect.sFull;
        xsect.wMax  = 2./3. * xsect.yFull;
        xsect.ywMax = 0.64 * xsect.yFull;
        break;

    case HORSESHOE:
        xsect.yFull = p[0]/ucf;
        xsect.aFull = 0.8293 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.2538 * xsect.yFull;
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = 1.077 * xsect.sFull;
        xsect.wMax  = 1.0 * xsect.yFull;
        xsect.ywMax = 0.5 * xsect.yFull;
        break;

    case GOTHIC:
        xsect.yFull = p[0]/ucf;
        xsect.aFull = 0.6554 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.2269 * xsect.yFull;
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = 1.065 * xsect.sFull;
        xsect.wMax  = 0.84 * xsect.yFull;
        xsect.ywMax = 0.45 * xsect.yFull;
        break;

    case CATENARY:
        xsect.yFull = p[0]/ucf;
        xsect.aFull = 0.70277 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.23172 * xsect.yFull;
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = 1.05 * xsect.sFull;
        xsect.wMax  = 0.9 * xsect.yFull;
        xsect.ywMax = 0.25 * xsect.yFull;
        break;

    case SEMIELLIPTICAL:
        xsect.yFull = p[0]/ucf;
        xsect.aFull = 0.785 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.242 * xsect.yFull;
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = 1.045 * xsect.sFull;
        xsect.wMax  = 1.0 * xsect.yFull;
        xsect.ywMax = 0.15 * xsect.yFull;
        break;

    case BASKETHANDLE:
        xsect.yFull = p[0]/ucf;
        xsect.aFull = 0.7862 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.2464 * xsect.yFull;
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = 1.06078 * xsect.sFull;
        xsect.wMax  = 0.944 * xsect.yFull;
        xsect.ywMax = 0.2 * xsect.yFull;
        break;

    case SEMICIRCULAR:
        xsect.yFull = p[0]/ucf;
        xsect.aFull = 1.2697 * xsect.yFull * xsect.yFull;
        xsect.rFull = 0.2946 * xsect.yFull;
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = 1.06637 * xsect.sFull;
        xsect.wMax  = 1.64 * xsect.yFull;
        xsect.ywMax = 0.15 * xsect.yFull;
        break;

    case RECT_CLOSED:
        if ( p[1] <= 0.0 ) return FALSE;
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = p[1]/ucf;
        xsect.aFull = xsect.yFull * xsect.wMax;
        xsect.rFull = xsect.aFull / (2.0 * (xsect.yFull + xsect.wMax));
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        aMax = RECT_ALFMAX * xsect.aFull;
        xsect.sMax = aMax * Math.pow(rect_closed_getRofA(xsect, aMax), 2./3.);
        xsect.ywMax = xsect.yFull;
        break;

    case RECT_OPEN:
        if ( p[1] <= 0.0 ) return FALSE;
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = p[1]/ucf;
        if (p[2] < 0.0 || p[2] > 2.0) return FALSE;   //# sides to ignore
        xsect.sBot = p[2];
        xsect.aFull = xsect.yFull * xsect.wMax;
        xsect.rFull = xsect.aFull / ((2.0 - xsect.sBot) *
                       xsect.yFull + xsect.wMax);
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = xsect.sFull;
        xsect.ywMax = xsect.yFull;
        break;

    case RECT_TRIANG:
        if ( p[1] <= 0.0 || p[2] <= 0.0 ) return FALSE;
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = p[1]/ucf;
        xsect.yBot  = p[2]/ucf;
        xsect.ywMax = xsect.yFull;

        // --- area of bottom triangle
        xsect.aBot  = xsect.yBot * xsect.wMax / 2.0;

        // --- slope of bottom side wall
        xsect.sBot  = xsect.wMax / xsect.yBot / 2.0;

        // --- length of side wall per unit of depth
        xsect.rBot  = Math.sqrt( 1. + xsect.sBot * xsect.sBot );

        xsect.aFull = xsect.wMax * (xsect.yFull - xsect.yBot / 2.0);
        xsect.rFull = xsect.aFull / (2.0 * xsect.yBot * xsect.rBot + 2.0 *
                        (xsect.yFull - xsect.yBot) + xsect.wMax);
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        aMax = RECT_TRIANG_ALFMAX * xsect.aFull;
        xsect.sMax  = aMax * Math.pow(rect_triang_getRofA(xsect, aMax), 2./3.);
        break;

    case RECT_ROUND:
        if ( p[1] <= 0.0 ) return FALSE;
        if ( p[2] < p[1]/2.0 ) p[2] = p[1]/2.0;
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = p[1]/ucf;
        xsect.rBot  = p[2]/ucf;

        // --- angle of circular arc
        theta = 2.0 * Math.asin(xsect.wMax / 2.0 / xsect.rBot);

        // --- area of circular bottom
        xsect.aBot  = xsect.rBot * xsect.rBot /
                       2.0 * (theta - Math.sin(theta));

        // --- section factor for circular bottom
        xsect.sBot  = Math.PI * xsect.rBot * xsect.rBot *
                    Math.pow(xsect.rBot/2.0, 2./3.);

        // --- depth of circular bottom
        xsect.yBot  = xsect.rBot * (1.0 - Math.cos(theta/2.0));
        xsect.ywMax = xsect.yFull;

        xsect.aFull = xsect.wMax * (xsect.yFull - xsect.yBot) + xsect.aBot;
        xsect.rFull = xsect.aFull / (xsect.rBot * theta + 2.0 *
                        (xsect.yFull - xsect.yBot) + xsect.wMax);
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        aMax = RECT_ROUND_ALFMAX * xsect.aFull;
        xsect.sMax = aMax * Math.pow(rect_round_getRofA(xsect, aMax), 2./3.);
        break;

    case MOD_BASKET:
        if ( p[1] <= 0.0 ) return FALSE;
        if ( p[2] < p[1]/2.0 ) p[2] = p[1]/2.0;
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = p[1]/ucf;

        // --- radius of circular arc
        xsect.rBot = p[2]/ucf;

        // --- angle of circular arc
        theta = 2.0 * Math.asin(xsect.wMax / 2.0 / xsect.rBot);
        xsect.sBot = theta;

        // --- height of circular arc
        xsect.yBot = xsect.rBot * (1.0 - Math.cos(theta/2.0));
        xsect.ywMax = xsect.yFull - xsect.yBot;

        // --- area of circular arc
        xsect.aBot = xsect.rBot * xsect.rBot /
                      2.0 * (theta - Math.sin(theta));

        // --- full area
        xsect.aFull = (xsect.yFull - xsect.yBot) * xsect.wMax +
                       xsect.aBot;

        // --- full hydraulic radius & section factor
        xsect.rFull = xsect.aFull / (xsect.rBot * theta + 2.0 *
                        (xsect.yFull - xsect.yBot) + xsect.wMax);
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);

        // --- area corresponding to max. section factor
        xsect.sMax = xsect_getSofA(xsect, Amax[MOD_BASKET]*xsect.aFull);
        break;

    case TRAPEZOIDAL:
        if ( p[1] < 0.0 || p[2] < 0.0 || p[3] < 0.0 ) return FALSE;
        xsect.yFull = p[0]/ucf;
        xsect.ywMax = xsect.yFull;

        // --- bottom width
        xsect.yBot = p[1]/ucf;

        // --- avg. slope of side walls
        xsect.sBot  = ( p[2] + p[3] )/2.0;
        if ( xsect.yBot == 0.0 && xsect.sBot == 0.0 ) return FALSE;

        // --- length of side walls per unit of depth
        xsect.rBot  = Math.sqrt( 1.0 + p[2]*p[2] ) + Math.sqrt( 1.0 + p[3]*p[3] );

        // --- top width
        xsect.wMax = xsect.yBot + xsect.yFull * (p[2] + p[3]);

        xsect.aFull = ( xsect.yBot + xsect.sBot * xsect.yFull ) * xsect.yFull;
        xsect.rFull = xsect.aFull / (xsect.yBot + xsect.yFull * xsect.rBot);
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = xsect.sFull;
        break;

    case TRIANGULAR:
        if ( p[1] <= 0.0 ) return FALSE;
        xsect.yFull = p[0]/ucf;
		xsect.wMax  = p[1]/ucf;
        xsect.ywMax = xsect.yFull;

        // --- slope of side walls
        xsect.sBot  = xsect.wMax / xsect.yFull / 2.;

        // --- length of side wall per unit of depth
        xsect.rBot  = Math.sqrt( 1. + xsect.sBot * xsect.sBot );

        xsect.aFull = xsect.yFull * xsect.yFull * xsect.sBot;
        xsect.rFull = xsect.aFull / (2.0 * xsect.yFull * xsect.rBot);
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = xsect.sFull;
        break;

    case PARABOLIC:
        if ( p[1] <= 0.0 ) return FALSE;
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = p[1]/ucf;
        xsect.ywMax = xsect.yFull;

        // --- rBot :: 1/c^.5, where y = c*x^2 is eqn. of parabolic shape
        xsect.rBot  = xsect.wMax / 2.0 / Math.sqrt(xsect.yFull);

        xsect.aFull = (2./3.) * xsect.yFull * xsect.wMax;
        xsect.rFull = xsect_getRofY(xsect, xsect.yFull);
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = xsect.sFull;
        break;

    case POWERFUNC:
        if ( p[1] <= 0.0 || p[2] <= 0.0 ) return FALSE;
        xsect.yFull = p[0]/ucf;
        xsect.wMax  = p[1]/ucf;
        xsect.ywMax = xsect.yFull;
        xsect.sBot  = 1.0 / p[2];
        xsect.rBot  = xsect.wMax / (xsect.sBot + 1) /
                        Math.pow(xsect.yFull, xsect.sBot);
        xsect.aFull = xsect.yFull * xsect.wMax / (xsect.sBot+1);
        xsect.rFull = xsect_getRofY(xsect, xsect.yFull);
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = xsect.sFull;
        break;

    case HORIZ_ELLIPSE:
        if ( p[1] == 0.0 ) p[2] = p[0];
        if ( p[2] > 0.0 )                        // std. ellipse pipe
        {
            index = floor(p[2]) - 1;        // size code
            if ( index < 0 ||
                 index >= NumCodesEllipse ) return FALSE;
            xsect.yFull = MinorAxis_Ellipse[index]/12.;
            xsect.wMax  = MajorAxis_Ellipse[index]/12.;
            xsect.aFull = Afull_Ellipse[index];
            xsect.rFull = Rfull_Ellipse[index];
        }
        else
        {
            // --- length of minor axis
            xsect.yFull = p[0]/ucf;

            // --- length of major axis
            if ( p[1] < 0.0 ) return FALSE;
            xsect.wMax = p[1]/ucf;
            xsect.aFull = 1.2692 * xsect.yFull * xsect.yFull;
            xsect.rFull = 0.3061 * xsect.yFull;
        }
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = xsect.sFull;
        xsect.ywMax = 0.48 * xsect.yFull;
        break;

    case VERT_ELLIPSE:
        if ( p[1] == 0.0 ) p[2] = p[0];
        if ( p[2] > 0.0 )                        // std. ellipse pipe
        {
            index = floor(p[2]) - 1;        // size code
            if ( index < 0 ||
                 index >= NumCodesEllipse ) return FALSE;
            xsect.yFull = MajorAxis_Ellipse[index]/12.;
            xsect.wMax  = MinorAxis_Ellipse[index]/12.;
            xsect.aFull = Afull_Ellipse[index];
            xsect.rFull = Rfull_Ellipse[index];
        }
        else
        {
            // --- length of major axis
            if ( p[1] < 0.0 ) return FALSE;

            // --- length of minor axis
            xsect.yFull = p[0]/ucf;
            xsect.wMax = p[1]/ucf;
            xsect.aFull = 1.2692 * xsect.wMax * xsect.wMax;
            xsect.rFull = 0.3061 * xsect.wMax;
        }
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = xsect.sFull;
        xsect.ywMax = 0.48 * xsect.yFull;
        break;

    case ARCH:
        if ( p[1] == 0.0 ) p[2] = p[0];
        if ( p[2] > 0.0 )                        // std. arch pipe
        {
            index = floor(p[2]) - 1;        // size code
            if ( index < 0 ||
                 index >= NumCodesArch ) return FALSE;
            xsect.yFull = Yfull_Arch[index]/12.;     // Yfull units are inches
            xsect.wMax  = Wmax_Arch[index]/12.;      // Wmax units are inches
            xsect.aFull = Afull_Arch[index];
            xsect.rFull = Rfull_Arch[index];
        }
        else                                     // non-std. arch pipe
        {
            if ( p[1] < 0.0 ) return FALSE;
            xsect.yFull = p[0]/ucf;
            xsect.wMax  = p[1]/ucf;
            xsect.aFull = 0.7879 * xsect.yFull * xsect.wMax;
            xsect.rFull = 0.2991 * xsect.yFull;
        }
        xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
        xsect.sMax  = xsect.sFull;
        xsect.ywMax = 0.28 * xsect.yFull;
        break;
    }
    return TRUE;
}

//=============================================================================
// TXsect *xsect
xsect_setIrregXsectParams(xsect)
//
//  Input:   xsect = ptr. to a cross section data structure
//  Output:  none
//  Purpose: assigns transect parameters to an irregular shaped cross section.
//
{
    let index = xsect.transect;
    let     i, iMax;
    let  wMax;
    let wTbl = Transect[index].widthTbl;

    xsect.yFull = Transect[index].yFull;
    xsect.wMax  = Transect[index].wMax;
    xsect.aFull = Transect[index].aFull;
    xsect.rFull = Transect[index].rFull;
    xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
    xsect.sMax = Transect[index].sMax;
    xsect.aBot = Transect[index].aMax;

    // Search transect's width table up to point where width decreases
    iMax = 0;
    wMax = wTbl[0];
    for (i = 1; i < N_TRANSECT_TBL; i++)
    {
	if ( wTbl[i] < wMax ) break;
	wMax = wTbl[i];
	iMax = i;
    }

    // Determine height at lowest widest point
    xsect.ywMax = xsect.yFull * iMax / (N_TRANSECT_TBL-1);
}

//=============================================================================
// TXsect *xsect
xsect_setCustomXsectParams(xsect)
//
//  Input:   xsect = ptr. to a cross section data structure
//  Output:  none
//  Purpose: assigns parameters to a custom-shaped cross section.
//
{
    let index = Curve[xsect.transect].refersTo;
    let yFull = xsect.yFull;
    let i, iMax;
    let wMax;
    let wTbl = Shape[index].widthTbl;

    xsect.wMax  = Shape[index].wMax * yFull;
    xsect.aFull = Shape[index].aFull * yFull * yFull;
    xsect.rFull = Shape[index].rFull * yFull;
    xsect.sFull = xsect.aFull * Math.pow(xsect.rFull, 2./3.);
    xsect.sMax  = Shape[index].sMax * yFull * yFull * Math.pow(yFull, 2./3.);
    xsect.aBot  = Shape[index].aMax * yFull * yFull;

    // Search shape's width table up to point where width decreases
    iMax = 0;
    wMax = wTbl[0];
    for (i = 1; i < N_SHAPE_TBL; i++)
    {
	if ( wTbl[i] < wMax ) break;
	wMax = wTbl[i];
	iMax = i;
    }

    // Determine height at lowest widest point
    xsect.ywMax = yFull * iMax / (N_SHAPE_TBL-1);
}

//=============================================================================
// TXsect* xsect
xsect_getAmax(xsect)
//
//  Input:   xsect = ptr. to a cross section data structure
//  Output:  returns area (ft2)
//  Purpose: finds xsection area at maximum flow depth.
//
{
    if ( xsect.type == IRREGULAR ) return xsect.aBot;
    else if ( xsect.type == CUSTOM ) return xsect.aBot;
    else return Amax[xsect.type] * xsect.aFull;
}

//=============================================================================
// TXsect *xsect, double a
xsect_getSofA(xsect, a)
//
//  Input:   xsect = ptr. to a cross section data structure
//           a = area (ft2)
//  Output:  returns section factor (ft^(8/3))
//  Purpose: computes xsection's section factor at a given area.
//
{
    let alpha = a / xsect.aFull;
    let r;
    switch ( xsect.type )
    {
      case FORCE_MAIN:
      case CIRCULAR:
        return circ_getSofA(xsect, a);

      case EGGSHAPED:
        return xsect.sFull * lookup(alpha, S_Egg, N_S_Egg);

      case HORSESHOE:
        return xsect.sFull * lookup(alpha, S_Horseshoe, N_S_Horseshoe);

      case GOTHIC:
        return xsect.sFull * lookup(alpha, S_Gothic, N_S_Gothic);

      case CATENARY:
        return xsect.sFull * lookup(alpha, S_Catenary, N_S_Catenary);

      case SEMIELLIPTICAL:
        return xsect.sFull * lookup(alpha, S_SemiEllip, N_S_SemiEllip);

      case BASKETHANDLE:
        return xsect.sFull * lookup(alpha, S_BasketHandle, N_S_BasketHandle);

      case SEMICIRCULAR:
        return xsect.sFull * lookup(alpha, S_SemiCirc, N_S_SemiCirc);

      case RECT_CLOSED:
        return rect_closed_getSofA(xsect, a);

      case RECT_OPEN:
        return rect_open_getSofA(xsect, a);

      case RECT_TRIANG:
        return rect_triang_getSofA(xsect, a);

      case RECT_ROUND:
        return rect_round_getSofA(xsect, a);

      default:
        if (a == 0.0) return 0.0;
        r = xsect_getRofA(xsect, a);
        if ( r < TINY ) return 0.0;
        return a * Math.pow(r, 2./3.);
    }
}

//=============================================================================
// TXsect *xsect, double a
xsect_getYofA(xsect, a)
//
//  Input:   xsect = ptr. to a cross section data structure
//           a = area (ft2)
//  Output:  returns depth (ft)
//  Purpose: computes xsection's depth at a given area.
//
{
    let alpha = a / xsect.aFull;
    switch ( xsect.type )
    {
      case FORCE_MAIN:
      case CIRCULAR: return circ_getYofA(xsect, a);

      case FILLED_CIRCULAR:
        return filled_circ_getYofA(xsect, a);

      case EGGSHAPED:
        return xsect.yFull * lookup(alpha, Y_Egg, N_Y_Egg);

      case HORSESHOE:
        return xsect.yFull * lookup(alpha, Y_Horseshoe, N_Y_Horseshoe);

      case GOTHIC:
        return xsect.yFull * lookup(alpha, Y_Gothic, N_Y_Gothic);

      case CATENARY:
        return xsect.yFull * lookup(alpha, Y_Catenary, N_Y_Catenary);

      case SEMIELLIPTICAL:
        return xsect.yFull * lookup(alpha, Y_SemiEllip, N_Y_SemiEllip);

      case BASKETHANDLE:
        return xsect.yFull * lookup(alpha, Y_BasketHandle, N_Y_BasketHandle);

      case SEMICIRCULAR:
        return xsect.yFull * lookup(alpha, Y_SemiCirc, N_Y_SemiCirc);

      case HORIZ_ELLIPSE:
        return xsect.yFull * invLookup(alpha, A_HorizEllipse, N_A_HorizEllipse);

      case VERT_ELLIPSE:
        return xsect.yFull * invLookup(alpha, A_VertEllipse, N_A_VertEllipse);

      case IRREGULAR:
        return xsect.yFull * invLookup(alpha,
            Transect[xsect.transect].areaTbl, N_TRANSECT_TBL);

      case CUSTOM:
        return xsect.yFull * invLookup(alpha,
            Shape[Curve[xsect.transect].refersTo].areaTbl, N_SHAPE_TBL);

      case ARCH:
        return xsect.yFull * invLookup(alpha, A_Arch, N_A_Arch);

      case RECT_CLOSED: return a / xsect.wMax;

      case RECT_TRIANG: return rect_triang_getYofA(xsect, a);

      case RECT_ROUND:  return rect_round_getYofA(xsect, a);

      case RECT_OPEN:   return a / xsect.wMax;

      case MOD_BASKET:  return mod_basket_getYofA(xsect, a);

      case TRAPEZOIDAL: return trapez_getYofA(xsect, a);

      case TRIANGULAR:  return triang_getYofA(xsect, a);

      case PARABOLIC:   return parab_getYofA(xsect, a);

      case POWERFUNC:   return powerfunc_getYofA(xsect, a);

      default:          return 0.0;
    }
}

//=============================================================================
// TXsect *xsect, double y
xsect_getAofY(xsect,  y)
//
//  Input:   xsect = ptr. to a cross section data structure
//           y = depth (ft)
//  Output:  returns area (ft2)
//  Purpose: computes xsection's area at a given depth.
//
{
    let yNorm = y / xsect.yFull;
    if ( y <= 0.0 ) return 0.0;
    switch ( xsect.type )
    {
      case FORCE_MAIN:
      case CIRCULAR:
        return xsect.aFull * lookup(yNorm, A_Circ, N_A_Circ);

      case FILLED_CIRCULAR:
        return filled_circ_getAofY(xsect, y);

      case EGGSHAPED:
        return xsect.aFull * lookup(yNorm, A_Egg, N_A_Egg);

      case HORSESHOE:
        return xsect.aFull * lookup(yNorm, A_Horseshoe, N_A_Horseshoe);

      case GOTHIC:
        return xsect.aFull * invLookup(yNorm, Y_Gothic, N_Y_Gothic);

      case CATENARY:
        return xsect.aFull * invLookup(yNorm, Y_Catenary, N_Y_Catenary);

      case SEMIELLIPTICAL:
        return xsect.aFull * invLookup(yNorm, Y_SemiEllip, N_Y_SemiEllip);

      case BASKETHANDLE:
        return xsect.aFull * lookup(yNorm, A_Baskethandle, N_A_Baskethandle);

      case SEMICIRCULAR:
        return xsect.aFull * invLookup(yNorm, Y_SemiCirc, N_Y_SemiCirc);

      case HORIZ_ELLIPSE:
        return xsect.aFull * lookup(yNorm, A_HorizEllipse, N_A_HorizEllipse);

      case VERT_ELLIPSE:
        return xsect.aFull * lookup(yNorm, A_VertEllipse, N_A_VertEllipse);

      case ARCH:
        return xsect.aFull * lookup(yNorm, A_Arch, N_A_Arch);

      case IRREGULAR:
        return xsect.aFull * lookup(yNorm,
            Transect[xsect.transect].areaTbl, N_TRANSECT_TBL);

      case CUSTOM:
        return xsect.aFull * lookup(yNorm,
            Shape[Curve[xsect.transect].refersTo].areaTbl, N_SHAPE_TBL);

     case RECT_CLOSED:  return y * xsect.wMax;

      case RECT_TRIANG: return rect_triang_getAofY(xsect, y);

      case RECT_ROUND:  return rect_round_getAofY(xsect, y);

      case RECT_OPEN:   return y * xsect.wMax;

      case MOD_BASKET:  return mod_basket_getAofY(xsect, y);

      case TRAPEZOIDAL: return trapez_getAofY(xsect, y);

      case TRIANGULAR:  return triang_getAofY(xsect, y);

      case PARABOLIC:   return parab_getAofY(xsect, y);

      case POWERFUNC:   return powerfunc_getAofY(xsect, y);

      default:          return 0.0;
    }
}

//=============================================================================
// TXsect *xsect, double y
xsect_getWofY(xsect, y)
//
//  Input:   xsect = ptr. to a cross section data structure
//           y = depth ft)
//  Output:  returns top width (ft)
//  Purpose: computes xsection's top width at a given depth.
//
{
    let yNorm = y / xsect.yFull;
    switch ( xsect.type )
    {
      case FORCE_MAIN:
      case CIRCULAR:
        return xsect.wMax * lookup(yNorm, W_Circ, N_W_Circ);

      case FILLED_CIRCULAR:
        yNorm = (y + xsect.yBot) / (xsect.yFull + xsect.yBot);
        return xsect.wMax * lookup(yNorm, W_Circ, N_W_Circ);

      case EGGSHAPED:
        return xsect.wMax * lookup(yNorm, W_Egg, N_W_Egg);

      case HORSESHOE:
        return xsect.wMax * lookup(yNorm, W_Horseshoe, N_W_Horseshoe);

      case GOTHIC:
        return xsect.wMax * lookup(yNorm, W_Gothic, N_W_Gothic);

      case CATENARY:
        return xsect.wMax * lookup(yNorm, W_Catenary, N_W_Catenary);

      case SEMIELLIPTICAL:
        return xsect.wMax * lookup(yNorm, W_SemiEllip, N_W_SemiEllip);

      case BASKETHANDLE:
        return xsect.wMax * lookup(yNorm, W_BasketHandle, N_W_BasketHandle);

      case SEMICIRCULAR:
        return xsect.wMax * lookup(yNorm, W_SemiCirc, N_W_SemiCirc);

      case HORIZ_ELLIPSE:
        return xsect.wMax * lookup(yNorm, W_HorizEllipse, N_W_HorizEllipse);

      case VERT_ELLIPSE:
        return xsect.wMax * lookup(yNorm, W_VertEllipse, N_W_VertEllipse);

      case ARCH:
        return xsect.wMax * lookup(yNorm, W_Arch, N_W_Arch);

      case IRREGULAR:
        return xsect.wMax * lookup(yNorm,
            Transect[xsect.transect].widthTbl, N_TRANSECT_TBL);

      case CUSTOM:
        return xsect.wMax * lookup(yNorm,
            Shape[Curve[xsect.transect].refersTo].widthTbl, N_SHAPE_TBL);

      case RECT_CLOSED: 
          if (yNorm == 1.0) return 0.0;                                        //(5.1.013)
          return xsect.wMax;

      case RECT_TRIANG: return rect_triang_getWofY(xsect, y);

      case RECT_ROUND:  return rect_round_getWofY(xsect, y);

      case RECT_OPEN:   return xsect.wMax;

      case MOD_BASKET:  return mod_basket_getWofY(xsect, y);

      case TRAPEZOIDAL: return trapez_getWofY(xsect, y);

      case TRIANGULAR:  return triang_getWofY(xsect, y);

      case PARABOLIC:   return parab_getWofY(xsect, y);

      case POWERFUNC:   return powerfunc_getWofY(xsect, y);

      default:          return 0.0;
    }
}

//=============================================================================
// TXsect *xsect, double y
xsect_getRofY(xsect, y)
//
//  Input:   xsect = ptr. to a cross section data structure
//           y = depth (ft)
//  Output:  returns hydraulic radius (ft)
//  Purpose: computes xsection's hydraulic radius at a given depth.
//
{
    let yNorm = y / xsect.yFull;
    switch ( xsect.type )
    {
      case FORCE_MAIN:
      case CIRCULAR:
        return xsect.rFull * lookup(yNorm, R_Circ, N_R_Circ);

      case FILLED_CIRCULAR:
        if ( xsect.yBot == 0.0 )
            return xsect.rFull * lookup(yNorm, R_Circ, N_R_Circ);
        return filled_circ_getRofY(xsect, y);

      case EGGSHAPED:
        return xsect.rFull * lookup(yNorm, R_Egg, N_R_Egg);

      case HORSESHOE:
        return xsect.rFull * lookup(yNorm, R_Horseshoe, N_R_Horseshoe);

      case BASKETHANDLE:
        return xsect.rFull * lookup(yNorm, R_Baskethandle, N_R_Baskethandle);

      case HORIZ_ELLIPSE:
        return xsect.rFull * lookup(yNorm, R_HorizEllipse, N_R_HorizEllipse);

      case VERT_ELLIPSE:
        return xsect.rFull * lookup(yNorm, R_VertEllipse, N_R_VertEllipse);

      case ARCH:
        return xsect.rFull * lookup(yNorm, R_Arch, N_R_Arch);

      case IRREGULAR:
        return xsect.rFull * lookup(yNorm,
            Transect[xsect.transect].hradTbl, N_TRANSECT_TBL);

      case CUSTOM:
        return xsect.rFull * lookup(yNorm,
            Shape[Curve[xsect.transect].refersTo].hradTbl, N_SHAPE_TBL);

      case RECT_TRIANG:  return rect_triang_getRofY(xsect, y);

      case RECT_ROUND:   return rect_round_getRofY(xsect, y);

      case TRAPEZOIDAL:  return trapez_getRofY(xsect, y);

      case TRIANGULAR:   return triang_getRofY(xsect, y);

      case PARABOLIC:    return parab_getRofY(xsect, y);

      case POWERFUNC:    return powerfunc_getRofY(xsect, y);

      default:           return xsect_getRofA( xsect, xsect_getAofY(xsect, y) );
    }
}

//=============================================================================
// TXsect *xsect, double a
xsect_getRofA(xsect, a)
//
//  Input:   xsect = ptr. to a cross section data structure
//           a = area (ft2)
//  Output:  returns hydraulic radius (ft)
//  Purpose: computes xsection's hydraulic radius at a given area.
//
{
    let cathy;
    if ( a <= 0.0 ) return 0.0;
    switch ( xsect.type )
    {
      case HORIZ_ELLIPSE:
      case VERT_ELLIPSE:
      case ARCH:
      case IRREGULAR:
      case FILLED_CIRCULAR:
      case CUSTOM:
        return xsect_getRofY( xsect, xsect_getYofA(xsect, a) );

      case RECT_CLOSED:  return rect_closed_getRofA(xsect, a);

      case RECT_OPEN:    return a / (xsect.wMax +
                             (2. - xsect.sBot) * a / xsect.wMax);

      case RECT_TRIANG:  return rect_triang_getRofA(xsect, a);

      case RECT_ROUND:   return rect_round_getRofA(xsect, a);

      case MOD_BASKET:   return mod_basket_getRofA(xsect, a);

      case TRAPEZOIDAL:  return trapez_getRofA(xsect, a);

      case TRIANGULAR:   return triang_getRofA(xsect, a);

      case PARABOLIC:    return parab_getRofA(xsect, a);

      case POWERFUNC:    return powerfunc_getRofA(xsect, a);

      default:
        cathy = xsect_getSofA(xsect, a);
        if ( cathy < TINY || a < TINY ) return 0.0;
        return Math.pow(cathy/a, 3./2.);
    }
}

//=============================================================================
// TXsect* xsect, double s
xsect_getAofS(xsect, s)
//
//  Input:   xsect = ptr. to a cross section data structure
//           s = section factor (ft^(8/3))
//  Output:  returns area (ft2)
//  Purpose: computes xsection's area at a given section factor.
//
{
    let psi = s / xsect.sFull;
    if ( s <= 0.0 ) return 0.0;
    if ( s > xsect.sMax ) s = xsect.sMax;
    switch ( xsect.type )
    {
      case DUMMY:     return 0.0;

      case FORCE_MAIN:
      case CIRCULAR:  return circ_getAofS(xsect, s);

      case EGGSHAPED:
        return xsect.aFull * invLookup(psi, S_Egg, N_S_Egg);

      case HORSESHOE:
        return xsect.aFull * invLookup(psi, S_Horseshoe, N_S_Horseshoe);

      case GOTHIC:
        return xsect.aFull * invLookup(psi, S_Gothic, N_S_Gothic);

      case CATENARY:
        return xsect.aFull * invLookup(psi, S_Catenary, N_S_Catenary);

      case SEMIELLIPTICAL:
        return xsect.aFull * invLookup(psi, S_SemiEllip, N_S_SemiEllip);

      case BASKETHANDLE:
        return xsect.aFull * invLookup(psi, S_BasketHandle, N_S_BasketHandle);

      case SEMICIRCULAR:
        return xsect.aFull * invLookup(psi, S_SemiCirc, N_S_SemiCirc);

      default: return generic_getAofS(xsect, s);
    }
}

//=============================================================================
// TXsect* xsect, double a
xsect_getdSdA(xsect, a)
//
//  Input:   xsect = ptr. to a cross section data structure
//           a = area (ft2)
//  Output:  returns derivative of section factor w.r.t. area (ft^2/3)
//  Purpose: computes xsection's derivative of its section factor with
//           respect to area at a given area.
//
{
    switch ( xsect.type )
    {
      case FORCE_MAIN:
      case CIRCULAR:
        return circ_getdSdA(xsect, a);

      case EGGSHAPED:
        return tabular_getdSdA(xsect, a, S_Egg, N_S_Egg);

      case HORSESHOE:
        return tabular_getdSdA(xsect, a, S_Horseshoe, N_S_Horseshoe);

      case GOTHIC:
        return tabular_getdSdA(xsect, a, S_Gothic, N_S_Gothic);

      case CATENARY:
        return tabular_getdSdA(xsect, a, S_Catenary, N_S_Catenary);

      case SEMIELLIPTICAL:
        return  tabular_getdSdA(xsect, a, S_SemiEllip, N_S_SemiEllip);

      case BASKETHANDLE:
        return  tabular_getdSdA(xsect, a, S_BasketHandle, N_S_BasketHandle);

      case SEMICIRCULAR:
        return  tabular_getdSdA(xsect, a, S_SemiCirc, N_S_SemiCirc);

      case RECT_CLOSED:
        return rect_closed_getdSdA(xsect, a);

      case RECT_OPEN:
        return rect_open_getdSdA(xsect, a);

      case RECT_TRIANG:
	return rect_triang_getdSdA(xsect, a);

      case RECT_ROUND:
	return rect_round_getdSdA(xsect, a);

      case MOD_BASKET:
	return mod_basket_getdSdA(xsect, a);

      case TRAPEZOIDAL:
	return trapez_getdSdA(xsect, a);

      case TRIANGULAR:
	return triang_getdSdA(xsect, a);

      default: return generic_getdSdA(xsect, a);
    }
}

//=============================================================================
// TXsect* xsect, double q
xsect_getYcrit(xsect, q)
//
//  Input:   xsect = ptr. to a cross section data structure
//           q = flow rate (cfs)
//  Output:  returns critical depth (ft)
//  Purpose: computes critical depth at a specific flow rate.
//
{
    let q2g = Math.sqrt(q) / GRAVITY;
    let y, r;

    if ( q2g == 0.0 ) return 0.0;
    switch ( xsect.type )
    {
      case DUMMY:
        return 0.0;

      case RECT_OPEN:
      case RECT_CLOSED:
        // --- analytical expression for yCritical is
        //     y = (q2g / w^2)^(1/3) where w = width
        y = Math.pow(q2g / Math.pow(xsect.wMax, 2), 1./3.);
        break;

      case TRIANGULAR:
        // --- analytical expression for yCritical is
        //     y = (2 * q2g / s^2)^(1/5) where s = side slope
        y = Math.pow(2.0 * q2g / Math.pow(xsect.sBot, 2), 1./5.);
        break;

      case PARABOLIC:
        // --- analytical expression for yCritical is
        //     y = (27/32 * q2g * c)^(1/4) where y = c*x^2
        //     is eqn. for parabola and 1/sqrt(c) = rBot
        y = Math.pow(27./32. * q2g / Math.pow(xsect.rBot, 2), 1./4.);
        break;

      case POWERFUNC:
        y = 1. / (2.0 * xsect.sBot + 3.0);
        y = Math.pow( q2g * (xsect.sBot + 1.0) / Math.pow(xsect.rBot, 2), y);
        break;

      default:
        // --- first estimate yCritical for an equivalent circular conduit
        //     using 1.01 * (q2g / yFull)^(1/4)
        y = 1.01 * Math.pow(q2g / xsect.yFull, 1./4.);
        if (y >= xsect.yFull) y = 0.97 * xsect.yFull;

        // --- then find ratio of conduit area to equiv. circular area
        r = xsect.aFull / (PI / 4.0 * Math.pow(xsect.yFull, 2));

        // --- use interval enumeration method to find yCritical if
        //     area ratio not too far from 1.0
        if ( r >= 0.5 && r <= 2.0 )
            y = getYcritEnum(xsect, q, y);

        // --- otherwise use Ridder's root finding method
        else y = getYcritRidder(xsect, q, y);
    }

    // --- do not allow yCritical to be > yFull
    return Math.min(y, xsect.yFull);
}

//=============================================================================
// TXsect* xsect, double s
generic_getAofS(xsect, s)
//
//  Input:   xsect = ptr. to a cross section data structure
//           s = section factor (ft^8/3)
//  Output:  returns area (ft2)
//  Purpose: finds area given section factor by
//           solving S = A*(A/P(A))^(2/3) using Newton-Raphson iterations.
//
{
    let a, a1, a2, tol;
    xsectStar = new TXsectStar();

    // ret facil
    let returnObj;
    let returnVal;

    if (s <= 0.0) return 0.0;

    // --- if S is between sMax and sFull then
    //     bracket A between aFull and aMax
    if ( (s <= xsect.sMax && s >= xsect.sFull)
    &&   xsect.sMax != xsect.sFull )
    {
        a1 = xsect.aFull;          // do this because sFull < sMax
        a2 = xsect_getAmax(xsect);
    }

    // --- otherwise bracket A between 0 and aMax
    else
    {
        a1 = 0.0;
        a2 = xsect_getAmax(xsect);
    }

    // --- place S & xsect in xsectStar for access by evalSofA function
    xsectStar.xsect = xsect;
    xsectStar.s = s;

    // --- compute starting guess for A
    a = 0.5 * (a1 + a2);

    // use the Newton-Raphson root finder to find A
    tol = 0.0001 * xsect.aFull;
    ////////////////////////////////////
    returnObj = {rts: a, p: xsectStar}
    returnVal = findroot_Newton(a1, a2
                    , returnObj, tol, evalSofA)
    a = returnObj.rts;
    xsectStar = returnObj.p
    ////////////////////////////////////
    //findroot_Newton(a1, a2, a, tol, evalSofA, xsectStar);
    return a;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {f: val1, df: val2, p: val3}
//let returnVal = evalSofA(a, returnObj)
//val1 = returnObj.f;
//val2 = returnObj.df;
//val3 = returnObj.p;
////////////////////////////////////
evalSofA(a, inObj)
//void evalSofA(double a, double* f, double* df, void* p)
//
//  Input:   a = area
//  Output:  f = root finding function
//           df = derivative of root finding function
//  Purpose: used in conjunction with getAofS() that evaluates
//           f = S(a) - s and df = dS(a)/dA.
//
{
    //TXsectStar* xsectStar;
    let s;

    let xsectStar = inObj.p;
    s = xsect_getSofA(xsectStar.xsect, a);
    inObj.f = s - xsectStar.s;
    inObj.df = xsect_getdSdA(xsectStar.xsect, a);
}

//=============================================================================

tabular_getdSdA(xsect, a, table, nItems)
//double tabular_getdSdA(TXsect* xsect, double a, double *table, int nItems)
//
//  Input:   xsect = ptr. to cross section data structure
//           a = area (ft2)
//           table = ptr. to table of section factor v. normalized area
//           nItems = number of equally spaced items in table
//  Output:  returns derivative of section factor w.r.t. area (ft^2/3)
//  Purpose: computes derivative of section factor w.r.t area
//           using geometry tables.
//
{
    let    i;
    let alpha = a / xsect.aFull;
    let delta = 1.0 / (nItems-1);
    let dSdA;

    // --- find which segment of table contains alpha
    i = Math.trunc(alpha / delta);
    if ( i >= nItems - 1 ) i = nItems - 2;

    // --- compute slope from this interval of table
    dSdA = (table[i+1] - table[i]) / delta;

    // --- convert slope to un-normalized value
    return dSdA * xsect.sFull / xsect.aFull;
}

//=============================================================================
// TXsect* xsect, double a
generic_getdSdA(xsect, a)
//
//  Input:   xsect = ptr. to cross section data structure
//           a = area (ft2)
//  Output:  returns derivative of section factor w.r.t. area (ft^2/3)
//  Purpose: computes derivative of section factor w.r.t area
//           using central difference approximation.
//
{
    let a1, a2;
    let alpha = a / xsect.aFull;
    let alpha1 = alpha - 0.001;
    let alpha2 = alpha + 0.001;
    if ( alpha1 < 0.0 ) alpha1 = 0.0;
    a1 = alpha1 * xsect.aFull;
    a2 = alpha2 * xsect.aFull;
    return (xsect_getSofA(xsect, a2) - xsect_getSofA(xsect, a1)) / (a2 - a1);
}

//=============================================================================
// double x, double *table, int nItems
lookup(x, table, nItems)
//
//  Input:   x = value of independent variable in a geometry table
//           table = ptr. to geometry table
//           nItems = number of equally spaced items in table
//  Output:  returns value of dependent table variable
//  Purpose: looks up a value in a geometry table (i.e., finds y given x).
//
{
    let  delta, x0, x1, y, y2;
    let     i;

    // --- find which segment of table contains x
    delta = 1.0 / (nItems-1);
    i = Math.trunc(x / delta);
    if ( i >= nItems - 1 ) return table[nItems-1];

    // --- compute x at start and end of segment
    x0 = i * delta;
    x1 = (i+1) * delta;

    // --- linearly interpolate a y-value
    y = table[i] + (x - x0) * (table[i+1] - table[i]) / delta;

    // --- use quadratic interpolation for low x value
    if ( i < 2 )
    {
        y2 = y + (x - x0) * (x - x1) / (delta*delta) *
             (table[i]/2.0 - table[i+1] + table[i+2]/2.0) ;
        if ( y2 > 0.0 ) y = y2;
    }
    if ( y < 0.0 ) y = 0.0;
    return y;
}

//=============================================================================
// double y, double *table, int nItems
invLookup(y, table, nItems)
//
//  Input:   y = value of dependent variable in a geometry table
//           table = ptr. to geometry table
//           nItems = number of equally spaced items in table
//  Output:  returns value of independent table variable
//  Purpose: performs inverse lookup in a geometry table (i.e., finds
//           x given y).
//
//  Notes:   This assumes that the geometry table has either strictly
//           increasing entries or that the maximum entry is always third
//           from the last (which is true for all section factor tables). In
//           the latter case, the location of a large y can be ambiguous
//           -- it can be both below and above the location of the maximum.
//           In such cases this routine searches only the interval above
//           the maximum (i.e., the last 2 segments of the table).
//
//           nItems-1 is the highest subscript for the table's data.
//
//           The x value's in a geometry table lie between 0 and 1.
//
{
    let dx;               // x-increment of table
    let x, x0, dy;        // interpolation variables
    let    n;                // # items in increasing portion of table
    let    i;                // lower table index that brackets y

    // --- compute table's uniform x-increment
    dx = 1.0 / (nItems-1);

    // --- truncate item count if last 2 table entries are decreasing
    n = nItems;
    if ( table[n-3] > table[n-1] ) n = n - 2;

    // --- check if y falls in decreasing portion of table
    if ( n < nItems && y > table[nItems-1])
    {
        if ( y >= table[nItems-3] ) return (n-1) * dx;
	    if ( y <= table[nItems-2] ) i = nItems - 2;
	    else i = nItems - 3;
    }

    // --- otherwise locate the interval where y falls in the table
    else i = locate(y, table, n-1);
    if ( i >= n - 1 ) return (n-1) * dx;

    // --- compute x at start and end of segment
    x0 = i * dx;

    // --- linearly interpolate an x value
    dy = table[i+1] - table[i];
    if ( dy == 0.0 ) x = x0;
    else x = x0 + (y - table[i]) * dx / dy;
    if ( x < 0.0 ) x = 0.0;
    if ( x > 1.0 ) x = 1.0;
    return x;
}

//=============================================================================
// double y, double *table, int jLast
locate(y, table, jLast)
//
//  Input:   y      = value being located in table
//           table  = ptr. to table with monotonically increasing entries
//           jLast  = highest table entry index to search over
//  Output:  returns index j of table such that table[j] <= y <= table[j+1]
//  Purpose: uses bisection method to locate the highest table index whose
//           table entry does not exceed a given value.
//
//  Notes:   This is only used in conjunction with invLookup().
//
{
    let j;
    let j1 = 0;
    let j2 = jLast;

    // Check if value <= first table entry
    if ( y <= table[0] ) return 0;

    // Check if value >= the last entry
    if ( y >= table[jLast] ) return jLast;

    // While a portion of the table still remains
    while ( j2 - j1 > 1)
    {
	// Find midpoint of remaining portion of table
        j = (j1 + j2) >> 1;

	// Value is greater or equal to midpoint: search from midpoint to j2
        if ( y >= table[j] ) j1 = j;

	// Value is less than midpoint: search from j1 to midpoint
        else j2 = j;
    }

    // Return the lower index of the remaining interval,
    return j1;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {p: val1}
//let returnVal = getQcritical(yc, returnObj)
//val1 = returnObj.p;
////////////////////////////////////
getQcritical(yc, inObj)
//double getQcritical(double yc, void* p)
//
//  Input:   yc = critical depth (ft)
//           p = pointer to a TXsectStar object
//  Output:  returns flow difference value (cfs)
//  Purpose: finds difference between critical flow at depth yc and
//           some target value.
//
{
    let a, w, qc;
    //TXsectStar* xsectStar;

    let xsectStar = inObj.p;
    a = xsect_getAofY(xsectStar.xsect, yc);
    w = xsect_getWofY(xsectStar.xsect, yc);
    qc = -xsectStar.qc;
    if ( w > 0.0 )  qc = a * Math.sqrt(GRAVITY * a / w) - xsectStar.qc;
    return qc;
}

//=============================================================================
// TXsect* xsect, double q, double y0
getYcritEnum(xsect, q, y0)
//
//  Input:   xsect = ptr. to cross section data structure
//           q = critical flow rate (cfs)
//           y0 = estimate of critical depth (ft)
//  Output:  returns true critical depth (ft)
//  Purpose: solves a * Math.sqrt(a(y)*g / w(y)) - q for y using interval
//           enumeration with starting guess of y0.
//
{
    let     q0, dy, qc, yc;
    let        i1, i;
    //TXsectStar xsectStar;
    xsectStar = new TXsectStar();
    
    // ret facil
    let returnObj;
    let returnVal;

    // --- divide cross section depth into 25 increments and
    //     locate increment corresponding to initial guess y0
    dy = xsect.yFull / 25.;
    i1 = Math.trunc(y0 / dy);

    // --- evaluate critical flow at this increment
    xsectStar.xsect = xsect;
    xsectStar.qc = 0.0;

    ////////////////////////////////////
    returnObj = {p: xsectStar}
    returnVal = getQcritical(i1*dy, returnObj)
    xsectStar = returnObj.p;
    ////////////////////////////////////
    q0 = returnVal;
    //q0 = getQcritical(i1*dy, xsectStar);

    // --- initial flow lies below target flow
    if ( q0 < q )
    {
        // --- search each successive higher depth increment
        yc = xsect.yFull;
        for ( i = i1+1; i <= 25; i++)
        {
            // --- if critical flow at current depth is above target
            //     then use linear interpolation to compute critical depth
            ////////////////////////////////////
            returnObj = {p: xsectStar}
            returnVal = getQcritical(i*dy, returnObj)
            xsectStar = returnObj.p;
            ////////////////////////////////////
            qc = returnVal;
            //qc = getQcritical(i*dy, xsectStar);
            if ( qc >= q )
            {
                yc = ( (q-q0) / (qc - q0) + (i-1) ) * dy;
                break;
            }
            q0 = qc;
        }
    }

    // --- initial flow lies above target flow
    else
    {
        // --- search each successively lower depth increment
        yc = 0.0;
        for ( i = i1-1; i >= 0; i--)
        {
            // --- if critical flow at current depth is below target
            //     then use linear interpolation to compute critical depth
            ////////////////////////////////////
            returnObj = {p: xsectStar}
            returnVal = getQcritical(i*dy, returnObj)
            xsectStar = returnObj.p;
            ////////////////////////////////////
            qc = returnVal;
            //qc = getQcritical(i*dy, xsectStar);
            if ( qc < q )
            {
                yc = ( (q-qc) / (q0-qc) + i ) * dy;
                break;
            }
            q0 = qc;
        }
    }
    return yc;
}

//=============================================================================
// TXsect* xsect, double q, double y0
getYcritRidder(xsect, q, y0)
//
//  Input:   xsect = ptr. to cross section data structure
//           q = critical flow rate (cfs)
//           y0 = estimate of critical depth (ft)
//  Output:  returns true critical depth (ft)
//  Purpose: solves a * Math.sqrt(a(y)*g / w(y)) - q for y using Ridder's
//           root finding method with starting guess of y0.
//
{
    let  y1 = 0.0;
    let  y2 = 0.99 * xsect.yFull;
    let  yc;
    let q0, q1, q2;
    xsectStar = new TXsectStar();

    // ret facil
    let returnObj;
    let returnVal;

    // --- store reference to cross section in global pointer
    xsectStar.xsect = xsect;
    xsectStar.qc = 0.0;

    // --- check if critical flow at (nearly) full depth < target flow
    ////////////////////////////////////
    returnObj = {p: xsectStar}
    returnVal = getQcritical(y2, returnObj)
    xsectStar = returnObj.p;
    ////////////////////////////////////
    q2 = returnVal;
    //q2 = getQcritical(y2, xsectStar);
    if (q2 < q ) return xsect.yFull;

    // --- evaluate critical flow at initial depth guess y0
    //     and at 1/2 of full depth
    ////////////////////////////////////
    returnObj = {p: xsectStar}
    returnVal = getQcritical(y0, returnObj)
    xsectStar = returnObj.p;
    ////////////////////////////////////
    q0 = returnVal;
    //q0 = getQcritical(y0, xsectStar);
    ////////////////////////////////////
    returnObj = {p: xsectStar}
    returnVal = getQcritical(0.5*xsect.yFull, returnObj)
    xsectStar = returnObj.p;
    ////////////////////////////////////
    q1 = returnVal;
    //q1 = getQcritical(0.5*xsect.yFull, xsectStar);

    // --- adjust search interval on depth so it contains flow q
    if ( q0 > q )
    {
        y2 = y0;
        if ( q1 < q ) y1 = 0.5*xsect.yFull;
    }
    else
    {
        y1 = y0;
        if ( q1 > q ) y2 = 0.5*xsect.yFull;
    }

    // --- save value of target critical flow in global variable
    xsectStar.qc = q;

    // --- call Ridder root finding procedure with error tolerance
    //     of 0.001 ft. to find critical depth yc
    ////////////////////////////////////
    returnObj = {p: xsectStar}
    returnVal = findroot_Ridder(y1, y2, 0.001, getQcritical, returnObj)
    xsectStar = returnObj.p;
    yc = returnVal;
    ////////////////////////////////////
    //yc = findroot_Ridder(y1, y2, 0.001, getQcritical, xsectStar);
    return yc;
}


//=============================================================================
//  RECT_CLOSED fuctions
//=============================================================================
// TXsect* xsect, double a
rect_closed_getSofA(xsect, a)
{
    // --- if a > area corresponding to Smax then
    //     interpolate between sMax and Sfull
    let alfMax = RECT_ALFMAX;
    if ( a / xsect.aFull > alfMax )
    {
        return xsect.sMax + (xsect.sFull - xsect.sMax) *
               (a/xsect.aFull - alfMax) / (1.0 - alfMax);
    }

    // --- otherwise use regular formula
    return a * Math.pow(xsect_getRofA(xsect, a), 2./3.);
}

// TXsect* xsect, double a
rect_closed_getdSdA(xsect, a)
{
    let alpha, alfMax, r;

    // --- if above level corresponding to sMax, then
    //     use slope between sFull & sMax
    alfMax = RECT_ALFMAX;
    alpha = a / xsect.aFull;
    if ( alpha > alfMax )
    {
        return (xsect.sFull - xsect.sMax) /
               ((1.0 - alfMax) * xsect.aFull);
    }

    // --- for small a/aFull use generic central difference formula
    if ( alpha <= 1.0e-30 ) return generic_getdSdA(xsect, a);

    // --- otherwise evaluate dSdA = [5/3 - (2/3)(dP/dA)R]R^(2/3)
    //     (where P = wetted perimeter & dPdA = 2/width)
    r = xsect_getRofA(xsect, a);
    return  (5./3. - (2./3.) * (2.0/xsect.wMax) * r) * Math.pow(r, 2./3.);
}

// TXsect* xsect, double a
rect_closed_getRofA(xsect, a)
{
    let p;
    if ( a <= 0.0 )   return 0.0;
    p = xsect.wMax + 2.*a/xsect.wMax; // Wetted Perim = width + 2*area/width
    if ( a/xsect.aFull > RECT_ALFMAX )
    {
        p += (a/xsect.aFull - RECT_ALFMAX) / (1.0 - RECT_ALFMAX) * xsect.wMax;
    }
    return a / p;
}


//=============================================================================
//  RECT_OPEN fuctions
//=============================================================================
// TXsect* xsect, double a
rect_open_getSofA(xsect, a)
{
    let y = a / xsect.wMax;
    let r = a / ((2.0-xsect.sBot)*y + xsect.wMax);
    return a * Math.pow(r, 2./3.);
}

// TXsect* xsect, double a
rect_open_getdSdA(xsect, a)
{
    let r, dPdA;

    // --- for small a/aFull use generic central difference formula
    if ( a / xsect.aFull <= 1.0e-30 ) return generic_getdSdA(xsect, a);

    // --- otherwise evaluate dSdA = [5/3 - (2/3)(dP/dA)R]R^(2/3)
    //     (where P = wetted perimeter)
    r = xsect_getRofA(xsect, a);
    dPdA = (2.0 - xsect.sBot) / xsect.wMax; // since P = geom2 + 2a/geom2
    return  (5./3. - (2./3.) * dPdA * r) * Math.pow(r, 2./3.);
}


//=============================================================================
//  RECT_TRIANG fuctions
//=============================================================================
// TXsect* xsect, double a
rect_triang_getYofA(xsect, a)
{
    // below upper section
    if ( a <= xsect.aBot ) return Math.sqrt(a / xsect.sBot);

    // above bottom section
    else return xsect.yBot + (a - xsect.aBot) / xsect.wMax;
}

// TXsect* xsect, double a
rect_triang_getRofA(xsect, a)
{
    let y;
    let p, alf;

    if ( a <= 0.0 )   return 0.0;
    y = rect_triang_getYofA(xsect, a);

    // below upper section
    if ( y <= xsect.yBot ) return a / (2. * y * xsect.rBot);

    // wetted perimeter without contribution of top surface
    p = 2. * xsect.yBot * xsect.rBot + 2. * (y - xsect.yBot);

    // top-surface contribution
    alf = (a / xsect.aFull) - RECT_TRIANG_ALFMAX;
    if ( alf > 0.0 ) p += alf / (1.0 - RECT_TRIANG_ALFMAX) * xsect.wMax;
    return a / p;
}

//TXsect* xsect, double a
rect_triang_getSofA(xsect, a)
{
    // --- if a > area corresponding to sMax, then
    //     interpolate between sMax and Sfull
    let alfMax = RECT_TRIANG_ALFMAX;
    if ( a / xsect.aFull > alfMax )
        return xsect.sMax + (xsect.sFull - xsect.sMax) *
               (a/xsect.aFull - alfMax) / (1.0 - alfMax);

    // --- otherwise use regular formula
    else return a * Math.pow(rect_triang_getRofA(xsect, a), 2./3.);
}

//TXsect* xsect, double a
rect_triang_getdSdA(xsect, a)
{
    let alpha, alfMax, dPdA, r;

    // --- if a > area corresponding to sMax, then
    //     use slope between sFull & sMax
    alfMax = RECT_TRIANG_ALFMAX;
    alpha = a / xsect.aFull;
    if ( alpha > alfMax )
        return (xsect.sFull - xsect.sMax) / ((1.0 - alfMax) * xsect.aFull);

    // --- use generic central difference method for very small a
    if ( alpha <= 1.0e-30 ) return generic_getdSdA(xsect, a);

    // --- find deriv. of wetted perimeter
    if ( a > xsect.aBot ) dPdA = 2.0 / xsect.wMax;  // for upper rectangle
    else dPdA = xsect.rBot / Math.sqrt(a * xsect.sBot);  // for triang. bottom

    // --- get hyd. radius & evaluate section factor derivative formula
    r = rect_triang_getRofA(xsect, a);
    return  (5./3. - (2./3.) * dPdA * r) * Math.pow(r, 2./3.);
}

//TXsect* xsect, double y
rect_triang_getAofY(xsect, y)
{
    if ( y <= xsect.yBot ) return y * y * xsect.sBot;         // below upper section
    else return xsect.aBot + (y - xsect.yBot) * xsect.wMax;  // above bottom section
}

//(TXsect* xsect, double y
rect_triang_getRofY(xsect, y)
{
    let p, a, alf;

    // y is below upper rectangular section
    if ( y <= xsect.yBot ) return y * xsect.sBot / (2. * xsect.rBot);

    // area
    a = xsect.aBot + (y - xsect.yBot) * xsect.wMax;

    // wetted perimeter without contribution of top surface
    p = 2. * xsect.yBot * xsect.rBot + 2. * (y - xsect.yBot);

    // top-surface contribution
    alf = (a / xsect.aFull) - RECT_TRIANG_ALFMAX;
    if ( alf > 0.0 ) p += alf / (1.0 - RECT_TRIANG_ALFMAX) * xsect.wMax;
    return a / p;
}

//TXsect* xsect, double y
rect_triang_getWofY(xsect, y)
{
    if ( y <= xsect.yBot ) return 2.0 * xsect.sBot * y;  // below upper section
    else return xsect.wMax;                               // above bottom section
}


//=============================================================================
//  RECT_ROUND fuctions
//=============================================================================
// TXsect* xsect, double a
rect_round_getYofA(xsect, a)
{
    let alpha;

    // --- if above circular bottom:
    if ( a > xsect.aBot )
        return xsect.yBot + (a - xsect.aBot) / xsect.wMax;

    // --- otherwise use circular xsection method to find height
    alpha = a / (PI * xsect.rBot * xsect.rBot);
    if ( alpha < 0.04 ) return (2.0 * xsect.rBot) * getYcircular(alpha);
    return (2.0 * xsect.rBot) * lookup(alpha, Y_Circ, N_Y_Circ);
}

// TXsect* xsect, double a
rect_round_getRofA(xsect, a)
{
    let y1, theta1, p, arg;

    // --- if above circular invert ...
    if ( a <= 0.0 ) return 0.0;
    if ( a > xsect.aBot )
    {
        // wetted perimeter without contribution of top surface
        y1 = (a - xsect.aBot) / xsect.wMax;
        theta1 = 2.0 * Math.asin(xsect.wMax/2.0/xsect.rBot);
        p = xsect.rBot*theta1 + 2.0*y1;

        // top-surface contribution
        arg = (a / xsect.aFull) - RECT_ROUND_ALFMAX;
        if ( arg > 0.0 ) p += arg / (1.0 - RECT_ROUND_ALFMAX) * xsect.wMax;
        return a / p;
    }

    // --- if within circular invert ...
    y1 = rect_round_getYofA(xsect, a);
    theta1 = 2.0*Math.acos(1.0 - y1/xsect.rBot);
    p = xsect.rBot * theta1;
    return a / p;
}

// TXsect* xsect, double a
rect_round_getSofA(xsect, a)
{
    let alpha, aFull, sFull;

    // --- if a > area corresponding to sMax,
    //     interpolate between sMax and sFull
    let alfMax = RECT_ROUND_ALFMAX;
    if ( a / xsect.aFull > alfMax )
    {
        return xsect.sMax + (xsect.sFull - xsect.sMax) *
               (a / xsect.aFull - alfMax) / (1.0 - alfMax);
    }

    // --- if above circular invert, use generic function
    else if ( a > xsect.aBot )
    {
        return a * Math.pow(xsect_getRofA(xsect, a), 2./3.);
    }

    // --- otherwise use circular xsection applied
    //     to full circular shape of bottom section
    else
    {
        aFull = PI * xsect.rBot * xsect.rBot;
        alpha = a / aFull;
        sFull = xsect.sBot;

        // --- use special for small a/aFull
        if ( alpha < 0.04 ) return sFull * getScircular(alpha);

        // --- otherwise use table
        else return sFull * lookup(alpha, S_Circ, N_S_Circ);
    }
}

//TXsect* xsect, double a
rect_round_getdSdA(xsect, a)
{
    let alfMax, r, dPdA;

    // --- if a > area corresponding to sMax, then
    //     use slope between sFull & sMax
    alfMax = RECT_ROUND_ALFMAX;
    if ( a / xsect.aFull > alfMax )
    {
        return (xsect.sFull - xsect.sMax) /
               ((1.0 - alfMax) * xsect.aFull);
    }

    // --- if above circular invert, use analytical for dS/dA
    else if ( a > xsect.aBot )
    {
        r = rect_round_getRofA(xsect, a);
        dPdA = 2.0 / xsect.wMax;       // d(wet perim)/dA for rect.
        return  (5./3. - (2./3.) * dPdA * r) * Math.pow(r, 2./3.);
    }

    // --- otherwise use generic finite difference function
    else return generic_getdSdA(xsect, a);
}

// TXsect* xsect, double y
rect_round_getAofY(xsect, y)
{
    let theta1;

    // --- if above circular invert...
    if ( y > xsect.yBot )
        return xsect.aBot + (y - xsect.yBot) * xsect.wMax;

    // --- find area of circular section
    theta1 = 2.0*Math.acos(1.0 - y/xsect.rBot);
    return 0.5 * xsect.rBot * xsect.rBot * (theta1 - Math.sin(theta1));
}

// TXsect* xsect, double y
rect_round_getRofY(xsect, y)
{
    let theta1;

    // --- if above top of circular bottom, use RofA formula
    if ( y <= 0.0 ) return 0.0;
    if ( y > xsect.yBot )
        return rect_round_getRofA( xsect, rect_round_getAofY(xsect, y) );

    // --- find hyd. radius of circular section
    theta1 = 2.0*Math.acos(1.0 - y/xsect.rBot);
    return 0.5 * xsect.rBot * (1.0 - Math.sin(theta1)) / theta1;
}

// TXsect* xsect, double y
rect_round_getWofY(xsect, y)
{
    // --- return width if depth above circular bottom section
    if ( y > xsect.yBot ) return xsect.wMax;

    // --- find width of circular section
    return 2.0 * Math.sqrt( y * (2.0*xsect.rBot - y) );
}


//=============================================================================
//  MOD_BASKETHANDLE fuctions
//=============================================================================

// Note: the variables rBot, yBot, and aBot refer to properties of the
//       circular top portion of the cross-section (not the bottom)
// TXsect* xsect, double a
mod_basket_getYofA(xsect, a)
{
    let alpha, y1;

    // --- water level below top of rectangular bottom
    if ( a <= xsect.aFull - xsect.aBot ) return a / xsect.wMax;

    // --- find unfilled top area / area of full circular top
    alpha = (xsect.aFull - a) / (PI * xsect.rBot * xsect.rBot);

    // --- find unfilled height
    if ( alpha < 0.04 ) y1 = getYcircular(alpha);
    else                y1 = lookup(alpha, Y_Circ, N_Y_Circ);
    y1 = 2.0 * xsect.rBot * y1;

    // --- return difference between full height & unfilled height
    return xsect.yFull - y1;
}

// TXsect* xsect, double a
mod_basket_getRofA(xsect, a)
{
    let y1, p, theta1;

    // --- water level is below top of rectangular bottom;
    //     return hyd. radius of rectangle
    if ( a <= xsect.aFull - xsect.aBot )
        return a / (xsect.wMax + 2.0 * a / xsect.wMax);

    // --- find height of empty area
    y1 = xsect.yFull - mod_basket_getYofA(xsect, a);

    // --- find angle of circular arc corresponding to this height
    theta1 = 2.0 * Math.acos(1.0 - y1 / xsect.rBot);

    // --- find perimeter of wetted portion of circular arc
    //     (angle of full circular opening was stored in sBot)
    p = (xsect.sBot - theta1) * xsect.rBot;

    // --- add on wetted perimeter of bottom rectangular area
    y1 = xsect.yFull - xsect.yBot;
    p =  p + 2.0*y1 + xsect.wMax;

    // --- return area / wetted perimeter
    return a / p;
}

// TXsect* xsect, double a
mod_basket_getdSdA(xsect, a)
{
    let r, dPdA;

    // --- if water level below top of rectangular bottom but not
    //     empty then use same code as for rectangular xsection
    if ( a <= xsect.aFull - xsect.aBot && a/xsect.aFull > 1.0e-30 )
    {
        r = a / (xsect.wMax + 2.0 * a / xsect.wMax);
        dPdA = 2.0 / xsect.wMax;
        return  (5./3. - (2./3.) * dPdA * r) * Math.pow(r, 2./3.);
    }

    // --- otherwise use generic function
    else return generic_getdSdA(xsect, a);
}

// TXsect* xsect, double y
mod_basket_getAofY(xsect, y)
{
    let a1, theta1, y1;

    // --- if water level is below top of rectangular bottom
    //     return depth * width
    if ( y <= xsect.yFull - xsect.yBot ) return y * xsect.wMax;

    // --- find empty top circular area
    y1 = xsect.yFull - y;
    theta1 = 2.0*Math.acos(1.0 - y1/xsect.rBot);
    a1 = 0.5 * xsect.rBot * xsect.rBot * (theta1 - Math.sin(theta1));

    // --- return difference between full and empty areas
    return xsect.aFull - a1;
}

// TXsect* xsect, double y
mod_basket_getWofY(xsect, y)
{
    let y1;

    // --- if water level below top of rectangular bottom then return width
    if ( y <= 0.0 ) return 0.0;
    if ( y <= xsect.yFull - xsect.yBot ) return xsect.wMax;

    // --- find width of empty top circular section
    y1 = xsect.yFull - y;
    return 2.0 * Math.sqrt( y1 * (2.0*xsect.rBot - y1) );
}


//=============================================================================
//  TRAPEZOIDAL fuctions
//
//  Note: yBot = width of bottom
//        sBot = avg. of side slopes
//        rBot = length of sides per unit of depth
//=============================================================================

// TXsect* xsect, double 
trapez_getYofA(xsect, a)
{
    if ( xsect.sBot == 0.0 ) return a / xsect.yBot;
    return ( Math.sqrt( xsect.yBot*xsect.yBot + 4.*xsect.sBot*a )
             - xsect.yBot )/(2. * xsect.sBot);
}

// TXsect* xsect, double a
trapez_getRofA(xsect, a)
{
    return a / (xsect.yBot + trapez_getYofA(xsect, a) * xsect.rBot);
}

// TXsect* xsect, double a
trapez_getdSdA(xsect, a)
{
    let r, dPdA;
    // --- use generic central difference method for very small a
    if ( a/xsect.aFull <= 1.0e-30 ) return generic_getdSdA(xsect, a);

    // --- otherwise use analytical formula:
    //     dSdA = [5/3 - (2/3)(dP/dA)R]R^(2/3)
    r = trapez_getRofA(xsect, a);
    dPdA = xsect.rBot /
            Math.sqrt( xsect.yBot * xsect.yBot + 4. * xsect.sBot * a );
    return  (5./3. - (2./3.) * dPdA * r) * Math.pow(r, 2./3.);
}

// TXsect* xsect, double y
trapez_getAofY(xsect, y)
{
    return ( xsect.yBot + xsect.sBot * y ) * y;
}

// TXsect* xsect, double y
trapez_getRofY(xsect, y)
{
    if ( y == 0.0 ) return 0.0;
    return trapez_getAofY(xsect, y) / (xsect.yBot + y * xsect.rBot);
}

// TXsect* xsect, double y
trapez_getWofY(xsect, y)
{
    return xsect.yBot + 2.0 * y * xsect.sBot;
}


//=============================================================================
//  TRIANGULAR fuctions
//=============================================================================
// TXsect* xsect, double a
triang_getYofA(xsect, a)
{
    return Math.sqrt(a / xsect.sBot);
}

// TXsect* xsect, double a
triang_getRofA(xsect, a)
{
    return a / (2. * triang_getYofA(xsect, a) * xsect.rBot);
}

// TXsect* xsect, double a
triang_getdSdA(xsect, a)
{
    let r, dPdA;
    // --- use generic finite difference method for very small 'a'
    if ( a/xsect.aFull <= 1.0e-30 ) return generic_getdSdA(xsect, a);

    // --- evaluate dSdA = [5/3 - (2/3)(dP/dA)R]R^(2/3)
    r = triang_getRofA(xsect, a);
    dPdA = xsect.rBot / Math.sqrt(a * xsect.sBot);
    return  (5./3. - (2./3.) * dPdA * r) * Math.pow(r, 2./3.);
}

// TXsect* xsect, double y
triang_getAofY(xsect, y)
{
    return y * y * xsect.sBot;
}

// TXsect* xsect, double y
triang_getRofY(xsect, y)
{
    return (y * xsect.sBot) / (2. * xsect.rBot);
}

// TXsect* xsect, double y
triang_getWofY(xsect, y)
{
    return 2.0 * xsect.sBot * y;
}


//=============================================================================
//  PARABOLIC fuctions
//=============================================================================

// TXsect* xsect, double a
parab_getYofA(xsect, a)
{
    return Math.pow( (3./4.) * a / xsect.rBot, 2./3. );
}

// TXsect* xsect, double a
parab_getRofA(xsect, a)
{
    if ( a <= 0.0 ) return 0.0;
    return a / parab_getPofY( xsect, parab_getYofA(xsect, a) );
}

// TXsect* xsect, double y
parab_getPofY(xsect, y)
{
    let x = 2. * Math.sqrt(y) / xsect.rBot;
    let t = Math.sqrt(1.0 + x * x);
    return 0.5 * xsect.rBot * xsect.rBot * ( x * t + Math.log(x + t) );
}

// TXsect* xsect, double y
parab_getAofY(xsect, y)
{
    return (4./3. * xsect.rBot * y * Math.sqrt(y));
}

// TXsect* xsect, double y
parab_getRofY(xsect, y)
{
    if ( y <= 0.0 ) return 0.0;
    return parab_getAofY(xsect, y) / parab_getPofY(xsect, y);
}

// TXsect* xsect, double y
parab_getWofY(xsect, y)
{
    return 2.0 * xsect.rBot * Math.sqrt(y);
}


//=============================================================================
//  POWERFUNC fuctions
//=============================================================================

// TXsect* xsect, double a
powerfunc_getYofA(xsect, a)
{
    return Math.pow(a / xsect.rBot, 1.0 / (xsect.sBot + 1.0));
}

// TXsect* xsect, double a
powerfunc_getRofA(xsect, a)
{
    if ( a <= 0.0 ) return 0.0;
    return a / powerfunc_getPofY(xsect, powerfunc_getYofA(xsect, a));
}

// TXsect* xsect, double y
powerfunc_getPofY(xsect, y)
{
    let dy1 = 0.02 * xsect.yFull;
    let h = (xsect.sBot + 1.0) * xsect.rBot / 2.0;
    let m = xsect.sBot;
    let p = 0.0;
    let y1 = 0.0;
    let x1 = 0.0;
    let x2, y2, dx, dy;
    do
    {
        y2 = y1 + dy1;
        if ( y2 > y ) y2 = y;
        x2 = h * Math.pow(y2, m);
        dx = x2 - x1;
        dy = y2 - y1;
        p += Math.sqrt(dx*dx + dy*dy);
        x1 = x2;
        y1 = y2;
    } while ( y2 < y );
    return 2.0 * p;
}

// TXsect* xsect, double y
powerfunc_getAofY(xsect, y)
{
    return xsect.rBot * Math.pow(y, xsect.sBot + 1.0);
}

// TXsect* xsect, double y
powerfunc_getRofY(xsect, y)
{
    if ( y <= 0.0 ) return 0.0;
    return powerfunc_getAofY(xsect, y) / powerfunc_getPofY(xsect, y);
}

// TXsect* xsect, double y
powerfunc_getWofY(xsect, y)
{
    return (xsect.sBot + 1.0) * xsect.rBot * Math.pow(y, xsect.sBot);
}


//=============================================================================
//  CIRCULAR functions
//=============================================================================

// TXsect* xsect, double a
circ_getYofA(xsect,  a)
{
    let alpha = a / xsect.aFull;

    // --- use special for small a/aFull
    if ( alpha < 0.04 )  return xsect.yFull * getYcircular(alpha);

    // --- otherwise use table
    else return xsect.yFull * lookup(alpha, Y_Circ, N_Y_Circ);
}

// TXsect* xsect, double s
circ_getAofS(xsect, s)
{
    let psi = s / xsect.sFull;
    if (psi == 0.0) return 0.0;
    if (psi >= 1.0) return xsect.aFull;

    // --- use special for small s/sFull
    if (psi <= 0.015) return xsect.aFull * getAcircular(psi);

    // --- otherwise use table
    else return xsect.aFull * invLookup(psi, S_Circ, N_S_Circ);
}

// TXsect* xsect, double a
circ_getSofA(xsect, a)
{
    let alpha = a / xsect.aFull;

    // --- use special for small a/aFull
    if ( alpha < 0.04 ) return xsect.sFull * getScircular(alpha);

    // --- otherwise use table
    else
    return xsect.sFull * lookup(alpha, S_Circ, N_S_Circ);
}

// TXsect* xsect, double a
circ_getdSdA(xsect, a)
{
    let alpha, theta, p, r, dPdA;

    // --- for near-zero area, use generic central difference formula
    alpha = a / xsect.aFull;
    if ( alpha <= 1.0e-30 ) return 1.0e-30;  //generic_getdSdA(xsect, a);

	// --- for small a/aFull use analytical derivative
    else if ( alpha < 0.04 )
    {
        theta = getThetaOfAlpha(alpha);
        p = theta * xsect.yFull / 2.0;
        r = a / p;
        dPdA = 4.0 / xsect.yFull / (1. - Math.cos(theta));
        return  (5./3. - (2./3.) * dPdA * r) * Math.pow(r, 2./3.);
    }

    // --- otherwise use generic tabular getdSdA
    else return tabular_getdSdA(xsect, a, S_Circ, N_S_Circ);
}

////////////////////////////////////////////////
// This is an alternate method used in SWMM 4.4.
////////////////////////////////////////////////
/*
circ_getdSdA(TXsect* xsect, double a)
{
    double alpha, a1, a2, da, s1, s2, ds;
    alpha = a / xsect.aFull;
    if ( alpha <= 1.0e-30 ) return 1.0e-30;
    da = 0.002;
    a1 = alpha - 0.001;
    a2 = alpha + 0.001;
    if ( a1 < 0.0 )
    {
        a1 = 0.0;
    	da = alpha + 0.001;
    }
    s1 = getScircular(a1);
    s2 = getScircular(a2);
    ds = (s2 - s1) / da;
    if ( ds <= 1.0e-30 ) ds = 1.0e-30;
    return xsect.sFull * ds / xsect.aFull;
}
*/

// TXsect* xsect, double y
circ_getAofY(xsect, y)
{
    let yNorm;
    yNorm = y / xsect.yFull;
    return xsect.aFull * lookup(yNorm, A_Circ, N_A_Circ);
}


//=============================================================================
//  FILLED_CIRCULAR functions
//=============================================================================

// TXsect* xsect, double a
filled_circ_getYofA(xsect, a)
{
    let y;

    // --- temporarily remove filled portion of circle
    xsect.yFull += xsect.yBot;
    xsect.aFull += xsect.aBot;
    a += xsect.aBot;

    // --- find depth in unfilled circle
    y = circ_getYofA(xsect, a);

    // --- restore original values
    y -= xsect.yBot;
    xsect.yFull -= xsect.yBot;
    xsect.aFull -= xsect.aBot;
    return y;
}

// TXsect* xsect, double y
filled_circ_getAofY(xsect, y)
{
    let a;

    // --- temporarily remove filled portion of circle
    xsect.yFull += xsect.yBot;
    xsect.aFull += xsect.aBot;
    y += xsect.yBot;

    // --- find area of unfilled circle
    a = circ_getAofY(xsect, y);

    // --- restore original values
    a -= xsect.aBot;
    xsect.yFull -= xsect.yBot;
    xsect.aFull -= xsect.aBot;
    return a;
}

// TXsect* xsect, double y
filled_circ_getRofY(xsect, y)
{
    let a, r, p;

    // --- temporarily remove filled portion of circle
    xsect.yFull += xsect.yBot;
    xsect.aFull += xsect.aBot;
    y += xsect.yBot;

    // --- get area,  hyd. radius & wetted perimeter of unfilled circle
    a = circ_getAofY(xsect, y);
    r = 0.25 * xsect.yFull * lookup(y/xsect.yFull, R_Circ, N_R_Circ);
    p = (a/r);

    // --- reduce area and wetted perimeter by amount of filled circle
    //     (rBot = filled perimeter, sBot = filled width)
    a = a - xsect.aBot;
    p = p - xsect.rBot + xsect.sBot;

    // --- compute actual hyd. radius & restore xsect parameters
    r = a / p;
    xsect.yFull -= xsect.yBot;
    xsect.aFull -= xsect.aBot;
    return r;
}


//=============================================================================
//  Special functions for circular cross sections
//=============================================================================
// double alpha
getYcircular(alpha)
{
    let theta;
    if ( alpha >= 1.0 ) return 1.0;
    if ( alpha <= 0.0 ) return 0.0;
    if ( alpha <= 1.0e-5 )
    {
        theta = Math.pow(37.6911*alpha, 1./3.);
        return theta * theta / 16.0;
    }
    theta = getThetaOfAlpha(alpha);
    return (1.0 - Math.cos(theta/2.)) / 2.0;
}

// double alpha
getScircular(alpha)
{
    let theta;
    if ( alpha >= 1.0 ) return 1.0;
    if ( alpha <= 0.0 ) return 0.0;
    if ( alpha <= 1.0e-5 )
    {
        theta = Math.pow(37.6911*alpha, 1.0/3.0);
        return Math.pow(theta, 13.0/3.0) / 124.4797;
    }
    theta = getThetaOfAlpha(alpha);
    return Math.pow((theta - Math.sin(theta)), 5.0/3.0) / (2.0 * PI) / Math.pow(theta, 2.0/3.0);
}

// double psi
getAcircular(psi)
{
    let theta;
    if ( psi >= 1.0 ) return 1.0;
    if ( psi <= 0.0 ) return 0.0;
    if ( psi <= 1.0e-6 )
    {
        theta = Math.pow(124.4797*psi, 3./13.);
        return theta*theta*theta / 37.6911;
    }
    theta = getThetaOfPsi(psi);
    return (theta - Math.sin(theta)) / (2.0 * PI);
}

// double alpha
getThetaOfAlpha(alpha)
{
    let    k;
    let theta, theta1, ap, d;

    if ( alpha > 0.04 ) theta = 1.2 + 5.08 * (alpha - 0.04) / 0.96;
    else theta = 0.031715 - 12.79384 * alpha + 8.28479 * Math.sqrt(alpha);
    theta1 = theta;
    ap  = (2.0*Math.PI) * alpha;
    for (k = 1; k <= 40; k++ )
    {
        d = - (ap - theta + Math.sin(theta)) / (1.0 - Math.cos(theta));
        // --- modification to improve convergence for large theta
        if ( d > 1.0 ) d = SIGN( 1.0, d );
        theta = theta - d;
        if ( Math.abs(d) <= 0.0001 ) return theta;
    }
    return theta1;
}

// double psi
getThetaOfPsi(psi)
{
    let    k;
    let theta, theta1, ap, tt, tt23, t3, d;

    if      (psi > 0.90)  theta = 4.17 + 1.12 * (psi - 0.90) / 0.176;
    else if (psi > 0.5)   theta = 3.14 + 1.03 * (psi - 0.5) / 0.4;
    else if (psi > 0.015) theta = 1.2 + 1.94 * (psi - 0.015) / 0.485;
    else                  theta = 0.12103 - 55.5075 * psi +
                                  15.62254 * Math.sqrt(psi);
    theta1 = theta;
    ap     = (2.0*Math.PI) * psi;

    for (k = 1; k <= 40; k++)
    {
        theta    = Math.abs(theta);
        tt       = theta - Math.sin(theta);
        tt23     = Math.pow(tt, 2./3.);
        t3       = Math.pow(theta, 1./3.);
        d        = ap * theta / t3 - tt * tt23;
        d        = d / ( ap*(2./3.)/t3 - (5./3.)*tt23*(1.0-Math.cos(theta)) );
        theta    = theta - d;
        if ( Math.abs(d) <= 0.0001 ) return theta;
    }
    return theta1;
}

//=============================================================================

//-----------------------------------------------------------------------------
//   runoff.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             09/15/14   (Build 5.1.007)
//             03/19/15   (Build 5.1.008)
//             08/01/16   (Build 5.1.011)
//             03/14/17   (Build 5.1.012)
//             03/01/20   (Build 5.1.014)
//   Author:   L. Rossman
//             M. Tryby
//
//   Runoff analysis functions.
//
//   Build 5.1.007:
//   - Climate file now opened in climate.c module.
//
//   Build 5.1.008:
//   - Memory for runoff pollutant load now allocated and freed in this module.
//   - Runoff time step chosen so that simulation does not exceed total duration.
//   - State of LIDs considered when choosing wet or dry time step.
//   - More checks added to skip over subcatchments with zero area.
//   - Support added for sending outfall node discharge onto a subcatchment.
//
//   Build 5.1.011:
//   - Runoff wet time step kept aligned with reporting times.
//   - Prior runoff time step used to convert returned outfall volume to flow.
//
//   Build 5.1.012:
//   - Runoff wet time step no longer kept aligned with reporting times.
//
//   Build 5.1.014:
//   - Fixed street sweeping bug.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Shared variables
//-----------------------------------------------------------------------------
 IsRaining;                // true if precip. falls on study area
 HasRunoff;                // true if study area generates runoff
 HasSnow;                  // true if any snow cover on study area
 Nsteps;                   // number of runoff time steps taken
 MaxSteps;                 // final number of runoff time steps
 MaxStepsPos;              // position in Runoff interface file
                                //    where MaxSteps is saved

//-----------------------------------------------------------------------------
//  Exportable variables 
//-----------------------------------------------------------------------------
HasWetLids;  // true if any LIDs are wet (used in lidproc.c)
OutflowLoad = []; // exported pollutant mass load (used in surfqual.c)

//-----------------------------------------------------------------------------
//  Imported variables
//-----------------------------------------------------------------------------
//extern float* SubcatchResults;         // Results vector defined in OUTPUT.C

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
// runoff_open     (called from swmm_start in swmm5.c)
// runoff_execute  (called from swmm_step in swmm5.c)
// runoff_close    (called from swmm_end in swmm5.c)


//=============================================================================

runoff_open()
//
//  Input:   none
//  Output:  returns the global error code
//  Purpose: opens the runoff analyzer.
//
{
    IsRaining = false;
    HasRunoff = false;
    HasSnow = false;
    Nsteps = 0;

    // --- open the Ordinary Differential Equation solver
    if ( !odesolve_open(MAXODES) ) report_writeErrorMsg(ERR_ODE_SOLVER, "");

    // --- allocate memory for pollutant runoff loads
    OutflowLoad = null;
    if ( Nobjects[POLLUT] > 0 )
    {
        //OutflowLoad = (double *) calloc(Nobjects[POLLUT], sizeof(double));
        OutflowLoad = new Array(Nobjects[POLLUT])
        if ( !OutflowLoad ) report_writeErrorMsg(ERR_MEMORY, "");
    }

    // --- see if a runoff interface file should be opened
    switch ( Frunoff.mode )
    {
      case USE_FILE:
        if ( (Frunoff.file = fopen(Frunoff.name, "r+b")) == null)
            report_writeErrorMsg(ERR_RUNOFF_FILE_OPEN, Frunoff.name);
        else runoff_initFile();
        break;
      case SAVE_FILE:
        if ( (Frunoff.file = fopen(Frunoff.name, "w+b")) == null)
            report_writeErrorMsg(ERR_RUNOFF_FILE_OPEN, Frunoff.name);
        else runoff_initFile();
        break;
    }
    return ErrorCode;
}

//=============================================================================

runoff_close()
//
//  Input:   none
//  Output:  none
//  Purpose: closes the runoff analyzer.
//
{
    // --- close the ODE solver
    odesolve_close();

    // --- free memory for pollutant runoff loads
    FREE(OutflowLoad);

    // --- close runoff interface file if in use
    if ( Frunoff.file )
    {
        // --- write to file number of time steps simulated
        if ( Frunoff.mode == SAVE_FILE )
        {
            fseek(Frunoff.file, MaxStepsPos, SEEK_SET);
            fwrite(Nsteps, sizeof(int), 1, Frunoff.file);
        }
        fclose(Frunoff.file);
    }

    // --- close climate file if in use
    if ( Fclimate.file ) fclose(Fclimate.file);
}

//=============================================================================

runoff_execute()
//
//  Input:   none
//  Output:  none
//  Purpose: computes runoff from each subcatchment at current runoff time.
//
{
    let      j;                        // object index
    let      day;                      // day of calendar year
    let   runoffStep;               // runoff time step (sec)
    let   oldRunoffStep;            // previous runoff time step (sec)
    let   runoff;                   // subcatchment runoff (ft/sec)
    let currentDate;              // current date/time 
    let     canSweep;                 // true if street sweeping can occur

    if ( ErrorCode ) return;

    // --- find previous runoff time step in sec
    oldRunoffStep = (NewRunoffTime - OldRunoffTime) / 1000.0;

    // --- convert elapsed runoff time in milliseconds to a calendar date
    currentDate = getDateTime(NewRunoffTime);

    // --- update climatological conditions
    climate_setState(currentDate);

    // --- if no subcatchments then simply update runoff elapsed time
    if ( Nobjects[SUBCATCH] == 0 )
    {
        OldRunoffTime = NewRunoffTime;
        NewRunoffTime += (1000 * DryStep);
        NewRunoffTime = Math.min(NewRunoffTime, TotalDuration);
        return;
    }

    // --- update current rainfall at each raingage
    //     NOTE: must examine gages in sequential order due to possible
    //     presence of co-gages (gages that share same rain time series).
    IsRaining = false;
    for (j = 0; j < Nobjects[GAGE]; j++)
    {
        gage_setState(j, currentDate);
        if ( Gage[j].rainfall > 0.0 ) IsRaining = true;
    }

    // --- read runoff results from interface file if applicable
    if ( Frunoff.mode == USE_FILE )
    {
        runoff_readFromFile();
        return;
    }

    // --- see if street sweeping can occur on current date
    day = datetime_dayOfYear(currentDate);
    if ( SweepStart <= SweepEnd )
    {
        if ( day >= SweepStart && day <= SweepEnd ) canSweep = true;
    }
    else if ( day <= SweepEnd || day >= SweepStart ) canSweep = true;
    else canSweep = false;

    // --- get runoff time step (in seconds)
    runoffStep = runoff_getTimeStep(currentDate);
    if ( runoffStep <= 0.0 )
    {
        ErrorCode = ERR_TIMESTEP;
        return;
    }

    // --- update runoff time clock (in milliseconds)
    OldRunoffTime = NewRunoffTime;
    NewRunoffTime += (1000 * runoffStep);

    // --- adjust runoff step so that total duration not exceeded
    if ( NewRunoffTime > TotalDuration )
    {
        runoffStep = (TotalDuration - OldRunoffTime) / 1000.0;
        NewRunoffTime = TotalDuration;
    }

    // --- update old state of each subcatchment, 
    for (j = 0; j < Nobjects[SUBCATCH]; j++) subcatch_setOldState(j);

    // --- determine any runon from drainage system outfall nodes
    if ( oldRunoffStep > 0.0 ) runoff_getOutfallRunon(oldRunoffStep);

    // --- determine runon from upstream subcatchments, and implement snow removal
    for (j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        if ( Subcatch[j].area == 0.0 ) continue;
        subcatch_getRunon(j);
        if ( !IgnoreSnowmelt ) snow_plowSnow(j, runoffStep);
    }
    
    // --- determine runoff and pollutant buildup/washoff in each subcatchment
    HasSnow = false;
    HasRunoff = false;
    HasWetLids = false;
    for (j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        // --- find total runoff rate (in ft/sec) over the subcatchment
        //     (the amount that actually leaves the subcatchment (in cfs)
        //     is also computed and is stored in Subcatch[j].newRunoff)
        if ( Subcatch[j].area == 0.0 ) continue;
        runoff = subcatch_getRunoff(j, runoffStep);

        // --- update state of study area surfaces
        if ( runoff > 0.0 ) HasRunoff = true;
        if ( Subcatch[j].newSnowDepth > 0.0 ) HasSnow = true;

        // --- skip pollutant buildup/washoff if quality ignored
        if ( IgnoreQuality ) continue;

        // --- add to pollutant buildup if runoff is negligible
        if ( runoff < MIN_RUNOFF ) surfqual_getBuildup(j, runoffStep); 

        // --- reduce buildup by street sweeping
        if ( canSweep && Subcatch[j].rainfall <= MIN_RUNOFF)
            surfqual_sweepBuildup(j, currentDate);

        // --- compute pollutant washoff 
        surfqual_getWashoff(j, runoff, runoffStep);
    }

    // --- update tracking of system-wide max. runoff rate
    stats_updateMaxRunoff();

    // --- save runoff results to interface file if one is used
    Nsteps++;
    if ( Frunoff.mode == SAVE_FILE )
    {
        runoff_saveToFile(runoffStep);
    }

    // --- reset subcatchment runon to 0
    for (j = 0; j < Nobjects[SUBCATCH]; j++) Subcatch[j].runon = 0.0;
}

//=============================================================================
// DateTime currentDate
runoff_getTimeStep(currentDate)
//
//  Input:   currentDate = current simulation date/time
//  Output:  time step (sec)
//  Purpose: computes a time step to use for runoff calculations.
//
{
    let  j;
    let timeStep;
    let maxStep = DryStep;

    // --- find shortest time until next evaporation or rainfall value
    //     (this represents the maximum possible time step)
    timeStep = datetime_timeDiff(climate_getNextEvapDate(), currentDate);
    if ( timeStep > 0.0 && timeStep < maxStep ) maxStep = timeStep;
    for (j = 0; j < Nobjects[GAGE]; j++)
    {
        timeStep = datetime_timeDiff(gage_getNextRainDate(j, currentDate),
                   currentDate);
        if ( timeStep > 0 && timeStep < maxStep ) maxStep = timeStep;
    }

    // --- determine whether wet or dry time step applies
    if ( IsRaining || HasSnow || HasRunoff || HasWetLids )
    {
        timeStep = WetStep;
    }
    else timeStep = DryStep;

    // --- limit time step if necessary
    if ( timeStep > maxStep ) timeStep = maxStep;
    return timeStep;
}

//=============================================================================
// void
runoff_initFile()
//
//  Input:   none
//  Output:  none
//  Purpose: initializes a Runoff Interface file for saving results.
//
{
    let   nSubcatch;
    let   nPollut;
    let   flowUnits;
    let  fileStamp = "SWMM5-RUNOFF";
    let  fStamp = "SWMM5-RUNOFF";

    MaxSteps = 0;
    if ( Frunoff.mode == SAVE_FILE )
    {
        // --- write file stamp, # subcatchments & # pollutants to file
        nSubcatch = Nobjects[SUBCATCH];
        nPollut = Nobjects[POLLUT];
        flowUnits = FlowUnits;
        fwrite(fileStamp, sizeof(char), ileStamp.length, Frunoff.file);
        fwrite(nSubcatch, sizeof(int), 1, Frunoff.file);
        fwrite(nPollut, sizeof(int), 1, Frunoff.file);
        fwrite(flowUnits, sizeof(int), 1, Frunoff.file);
        MaxStepsPos = ftell(Frunoff.file); 
        fwrite(MaxSteps, sizeof(int), 1, Frunoff.file);
    }

    if ( Frunoff.mode == USE_FILE )
    {
        // --- check that interface file contains proper header records
        fread(fStamp, sizeof(char), fileStamp.length, Frunoff.file);
        if ( strcmp(fStamp, fileStamp) != 0 )
        {
            report_writeErrorMsg(ERR_RUNOFF_FILE_FORMAT, "");
            return;
        }
        nSubcatch = -1;
        nPollut = -1;
        flowUnits = -1;
        fread(nSubcatch, sizeof(int), 1, Frunoff.file);
        fread(nPollut, sizeof(int), 1, Frunoff.file);
        fread(flowUnits, sizeof(int), 1, Frunoff.file);
        fread(MaxSteps, sizeof(int), 1, Frunoff.file);
        if ( nSubcatch != Nobjects[SUBCATCH]
        ||   nPollut   != Nobjects[POLLUT]
        ||   flowUnits != FlowUnits
        ||   MaxSteps  <= 0 )
        {
             report_writeErrorMsg(ERR_RUNOFF_FILE_FORMAT, "");
        }
    }
}

//=============================================================================
// float tStep
 runoff_saveToFile(tStep)
//
//  Input:   tStep = runoff time step (sec)
//  Output:  none
//  Purpose: saves current runoff results to Runoff Interface file.
//
{
    let j;
    let n = MAX_SUBCATCH_RESULTS + Nobjects[POLLUT] - 1;
    

    fwrite(tStep, sizeof(float), 1, Frunoff.file);
    for (j=0; j<Nobjects[SUBCATCH]; j++)
    {
        ////////////////////////////////////
        returnObj = {x: SubcatchResults}
        returnVal = subcatch_getResults(j, 1.0, returnObj)
        SubcatchResults = returnObj.x;
        ////////////////////////////////////
        //subcatch_getResults(j, 1.0, SubcatchResults);
        fwrite(SubcatchResults, sizeof(float), n, Frunoff.file);
    }
}

//=============================================================================
// void
 runoff_readFromFile()
//
//  Input:   none
//  Output:  none
//  Purpose: reads runoff results from Runoff Interface file for current time.
//
{
    let    i, j;
    let    nResults;                   // number of results per subcatch.
    let    kount;                      // count of items read from file
    let  tStep;                      // runoff time step (sec)
    let gw; //TGroundwater* gw;                  // ptr. to Groundwater object

    // --- make sure not past end of file
    if ( Nsteps > MaxSteps )
    {
         report_writeErrorMsg(ERR_RUNOFF_FILE_END, "");
         return;
    }

    // --- replace old state with current one for all subcatchments
    for (j = 0; j < Nobjects[SUBCATCH]; j++) subcatch_setOldState(j);

    // --- read runoff time step
    kount = 0;
    kount += fread(tStep, sizeof(float), 1, Frunoff.file);

    // --- compute number of results saved for each subcatchment
    nResults = MAX_SUBCATCH_RESULTS + Nobjects[POLLUT] - 1;

    // --- for each subcatchment
    for (j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        // --- read vector of saved results
        kount += fread(SubcatchResults, sizeof(float), nResults, Frunoff.file);

        // --- extract hydrologic results, converting units where necessary
        //     (results were saved to file in user's units)
        Subcatch[j].newSnowDepth = SubcatchResults[SUBCATCH_SNOWDEPTH] /
                                   UCF(RAINDEPTH);
        Subcatch[j].evapLoss     = SubcatchResults[SUBCATCH_EVAP] /
                                   UCF(RAINFALL);
        Subcatch[j].infilLoss    = SubcatchResults[SUBCATCH_INFIL] /
                                   UCF(RAINFALL);
        Subcatch[j].newRunoff    = SubcatchResults[SUBCATCH_RUNOFF] /
                                   UCF(FLOW);
        gw = Subcatch[j].groundwater;
        if ( gw )
        {
            gw.newFlow    = SubcatchResults[SUBCATCH_GW_FLOW] / UCF(FLOW);
            gw.lowerDepth = Aquifer[gw.aquifer].bottomElev -
                             (SubcatchResults[SUBCATCH_GW_ELEV] / UCF(LENGTH));
            gw.theta      = SubcatchResults[SUBCATCH_SOIL_MOIST];
        }

        // --- extract water quality results
        for (i = 0; i < Nobjects[POLLUT]; i++)
        {
            Subcatch[j].newQual[i] = SubcatchResults[SUBCATCH_WASHOFF + i];
        }
    }

    // --- report error if not enough values were read
    if ( kount < 1 + Nobjects[SUBCATCH] * nResults )
    {
         report_writeErrorMsg(ERR_RUNOFF_FILE_READ, "");
         return;
    }

    // --- update runoff time clock
    OldRunoffTime = NewRunoffTime;
    NewRunoffTime = OldRunoffTime + (tStep)*1000.0;
    NewRunoffTime = MIN(NewRunoffTime, TotalDuration);
    Nsteps++;
}

//=============================================================================

// double tStep
runoff_getOutfallRunon(tStep)
//
//  Input:   tStep = previous runoff time step (sec)
//  Output:  none
//  Purpose: adds flow and pollutant loads leaving drainage system outfalls
//           during the previous runoff time step to designated subcatchments.
//
{
    let i, k, p;
    let w;

    // --- examine each outfall node
    for (i = 0; i < Nnodes[OUTFALL]; i++)
    {
        // --- ignore node if outflow not re-routed onto a subcatchment
        k = Outfall[i].routeTo;
        if ( k < 0 ) continue;
        if ( Subcatch[k].area == 0.0 ) continue;

        // --- add outfall's flow to subcatchment as runon and re-set routed
        //     flow volume to 0
        subcatch_addRunonFlow(k, Outfall[i].vRouted/tStep);
        massbal_updateRunoffTotals(RUNOFF_RUNON, Outfall[i].vRouted);
        Outfall[i].vRouted = 0.0;

        // --- add outfall's pollutant load on to subcatchment's wet
        //     deposition load and re-set routed load to 0
        //     (Subcatch.newQual is being used as a temporary load accumulator)
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            w = Outfall[i].wRouted[p] * LperFT3;
            massbal_updateLoadingTotals(DEPOSITION_LOAD, p, w * Pollut[p].mcf);
            Subcatch[k].newQual[p] += w / tStep;
            Outfall[i].wRouted[p] = 0.0;
        }
    }
}

//-----------------------------------------------------------------------------
//   gage.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/10  (Build 5.1.001)
//             09/15/14  (Build 5.1.007)
//             05/10/18  (Build 5.1.013)
//   Author:   L. Rossman
//
//   Rain gage functions.
//
//   Build 5.1.007:
//   - Support for monthly rainfall adjustments added.
//
//   Build 5.1.013:
//   - Validation no longer performed on unused gages.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
OneSecond = 1.1574074e-5;

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  gage_readParams        (called by input_readLine)
//  gage_validate          (called by project_validate)
//  gage_initState         (called by project_init)
//  gage_setState          (called by runoff_execute & getRainfall in rdii.c)
//  gage_getPrecip         (called by subcatch_getRunoff)
//  gage_getNextRainDate   (called by runoff_getTimeStep)

//=============================================================================
// int j, char* tok[], int ntoks
gage_readParams(j, tok, ntoks)
//
//  Input:   j = rain gage index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads rain gage parameters from a line of input data
//
//  Data formats are:
//    Name RainType RecdFreq SCF TIMESERIES SeriesName
//    Name RainType RecdFreq SCF FILE FileName Station Units StartDate
//
{
    let     k, err;
    let     id;
    let     fname;
    let     staID;
    let   x = new Array(7);

    // --- check that gage exists
    if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(GAGE, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);

    // --- assign default parameter values
    x[0] = -1.0;         // No time series index
    x[1] = 1.0;          // Rain type is volume
    x[2] = 3600.0;       // Recording freq. is 3600 sec
    x[3] = 1.0;          // Snow catch deficiency factor
    x[4] = NO_DATE;      // Default is no start/end date
    x[5] = NO_DATE;
    x[6] = 0.0;          // US units
    fname = "";
    staID = "";

    if ( ntoks < 5 ) return error_setInpError(ERR_ITEMS, "");
    k = findmatch(tok[4], GageDataWords);
    if      ( k == RAIN_TSERIES )
    {
        err = readGageSeriesFormat(tok, ntoks, x);
    }
    else if ( k == RAIN_FILE    )
    {
        if ( ntoks < 8 ) return error_setInpError(ERR_ITEMS, "");
        sstrncpy(fname, tok[5], MAXFNAME);
        sstrncpy(staID, tok[6], MAXMSG);
        err = readGageFileFormat(tok, ntoks, x);
    }
    else return error_setInpError(ERR_KEYWORD, tok[4]);

    // --- save parameters to rain gage object
    if ( err > 0 ) return err;
    Gage[j].ID = id;
    Gage[j].tSeries      = x[0];
    Gage[j].rainType     = x[1];
    Gage[j].rainInterval = x[2];
    Gage[j].snowFactor   = x[3];
    Gage[j].rainUnits    = x[6];
    if ( Gage[j].tSeries >= 0 ) Gage[j].dataSource = RAIN_TSERIES;
    else                        Gage[j].dataSource = RAIN_FILE;
    if ( Gage[j].dataSource == RAIN_FILE )
    {
        sstrncpy(Gage[j].fname, fname, MAXFNAME);
        sstrncpy(Gage[j].staID, staID, MAXMSG);
        Gage[j].startFileDate = x[4];
        Gage[j].endFileDate = x[5];
    }
    Gage[j].unitsFactor = 1.0;
    Gage[j].coGage = -1;
    Gage[j].isUsed = false;
    return 0;
}

//=============================================================================
// char* tok[], int ntoks, double x[]
readGageSeriesFormat(tok, ntoks, x)
{
    let m, ts;
    let aTime;

    // return facilitators
    let returnObj;
    let returnVal;

    if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");

    // --- determine type of rain data
    m = findmatch(tok[1], RainTypeWords);
    if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);
    x[1] = m;

    // --- get data time interval & convert to seconds
    ////////////////////////////////////
    returnObj = {y: x[2]}
    returnVal = getDouble(tok[2], returnObj);
    x[2] = returnObj.y;
    ////////////////////////////////////
    
    if ( returnVal ) x[2] = Math.floor(x[2]*3600 + 0.5);
    //else if ( datetime_strToTime(tok[2], aTime) )
    else{
        ////////////////////////////////////
        returnObj = {t: aTime}
        returnVal = datetime_strToTime(tok[2], returnObj);
        aTime = returnObj.t;
        ////////////////////////////////////
        if (returnVal)
        {
            x[2] = Math.floor(aTime*SECperDAY + 0.5);
        } else {
            return error_setInpError(ERR_DATETIME, tok[2]);
        }
    }
    
    if ( x[2] <= 0.0 ) return error_setInpError(ERR_DATETIME, tok[2]);

    // --- get snow catch deficiency factor
    ////////////////////////////////////
    returnObj = {y: x[3]}
    returnVal1 = getDouble(tok[3], returnObj);
    x[3] = returnObj.y;
    ////////////////////////////////////
    if( !returnVal1 )
    //if ( null == (x[3] = getDouble(tok[3])))
        return error_setInpError(ERR_DATETIME, tok[3]);

    // --- get time series index
    ts = project_findObject(TSERIES, tok[5]);
    if ( ts < 0 ) return error_setInpError(ERR_NAME, tok[5]);
    x[0] = ts;
    tok[2] = "";
    return 0;
}

//=============================================================================
// char* tok[], int ntoks, double x[]
readGageFileFormat(tok, ntoks, x)
{
    let   m, u;
    let aDate;
    let aTime;

    // return facilitators
    let returnObj;
    let returnVal1;
    let returnVal2;

    // --- determine type of rain data
    m = findmatch(tok[1], RainTypeWords);
    if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);
    x[1] = m;

    // --- get data time interval & convert to seconds
    ////////////////////////////////////
    returnObj = {y: x[2]}
    returnVal1 = getDouble(tok[2], returnObj);
    x[2] = returnObj.y;
    ////////////////////////////////////

    ////////////////////////////////////
    returnObj = {t: aTime}
    returnVal2 = datetime_strToTime(tok[2], returnObj);
    aTime = returnObj.t;
    ////////////////////////////////////
    if (  !returnVal1 ) x[2] *= 3600;
    //else if ( datetime_strToTime(tok[2], aTime) )
    else if(returnVal2)
    {
        x[2] = Math.floor(aTime*SECperDAY + 0.5);
    }
    else return error_setInpError(ERR_DATETIME, tok[2]);
    if ( x[2] <= 0.0 ) return error_setInpError(ERR_DATETIME, tok[2]);

    // --- get snow catch deficiency factor
    ////////////////////////////////////
    returnObj = {y: x[3]}
    returnVal1 = getDouble(tok[3], returnObj);
    x[3] = returnObj.y;
    ////////////////////////////////////
    if(!returnVal1) 
    //if ( null == ( x[3] = getDouble(tok[3])))
        return error_setInpError(ERR_NUMBER, tok[3]);
 
    // --- get rain depth units
    u = findmatch(tok[7], RainUnitsWords);
    if ( u < 0 ) return error_setInpError(ERR_KEYWORD, tok[7]);
    x[6] = u;

    // --- get start date (if present)
    if ( ntoks > 8 && tok[8] != '*')
    {
        ////////////////////////////////////
        returnObj = {d: aDate}
        returnVal2 = datetime_strToDate(tok[8], returnObj);
        aDate = returnObj.d;
        ////////////////////////////////////
        //if ( !datetime_strToDate(tok[8], aDate) )
        if ( !returnVal2 )
            return error_setInpError(ERR_DATETIME, tok[8]);
        x[4] =  aDate;
    }
    return 0;
}

//=============================================================================
// int j
 gage_validate(j)
//
//  Input:   j = rain gage index
//  Output:  none
//  Purpose: checks for valid rain gage parameters
//
//  NOTE: assumes that any time series used by a rain gage has been
//        previously validated.
//
{
    let i, k;
    let gageInterval;

    // --- for gage with time series data:
    if ( Gage[j].dataSource == RAIN_TSERIES )
    {
        // --- no validation for an unused gage
        if ( !Gage[j].isUsed ) return;

        // --- see if gage uses same time series as another gage
        k = Gage[j].tSeries;
        for (i=0; i<j; i++)
        {
            if ( Gage[i].dataSource == RAIN_TSERIES && Gage[i].tSeries == k
                 && Gage[i].isUsed )
            {
                Gage[j].coGage = i;

                // --- check that both gages record same type of data
                if ( Gage[j].rainType != Gage[i].rainType )
                {
                    report_writeErrorMsg(ERR_RAIN_GAGE_FORMAT, Gage[j].ID);
                }
                return;
            }
        }

        // --- check gage's recording interval against that of time series
        if ( Tseries[k].refersTo >= 0 )
        {
            report_writeErrorMsg(ERR_RAIN_GAGE_TSERIES, Gage[j].ID);
        }
        gageInterval = (Math.floor(Tseries[k].dxMin*SECperDAY + 0.5));
        if ( gageInterval > 0 && Gage[j].rainInterval > gageInterval )
        {
            report_writeErrorMsg(ERR_RAIN_GAGE_INTERVAL, Gage[j].ID);
        } 
        if ( Gage[j].rainInterval < gageInterval )
        {
            report_writeWarningMsg(WARN09, Gage[j].ID);
        }
        if ( Gage[j].rainInterval < WetStep )
        {
            report_writeWarningMsg(WARN01, Gage[j].ID);
            WetStep = Gage[j].rainInterval;
        }
    }
}

//=============================================================================
// int j
 gage_initState(j)
//
//  Input:   j = rain gage index
//  Output:  none
//  Purpose: initializes state of rain gage.
//
{
    // --- initialize actual and reported rainfall                             //(5.1.013)
    Gage[j].rainfall = 0.0;
    Gage[j].reportRainfall = 0.0;
    if ( IgnoreRainfall ) return;

    // --- for gage with file data:
    if ( Gage[j].dataSource == RAIN_FILE )
    {
        // --- set current file position to start of period of record
        Gage[j].currentFilePos = Gage[j].startFilePos;

        // --- assign units conversion factor
        //     (rain depths on interface file are in inches)
        if ( UnitSystem == SI ) Gage[j].unitsFactor = MMperINCH;
    }

    // --- get first & next rainfall values
    if ( getFirstRainfall(j) )
    {
        // --- find date at end of starting rain interval
        Gage[j].endDate = datetime_addSeconds(
                          Gage[j].startDate, Gage[j].rainInterval);

        // --- if rainfall record begins after start of simulation,
        if ( Gage[j].startDate > StartDateTime )
        {
            // --- make next rainfall date the start of the rain record
            Gage[j].nextDate = Gage[j].startDate;
            Gage[j].nextRainfall = Gage[j].rainfall;

            // --- make start of current rain interval the simulation start
            Gage[j].startDate = StartDateTime;
            Gage[j].endDate = Gage[j].nextDate;
            Gage[j].rainfall = 0.0;
        }

        // --- otherwise find next recorded rainfall
        else if ( !getNextRainfall(j) ) Gage[j].nextDate = NO_DATE;
    }
    else Gage[j].startDate = NO_DATE;
}

//=============================================================================
// int j, DateTime t
gage_setState(j, t)
//
//  Input:   j = rain gage index
//           t = a calendar date/time
//  Output:  none
//  Purpose: updates state of rain gage for specified date. 
//
{
    // --- return if gage not used by any subcatchment
    if ( Gage[j].isUsed == false ) return;

    // --- set rainfall to zero if disabled
    if ( IgnoreRainfall )
    {
        Gage[j].rainfall = 0.0;
        return;
    }

    // --- use rainfall from co-gage (gage with lower index that uses
    //     same rainfall time series or file) if it exists
    if ( Gage[j].coGage >= 0)
    {
        Gage[j].rainfall = Gage[Gage[j].coGage].rainfall;
        return;
    }

    // --- otherwise march through rainfall record until date t is bracketed
    t += OneSecond;
    for (;;)
    {
        // --- no rainfall if no interval start date
        if ( Gage[j].startDate == NO_DATE )
        {
            Gage[j].rainfall = 0.0;
            return;
        }

        // --- no rainfall if time is before interval start date
        if ( t < Gage[j].startDate )
        {
            Gage[j].rainfall = 0.0;
            return;
        }

        // --- use current rainfall if time is before interval end date
        if ( t < Gage[j].endDate )
        {
            return;
        }

        // --- no rainfall if t >= interval end date & no next interval exists
        if ( Gage[j].nextDate == NO_DATE )
        {
            Gage[j].rainfall = 0.0;
            return;
        }

        // --- no rainfall if t > interval end date & <  next interval date
        if ( t < Gage[j].nextDate )
        {
            Gage[j].rainfall = 0.0;
            return;
        }

        // --- otherwise update next rainfall interval date
        Gage[j].startDate = Gage[j].nextDate;
        Gage[j].endDate = datetime_addSeconds(Gage[j].startDate,
                          Gage[j].rainInterval);
        Gage[j].rainfall = Gage[j].nextRainfall;
        if ( !getNextRainfall(j) ) Gage[j].nextDate = NO_DATE;
    }
}

//=============================================================================
// int j, DateTime aDate
gage_getNextRainDate(j, aDate)
//
//  Input:   j = rain gage index
//           aDate = calendar date/time
//  Output:  next date with rainfall occurring
//  Purpose: finds the next date from  specified date when rainfall occurs.
//
{
    if ( Gage[j].isUsed == false ) return aDate;
    aDate += OneSecond;
    if ( aDate < Gage[j].startDate ) return Gage[j].startDate;
    if ( aDate < Gage[j].endDate   ) return Gage[j].endDate;
    return Gage[j].nextDate;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {rainfall: val1, snowfall: val2}
//let returnVal = gage_getPrecip(j, returnObj)
//val1 = returnObj.rainfall;
//val2 = returnObj.snowfall;
////////////////////////////////////
gage_getPrecip(j, inObj)
//double gage_getPrecip(int j, double *rainfall, double *snowfall)
//
//  Input:   j = rain gage index
//  Output:  rainfall = rainfall rate (ft/sec)
//           snowfall = snow fall rate (ft/sec)
//           returns total precipitation (ft/sec)
//  Purpose: determines whether gage's recorded rainfall is rain or snow.
//
{
    inObj.rainfall = 0.0;
    inObj.snowfall = 0.0;
    if ( !IgnoreSnowmelt && Temp.ta <= Snow.snotmp )
    {
        inObj.snowfall = Gage[j].rainfall * Gage[j].snowFactor / UCF(RAINFALL);
    }
    else inObj.rainfall = Gage[j].rainfall / UCF(RAINFALL);
    return (inObj.rainfall) + (inObj.snowfall);
} 

//=============================================================================
// int j, DateTime reportDate
gage_setReportRainfall(j, reportDate)
//
//  Input:   j = rain gage index
//           reportDate = date/time value of current reporting time
//  Output:  none
//  Purpose: sets the rainfall value reported at the current reporting time.
//
{
    let result;

    // --- use value from co-gage if it exists
    if ( Gage[j].coGage >= 0)
    {
        Gage[j].reportRainfall = Gage[Gage[j].coGage].reportRainfall;
        return;
    }

    // --- otherwise increase reporting time by 1 second to avoid
    //     roundoff problems
    reportDate += OneSecond;

    // --- use current rainfall if report date/time is before end
    //     of current rain interval
    if ( reportDate < Gage[j].endDate ) result = Gage[j].rainfall;

    // --- use 0.0 if report date/time is before start of next rain interval
    else if ( reportDate < Gage[j].nextDate ) result = 0.0;

    // --- otherwise report date/time falls right on end of current rain
    //     interval and start of next interval so use next interval's rainfall
    else result = Gage[j].nextRainfall;
    Gage[j].reportRainfall = result;
}

//=============================================================================
// int j
getFirstRainfall(j)
//
//  Input:   j = rain gage index
//  Output:  returns true if successful
//  Purpose: positions rainfall record to date with first rainfall.
//
{
    let    k;                          // time series index
    let  vFirst;                     // first rain volume (ft or m)
    let rFirst;                     // first rain intensity (in/hr or mm/hr)

    // rat facil
    let returnObj;
    let returnVal;

    // --- assign default values to date & rainfall
    Gage[j].startDate = NO_DATE;
    Gage[j].rainfall = 0.0;

    // --- initialize internal cumulative rainfall value
    Gage[j].rainAccum = 0;

    // --- use rain interface file if applicable
    if ( Gage[j].dataSource == RAIN_FILE )
    {
        if ( Frain.file && Gage[j].endFilePos > Gage[j].startFilePos )
        {
            // --- retrieve 1st date & rainfall volume from file
            fseek(Frain.file, Gage[j].startFilePos, SEEK_SET);
            fread(Gage[j].startDate, sizeof(DateTime), 1, Frain.file);
            fread(vFirst, sizeof, 1, Frain.file);
            Gage[j].currentFilePos = ftell(Frain.file);

            // --- convert rainfall to intensity
            Gage[j].rainfall = convertRainfall(j, vFirst);
            return 1;
        }
        return 0;
    }

    // --- otherwise access user-supplied rainfall time series
    else
    {
        k = Gage[j].tSeries;
        if ( k >= 0 )
        {
            // --- retrieve first rainfall value from time series
            ////////////////////////////////////
            returnObj = {x: Gage[j].startDate, y: rFirst}
            returnVal = table_getFirstEntry(Tseries[k], returnObj)
            Gage[j].startDate = returnObj.x;
            rFirst = returnObj.y;
            ////////////////////////////////////
            //if ( table_getFirstEntry(Tseries[k], Gage[j].startDate, rFirst) )
            if ( returnVal )
            {
                // --- convert rainfall to intensity
                Gage[j].rainfall = convertRainfall(j, rFirst);
                return 1;
            }
        }
        return 0;
    }
}

//=============================================================================
// int j
getNextRainfall(j)
//
//  Input:   j = rain gage index
//  Output:  returns 1 if successful; 0 if not
//  Purpose: positions rainfall record to date with next non-zero rainfall
//           while updating the gage's next rain intensity value.
//
//  Note: zero rainfall values explicitly entered into a rain file or
//        time series are skipped over so that a proper accounting of
//        wet and dry periods can be maintained.
//
{
    let    k;                          // time series index
    let  vNext;                      // next rain volume (ft or m)
    let rNext;                      // next rain intensity (in/hr or mm/hr)

    // ret facil
    let returnObj;
    let returnVal;

    Gage[j].nextRainfall = 0.0;
    do
    {
        if ( Gage[j].dataSource == RAIN_FILE )
        {
            if ( Frain.file && Gage[j].currentFilePos < Gage[j].endFilePos )
            {
                fseek(Frain.file, Gage[j].currentFilePos, SEEK_SET);
                fread(Gage[j].nextDate, sizeof(DateTime), 1, Frain.file);
                fread(vNext, sizeof, 1, Frain.file);
                Gage[j].currentFilePos = ftell(Frain.file);
                rNext = convertRainfall(j, vNext);
            }
            else return 0;
        }

        else
        {
            k = Gage[j].tSeries;
            if ( k >= 0 )
            {
                ////////////////////////////////////
                returnObj = {x: Gage[j].nextDate, y: rNext}
                returnVal = table_getNextEntry(Tseries[k], returnObj)
                Gage[j].nextDate = returnObj.x;
                rNext = returnObj.y;
                ////////////////////////////////////
                if( !returnVal ) {
                //if ( !table_getNextEntry(Tseries[k], Gage[j].nextDate, rNext) ){
                    return 0;
                }
                rNext = convertRainfall(j, rNext);
            }
            else return 0;
        }
    } while (rNext == 0.0);
    Gage[j].nextRainfall = rNext;
    return 1;
}

//=============================================================================
// int j, double r
convertRainfall(j, r)
//
//  Input:   j = rain gage index
//           r = rainfall value (user units)
//  Output:  returns rainfall intensity (user units)
//  Purpose: converts rainfall value to an intensity (depth per hour).
//
{
    let r1;
    switch ( Gage[j].rainType )
    {
      case RAINFALL_INTENSITY:
        r1 = r;
        break;

      case RAINFALL_VOLUME:
        r1 = r / Gage[j].rainInterval * 3600.0;
        break;

      case CUMULATIVE_RAINFALL:
        if ( r  < Gage[j].rainAccum )
             r1 = r / Gage[j].rainInterval * 3600.0;
        else r1 = (r - Gage[j].rainAccum) / Gage[j].rainInterval * 3600.0;
        Gage[j].rainAccum = r;
        break;

      default: r1 = r;
    }
    return r1 * Gage[j].unitsFactor * Adjust.rainFactor;
}

//=============================================================================

//-----------------------------------------------------------------------------
//   gwater.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/19/14  (Build 5.1.000)
//             09/15/14  (Build 5.1.007)
//             03/19/15  (Build 5.1.008)
//             08/05/15  (Build 5.1.010)
//   Author:   L. Rossman
//
//   Groundwater functions.
//
//   Build 5.1.007:
//   - User-supplied for deep GW seepage flow added.
//   - New variable names for use in user-supplied GW flow equations added.
//
//   Build 5.1.008:
//   - More variable names for user-supplied GW flow equations added.
//   - Subcatchment area made into a shared variable.
//   - Evaporation loss initialized to 0.
//   - Support for collecting GW statistics added.
//
//   Build 5.1.010:
//   - Unsaturated hydraulic conductivity added to GW flow equation variables.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
GWTOL = 0.0001;    // ODE solver tolerance
XTOL  = 0.001;     // tolerance for moisture & depth

//enum   GWstates {
THETA = 0                // moisture content of upper GW zone
LOWERDEPTH = 1;          // depth of lower saturated GW zone

//enum   GWvariables {
gwvHGW = 0                        // water table height (ft)
gwvHSW = 0                        // surface water height (ft)
gwvHCB = 0                        // channel bottom height (ft)
gwvHGS = 0                        // ground surface height (ft)
gwvKS = 0                         // sat. hyd. condutivity (ft/s)
gwvK = 0                          // unsat. hyd. conductivity (ft/s)
gwvTHETA = 0                      // upper zone moisture content
gwvPHI = 0                        // soil porosity
gwvFI = 0                         // surface infiltration (ft/s) 
gwvFU = 0                         // uper zone percolation rate (ft/s)
gwvA = 0                          // subcatchment area (ft2)
gwvMAX = 0 

// Names of GW variables that can be used in GW outflow expression
GWVarWords = ["HGW", "HSW", "HCB", "HGS", "KS", "K",
                             "THETA", "PHI", "FI", "FU", "A", null];

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
//  NOTE: all flux rates are in ft/sec, all depths are in ft.
Area;            // subcatchment area (ft2)
Infil_gw;           // infiltration rate from surface
MaxEvap;         // max. evaporation rate
AvailEvap;       // available evaporation rate
UpperEvap;       // evaporation rate from upper GW zone
LowerEvap;       // evaporation rate from lower GW zone
UpperPerc;       // percolation rate from upper to lower zone
LowerLoss;       // loss rate from lower GW zone
GWFlow;          // flow rate from lower zone to conveyance node
MaxUpperPerc;    // upper limit on UpperPerc
MaxGWFlowPos;    // upper limit on GWFlow when its positve
MaxGWFlowNeg;    // upper limit on GWFlow when its negative
FracPerv;        // fraction of surface that is pervious
TotalDepth;      // total depth of GW aquifer
Theta;           // moisture content of upper zone
HydCon;          // unsaturated hydraulic conductivity (ft/s)
Hgw;             // ht. of saturated zone
Hstar;           // ht. from aquifer bottom to node invert
Hsw;             // ht. from aquifer bottom to water surface
Tstep;           // current time step (sec)
A;     // TAquifer           // aquifer being analyzed
GW;    // TGroundwater*      // groundwater object being analyzed
LatFlowExpr; // MathExpr*    // user-supplied lateral GW flow expression
DeepFlowExpr;// MathExpr*    // user-supplied deep GW flow expression

//-----------------------------------------------------------------------------
//  External Functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  gwater_readAquiferParams     (called by input_readLine)
//  gwater_readGroundwaterParams (called by input_readLine)
//  gwater_readFlowExpression    (called by input_readLine)
//  gwater_deleteFlowExpression  (called by deleteObjects in project.c)
//  gwater_validateAquifer       (called by swmm_open)
//  gwater_validate              (called by subcatch_validate) 
//  gwater_initState             (called by subcatch_initState)
//  gwater_getVolume             (called by massbal_open & massbal_getGwaterError)
//  gwater_getGroundwater        (called by getSubareaRunoff in subcatch.c)
//  gwater_getState              (called by saveRunoff in hotstart.c)
//  gwater_setState              (called by readRunoff in hotstart.c)

//=============================================================================
// int j, char* tok[], int ntoks
gwater_readAquiferParams(j, tok, ntoks)
//
//  Input:   j = aquifer index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns error message
//  Purpose: reads aquifer parameter values from line of input data
//
//  Data line contains following parameters:
//    ID, porosity, wiltingPoint, fieldCapacity,     conductivity,
//    conductSlope, tensionSlope, upperEvapFraction, lowerEvapDepth,
//    gwRecession,  bottomElev,   waterTableElev,    upperMoisture
//    (evapPattern)
//
{
    let   i, p;
    let x = new Array(12);
    let id;
    // return facilitators
    let returnObj;
    let returnVal;

    // --- check that aquifer exists
    if ( ntoks < 13 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(AQUIFER, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);

    // --- read remaining tokens as numbers
    for (i = 0; i < 11; i++) x[i] = 0.0;
    for (i = 1; i < 13; i++)
    {
        ////////////////////////////////////
        returnObj = {y: x[i-1]}
        returnVal = getDouble(tok[i], returnObj);
        x[i-1] = returnObj.y;
        ////////////////////////////////////
        if(!returnVal) 
        //if ( null == (x[i-1] = getDouble(tok[i])))
            return error_setInpError(ERR_NUMBER, tok[i]);
    }

    // --- read upper evap pattern if present
    p = -1;
    if ( ntoks > 13 )
    {
        p = project_findObject(TIMEPATTERN, tok[13]);
        if ( p < 0 ) return error_setInpError(ERR_NAME, tok[13]);
    }

    // --- assign parameters to aquifer object
    Aquifer[j].ID = id;
    Aquifer[j].porosity       = x[0];
    Aquifer[j].wiltingPoint   = x[1];
    Aquifer[j].fieldCapacity  = x[2];
    Aquifer[j].conductivity   = x[3] / UCF(RAINFALL);
    Aquifer[j].conductSlope   = x[4];
    Aquifer[j].tensionSlope   = x[5] / UCF(LENGTH);
    Aquifer[j].upperEvapFrac  = x[6];
    Aquifer[j].lowerEvapDepth = x[7] / UCF(LENGTH);
    Aquifer[j].lowerLossCoeff = x[8] / UCF(RAINFALL);
    Aquifer[j].bottomElev     = x[9] / UCF(LENGTH);
    Aquifer[j].waterTableElev = x[10] / UCF(LENGTH);
    Aquifer[j].upperMoisture  = x[11];
    Aquifer[j].upperEvapPat   = p;
    return 0;
}

//=============================================================================
// char* tok[], int ntoks
gwater_readGroundwaterParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns error code
//  Purpose: reads groundwater inflow parameters for a subcatchment from
//           a line of input data.
//
//  Data format is:
//  subcatch  aquifer  node  surfElev  a1  b1  a2  b2  a3  fixedDepth +
//            (nodeElev  bottomElev  waterTableElev  upperMoisture )
//
{
    let    i, j, k, m, n;
    let x = new Array(11);
    let gw; // TGroundwater*
    // return facilitators
    let returnVal;
    let returnObj;

    // --- check that specified subcatchment, aquifer & node exist
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");
    j = project_findObject(SUBCATCH, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- check for enough tokens
    if ( ntoks < 11 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that specified aquifer and node exists
    k = project_findObject(AQUIFER, tok[1]);
    if ( k < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    n = project_findObject(NODE, tok[2]);
    if ( n < 0 ) return error_setInpError(ERR_NAME, tok[2]);

    // -- read in the flow parameters
    for ( i = 0; i < 7; i++ )
    {
        ////////////////////////////////////
        returnObj = {y: x[i]}
        returnVal = getDouble(tok[i+3], returnObj);
        x[i] = returnObj.y;
        ////////////////////////////////////
        if(!returnVal) 
        //if ( null == (x[i] = getDouble(tok[i+3]))) 
            return error_setInpError(ERR_NUMBER, tok[i+3]);
    }

    // --- read in optional depth parameters
    for ( i = 7; i < 11; i++)
    {
        x[i] = MISSING;
        m = i + 3;
        if ( ntoks > m && tok[m] != '*' )
        {    
            ////////////////////////////////////
            returnObj = {y: x[i]}
            returnVal = getDouble(tok[m], returnObj);
            x[i] = returnObj.y;
            ////////////////////////////////////
            if(!returnVal) 
            //if (null == (x[i] = getDouble(tok[m]))) 
                return error_setInpError(ERR_NUMBER, tok[m]);
            if ( i < 10 ) x[i] /= UCF(LENGTH);
        }
    }

    // --- create a groundwater flow object
    if ( !Subcatch[j].groundwater )
    {
        //gw = (TGroundwater *) malloc(sizeof(TGroundwater));
        gw = new TGroundwater();
        if ( !gw ) return error_setInpError(ERR_MEMORY, "");
        Subcatch[j].groundwater = gw;
    }
    else gw = Subcatch[j].groundwater;

    // --- populate the groundwater flow object with its parameters
    gw.aquifer    = k;
    gw.node       = n;
    gw.surfElev   = x[0] / UCF(LENGTH);
    gw.a1         = x[1];
    gw.b1         = x[2];
    gw.a2         = x[3];
    gw.b2         = x[4];
    gw.a3         = x[5];
    gw.fixedDepth = x[6] / UCF(LENGTH);
    gw.nodeElev   = x[7];                       //already converted to ft.
    gw.bottomElev     = x[8];
    gw.waterTableElev = x[9];
    gw.upperMoisture  = x[10];
    return 0;
}

//=============================================================================
// char* tok[], int ntoks
gwater_readFlowExpression(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns error code
//  Purpose: reads mathematical expression for lateral or deep groundwater
//           flow for a subcatchment from a line of input data.
//
//  Format is: subcatch LATERAL/DEEP <expr>
//     where subcatch is the ID of the subcatchment, LATERAL is for lateral
//     GW flow, DEEP is for deep GW flow and <expr> is any well-formed math
//     expression. 
//
{
    let   i, j, k;
    let  exprStr;
    let expr;  //MathExpr*

    // --- return if too few tokens
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that subcatchment exists
    j = project_findObject(SUBCATCH, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- check if expression is for lateral or deep GW flow
    k = 1;
    if ( match(tok[1], "LAT") ) k = 1;
    else if ( match(tok[1], "DEEP") ) k = 2;
    else return error_setInpError(ERR_KEYWORD, tok[1]);

    // --- concatenate remaining tokens into a single string
    strcpy(exprStr, tok[2]);
    for ( i = 3; i < ntoks; i++)
    {
        strcat(exprStr, " ");
        strcat(exprStr, tok[i]);
    }

    // --- delete any previous flow eqn.
    if ( k == 1 ) mathexpr_delete(Subcatch[j].gwLatFlowExpr);
    else          mathexpr_delete(Subcatch[j].gwDeepFlowExpr);

    // --- create a parsed expression tree from the string expr
    //     (getVariableIndex is the that converts a GW
    //      variable's name into an index number) 
    expr = mathexpr_create(exprStr, getVariableIndex);
    if ( expr == null ) return error_setInpError(ERR_TREATMENT_EXPR, "");

    // --- save expression tree with the subcatchment
    if ( k == 1 ) Subcatch[j].gwLatFlowExpr = expr;
    else          Subcatch[j].gwDeepFlowExpr = expr;
    return 0;
}

//=============================================================================
// int j
gwater_deleteFlowExpression(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: deletes a subcatchment's custom groundwater flow expressions.
//
{
    mathexpr_delete(Subcatch[j].gwLatFlowExpr);
    mathexpr_delete(Subcatch[j].gwDeepFlowExpr);
}

//=============================================================================
// int j
 gwater_validateAquifer(j)
//
//  Input:   j = aquifer index
//  Output:  none
//  Purpose: validates groundwater aquifer properties .
//
{
	let p;

    if ( Aquifer[j].porosity          <= 0.0 
    ||   Aquifer[j].fieldCapacity     >= Aquifer[j].porosity
    ||   Aquifer[j].wiltingPoint      >= Aquifer[j].fieldCapacity
    ||   Aquifer[j].conductivity      <= 0.0
    ||   Aquifer[j].conductSlope      <  0.0
    ||   Aquifer[j].tensionSlope      <  0.0
    ||   Aquifer[j].upperEvapFrac     <  0.0
    ||   Aquifer[j].lowerEvapDepth    <  0.0
    ||   Aquifer[j].waterTableElev    <  Aquifer[j].bottomElev
    ||   Aquifer[j].upperMoisture     >  Aquifer[j].porosity 
    ||   Aquifer[j].upperMoisture     <  Aquifer[j].wiltingPoint )
        report_writeErrorMsg(ERR_AQUIFER_PARAMS, Aquifer[j].ID);

    p = Aquifer[j].upperEvapPat;
    if ( p >= 0 && Pattern[p].type != MONTHLY_PATTERN )
    {
        report_writeErrorMsg(ERR_AQUIFER_PARAMS, Aquifer[j].ID);
    }
}

//=============================================================================
// int j
 gwater_validate(j)
{
    let  a;  // TAquifer       // Aquifer data structure
    let  gw; // TGroundwater*  // Groundwater data structure
    
    gw = Subcatch[j].groundwater;
    if ( gw )
    {
        a = Aquifer[gw.aquifer];

        // ... use aquifer values for missing groundwater parameters
        if ( gw.bottomElev == MISSING ) gw.bottomElev = a.bottomElev;
        if ( gw.waterTableElev == MISSING ) gw.waterTableElev = a.waterTableElev;
        if ( gw.upperMoisture == MISSING ) gw.upperMoisture = a.upperMoisture;

        // ... ground elevation can't be below water table elevation
        if ( gw.surfElev < gw.waterTableElev )
            report_writeErrorMsg(ERR_GROUND_ELEV, Subcatch[j].ID);
    }
}

//=============================================================================
// int j
 gwater_initState(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: initializes state of subcatchment's groundwater.
//
{
    let  a;    // TAquifer     // Aquifer data structure
    let gw;    // TGroundwater*// Groundwater data structure
    
    gw = Subcatch[j].groundwater;
    if ( gw )
    {
        a = Aquifer[gw.aquifer];

        // ... initial moisture content
        gw.theta = gw.upperMoisture;
        if ( gw.theta >= a.porosity )
        {
            gw.theta = a.porosity - XTOL;
        }

        // ... initial depth of lower (saturated) zone
        gw.lowerDepth = gw.waterTableElev - gw.bottomElev;
        if ( gw.lowerDepth >= gw.surfElev - gw.bottomElev )
        {
            gw.lowerDepth = gw.surfElev - gw.bottomElev - XTOL;
        }

        // ... initial lateral groundwater outflow
        gw.oldFlow = 0.0;
        gw.newFlow = 0.0;
        gw.evapLoss = 0.0;

        // ... initial available infiltration volume into upper zone
        gw.maxInfilVol = (gw.surfElev - gw.waterTableElev) *
                          (a.porosity - gw.theta) /
                          subcatch_getFracPerv(j);
    }
}

//=============================================================================
// int j, double x[]
gwater_getState(j, x)
//
//  Input:   j = subcatchment index
//  Output:  x[] = array of groundwater state variables
//  Purpose: retrieves state of subcatchment's groundwater.
//
{
    let gw = Subcatch[j].groundwater;
    x[0] = gw.theta;
    x[1] = gw.bottomElev + gw.lowerDepth;
    x[2] = gw.newFlow;
    x[3] = gw.maxInfilVol;
}

//=============================================================================
// int j, double x[]
gwater_setState(j, x)
//
//  Input:   j = subcatchment index
//           x[] = array of groundwater state variables
//  Purpose: assigns values to a subcatchment's groundwater state.
//
{
    let gw = Subcatch[j].groundwater;
    if ( gw == null ) return;
    gw.theta = x[0];
    gw.lowerDepth = x[1] - gw.bottomElev;
    gw.oldFlow = x[2];
    if ( x[3] != MISSING ) gw.maxInfilVol = x[3];
}

//=============================================================================
// int j
gwater_getVolume(j)
//
//  Input:   j = subcatchment index
//  Output:  returns total volume of groundwater in ft/ft2
//  Purpose: finds volume of groundwater stored in upper & lower zones
//
{
    let a;     // TAquifer
    let gw;    // TGroundwater*
    let upperDepth;
    gw = Subcatch[j].groundwater;
    if ( gw == null ) return 0.0;
    a = Aquifer[gw.aquifer];
    upperDepth = gw.surfElev - gw.bottomElev - gw.lowerDepth;
    return (upperDepth * gw.theta) + (gw.lowerDepth * a.porosity);
}

//=============================================================================
// int j, double evap, double infil, double tStep
gwater_getGroundwater(j, evap, infil, tStep)
//
//  Purpose: computes groundwater flow from subcatchment during current time step.
//  Input:   j     = subcatchment index
//           evap  = pervious surface evaporation volume consumed (ft3)
//           infil = surface infiltration volume (ft3)
//           tStep = time step (sec)
//  Output:  none
//
{
    let    n;                          // node exchanging groundwater
    let x = new Array(2);                       // upper moisture content & lower depth 
    let vUpper;                     // upper vol. available for percolation
    let nodeFlow;                   // max. possible GW flow from node

    // --- save subcatchment's groundwater and aquifer objects to 
    //     shared variables
    GW = Subcatch[j].groundwater;
    if ( GW == null ) return;
    LatFlowExpr = Subcatch[j].gwLatFlowExpr;
    DeepFlowExpr = Subcatch[j].gwDeepFlowExpr;
    A = Aquifer[GW.aquifer];

    // --- get fraction of total area that is pervious
    FracPerv = subcatch_getFracPerv(j);
    if ( FracPerv <= 0.0 ) return;
    Area = Subcatch[j].area;

    // --- convert infiltration volume (ft3) to equivalent rate
    //     over entire GW (subcatchment) area
    infil = infil / Area / tStep;
    Infil_gw = infil;
    Tstep = tStep;

    // --- convert pervious surface evaporation already exerted (ft3)
    //     to equivalent rate over entire GW (subcatchment) area
    evap = evap / Area / tStep;

    // --- convert max. surface evap rate (ft/sec) to a rate
    //     that applies to GW evap (GW evap can only occur
    //     through the pervious land surface area)
    MaxEvap = Evap.rate * FracPerv;

    // --- available subsurface evaporation is difference between max.
    //     rate and pervious surface evap already exerted
    AvailEvap = MAX((MaxEvap - evap), 0.0);

    // --- save total depth & outlet node properties to shared variables
    TotalDepth = GW.surfElev - GW.bottomElev;
    if ( TotalDepth <= 0.0 ) return;
    n = GW.node;

    // --- establish min. water table height above aquifer bottom at which
    //     GW flow can occur (override node's invert if a value was provided
    //     in the GW object)
    if ( GW.nodeElev != MISSING ) Hstar = GW.nodeElev - GW.bottomElev;
    else Hstar = Node[n].invertElev - GW.bottomElev;
    
    // --- establish surface water height (relative to aquifer bottom)
    //     for drainage system node connected to the GW aquifer
    if ( GW.fixedDepth > 0.0 )
    {
        Hsw = GW.fixedDepth + Node[n].invertElev - GW.bottomElev;
    }
    else Hsw = Node[n].newDepth + Node[n].invertElev - GW.bottomElev;

    // --- store state variables (upper zone moisture content, lower zone
    //     depth) in work vector x
    x[THETA] = GW.theta;
    x[LOWERDEPTH] = GW.lowerDepth;

    // --- set limit on percolation rate from upper to lower GW zone
    vUpper = (TotalDepth - x[LOWERDEPTH]) * (x[THETA] - A.fieldCapacity);
    vUpper = MAX(0.0, vUpper); 
    MaxUpperPerc = vUpper / tStep;

    // --- set limit on GW flow out of aquifer based on volume of lower zone
    MaxGWFlowPos = x[LOWERDEPTH]*A.porosity / tStep;

    // --- set limit on GW flow into aquifer from drainage system node
    //     based on min. of capacity of upper zone and drainage system
    //     inflow to the node
    MaxGWFlowNeg = (TotalDepth - x[LOWERDEPTH]) * (A.porosity - x[THETA])
                   / tStep;
    nodeFlow = (Node[n].inflow + Node[n].newVolume/tStep) / Area;
    MaxGWFlowNeg = -MIN(MaxGWFlowNeg, nodeFlow);
    
    // --- integrate eqns. for d(Theta)/dt and d(LowerDepth)/dt
    //     NOTE: ODE solver must have been initialized previously
    odesolve_integrate(x, 2, 0, tStep, GWTOL, tStep, getDxDt);
    
    // --- keep state variables within allowable bounds
    x[THETA] = MAX(x[THETA], A.wiltingPoint);
    if ( x[THETA] >= A.porosity )
    {
        x[THETA] = A.porosity - XTOL;
        x[LOWERDEPTH] = TotalDepth - XTOL;
    }
    x[LOWERDEPTH] = MAX(x[LOWERDEPTH],  0.0);
    if ( x[LOWERDEPTH] >= TotalDepth )
    {
        x[LOWERDEPTH] = TotalDepth - XTOL;
    }

    // --- save new values of state values
    GW.theta = x[THETA];
    GW.lowerDepth  = x[LOWERDEPTH];
    getFluxes(GW.theta, GW.lowerDepth);
    GW.oldFlow = GW.newFlow;
    GW.newFlow = GWFlow;
    GW.evapLoss = UpperEvap + LowerEvap;

    //--- find max. infiltration volume (as depth over
    //    the pervious portion of the subcatchment)
    //    that upper zone can support in next time step
    GW.maxInfilVol = (TotalDepth - x[LOWERDEPTH]) *
                      (A.porosity - x[THETA]) / FracPerv;

    // --- update GW mass balance
    updateMassBal(Area, tStep);

    // --- update GW statistics 
    stats_updateGwaterStats(j, infil, GW.evapLoss, GWFlow, LowerLoss,
        GW.theta, GW.lowerDepth + GW.bottomElev, tStep);
}

//=============================================================================
// double area, double tStep
updateMassBal(area, tStep)
//
//  Input:   area  = subcatchment area (ft2)
//           tStep = time step (sec)
//  Output:  none
//  Purpose: updates GW mass balance with volumes of water fluxes.
//
{
    let vInfil;                     // infiltration volume
    let vUpperEvap;                 // upper zone evap. volume
    let vLowerEvap;                 // lower zone evap. volume
    let vLowerPerc;                 // lower zone deep perc. volume
    let vGwater;                    // volume of exchanged groundwater
    let ft2sec = area * tStep;

    vInfil     = Infil_gw * ft2sec;
    vUpperEvap = UpperEvap * ft2sec;
    vLowerEvap = LowerEvap * ft2sec;
    vLowerPerc = LowerLoss * ft2sec;
    vGwater    = 0.5 * (GW.oldFlow + GW.newFlow) * ft2sec;
    massbal_updateGwaterTotals(vInfil, vUpperEvap, vLowerEvap, vLowerPerc,
                               vGwater);
}

//=============================================================================
// double theta, double lowerDepth
 getFluxes(theta, lowerDepth)
//
//  Input:   upperVolume = vol. depth of upper zone (ft)
//           upperDepth  = depth of upper zone (ft)
//  Output:  none
//  Purpose: computes water fluxes into/out of upper/lower GW zones.
//
{
    let upperDepth;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- find upper zone depth
    lowerDepth = MAX(lowerDepth, 0.0);
    lowerDepth = MIN(lowerDepth, TotalDepth);
    upperDepth = TotalDepth - lowerDepth;

    // --- save lower depth and theta to global variables
    Hgw = lowerDepth;
    Theta = theta;

    // --- find evaporation rate from both zones
    getEvapRates(theta, upperDepth);

    // --- find percolation rate from upper to lower zone
    UpperPerc = getUpperPerc(theta, upperDepth);
    UpperPerc = MIN(UpperPerc, MaxUpperPerc);

    // --- find loss rate to deep GW
    if ( DeepFlowExpr != null ){
        ////////////////////////////////////
        returnObj = {expr: DeepFlowExpr, getVariableValue: (varIndex)
            //
            //  Input:   varIndex = index of a GW variable
            //  Output:  returns current value of GW variable
            //  Purpose: finds current value of a GW variable.
            //
            {
                switch (varIndex)
                {
                case gwvHGW:  return Hgw * UCF(LENGTH);
                case gwvHSW:  return Hsw * UCF(LENGTH);
                case gwvHCB:  return Hstar * UCF(LENGTH);
                case gwvHGS:  return TotalDepth * UCF(LENGTH);
                case gwvKS:   return A.conductivity * UCF(RAINFALL);
                case gwvK:    return HydCon * UCF(RAINFALL);
                case gwvTHETA:return Theta;
                case gwvPHI:  return A.porosity;
                case gwvFI:   return Infil_gw * UCF(RAINFALL); 
                case gwvFU:   return UpperPerc * UCF(RAINFALL);
                case gwvA:    return Area * UCF(LANDAREA);
                default:      return 0.0;
                }
            }}
        returnVal = mathexpr_eval(returnObj);
        DeepFlowExpr = returnObj.expr;
        ////////////////////////////////////
        LowerLoss = returnVal / UCF(RAINFALL)
        //LowerLoss = mathexpr_eval(DeepFlowExpr, getVariableValue) / UCF(RAINFALL);
    }
    else{
        LowerLoss = A.lowerLossCoeff * lowerDepth / TotalDepth;
    }
    LowerLoss = Math.min(LowerLoss, lowerDepth/Tstep);

    // --- find GW flow rate from lower zone to drainage system node
    GWFlow = getGWFlow(lowerDepth);
    if ( LatFlowExpr != null )
    {
        ////////////////////////////////////
        returnObj = {expr: LatFlowExpr, getVariableValue: (varIndex)
            //
            //  Input:   varIndex = index of a GW variable
            //  Output:  returns current value of GW variable
            //  Purpose: finds current value of a GW variable.
            //
            {
                switch (varIndex)
                {
                case gwvHGW:  return Hgw * UCF(LENGTH);
                case gwvHSW:  return Hsw * UCF(LENGTH);
                case gwvHCB:  return Hstar * UCF(LENGTH);
                case gwvHGS:  return TotalDepth * UCF(LENGTH);
                case gwvKS:   return A.conductivity * UCF(RAINFALL);
                case gwvK:    return HydCon * UCF(RAINFALL);
                case gwvTHETA:return Theta;
                case gwvPHI:  return A.porosity;
                case gwvFI:   return Infil_gw * UCF(RAINFALL); 
                case gwvFU:   return UpperPerc * UCF(RAINFALL);
                case gwvA:    return Area * UCF(LANDAREA);
                default:      return 0.0;
                }
            }}
        returnVal = mathexpr_eval(returnObj);
        LatFlowExpr = returnObj.expr;
        ////////////////////////////////////
        GWFlow += returnVal / UCF(GWFLOW)
        //GWFlow += mathexpr_eval(LatFlowExpr, getVariableValue) / UCF(GWFLOW);
    }
    if ( GWFlow >= 0.0 ) GWFlow = MIN(GWFlow, MaxGWFlowPos);
    else GWFlow = MAX(GWFlow, MaxGWFlowNeg);
}

//=============================================================================
////////////////////////////////////
//let returnObj = {v1: val1, v2: val2}
//let returnVal = getDdDt(t, returnObj)
//val1 = returnObj.v1;
//val2 = returnObj.v2
////////////////////////////////////
 getDxDt(t, inObj)
//
//  Input:   t    = current time (not used)
//           x    = array of state variables
//  Output:  dxdt = array of time derivatives of state variables
//  Purpose: computes time derivatives of upper moisture content 
//           and lower depth.
//
{
    let qUpper;    // inflow - outflow for upper zone (ft/sec)
    let qLower;    // inflow - outflow for lower zone (ft/sec)
    let denom;

    getFluxes(inObj.v1[THETA], inObj.v1[LOWERDEPTH]);
    qUpper = Infil_gw - UpperEvap - UpperPerc;
    qLower = UpperPerc - LowerLoss - LowerEvap - GWFlow;

    // --- d(upper zone moisture)/dt = (net upper zone flow) /
    //                                 (upper zone depth)
    denom = TotalDepth - inObj.v1[LOWERDEPTH];
    if (denom > 0.0)
        inObj.v2[THETA] = qUpper / denom;
    else
        inObj.v2[THETA] = 0.0;

    // --- d(lower zone depth)/dt = (net lower zone flow) /
    //                              (upper zone moisture deficit)
    denom = A.porosity - inObj.v1[THETA];
    if (denom > 0.0)
        inObj.v2[LOWERDEPTH] = qLower / denom;
    else
        inObj.v2[LOWERDEPTH] = 0.0;
}

//=============================================================================
// double theta, double upperDepth
getEvapRates(theta, upperDepth)
//
//  Input:   theta      = moisture content of upper zone
//           upperDepth = depth of upper zone (ft)
//  Output:  none
//  Purpose: computes evapotranspiration out of upper & lower zones.
//
{
    let p, month;
    let f;
    let lowerFrac, upperFrac;

    // --- no GW evaporation when infiltration is occurring
    UpperEvap = 0.0;
    LowerEvap = 0.0;
    if ( Infil_gw > 0.0 ) return;

    // --- get monthly-adjusted upper zone evap fraction
    upperFrac = A.upperEvapFrac;
    f = 1.0;
    p = A.upperEvapPat;
    if ( p >= 0 )
    {
        month = datetime_monthOfYear(getDateTime(NewRunoffTime));
        f = Pattern[p].factor[month-1];
    }
    upperFrac *= f;

    // --- upper zone evaporation requires that soil moisture
    //     be above the wilting point
    if ( theta > A.wiltingPoint )
    {
        // --- actual evap is upper zone fraction applied to max. potential
        //     rate, limited by the available rate after any surface evap 
        UpperEvap = upperFrac * MaxEvap;
        UpperEvap = MIN(UpperEvap, AvailEvap);
    }

    // --- check if lower zone evaporation is possible
    if ( A.lowerEvapDepth > 0.0 )
    {
        // --- find the fraction of the lower evaporation depth that
        //     extends into the saturated lower zone
        lowerFrac = (A.lowerEvapDepth - upperDepth) / A.lowerEvapDepth;
        lowerFrac = MAX(0.0, lowerFrac);
        lowerFrac = MIN(lowerFrac, 1.0);

        // --- make the lower zone evap rate proportional to this fraction
        //     and the evap not used in the upper zone
        LowerEvap = lowerFrac * (1.0 - upperFrac) * MaxEvap;
        LowerEvap = MIN(LowerEvap, (AvailEvap - UpperEvap));
    }
}

//=======================================// double theta, double upperDepth
getUpperPerc(theta, upperDepth)
//
//  Input:   theta      = moisture content of upper zone
//           upperDepth = depth of upper zone (ft)
//  Output:  returns percolation rate (ft/sec)
//  Purpose: finds percolation rate from upper to lower zone.
//
{
    let delta;                       // unfilled water content of upper zone
    let dhdz;                        // avg. change in head with depth
    let hydcon;                      // unsaturated hydraulic conductivity

    // --- no perc. from upper zone if no depth or moisture content too low    
    if ( upperDepth <= 0.0 || theta <= A.fieldCapacity ) return 0.0;

    // --- compute hyd. conductivity as of moisture content
    delta = theta - A.porosity;
    hydcon = A.conductivity * exp(delta * A.conductSlope);

    // --- compute integral of dh/dz term
    delta = theta - A.fieldCapacity;
    dhdz = 1.0 + A.tensionSlope * 2.0 * delta / upperDepth;

    // --- compute upper zone percolation rate
    HydCon = hydcon;
    return hydcon * dhdz;
}

//=============================================================================
// double lowerDepth
getGWFlow(lowerDepth)
//
//  Input:   lowerDepth = depth of lower zone (ft)
//  Output:  returns groundwater flow rate (ft/sec)
//  Purpose: finds groundwater outflow from lower saturated zone.
//
{
    let q, t1, t2, t3;

    // --- water table must be above Hstar for flow to occur
    if ( lowerDepth <= Hstar ) return 0.0;

    // --- compute groundwater component of flow
    if ( GW.b1 == 0.0 ) t1 = GW.a1;
    else t1 = GW.a1 * Math.pow( (lowerDepth - Hstar)*UCF(LENGTH), GW.b1);

    // --- compute surface water component of flow
    if ( GW.b2 == 0.0 ) t2 = GW.a2;
    else if (Hsw > Hstar)
    {
        t2 = GW.a2 * Math.pow( (Hsw - Hstar)*UCF(LENGTH), GW.b2);
    }
    else t2 = 0.0;

    // --- compute groundwater/surface water interaction term
    t3 = GW.a3 * lowerDepth * Hsw * UCF(LENGTH) * UCF(LENGTH);

    // --- compute total groundwater flow
    q = (t1 - t2 + t3) / UCF(GWFLOW); 
    if ( q < 0.0 && GW.a3 != 0.0 ) q = 0.0;
    return q;
}

//=============================================================================
// char* s
 getVariableIndex(s)
//
//  Input:   s = name of a groundwater variable
//  Output:  returns index of groundwater variable
//  Purpose: finds position of GW variable in list of GW variable names.
//
{
    let k;

    k = findmatch(s, GWVarWords);
    if ( k >= 0 ) return k;
    return -1;
}

//=============================================================================
// int varIndex
getVariableValue(varIndex)
//
//  Input:   varIndex = index of a GW variable
//  Output:  returns current value of GW variable
//  Purpose: finds current value of a GW variable.
//
{
    switch (varIndex)
    {
    case gwvHGW:  return Hgw * UCF(LENGTH);
    case gwvHSW:  return Hsw * UCF(LENGTH);
    case gwvHCB:  return Hstar * UCF(LENGTH);
    case gwvHGS:  return TotalDepth * UCF(LENGTH);
    case gwvKS:   return A.conductivity * UCF(RAINFALL);
    case gwvK:    return HydCon * UCF(RAINFALL);
    case gwvTHETA:return Theta;
    case gwvPHI:  return A.porosity;
    case gwvFI:   return Infil_gw * UCF(RAINFALL); 
    case gwvFU:   return UpperPerc * UCF(RAINFALL);
    case gwvA:    return Area * UCF(LANDAREA);
    default:      return 0.0;
    }
}


//-----------------------------------------------------------------------------
//   transect.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//   Author:   L. Rossman
//
//   Geometry processing for irregular cross-section transects.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
MAXSTATION = 1500                // max. number of stations in a transect

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
   Ntransects;              // total number of transects
   Nstations;               // number of stations in current transect
 Station = new Array(MAXSTATION+1);  // x-coordinate of each station
 Elev= new Array(MAXSTATION+1);     // elevation of each station
 Nleft;                  // Manning's n for left overbank
 Nright;                 // Manning's n for right overbank
 Nchannel;               // Manning's n for main channel
 Xleftbank;              // station where left overbank ends
 Xrightbank;             // station where right overbank begins
 Xfactor;                // multiplier for station spacing
 Yfactor;                // factor added to station elevations
 Lfactor;                // main channel/flood plain length

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)   
//-----------------------------------------------------------------------------
//  transect_create      (called by createObjects in project.c)
//  transect_delete      (called by deleteObjects in project.c)
//  transect_readParams  (called by parseLine in input.c)
//  transect_validate    (called by input_readData)


//=============================================================================
// int n
transect_create(n)
//
//  Input:   n = number of transect objects to create
//  Output:  returns an error code
//  Purpose: creates an array of cross-section transects.
//
{
    Ntransects = n;
    if ( n == 0 ) return 0;
    Transect = new Array(Ntransects);
    for(let i = 0; i < Ntransects; i++){
        Transect[i] = new TTransect();
    }
    if ( Transect == null ) return ERR_MEMORY;
    Nchannel = 0.0;
    Nleft = 0.0;
    Nright = 0.0;
    Nstations = 0;
    return 0;
}

//=============================================================================

transect_delete()
//
//  Input:   none
//  Output:  none
//  Purpose: deletes memory allocated for all transects.
//
{
    if ( Ntransects == 0 ) return;
    Transect = null;
    Ntransects = 0;
}

//=============================================================================
// int* count, char* tok[], int ntoks
transect_readParams(count, tok, ntoks)
//
//  Input:   count = transect index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  updated value of count,
//           returns an error code
//  Purpose: read parameters of a transect from a tokenized line of input data.
//
//  Format of transect data follows that used for HEC-2 program:
//    NC  nLeft  nRight  nChannel
//    X1  name  nSta  xLeftBank  xRightBank  0  0  0  xFactor  yFactor
//    GR  Elevation  Station  ... 
//
{
    let    i, k;
    let    index = count;             // transect index
    let    errcode;                    // error code
    let x = new Array(10);                      // parameter values
    let  id;                         // transect ID name

    //return facilitators
    let returnObj;
    let returnVal;

    // --- match first token to a transect keyword
    k = findmatch(tok[0], TransectKeyWords);
    if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[0]);

    // --- read parameters associated with keyword
    switch ( k )
    {
      // --- NC line: Manning n values
      case 0:

        // --- finish processing the previous transect
        transect_validate(index - 1);

        // --- read Manning's n values
        if ( ntoks < 4 ) return error_setInpError(ERR_ITEMS, "");
        for (i = 1; i <= 3; i++)
        {
            ////////////////////////////////////
            returnObj = {y: x[i]}
            returnVal = getDouble(tok[i], returnObj);
            x[i] = returnObj.y;
            ////////////////////////////////////
            if ( !returnVal )
            //if ( null == (x[i] = getDouble(tok[i])) )
                return error_setInpError(ERR_NUMBER, tok[i]);
        }
        return setManning(x);

      // --- X1 line: identifies start of next transect
      case 1:

        // --- check that transect was already added to project
        //     (by input_countObjects)
        if ( ntoks < 10 ) return error_setInpError(ERR_ITEMS, "");
        id = project_findID(TRANSECT, tok[1]);
        if ( id == null ) return error_setInpError(ERR_NAME, tok[1]);

        // --- read in rest of numerical values on data line
        for ( i = 2; i < 10; i++ )
        {
            ////////////////////////////////////
            returnObj = {y: x[i]}
            returnVal = getDouble(tok[i], returnObj);
            x[i] = returnObj.y;
            ////////////////////////////////////
            if ( !returnVal )
            //if ( null == (x[i] = getDouble(tok[i])) )
                return error_setInpError(ERR_NUMBER, tok[i]);
        }

        // --- update total transect count
        count = index + 1;

        // --- transfer parameter values to transect's properties
        return setParams(index, id, x);

      // --- GR line: station elevation & location data
      case 2:

        // --- check that line contains pairs of data values
        if ( (ntoks - 1) % 2 > 0 ) return error_setInpError(ERR_ITEMS, "");

        // --- parse each pair of Elevation-Station values
        i = 1;
        while ( i < ntoks )
        {
            ////////////////////////////////////
            returnObj = {y: x[1]}
            returnVal = getDouble(tok[i], returnObj);
            x[1] = returnObj.y;
            ////////////////////////////////////
            if ( !returnVal )
            //if ( null == (x[1] = getDouble(tok[i])) )
                return error_setInpError(ERR_NUMBER, tok[i]);
            ////////////////////////////////////
            returnObj = {y: x[2]}
            returnVal = getDouble(tok[i+1], returnObj);
            x[2] = returnObj.y;
            ////////////////////////////////////
            if ( !returnVal )
            //if ( (x[2] = getDouble(tok[i+1])) == null )
                return error_setInpError(ERR_NUMBER, tok[i+1]);
            errcode = addStation(x[1], x[2]);
            if ( errcode ) return errcode;
            i += 2;
        }
        return 0;
    }
    return 0;
}

//=============================================================================
// int j
 transect_validate(j)
//
//  Input:   j = transect index
//  Output:  none
//  Purpose: validates transect data and creates its geometry tables.
//
{
    let    i, nLast;
    let dy, y, ymin, ymax;
    let oldNchannel = Nchannel;

    // --- check for valid transect data
    if ( j < 0 || j >= Ntransects ) return;
    if ( Nstations < 2 ) 
    {
        report_writeErrorMsg(ERR_TRANSECT_TOO_FEW, Transect[j].ID);
        return;
    }
    if ( Nstations >= MAXSTATION )
    {
        report_writeErrorMsg(ERR_TRANSECT_TOO_MANY, Transect[j].ID);
        return;
    }
    if ( Nchannel <= 0.0 )
    {
        report_writeErrorMsg(ERR_TRANSECT_MANNING, Transect[j].ID);
        return;
    }
    if ( Xleftbank > Xrightbank )
    {
        report_writeErrorMsg(ERR_TRANSECT_OVERBANK, Transect[j].ID);
        return;
    }

    // --- adjust main channel's Mannings n to make its equivalent
    //     length equal to that of entire flood plain
    Nchannel = Nchannel * Math.sqrt(Lfactor);
    Transect[j].lengthFactor = Lfactor;

    // --- find max. depth across transect
    ymax = Elev[1];
    ymin = Elev[1];
    for (i = 2; i <= Nstations; i++)
    {
        ymax = MAX(Elev[i], ymax);
        ymin = MIN(Elev[i], ymin);
    }
    if ( ymin >= ymax )
    {
        report_writeErrorMsg(ERR_TRANSECT_NO_DEPTH, Transect[j].ID);
        return;
    }
    Transect[j].yFull = ymax - ymin;

    // --- add vertical sides to transect to reach full ht. on both ends
    Station[0] = Station[1];
    Elev[0] = ymax;
    Nstations++;
    Station[Nstations] = Station[Nstations-1];
    Elev[Nstations] = Elev[0];

    // --- determine size & depth increment for geometry tables
    Transect[j].nTbl = N_TRANSECT_TBL;
    dy = (ymax - ymin) / (Transect[j].nTbl - 1);

    // --- set 1st table entries to zero
    Transect[j].areaTbl[0] = 0.0;
    Transect[j].hradTbl[0] = 0.0;
    Transect[j].widthTbl[0] = 0.0;

    // --- compute geometry for each depth increment
    y = ymin;
    Transect[j].wMax = 0.0;
    for (i = 1; i < Transect[j].nTbl; i++)
    {
        y += dy;
        Transect[j].areaTbl[i] = 0.0;
        Transect[j].hradTbl[i] = 0.0;
        Transect[j].widthTbl[i] = 0.0;
        getGeometry(i, j, y);
    }

    // --- determine max. section factor 
    setMaxSectionFactor(j);

    // --- normalize geometry table entries
    //     (full cross-section values are last table entries)
    nLast = Transect[j].nTbl - 1;
    Transect[j].aFull = Transect[j].areaTbl[nLast];
    Transect[j].rFull = Transect[j].hradTbl[nLast];
    Transect[j].wMax = Transect[j].widthTbl[nLast];

    for (i = 1; i <= nLast; i++)
    {
        Transect[j].areaTbl[i] /= Transect[j].aFull;
        Transect[j].hradTbl[i] /= Transect[j].rFull;
        Transect[j].widthTbl[i] /= Transect[j].wMax;
    }

    // --- set width at 0 height equal to width at 4% of max. height
    Transect[j].widthTbl[0] = Transect[j].widthTbl[1];

    // --- save unadjusted main channel roughness 
    Transect[j].roughness = oldNchannel;
}

//=============================================================================
//double n[]
 setManning(n)
//
//  Input:   n[] = array of Manning's n values
//  Output:  returns an error code
//  Purpose: sets Manning's n for overbanks and main channel of a transect.
//
{
    let i;
    for (i=1; i<=3; i++)
    {
        if ( n[i] < 0.0 ) return ERR_NUMBER;
    }
    if ( n[1] > 0.0 ) Nleft = n[1];
    if ( n[2] > 0.0 ) Nright = n[2];
    if ( n[3] > 0.0 ) Nchannel = n[3];
    if ( Nleft == 0.0  ) Nleft = Nchannel;
    if ( Nright == 0.0 ) Nright = Nchannel;
    return 0;
}

//=============================================================================
// int j, char* id, double x[]
 setParams(j, id, x)
//
//  Input:   j = transect index
//           id = transect ID name
//           x[] = array of parameter values
//  Output:  returns an error code
//  Purpose: assigns parameter values to current transect being processed.
//
{
    if ( j < 0 || j >= Ntransects ) return ERR_NUMBER;
    Transect[j].ID = id;                         // ID name
    Xleftbank = x[3] / UCF(LENGTH);              // left overbank location
    Xrightbank = x[4] / UCF(LENGTH);             // right overbank location
    Lfactor = x[7];                              // channel/bank length
    if ( Lfactor == 0.0 ) Lfactor = 1.0;
    Xfactor = x[8];                              // station location multiplier
    if ( Xfactor == 0.0 ) Xfactor = 1.0;
    Xleftbank *= Xfactor;                        // adjusted left bank
    Xrightbank *= Xfactor;                       // adjusted right bank
    Yfactor = x[9] / UCF(LENGTH);                // elevation offset
    Nstations = 0;
    return 0;
}

//=============================================================================
// double y, double x
 addStation(y,  x)
//
//  Input:   y = station elevation value
//           x = station distance value
//  Output:  returns an error code
//  Purpose: adds a new station to the transect currently being processed.
//
{
    // --- check for valid number of stations
    if ( Nstations < 0 ) return ERR_TRANSECT_UNKNOWN;
    Nstations++;
    if ( Nstations >= MAXSTATION ) return 0;

    // --- add station distance, modified by distance multiplier
    Station[Nstations] = x * Xfactor / UCF(LENGTH);

    // --- add station elevation, modified by offset elevation
    Elev[Nstations] = (y + Yfactor) / UCF(LENGTH);

    // --- check if station distances are non-increasing
    if ( Nstations > 1
        && Station[Nstations] < Station[Nstations-1] )
        return ERR_TRANSECT_SEQUENCE;
    return 0;    
}

//=============================================================================
// int i, int j, double y
 getGeometry(i, j, y)
//
//  Input:   i = index of current entry in geometry tables
//           j = transect index
//           y = depth of current entry in geometry tables
//  Output:  none
//  Purpose: computes entries in a transect's geometry tables at a given depth. 
//
{
    let    k;                // station index
    let ylo,              // lower elev. of transect slice
           yhi,              // higher elev. of transect slice
           w,                // top width of transect slice
           wp,               // wetted perimeter of transect slice
           wpSum,            // total wetted perimeter across transect
           a,                // area of transect slice
           aSum,             // total area across transect
           q,                // flow across transect slices with same roughness
           qSum;             // total flow across transect
    let   findFlow;          // true if flow thru area slice needs updating

    // --- initialize
    wpSum = 0.0;
    aSum = 0.0;
    qSum = 0.0;

    // --- examine each horizontal station from left to right
    for (k = 1; k <= Nstations; k++)
    {
        // --- determine low & high elevations for transect sub-section
        if ( Elev[k-1] >= Elev[k] )
        {
            yhi = Elev[k-1];
            ylo = Elev[k];
        }
        else
        {
            yhi = Elev[k];
            ylo = Elev[k-1];
        }

        // --- skip station if its totally dry
        if ( ylo >= y ) continue;

        // --- get top width, area & wetted perimeter values for transect
        //     slice between station k and k-1
        getSliceGeom(k, y, ylo, yhi, w, a, wp);

        // --- update total transect values
        wpSum += wp;
        aSum += a;
        Transect[j].areaTbl[i] += a;
        Transect[j].widthTbl[i] += w;

        // --- must update flow if station elevation is above water level
        if ( Elev[k] >= y ) findFlow = TRUE;
        else findFlow = FALSE;

        // --- update flow across transect if called for
        q = getFlow(k, aSum, wpSum, findFlow);
        if ( q > 0.0 )
        {
            qSum += q;
            aSum = 0.0;
            wpSum = 0.0;
        }

    }   // next station k 

    // --- find hyd. radius table entry solving Manning eq. with
    //     total flow, total area, and main channel n
    aSum = Transect[j].areaTbl[i];
    if ( aSum == 0.0 ) Transect[j].hradTbl[i] = Transect[j].hradTbl[i-1];
    else Transect[j].hradTbl[i] = Math.pow(qSum * Nchannel / 1.49 / aSum, 1.5);
}

//=============================================================================
//int k, double y, double ylo, double yhi, double *w,
//                  double *a, double *wp
getSliceGeom(k, y, ylo, yhi, w,
                   a, wp)
//
//  Input:   k = station index
//           y = water elevation
//           ylo = transect elevation on low side of slice
//           yhi = transect elevation on high side of slice
//  Output   w = width of transect slice
//           a = area of transect slice
//           wp = wetted perimeter of transect slice
//  Purpose: finds area, width & wetted perim. for slice of transect that
//           is covered by given water depth.
//
//      yhi  |           
//           |
//        y  |**********
//           |********** --> slice of transect being analyzed
//      ylo  |**********|
//           |**********|
//           |**********|
//         Station    Station
//           k-1        k
//
{
    let width, ratio;

    // --- compute width & wetted perimeter of transect slice
    width = Math.abs(Station[k] - Station[k-1]);
    w = width;
    wp = Math.sqrt(width * width + (yhi - ylo) * (yhi - ylo));
    a  = 0.0;

    // --- find area for completely submerged slice
    if ( y > yhi )
    {
        a = width * ( (y - yhi) + (y - ylo) ) / 2.0;
    }

    // --- otherwise find area and adjust width & wetted perim. for
    //     partly submerged slice
    else if ( yhi > ylo )
    {
         ratio = (y - ylo) / (yhi - ylo);
         a = width * (yhi - ylo) / 2.0 * ratio * ratio;
         w *= ratio;
         wp *= ratio;
     }
}

//=============================================================================
// int k, double a, double wp, int findFlow
getFlow(k, a, wp, findFlow)
//
//  Input:   k = index of station at end of transect sub-section
//           a = flow area of sub-section
//           wp = wetted perimeter of flow area of sub-section
//           findFlow = TRUE if flow needs updating 
//  Output:  returns normal flow (per unit of slope)
//  Purpose: finds flow through a sub-section of a transect.
//
{
    let n;                          // Manning's n

    if ( findFlow == FALSE)
    {
        // --- flow needs updating if we are at last station
        if ( k == Nstations - 1 ) findFlow = TRUE;

        // --- flow needs updating if we are at end of left overbank and
        //     there is a change in Manning's n and section not vertical
        else if ( Station[k] == Xleftbank )
        {
            if ( Nleft != Nchannel &&
                Station[k] != Station[k-1] ) findFlow = TRUE;
        }

        // --- flow needs updating if we are at start of right overbank and
        //     there is a change in Manning's n and section not vertical
        else if ( Station[k] == Xrightbank )
        {
            if ( Nright != Nchannel &&
                Station[k] != Station[k+1] ) findFlow = TRUE;
        }
    }

    // --- if flow needs updating
    if ( findFlow )
    {
        // --- find value of Manning's n to use
        n = Nchannel;
        if ( Station[k-1] < Xleftbank ) n = Nleft;
        if ( Station[k] > Xrightbank )  n = Nright;

        // --- compute flow through flow area
        return PHI / n * a * Math.pow(a/wp, 2./3.);
    }
    return 0.0;
}

//=============================================================================
// int j
setMaxSectionFactor(j)
//
//  Input:   j = transect index
//  Output:  none
//  Purpose: determines the maximum section factor for a transect and the
//           area where this maxumum occurs.
//
{
    let    i;
    let sf;

    Transect[j].aMax = 0.0;
    Transect[j].sMax = 0.0;
    for (i=1; i<Transect[j].nTbl; i++)
    {
        sf = Transect[j].areaTbl[i] * Math.pow(Transect[j].hradTbl[i], 2./3.);
        if ( sf > Transect[j].sMax )
        {
            Transect[j].sMax = sf;
            Transect[j].aMax = Transect[j].areaTbl[i];
        }
    }
}

//=============================================================================

//-----------------------------------------------------------------------------
//   climate.c
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/10 (Build 5.1.001)
//            09/15/14 (Build 5.1.007)
//            03/19/15 (Build 5.1.008)
//            08/05/15 (Build 5.1.010)
//            08/01/16 (Build 5.1.011)
//            05/10/18 (Build 5.1.013)
//   Author:  L. Rossman
//
//   Climate related functions.
//
//   Build 5.1.007:
//   - NCDC GHCN climate file format added.
//   - Monthly adjustments for temperature, evaporation & rainfall added.
//
//   Build 5.1.008:
//   - Monthly adjustments for hyd. conductivity added.
//   - Time series evaporation rates can now vary within a day.
//   - Evaporation rates are now properly updated when only flow routing
//     is being simulated.
//
//   Build 5.1.010:
//   - Hargreaves evaporation now computed using 7-day average temperatures.
//             
//   Build 5.1.011:
//   - Monthly adjustment for hyd. conductivity <= 0 is ignored.
//
//   Build 5.1.013:
//   - Reads names of monthly adjustment patterns for various parameters
//     of a subcatchment from the [ADJUSTMENTS] section of input file.
///-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
//enum ClimateFileFormats {
    UNKNOWN_FORMAT = 0
    USER_PREPARED = 0     // SWMM 5's own user format
    GHCND = 0             // NCDC GHCN Daily format
    TD3200 = 0            // NCDC TD3200 format
    DLY0204 = 0          // Canadian DLY02 or DLY04 format
    MAXCLIMATEVARS  = 4;
    MAXDAYSPERMONTH = 32;
    
    // These variables are used when processing climate files.
    //enum   ClimateVarType {TMIN, TMAX, EVAP, WIND};
    TMIN = 0
    TMAX = 1
    EVAP = 2
    WIND = 3
    //enum   WindSpeedType  {WDMV, AWND};
    WDMV = 0
    AWND = 0
    ClimateVarWords = ["TMIN", "TMAX", "EVAP", "WDMV", "AWND",
                                      null];
    
    //-----------------------------------------------------------------------------
    //  Data Structures
    //-----------------------------------------------------------------------------
    class TMovAve
    {
        constructor(){
            this.tAve;          // moving avg. for daily temperature (deg F)
            this.tRng;          // moving avg. for daily temp. range (deg F)
            this.ta = new Array(7);         // data window for tAve
            this.tr = new Array(7);         // data window for tRng
            this.count;         // length of moving average window
            this.maxCount;      // maximum length of moving average window
            this.front;         // index of front of moving average window
        }
    } ;
    
    
    //-----------------------------------------------------------------------------
    //  Shared variables
    //-----------------------------------------------------------------------------
    // Temperature variables
    Tmin;                 // min. daily temperature (deg F)
       Tmax;                 // max. daily temperature (deg F)
       Trng;                 // 1/2 range of daily temperatures
       Trng1;                // prev. max - current min. temp.
       Tave;                 // average daily temperature (deg F)
       Hrsr;                 // time of min. temp. (hrs)
       Hrss;                 // time of max. temp (hrs)
       Hrday;                // avg. of min/max temp times
       Dhrdy;                // hrs. between min. & max. temp. times
       Dydif;                // hrs. between max. & min. temp. times
     LastDay;              // date of last day with temp. data
    //static TMovAve   Tma;                  // moving average of daily temperatures
    Tma;
    
    // Evaporation variables
     NextEvapDate;         // next date when evap. rate changes
       NextEvapRate;         // next evaporation rate (user units)
    
    // Climate file variables
         FileFormat;            // file format (see ClimateFileFormats)
         FileYear;              // current year of file data
         FileMonth;             // current month of year of file data
         FileDay;               // current day of month of file data
         FileLastDay;           // last day of current month of file data
         FileElapsedDays;       // number of days read from file
      FileValue = new Array(4);          // current day's values of climate data
      FileData = Array.from(Array(4), () => new Array(32)) // [4][32];       // month's worth of daily climate data
      FileLine;   // line from climate data file
    
         FileFieldPos = new Array(4);       // start of data fields for file record
         FileDateFieldPos;      // start of date field for file record 
         FileWindType;          // wind speed type
    
    //-----------------------------------------------------------------------------
    //  External functions (defined in funcs.h)
    //-----------------------------------------------------------------------------
    //  climate_readParams                 // called by input_parseLine
    //  climate_readEvapParams             // called by input_parseLine
    //  climate_validate                   // called by project_validate
    //  climate_openFile                   // called by runoff_open
    //  climate_initState                  // called by project_init
    //  climate_setState                   // called by runoff_execute
    //  climate_getNextEvapDate            // called by runoff_getTimeStep
    
    
    //=============================================================================
    // char* tok[], int ntoks
     climate_readParams(tok, ntoks)
    //
    //  Input:   tok[] = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //  Purpose: reads climate/temperature parameters from input line of data
    //
    //  Format of data can be
    //    TIMESERIES  name
    //    FILE        name
    //    WINDSPEED   MONTHLY  v1  v2  ...  v12
    //    WINDSPEED   FILE
    //    SNOWMELT    v1  v2  ...  v6
    //    ADC         IMPERV/PERV  v1  v2  ...  v10
    //
    {
        let i, j, k;
        let x = new Array(6)
        let y;
        let aDate;
    
        // return facilitators
        let returnObj;
        let returnVal;
    
        // --- identify keyword
        k = findmatch(tok[0], TempKeyWords);
        if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[0]);
        switch (k)
        {
          case 0: // Time series name
            // --- check that time series name exists
            if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
            i = project_findObject(TSERIES, tok[1]);
            if ( i < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    
            // --- record the time series as being the data source for temperature
            Temp.dataSource = TSERIES_TEMP;
            Temp.tSeries = i;
            Tseries[i].refersTo = TSERIES_TEMP;
            break;
    
          case 1: // Climate file
            // --- record file as being source of temperature data
            if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
            Temp.dataSource = FILE_TEMP;
    
            // --- save name and usage mode of external climate file
            Fclimate.mode = USE_FILE;
            sstrncpy(Fclimate.name, tok[1], MAXFNAME);
    
            // --- save starting date to read from file if one is provided
            Temp.fileStartDate = NO_DATE;
            if ( ntoks > 2 )
            {
                if ( tok[2] != '*')
                {
                    ////////////////////////////////////
                    returnObj = {d: aDate}
                    returnVal = datetime_strToDate(tok[2], returnObj);
                    aDate = returnObj.d;
                    ////////////////////////////////////
                    //if ( !datetime_strToDate(tok[2], aDate) )
                    if( !returnVal)
                        return error_setInpError(ERR_DATETIME, tok[2]);
                    Temp.fileStartDate = aDate;
                }
            }
            break;
    
          case 2: // Wind speeds
            // --- check if wind speeds will be supplied from climate file
            if ( strcomp(tok[1], w_FILE) )
            {
                Wind.type = FILE_WIND;
            }
    
            // --- otherwise read 12 monthly avg. wind speed values
            else
            {
                if ( ntoks < 14 ) return error_setInpError(ERR_ITEMS, "");
                Wind.type = MONTHLY_WIND;
                for (i=0; i<12; i++)
                {
                    ////////////////////////////////////
                    returnObj = {y: y}
                    returnVal = getDouble(tok[i+2], returnObj);
                    y = returnObj.y;
                    ////////////////////////////////////
                    if (!returnVal)
                    //if ( !getDouble(tok[i+2], &y) )
                        return error_setInpError(ERR_NUMBER, tok[i+2]);
                    Wind.aws[i] = y;
                }
            }
            break;
    
          case 3: // Snowmelt params
            if ( ntoks < 7 ) return error_setInpError(ERR_ITEMS, "");
            for (i=1; i<7; i++)
            {
                ////////////////////////////////////
                returnObj = {y: x[i-1]}
                returnVal = getDouble(tok[i], returnObj);
                x[i-1] = returnObj.y;
                ////////////////////////////////////
                if (!returnVal)
                //if ( null == (x[i-1] = getDouble(tok[i])) )
                    return error_setInpError(ERR_NUMBER, tok[i]);
            }
            // --- convert deg. C to deg. F for snowfall temperature
            if ( UnitSystem == SI ) x[0] = 9./5.*x[0] + 32.0;
            Snow.snotmp = x[0];
            Snow.tipm   = x[1];
            Snow.rnm    = x[2];
            Temp.elev   = x[3] / UCF(LENGTH);
            Temp.anglat = x[4];
            Temp.dtlong = x[5] / 60.0;
            break;
    
          case 4:  // Areal Depletion Curve data
            // --- check if data is for impervious or pervious areas
            if ( ntoks < 12 ) return error_setInpError(ERR_ITEMS, "");
            if      ( match(tok[1], w_IMPERV) ) i = 0;
            else if ( match(tok[1], w_PERV)   ) i = 1;
            else return error_setInpError(ERR_KEYWORD, tok[1]);
    
            // --- read 10 fractional values
            for (j=0; j<10; j++)
            {
                ////////////////////////////////////
                returnObj = {y: y}
                returnVal = getDouble(tok[j+2], returnObj);
                y = returnObj.y;
                ////////////////////////////////////
                if (!returnVal || y < 0.0 || y > 1.0 )
                //if ( null == (y = getDouble(tok[j+2])) || y < 0.0 || y > 1.0 )
                    return error_setInpError(ERR_NUMBER, tok[j+2]);
                Snow.adc[i][j] = y;
            }
            break;
        }
        return 0;
    }
    
    //=============================================================================
    // char* tok[], int ntoks
    climate_readEvapParams(tok, ntoks)
    //
    //  Input:   tok[] = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //  Purpose: reads evaporation parameters from input line of data.
    //
    //  Data formats are:
    //    CONSTANT  value
    //    MONTHLY   v1 ... v12
    //    TIMESERIES name
    //    TEMPERATURE
    //    FILE      (v1 ... v12)
    //    RECOVERY   name
    //    DRY_ONLY   YES/NO
    //
    {
        let i, k;
        let x;
    
        // return facilitators
        let returnObj;
        let returnVal;
    
        // --- find keyword indicating what form the evaporation data is in
        k = findmatch(tok[0], EvapTypeWords);
        if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[0]);
    
        // --- check for RECOVERY pattern data
        if ( k == RECOVERY )
        {
            if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
            i = project_findObject(TIMEPATTERN, tok[1]);
            if ( i < 0 ) return error_setInpError(ERR_NAME, tok[1]);
            Evap.recoveryPattern = i;
            return 0;
        }
    
        // --- check for no evaporation in wet periods
        if ( k == DRYONLY )
        {
            if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
            if      ( strcomp(tok[1], w_NO ) )  Evap.dryOnly = FALSE;
            else if ( strcomp(tok[1], w_YES ) ) Evap.dryOnly = TRUE;
            else return error_setInpError(ERR_KEYWORD, tok[1]);
            return 0;
        }
    
        // --- process data depending on its form
        Evap.type = k;
        if ( k != TEMPERATURE_EVAP && ntoks < 2 )
            return error_setInpError(ERR_ITEMS, "");
        switch ( k )
        {
          case CONSTANT_EVAP:
            // --- for constant evap., fill monthly avg. values with same number
            ////////////////////////////////////
            returnObj = {y: x}
            returnVal = getDouble(tok[1], returnObj);
            x = returnObj.y;
            ////////////////////////////////////
            if(!returnVal)
            //if ( null == (x = getDouble(tok[1])) )
                return error_setInpError(ERR_NUMBER, tok[1]);
            for (i=0; i<12; i++) Evap.monthlyEvap[i] = x;
            break;
    
          case MONTHLY_EVAP:
            // --- for monthly evap., read a value for each month of year
            if ( ntoks < 13 ) return error_setInpError(ERR_ITEMS, "");
            for ( i=0; i<12; i++)
                ////////////////////////////////////
                returnObj = {y: Evap.monthlyEvap[i]}
                returnVal = getDouble(tok[i+1], returnObj);
                Evap.monthlyEvap[i] = returnObj.y;
                ////////////////////////////////////
                if(!returnVal)
                //if ( null == (Evap.monthlyEvap[i] = getDouble(tok[i+1])))
                    return error_setInpError(ERR_NUMBER, tok[i+1]);
            break;
    
          case TIMESERIES_EVAP:
            // --- for time series evap., read name of time series
            i = project_findObject(TSERIES, tok[1]);
            if ( i < 0 ) return error_setInpError(ERR_NAME, tok[1]);
            Evap.tSeries = i;
            Tseries[i].refersTo = TIMESERIES_EVAP;
            break;
    
          case FILE_EVAP:
            // --- for evap. from climate file, read monthly pan coeffs.
            //     if they are provided (default values are 1.0)
            if ( ntoks > 1 )
            {
                if ( ntoks < 13 ) return error_setInpError(ERR_ITEMS, "");
                for (i=0; i<12; i++)
                {
                    ////////////////////////////////////
                    returnObj = {y: Evap.panCoeff[i]}
                    returnVal = getDouble(tok[i+1], returnObj);
                    Evap.panCoeff[i] = returnObj.y;
                    ////////////////////////////////////
                    if(!returnVal)
                    //if ( null == (Evap.panCoeff[i] = getDouble(tok[i+1])) )
                        return error_setInpError(ERR_NUMBER, tok[i+1]);
                }
            }
            break;
        }
        return 0;
    }
    
    //=============================================================================
    // char* tok[], int ntoks
    climate_readAdjustments(tok, ntoks)
    //
    //  Input:   tok[] = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //  Purpose: reads adjustments to monthly evaporation or rainfall
    //           from input line of data.
    //
    //  Data formats are:
    //    TEMPERATURE   v1 ... v12
    //    EVAPORATION   v1 ... v12
    //    RAINFALL      v1 ... v12
    //    CONDUCTIVITY  v1 ... v12
    //    N-PERV        subcatchID  patternID                                      //(5.1.013
    //    DSTORE        subcatchID  patternID                                      //
    //    INFIL         subcatchID  patternID                                      //
    {
        let i, j;                                                                  //(5.1.013)
    
        // return facilitators
        let returnObj;
        let returnVal;
    
        if (ntoks == 1) return 0;
    
        if ( match(tok[0], "TEMP") )
        {
            if ( ntoks < 13 )  return error_setInpError(ERR_ITEMS, "");
            for (i = 1; i < 13; i++)
            {
                ////////////////////////////////////
                returnObj = {y: Adjust.temp[i-1]}
                returnVal = getDouble(tok[i], returnObj);
                Adjust.temp[i-1] = returnObj.y;
                ////////////////////////////////////
                if(!returnVal)
                //if ( null == (Adjust.temp[i-1] = getDouble(tok[i])) )
                    return error_setInpError(ERR_NUMBER, tok[i]);
            }
            return 0;
        }
    
        if ( match(tok[0], "EVAP") )
        {
            if ( ntoks < 13 )  return error_setInpError(ERR_ITEMS, "");
            for (i = 1; i < 13; i++)
            {
                ////////////////////////////////////
                returnObj = {y: Adjust.evap[i-1]}
                returnVal = getDouble(tok[i], returnObj);
                Adjust.evap[i-1] = returnObj.y;
                ////////////////////////////////////
                if(!returnVal)
                //if ( null == (Adjust.evap[i-1] = getDouble(tok[i])))
                    return error_setInpError(ERR_NUMBER, tok[i]);
            }
            return 0;
        }
    
        if ( match(tok[0], "RAIN") )
        {
            if ( ntoks < 13 )  return error_setInpError(ERR_ITEMS, "");
            for (i = 1; i < 13; i++)
            {
                ////////////////////////////////////
                returnObj = {y: Adjust.rain[i-1]}
                returnVal = getDouble(tok[i], returnObj);
                Adjust.rain[i-1] = returnObj.y;
                ////////////////////////////////////
                if(!returnVal)
                //if ( null == (Adjust.rain[i-1] = getDouble(tok[i])))
                    return error_setInpError(ERR_NUMBER, tok[i]);
            }
            return 0;
        }
    
        if ( match(tok[0], "CONDUCT") )
        {
            if ( ntoks < 13 )  return error_setInpError(ERR_ITEMS, "");
            for (i = 1; i < 13; i++)
            {
                ////////////////////////////////////
                returnObj = {y: Adjust.hydcon[i-1]}
                returnVal = getDouble(tok[i], returnObj);
                Adjust.hydcon[i-1] = returnObj.y;
                ////////////////////////////////////
                if(!returnVal)
                //if ( null == (Adjust.hydcon[i-1] = getDouble(tok[i])))
                    return error_setInpError(ERR_NUMBER, tok[i]);
                if ( Adjust.hydcon[i-1] <= 0.0 ) Adjust.hydcon[i-1] = 1.0;
            }
            return 0;
        }
    
    ////  Following code segments added to release 5.1.013.  ////                  //(5.1.013)
        if ( match(tok[0], "N-PERV") )
        {
            if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");
            i = project_findObject(SUBCATCH, tok[1]);
            if (i < 0) return error_setInpError(ERR_NAME, tok[1]);
            j = project_findObject(TIMEPATTERN, tok[2]);
            if (j < 0) return error_setInpError(ERR_NAME, tok[2]);
            Subcatch[i].nPervPattern = j;
            return 0;
        }
    
        if ( match(tok[0], "DSTORE") )
        {
            if (ntoks < 3) return error_setInpError(ERR_ITEMS, "");
            i = project_findObject(SUBCATCH, tok[1]);
            if (i < 0) return error_setInpError(ERR_NAME, tok[1]);
            j = project_findObject(TIMEPATTERN, tok[2]);
            if (j < 0) return error_setInpError(ERR_NAME, tok[2]);
            Subcatch[i].dStorePattern = j;
            return 0;
        }
    
        if (match(tok[0], "INFIL"))
        {
            if (ntoks < 3) return error_setInpError(ERR_ITEMS, "");
            i = project_findObject(SUBCATCH, tok[1]);
            if (i < 0) return error_setInpError(ERR_NAME, tok[1]);
            j = project_findObject(TIMEPATTERN, tok[2]);
            if (j < 0) return error_setInpError(ERR_NAME, tok[2]);
            Subcatch[i].infilPattern = j;
            return 0;
        }
    ////
        return error_setInpError(ERR_KEYWORD, tok[0]);
    }
    
    //=============================================================================
    
    climate_validate()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: validates climatological variables
    //
    {
        let       i;
        let    a, z, pa;
    
        // --- check if climate data comes from external data file 
        if ( Wind.type == FILE_WIND || Evap.type == FILE_EVAP ||
             Evap.type == TEMPERATURE_EVAP )
        {
            if ( Fclimate.mode == NO_FILE )
            {
                report_writeErrorMsg(ERR_NO_CLIMATE_FILE, "");
            }
        }
    
        // --- open the climate data file
        if ( Fclimate.mode == USE_FILE ) climate_openFile();
    
        // --- snow melt parameters tipm & rnm must be fractions
        if ( Snow.tipm < 0.0 ||
             Snow.tipm > 1.0 ||
             Snow.rnm  < 0.0 ||
             Snow.rnm  > 1.0 ) report_writeErrorMsg(ERR_SNOWMELT_PARAMS, "");
    
        // --- latitude should be between -90 & 90 degrees
        a = Temp.anglat;
        if ( a <= -89.99 ||
             a >= 89.99  ) report_writeErrorMsg(ERR_SNOWMELT_PARAMS, "");
        else Temp.tanAnglat = Math.tan(a * PI / 180.0);
    
        // --- compute psychrometric constant
        z = Temp.elev / 1000.0;
        if ( z <= 0.0 ) pa = 29.9;
        else  pa = 29.9 - 1.02*z + 0.0032*Math.pow(z, 2.4); // atmos. pressure
        Temp.gamma = 0.000359 * pa;
    
        // --- convert units of monthly temperature & evap adjustments
        for (i = 0; i < 12; i++)
        {
            if (UnitSystem == SI) Adjust.temp[i] *= 9.0/5.0;
            Adjust.evap[i] /= UCF(EVAPRATE);
        }
    }
    
    //=============================================================================
    
    climate_openFile()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: opens a climate file and reads in first set of values.
    //
    {
        let i, m, y;
        let returnObj;
    
        // --- open the file
        if ( (Fclimate.file = fopen(Fclimate.name, "rt")) == null )
        {
            report_writeErrorMsg(ERR_CLIMATE_FILE_OPEN, Fclimate.name);
            return;
        }
    
        // --- initialize values of file's climate variables
        //     (Temp.ta was previously initialized in project.c)
        FileValue[TMIN] = Temp.ta;
        FileValue[TMAX] = Temp.ta;
        FileValue[EVAP] = 0.0;
        FileValue[WIND] = 0.0;
    
        // --- find climate file's format
        FileFormat = getFileFormat();
        if ( FileFormat == UNKNOWN_FORMAT )
        {
            report_writeErrorMsg(ERR_CLIMATE_FILE_READ, Fclimate.name);
            return;
        }
    
        // --- position file to begin reading climate file at either user-specified
        //     month/year or at start of simulation period.
        rewind(Fclimate.file);
        strcpy(FileLine, "");
        if ( Temp.fileStartDate == NO_DATE ){
            //datetime_decodeDate(StartDate, FileYear, FileMonth, FileDay);
            ////////////////////////////////////
            returnObj = {year: FileYear, month: FileMonth, day: FileDay}
            datetime_decodeDate(StartDate, returnObj);
            FileYear = returnObj.year;
            FileMonth = returnObj.month;
            FileDay = returnObj.day;
            ////////////////////////////////////
        }
        else{
            //datetime_decodeDate(Temp.fileStartDate, FileYear, FileMonth, FileDay);
            ////////////////////////////////////
            returnObj = {year: FileYear, month: FileMonth, day: FileDay}
            datetime_decodeDate(Temp.fileStartDate, returnObj);
            FileYear = returnObj.year;
            FileMonth = returnObj.month;
            FileDay = returnObj.day;
            ////////////////////////////////////
        }
        while ( !feof(Fclimate.file) )
        {
            strcpy(FileLine, "");
            readFileLine(y, m);
            if ( y == FileYear && m == FileMonth ) break;
        }
        if ( feof(Fclimate.file) )
        {
            report_writeErrorMsg(ERR_CLIMATE_END_OF_FILE, Fclimate.name);
            return;
        }
    
        // --- initialize file dates and current climate variable values
        if ( !ErrorCode )
        {
            FileElapsedDays = 0;
            FileLastDay = datetime_daysPerMonth(FileYear, FileMonth);
            readFileValues();
            for (i=TMIN; i<=WIND; i++)
            {
                if ( FileData[i][FileDay] == MISSING ) continue;
                FileValue[i] = FileData[i][FileDay];
            }
        }
    }
    
    //=============================================================================
    
    climate_initState()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: initializes climate state variables.
    //
    {
        LastDay = NO_DATE;
        Temp.tmax = MISSING;
        Snow.removed = 0.0;
        NextEvapDate = StartDate;
        NextEvapRate = 0.0;
    
        // ret facil
        let returnObj;
        let returnVal;
    
        // --- initialize variables for time series evaporation
        if ( Evap.type == TIMESERIES_EVAP && Evap.tSeries >= 0  )
        {
            // --- initialize NextEvapDate & NextEvapRate to first entry of
            //     time series whose date <= the simulation start date
            ////////////////////////////////////
            returnObj = {x: NextEvapDate, y: NextEvapRate}
            returnVal = table_getFirstEntry(Tseries[Evap.tSeries], returnObj)
            NextEvapDate = returnObj.x;
            NextEvapRate = returnObj.y;
            ////////////////////////////////////
            //table_getFirstEntry(Tseries[Evap.tSeries],
            //                    NextEvapDate, NextEvapRate);
            if ( NextEvapDate < StartDate )
            {  
                setNextEvapDate(StartDate);
            }
            Evap.rate = NextEvapRate / UCF(EVAPRATE);
    
            // --- find the next time evaporation rates change after this
            setNextEvapDate(NextEvapDate); 
        }
    
        // --- initialize variables for temperature evaporation
        if ( Evap.type == TEMPERATURE_EVAP )
        {
            Tma.maxCount = sizeof(Tma.ta) / sizeof(double);
            Tma.count = 0;
            Tma.front = 0;
            Tma.tAve = 0.0;
            Tma.tRng = 0.0;
        }
    }
    
    //=============================================================================
    // DateTime theDate
    climate_setState(theDate)
    //
    //  Input:   theDate = simulation date
    //  Output:  none
    //  Purpose: sets climate variables for current date.
    //
    {
        if ( Fclimate.mode == USE_FILE ) updateFileValues(theDate);
        if ( Temp.dataSource != NO_TEMP ) setTemp(theDate);
        setEvap(theDate);
        setWind(theDate);
        Adjust.rainFactor = Adjust.rain[datetime_monthOfYear(theDate)-1];
        Adjust.hydconFactor = Adjust.hydcon[datetime_monthOfYear(theDate)-1];
        setNextEvapDate(theDate);
    }
    
    //=============================================================================
    
    climate_getNextEvapDate()
    //
    //  Input:   none
    //  Output:  returns the current value of NextEvapDate
    //  Purpose: gets the next date when evaporation rate changes.
    //
    {
        return NextEvapDate;
    }
    
    //=============================================================================
    // DateTime theDate
    setNextEvapDate(theDate)
    //
    //  Input:   theDate = current simulation date
    //  Output:  sets a new value for NextEvapDate
    //  Purpose: finds date for next change in evaporation after the current date.
    //
    {
        let    yr, mon, day, k;
        let d, e;
    
        // ret facil
        let returnObj;
        let returnVal;
    
        // --- do nothing if current date hasn't reached the current next date
        if ( NextEvapDate > theDate ) return;
    
        switch ( Evap.type )
        {
          // --- for constant evaporation, use a next date far in the future
          case CONSTANT_EVAP:
             NextEvapDate = theDate + 365.;
             break;
    
          // --- for monthly evaporation, use the start of the next month
          case MONTHLY_EVAP:
            //datetime_decodeDate(theDate, yr, mon, day);
            ////////////////////////////////////
            let returnObj = {year: yr, month: mon, day: day}
            datetime_decodeDate(theDate, returnObj);
            yr = returnObj.year;
            mon = returnObj.month;
            day = returnObj.day;
            ////////////////////////////////////
            if ( mon == 12 )
            {
                mon = 1;
                yr++;
            }
            else mon++;
            NextEvapDate = datetime_encodeDate(yr, mon, 1);
            break;
    
          // --- for time series evaporation, find the next entry in the
          //     series on or after the current date
          case TIMESERIES_EVAP:
            k = Evap.tSeries;
            if ( k >= 0 )
            {
                NextEvapDate = theDate + 365.;
                ////////////////////////////////////
                returnObj = {x: d, y: e}
                returnVal = table_getNextEntry(Tseries[k], returnObj)
                d = returnObj.x;
                e = returnObj.y;
                ////////////////////////////////////
                //while ( table_getNextEntry(Tseries[k], d, e) && d <= EndDateTime )
                while( returnVal && d <= EndDateTime )
                {
                    if ( d >= theDate )
                    {
                        NextEvapDate = d;
                        NextEvapRate = e;
                        break;
                    }
                    ////////////////////////////////////
                    returnObj = {x: d, y: e}
                    returnVal = table_getNextEntry(Tseries[k], returnObj)
                    d = returnObj.x;
                    e = returnObj.y;
                    ////////////////////////////////////
                }
            }
            break;
    
          // --- for climate file daily evaporation, use the next day
          case FILE_EVAP:
            NextEvapDate = floor(theDate) + 1.0;
            break;
    
          default: NextEvapDate = theDate + 365.;
        }
    }
    
    //=============================================================================
    // DateTime theDate
    updateFileValues(theDate)
    //
    //  Input:   theDate = current simulation date
    //  Output:  none
    //  Purpose: updates daily climate variables for new day or reads in
    //           another month worth of values if a new month begins.
    //
    //  NOTE:    counters FileElapsedDays, FileDay, FileMonth, FileYear and
    //           FileLastDay were initialized in climate_openFile().
    //
    {
        let i;
        let deltaDays;
    
        // --- see if a new day has begun
        deltaDays = (int)(floor(theDate) - floor(StartDateTime));
        if ( deltaDays > FileElapsedDays )
        {
            // --- advance day counters
            FileElapsedDays++;
            FileDay++;
    
            // --- see if new month of data needs to be read from file
            if ( FileDay > FileLastDay )
            {
                FileMonth++;
                if ( FileMonth > 12 )
                {
                    FileMonth = 1;
                    FileYear++;
                }
                readFileValues();
                FileDay = 1;
                FileLastDay = datetime_daysPerMonth(FileYear, FileMonth);
            }
    
            // --- set climate variables for new day
            for (i=TMIN; i<=WIND; i++)
            {
                // --- no change in current value if its missing
                if ( FileData[i][FileDay] == MISSING ) continue;
                FileValue[i] = FileData[i][FileDay];
            }
        }
    }
    
    //=============================================================================
    // DateTime theDate
    setTemp(theDate)
    //
    //  Input:   theDate = simulation date
    //  Output:  none
    //  Purpose: updates temperatures for new simulation date.
    //
    {
        let      j;                        // snow data object index
        let      k;                        // time series index
        let      mon;                      // month of year 
        let      day;                      // day of year
        let theDay;                   // calendar day
        let   hour;                     // hour of day
        let   tmp;                      // temporary temperature
    
        // ret facil
        let returnObj;
        let returnVal;
    
        // --- see if a new day has started
        mon = datetime_monthOfYear(theDate);
        theDay = floor(theDate);
        if ( theDay > LastDay )
        {
            // --- update min. & max. temps & their time of day
            day = datetime_dayOfYear(theDate);
            if ( Temp.dataSource == FILE_TEMP )
            {
                Tmin = FileValue[TMIN] + Adjust.temp[mon-1];
                Tmax = FileValue[TMAX] + Adjust.temp[mon-1];
                if ( Tmin > Tmax )
                {
                    tmp = Tmin;
                    Tmin = Tmax;
                    Tmax = tmp;
                }
                updateTempTimes(day);
                if ( Evap.type == TEMPERATURE_EVAP )
                {
                    updateTempMoveAve(Tmin, Tmax); 
                    FileValue[EVAP] = getTempEvap(day, Tma.tAve, Tma.tRng);
                }
            }
    
            // --- compute snow melt coefficients based on day of year
            Snow.season = sin(0.0172615*(day-81.0));
            for (j=0; j<Nobjects[SNOWMELT]; j++)
            {
                snow_setMeltCoeffs(j, Snow.season);
            }
    
            // --- update date of last day analyzed
            LastDay = theDate;
        }
    
        // --- for min/max daily temps. from climate file,
        //     compute hourly temp. by sinusoidal interp.
        if ( Temp.dataSource == FILE_TEMP )
        {
            hour = (theDate - theDay) * 24.0;
            if ( hour < Hrsr )
                Temp.ta = Tmin + Trng1/2.0 * sin(PI/Dydif * (Hrsr - hour));
            else if ( hour >= Hrsr && hour <= Hrss )
                Temp.ta = Tave + Trng * sin(PI/Dhrdy * (Hrday - hour));
            else
                Temp.ta = Tmax - Trng * sin(PI/Dydif * (hour - Hrss));
        }
    
        // --- for user-supplied temperature time series,
        //     get temperature value from time series
        if ( Temp.dataSource == TSERIES_TEMP )
        {
            k = Temp.tSeries;
            if ( k >= 0)
            {
                ////////////////////////////////////
                returnObj = {table: Tseries[k]}
                returnVal = table_tseriesLookup(returnObj, theDate, true);
                Tseries[k] = returnObj.table;
                ////////////////////////////////////
                Temp.ta = returnVal;
                //Temp.ta = table_tseriesLookup(Tseries[k], theDate, true);
    
                // --- convert from deg. C to deg. F if need be
                if ( UnitSystem == SI )
                {
                    Temp.ta = (9./5.) * Temp.ta + 32.0;
                }
    
                // --- apply climate change adjustment factor 
                Temp.ta += Adjust.temp[mon-1];
            }
        }
    
        // --- compute saturation vapor pressure
        Temp.ea = 8.1175e6 * exp(-7701.544 / (Temp.ta + 405.0265) );
    }
    
    //=============================================================================
    // DateTime theDate
    setEvap(theDate)
    //
    //  Input:   theDate = simulation date
    //  Output:  none
    //  Purpose: sets evaporation rate (ft/sec) for a specified date.
    //
    {
        let k;
        let mon = datetime_monthOfYear(theDate);
    
        switch ( Evap.type )
        {
          case CONSTANT_EVAP:
            Evap.rate = Evap.monthlyEvap[0] / UCF(EVAPRATE);
            break;
    
          case MONTHLY_EVAP:
            Evap.rate = Evap.monthlyEvap[mon-1] / UCF(EVAPRATE);
            break;
    
          case TIMESERIES_EVAP:
            if ( theDate >= NextEvapDate )
                Evap.rate = NextEvapRate / UCF(EVAPRATE);
            break;
    
          case FILE_EVAP:
            Evap.rate = FileValue[EVAP] / UCF(EVAPRATE);
            Evap.rate *= Evap.panCoeff[mon-1];
            break;
    
          case TEMPERATURE_EVAP:
            Evap.rate = FileValue[EVAP] / UCF(EVAPRATE);
            break;
    
          default: Evap.rate = 0.0;
        }
    
        // --- apply climate change adjustment
        Evap.rate += Adjust.evap[mon-1];
    
        // --- set soil recovery factor
        Evap.recoveryFactor = 1.0;
        k = Evap.recoveryPattern;
        if ( k >= 0 && Pattern[k].type == MONTHLY_PATTERN )
        {
            Evap.recoveryFactor = Pattern[k].factor[mon-1];
        }
    }
    
    //=============================================================================
    // DateTime theDate
    setWind(theDate)
    //
    //  Input:   theDate = simulation date
    //  Output:  none
    //  Purpose: sets wind speed (mph) for a specified date.
    //
    {
        let yr, mon, day;
    
        switch ( Wind.type )
        {
          case MONTHLY_WIND:
            //datetime_decodeDate(theDate, yr, mon, day);
            ////////////////////////////////////
            let returnObj = {year: yr, month: mon, day: day}
            datetime_decodeDate(theDate, returnObj);
            yr = returnObj.year;
            mon = returnObj.month;
            day = returnObj.day;
            ////////////////////////////////////
            Wind.ws = Wind.aws[mon-1] / UCF(WINDSPEED);
            break;
    
          case FILE_WIND:
            Wind.ws = FileValue[WIND];
            break;
    
          default: Wind.ws = 0.0;
        }
    }
    
    //=============================================================================
    // int day
    updateTempTimes(day)
    //
    //  Input:   day = day of year
    //  Output:  none
    //  Purpose: computes time of day when min/max temperatures occur.
    //           (min. temp occurs at sunrise, max. temp. at 3 hrs. < sunset)
    //
    {
        let decl;                       // earth's declination
        let hrang;                      // hour angle of sunrise/sunset
        let arg;
    
        decl  = 0.40928*cos(0.017202*(172.0-day));
        arg = -tan(decl)*Temp.tanAnglat;
        if      ( arg <= -1.0 ) arg = PI;
        else if ( arg >= 1.0 )  arg = 0.0;
        else                    arg = acos(arg);
        hrang = 3.8197 * arg;
        Hrsr  = 12.0 - hrang + Temp.dtlong;
        Hrss  = 12.0 + hrang + Temp.dtlong - 3.0;
        Dhrdy = Hrsr - Hrss;
        Dydif = 24.0 + Hrsr - Hrss;
        Hrday = (Hrsr + Hrss) / 2.0;
        Tave  = (Tmin + Tmax) / 2.0;
        Trng  = (Tmax - Tmin) / 2.0;
        if ( Temp.tmax == MISSING ) Trng1 = Tmax - Tmin;
        else                        Trng1 = Temp.tmax - Tmin;
        Temp.tmax = Tmax;
    }
    
    //=============================================================================
    // int day, double tave, double trng
    getTempEvap(day, tave, trng)
    //
    //  Input:   day = day of year
    //           tave = 7-day average temperature (deg F)
    //           trng = 7-day average daily temperature range (deg F)
    //  Output:  returns evaporation rate in user's units (US:in/day, SI:mm/day)
    //  Purpose: uses Hargreaves method to compute daily evaporation rate
    //           from daily average temperatures and Julian day.
    //
    {
        let a = 2.0*PI/365.0;
        let ta = (tave - 32.0)*5.0/9.0;           //average temperature (deg C)
        let tr = trng*5.0/9.0;                    //temperature range (deg C)
        let lamda = 2.50 - 0.002361 * ta;         //latent heat of vaporization
        let dr = 1.0 + 0.033*cos(a*day);          //relative earth-sun distance
        let phi = Temp.anglat*2.0*PI/360.0;       //latitude angle (rad)
        let del = 0.4093*sin(a*(284+day));        //solar declination angle (rad)
        let omega = acos(-tan(phi)*tan(del));     //sunset hour angle (rad)
        let ra = 37.6*dr*                         //extraterrestrial radiation
                    (omega*sin(phi)*sin(del) +
                     cos(phi)*cos(del)*sin(omega));
        let e = 0.0023*ra/lamda*sqrt(tr)*(ta+17.8);    //evap. rate (mm/day)
        if ( e < 0.0 ) e = 0.0;
        if ( UnitSystem == US ) e /= MMperINCH;           //evap rate (in/day)
        return e;
    }
    
    //=============================================================================
    
     getFileFormat()
    //
    //  Input:   none
    //  Output:  returns code number of climate file's format
    //  Purpose: determines what format the climate file is in.
    //
    {
        let recdType = "";
        let elemType = ""; //size 4
        let filler = "";   // size 5
        let staID;        // size 80
        let s;            // size 80
        let line;    // size MAXLINE
    
        let  y, m, d, n;
    
        // --- read first line of file
        if ( fgets(line, MAXLINE, Fclimate.file) == null ) return UNKNOWN_FORMAT;
    
        // --- check for TD3200 format
        sstrncpy(recdType, line, 3);
        sstrncpy(filler, line[23], 4);
        if ( strcmp(recdType, "DLY") == 0 &&
             strcmp(filler, "9999")  == 0 ) return TD3200;
    
        // --- check for DLY0204 format
        if ( line.length >= 233 )
        {
            sstrncpy(elemType, line[13], 3);
            n = parseInt(elemType);
            if ( n == 1 || n == 2 || n == 151 ) return DLY0204;
        }
    
        // --- check for USER_PREPARED format
        n = sscanf(line, "%s %d %d %d %s", staID, y, m, d, s);
        if ( n == 5 ) return USER_PREPARED;
    
        // --- check for GHCND format
        if ( isGhcndFormat(line) ) return GHCND;
    
        return UNKNOWN_FORMAT;
    }
    
    //=============================================================================
    //int *y, int *m
    readFileLine(y, m)
    //
    //  Input:   none
    //  Output:  y = year
    //           m = month
    //  Purpose: reads year & month from next line of climate file.
    //
    {
        // --- read next line from climate data file
        while ( FileLine.length == 0 )
        {
            if ( fgets(FileLine, MAXLINE, Fclimate.file) == null ) return;
             if ( FileLine[0] == '\n' ) FileLine[0] = '\0';
        }
    
        // --- parse year & month from line
        switch (FileFormat)
        {
        case  USER_PREPARED: readUserFileLine(y, m);   break;
        case  TD3200:        readTD3200FileLine(y,m);  break;
        case  DLY0204:       readDLY0204FileLine(y,m); break;
        case  GHCND:         readGhcndFileLine(y,m);   break; 
        }
    }
    
    //=============================================================================
    // int* y, int* m
    readUserFileLine(y, m)
    //
    //  Input:   none
    //  Output:  y = year
    //           m = month
    //  Purpose: reads year & month from line of User-Prepared climate file.
    //
    {
        let n;
        let staID;
        n = sscanf(FileLine, "%s %d %d", staID, y, m);
        if ( n < 3 )
        {
            report_writeErrorMsg(ERR_CLIMATE_FILE_READ, Fclimate.name);
        }
    }
    
    //=============================================================================
    // int* y, int* m
    readTD3200FileLine(y, m)
    //
    //  Input:   none
    //  Output:  y = year
    //           m = month
    //  Purpose: reads year & month from line of TD-3200 climate file.
    //
    {
        let recdType = ""; //[4]
        let year = ""; //[5]
        let month = ""; //[3]
        let  len;
    
        // --- check for minimum number of characters
        len = FileLine.length;
        if ( len < 30 )
        {
            report_writeErrorMsg(ERR_CLIMATE_FILE_READ, Fclimate.name);
            return;
        }
    
        // --- check for proper type of record
        sstrncpy(recdType, FileLine, 3);
        if ( strcmp(recdType, "DLY") != 0 )
        {
            report_writeErrorMsg(ERR_CLIMATE_FILE_READ, Fclimate.name);
            return;
        }
    
        // --- get record's date
        sstrncpy(year,  FileLine[17], 4);
        sstrncpy(month, FileLine[21], 2);
        y = parseInt(year);
        m = parseInt(month);
    }
    
    //=============================================================================
    // int* y, int* m
    readDLY0204FileLine(y, m)
    //
    //  Input:   none
    //  Output:  y = year
    //           m = month
    //  Purpose: reads year & month from line of DLY02 or DLY04 climate file.
    //
    {
        let year = ""; //[5]
        let month = ""; //[3]
        let  len;
    
        // --- check for minimum number of characters
        len = FileLine.length;
        if ( len < 16 )
        {
            report_writeErrorMsg(ERR_CLIMATE_FILE_READ, Fclimate.name);
            return;
        }
    
        // --- get record's date
        sstrncpy(year,  FileLine[7], 4);
        sstrncpy(month, FileLine[11], 2);
        y = parseInt(year);
        m = parseInt(month);
    }
    
    //=============================================================================
    
    readFileValues()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: reads next month's worth of data from climate file.
    //
    {
        let  i, j;
        let  y, m;
    
        // --- initialize FileData array to missing values
        for ( i=0; i<MAXCLIMATEVARS; i++)
        {
            for (j=0; j<MAXDAYSPERMONTH; j++) FileData[i][j] = MISSING;
        }
    
        while ( !ErrorCode )
        {
            // --- return when date on line is after current file date
            if ( feof(Fclimate.file) ) return;
            readFileLine(y, m);
            if ( y > FileYear || m > FileMonth ) return;
    
            // --- parse climate values from file line
            switch (FileFormat)
            {
            case  USER_PREPARED: parseUserFileLine();   break;
            case  TD3200:        parseTD3200FileLine();  break;
            case  DLY0204:       parseDLY0204FileLine(); break;
            case  GHCND:         parseGhcndFileLine();   break; 
            }
            strcpy(FileLine, "");
        }
    }
    
    //=============================================================================
    
    parseUserFileLine()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: parses climate variable values from a line of a user-prepared
    //           climate file.
    //
    {
        let   n;
        let   y, m, d;
        let  staID//[80];
        let  s0//[80];
        let  s1//[80];
        let  s2//[80];
        let  s3//[80];
        let x;
    
        // --- read day, Tmax, Tmin, Evap, & Wind from file line
        n = sscanf(FileLine, "%s %d %d %d %s %s %s %s",
            staID, y, m, d, s0, s1, s2, s3);
        if ( n < 4 ) return;
        if ( d < 1 || d > 31 ) return;
    
        // --- process TMAX
        if ( s0.length > 0 && s0 != '*' )
        {
            x = atof(s0);
            if ( UnitSystem == SI ) x = 9./5.*x + 32.0;
            FileData[TMAX][d] =  x;
        }
    
        // --- process TMIN
        if ( s1.length > 0 && s1 != '*' )
        {
            x = atof(s1);
            if ( UnitSystem == SI ) x = 9./5.*x + 32.0;
            FileData[TMIN][d] =  x;
        }
    
        // --- process EVAP
        if ( s2.length > 0 && s2 != '*' ) FileData[EVAP][d] = atof(s2);
    
        // --- process WIND
        if ( s3.length > 0 && s3 != '*' ) FileData[WIND][d] = atof(s3);
    }
    
    //=============================================================================
    
    parseTD3200FileLine()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: parses climate variable values from a line of a TD3200 file.
    //
    {
        let  i;
        let param = "";// [5]
    
        // --- parse parameter name
        sstrncpy(param, FileLine[11], 4);
    
        // --- see if parameter is temperature, evaporation or wind speed
        for (i=0; i<MAXCLIMATEVARS; i++)
        {
            if (strcmp(param, ClimateVarWords[i]) == 0 ) setTD3200FileValues(i);
        }
    }
    
    //=============================================================================
    //int i
    setTD3200FileValues(i)
    //
    //  Input:   i = climate variable code
    //  Output:  none
    //  Purpose: reads month worth of values for climate variable from TD-3200 file.
    //
    {
        let valCount = "";//[4]
        let day = "";//[3]
        let sign = "";//[2]
        let value = "";//[6]
        let flag2 = "";//[2]
        let x;
        let  nValues;
        let  j, k, d;
        let  lineLength;
    
        // --- parse number of days with data from cols. 27-29 of file line
        //sstrncpy(valCount, FileLine[27], 3);
        valCount = FileLine.slice(27, 30)
        nValues = parseInt(valCount);
        lineLength = FileLine.length;
    
        // --- check for enough characters on line
        if ( lineLength >= 12*nValues + 30 )
        {
            // --- for each day's value
            for (j=0; j<nValues; j++)
            {
                // --- parse day, value & flag from file line
                k = 30 + j*12;
                //sstrncpy(day,   &FileLine[k], 2);
                //sstrncpy(sign,  &FileLine[k+4], 1);
                //sstrncpy(value, &FileLine[k+5], 5);
                //sstrncpy(flag2, &FileLine[k+11], 1);
                day = FileLine.slice(k, k+2)
                sign = FileLine.slice(k+4, k+1)
                value = FileLine.slice(k, k+5)
                flag2 = FileLine.slice(k, k+1)
    
                // --- if value is valid then store it in FileData array
                d = parseInt(day);
                if ( value != "99999"
                     && ( flag2[0] == '0' || flag2[0] == '1')
                     &&   d > 0
                     &&   d <= 31 )
                {
                    // --- convert from string value to numerical value
                    x = parseFloat(value);
                    if ( sign[0] == '-' ) x = -x;
    
                    // --- convert evaporation from hundreths of inches
                    if ( i == EVAP )
                    {
                        x /= 100.0;
    
                        // --- convert to mm if using SI units
                        if ( UnitSystem == SI ) x *= MMperINCH;
                    }
    
                    // --- convert wind speed from miles/day to miles/hour
                    if ( i == WIND ) x /= 24.0;
    
                    // --- store value
                    FileData[i][d] = x;
                }
            }
        }
    }
    
    //=============================================================================
    
    parseDLY0204FileLine()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: parses a month's worth of climate variable values from a line of
    //           a DLY02 or DLY04 climate file.
    //
    {
        let  j, k, p;
        let param = "";//[4]
        let sign  = "";//[2]
        let value = "";//[6]
        let code  = "";//[2]
        let x;
    
        // --- parse parameter name
        param =  FileLine.slice(13, 16);
    
        // --- see if parameter is min or max temperature
        p = parseInt(param);
        if ( p == 1 ) p = TMAX;
        else if ( p == 2 ) p = TMIN;
        else if ( p == 151 ) p = EVAP;
        else return;
    
        // --- check for 233 characters on line
        if ( FileLine.length < 233 ) return;
    
        // --- for each of 31 days
        k = 16;
        for (j=1; j<=31; j++)
        {
            // --- parse value & flag from file line
            sign =  FileLine.slice(k, k+1);
            value = FileLine.slice(k+1, k+6);
            code =  FileLine.slice(k+6, k+7);
            k += 7;
    
            // --- if value is valid then store it in FileData array
    
            if ( strcmp(value, "99999") != 0 && strcmp(value, "     ") != 0 )
            {
                switch (p)
                {
                case TMAX:
                case TMIN:
                    // --- convert from integer tenths of a degree C to degrees F
                    x = atof(value) / 10.0;
                    if ( sign[0] == '-' ) x = -x;
                    x = 9./5.*x + 32.0;
                    break;
                case EVAP:
                    // --- convert from 0.1 mm to inches or mm
                    x = atof(value) / 10.0;
                    if ( UnitSystem == US ) x /= MMperINCH;
                    break;
                default: return;
                }
                FileData[p][j] = x;
            }
        }
    }
    
    //=============================================================================
    //char* line
    isGhcndFormat(line)
    //
    //  Input:   line = first line of text from a climate file
    //  Output:  returns TRUE if climate file is in NCDC GHCN Daily format.
    //  Purpose: Checks if a climate file is in the NCDC GHCN Daily format
    //           and determines the position of each climate variable field.
    //
    {
        let i;
        let ptr;
    
        // --- find starting position of the DATE field
        ptr = strstr(line, "DATE");
        if ( ptr == null ) return FALSE;
        FileDateFieldPos = ptr - line;
    
        // --- initialize starting position of each data field
        for ( i = TMIN; i <= WIND; i++) FileFieldPos[i] = -1;
    
        // --- find starting position of each climate variable's data field
        ptr = strstr(line, "TMIN");
        if ( ptr ) FileFieldPos[TMIN] = ptr - line;
        ptr = strstr(line, "TMAX");
        if ( ptr ) FileFieldPos[TMAX] = ptr - line;
        ptr = strstr(line, "EVAP");
        if ( ptr ) FileFieldPos[EVAP] = ptr - line;
    
        // --- WIND can either be daily movement or average speed
        FileWindType = WDMV;
        ptr = strstr(line, "WDMV");
        if ( ptr == null )
        {
            FileWindType = AWND;
            ptr = strstr(line, "AWND");
        }
        if ( ptr ) FileFieldPos[WIND] = ptr - line;
    
        // --- check if at least one climate variable was found
        for (i = TMIN; i <= WIND; i++) if (FileFieldPos[i] >= 0 ) return TRUE;
        return FALSE;
    }
    
    //=============================================================================
    // int* y, int* m
    readGhcndFileLine(y, m)
    //
    //  Input:   none
    //  Output:  y = year
    //           m = month
    //  Purpose: reads year & month from line of a NCDC GHCN Daily climate file.
    //
    {
        let n = sscanf(FileLine[FileDateFieldPos], "%4d%2d", y, m);
        if ( n != 2 )
        {
            y = -99999;
            m = -99999;
        }
    }
    
    //=============================================================================
    
    parseGhcndFileLine()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: parses a line of a NCDC GHCN Daily file for daily
    //           values of max/min temperature, pan evaporation and
    //           wind speed.
    //
    {
        let y, m, d, n, v;
        let x;
    
        // --- parse day of month from date field
        n = sscanf(FileLine[FileDateFieldPos], "%4d%2d%2d", y, m, d);
        if ( n < 3 ) return;
        if ( d < 1 || d > 31 ) return;
    
        // --- parse temperatures (in tenths of deg. C) to deg F
        if ( FileFieldPos[TMAX] >= 0 )
        {
            if ( sscanf(FileLine[FileFieldPos[TMAX]], "%8d", v) > 0 )
            {
                if ( abs(v) < 9999 )
                    FileData[TMAX][d] = v*0.1*9.0/5.0 + 32.0;
            }
        }
        if ( FileFieldPos[TMIN] >= 0 )
        {
            if ( sscanf(FileLine[FileFieldPos[TMIN]], "%8d", v) > 0 )
            {
                if ( abs(v) < 9999 )
                    FileData[TMIN][d] = v*0.1*9.0/5.0 + 32.0;
            }
        }
    
        // -- parse evaporation (in tenths of mm) to user units
        if ( FileFieldPos[EVAP] >= 0 )
        {
            if ( sscanf(FileLine[FileFieldPos[EVAP]], "%8d", v) > 0 )
            {
                if ( abs(v) < 9999 )
                {
                    x = v * 0.1;
                    if ( UnitSystem == US ) x /= MMperINCH;
                    FileData[EVAP][d] = x;
                }
            }
        }
    
        // --- parse wind speed (in km/day for WDMV or tenths of m/s for AWND)
        //     to miles/hr
        if ( FileFieldPos[WIND] >= 0 )
        {
            if ( sscanf(FileLine[FileFieldPos[WIND]], "%8d", v) > 0 )
            {
                if ( abs(v) < 9999 )
                {
                    if ( FileWindType == WDMV ) x = v * 0.62137 / 24.;
                    else x = v * 0.1 / 1000. * 0.62137 * 3600.;
                    FileData[WIND][d] = x;
                }
            }
        }
    }
    
    //=============================================================================
    //double tmin, double tmax
    updateTempMoveAve(tmin, tmax)
    //
    //  Input:   tmin = minimum daily temperature (deg F)
    //           tmax = maximum daily temperature (deg F)
    //  Output:  none
    //  Purpose: updates moving averages of average daily temperature
    //           and daily temperature range stored in structure Tma.
    //
    {
        let ta,               // new day's average temperature (deg F)
               tr;               // new day's temperature range (deg F)
        let    count = Tma.count;
    
        // --- find ta and tr from new day's min and max temperature
        ta = (tmin + tmax) / 2.0;
        tr = Math.abs(tmax - tmin);
    
        // --- if the array used to store previous days' temperatures is full
        if ( count == Tma.maxCount )
        {
            // --- update the moving averages with the new day's value
            Tma.tAve = (Tma.tAve * count + ta - Tma.ta[Tma.front]) / count;
            Tma.tRng = (Tma.tRng * count + tr - Tma.tr[Tma.front]) / count;
    
            // --- replace the values at the front of the moving average window
            Tma.ta[Tma.front] = ta;
            Tma.tr[Tma.front] = tr;
    
            // --- move the front one position forward
            Tma.front++;
            if ( Tma.front == count ) Tma.front = 0;
        }
    
        // --- array of previous day's values not full (at start of simulation)
        else
        {
            // --- find new moving averages by adding new values to previous ones
            Tma.tAve = (Tma.tAve * count + ta) / (count + 1);
            Tma.tRng = (Tma.tRng * count + tr) / (count + 1);
    
            // --- save new day's values
            Tma.ta[Tma.front] = ta;
            Tma.tr[Tma.front] = tr;
    
            // --- increment count and front of moving average window
            Tma.count++;
            Tma.front++;
            if ( Tma.count == Tma.maxCount ) Tma.front = 0;
        }
    }
    
//-----------------------------------------------------------------------------
//   lid.h
//
//   Project: EPA SWMM5
//   Version: 5.1
//   Date:    03/20/14   (Build 5.1.001)
//            03/19/15   (Build 5.1.008)
//            08/01/16   (Build 5.1.011)
//            03/14/17   (Build 5.1.012)
//            05/10/18   (Build 5.1.013)
//   Author:  L. Rossman (US EPA)
//
//   Public interface for LID functions.
//
//   Build 5.1.008:
//   - Support added for Roof Disconnection LID.
//   - Support added for separate routing of LID drain flows.
//   - Detailed LID reporting modified.
//
//   Build 5.1.011:
//   - Water depth replaces moisture content for LID's pavement layer.
//   - Arguments for lidproc_saveResults() modified.
//
//   Build 5.1.012:
//   - Redefined meaning of wasDry in TLidRptFile structure.
//
//   Build 5.1.013:
//   - New member fromPerv added to TLidUnit structure to allow LID
//     units to also treat pervious area runoff.
//   - New members hOpen and hClose addded to TDrainLayer to open/close
//     drain when certain heads are reached.
//   - New member qCurve added to TDrainLayer to allow underdrain flow to
//     be adjusted by a curve of multiplier v. head.
//   - New array drainRmvl added to TLidProc to allow for underdrain
//     pollutant removal values.
//   - New members added to TPavementLayer and TLidUnit to support
//     unclogging permeable pavement at fixed intervals.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Enumerations
//-----------------------------------------------------------------------------
//enum LidTypes {
       BIO_CELL = 0                // bio-retention cell
       RAIN_GARDEN = 1             // rain garden
       GREEN_ROOF = 2              // green roof
       INFIL_TRENCH = 3            // infiltration trench
       POROUS_PAVEMENT = 4         // porous pavement
       RAIN_BARREL = 5             // rain barrel
       VEG_SWALE = 6               // vegetative swale
       ROOF_DISCON = 7            // roof disconnection
    
    //enum TimePeriod {
       PREVIOUS = 0                // previous time period
       CURRENT = 1                // current time period
    
    //-----------------------------------------------------------------------------
    //  Data Structures
    //-----------------------------------------------------------------------------
    MAX_LAYERS = 4
    
    // LID Surface Layer
    class TSurfaceLayer
    {
        constructor(){
            this.thickness;          // depression storage or berm ht. (ft)
            this.voidFrac;           // available fraction of storage volume
            this.roughness;          // surface Mannings n
            this.surfSlope;          // land surface slope (fraction)
            this.sideSlope;          // swale side slope (run/rise)
            this.alpha;              // slope/roughness term in Manning eqn.
            this.canOverflow;        // 1 if immediate outflow of excess water
        }
    }  ;
    
    // LID Pavement Layer
    class TPavementLayer
    {
        constructor(){
            this.thickness;           // layer thickness (ft)
            this.voidFrac;            // void volume / total volume
            this.impervFrac;          // impervious area fraction
            this.kSat;                // permeability (ft/sec)
            this.clogFactor;          // clogging factor
            this.regenDays;           // clogging regeneration interval (days)     //(5.1.013)
            this.regenDegree;         // degree of clogging regeneration           //
        }
    }  ;
    
    // LID Soil Layer
    class TSoilLayer
    {
        constructor(){
            this.thickness;          // layer thickness (ft)
            this.porosity;           // void volume / total volume
            this.fieldCap;           // field capacity
            this.wiltPoint;          // wilting point
            this.suction;            // suction head at wetting front (ft)
            this.kSat;               // saturated hydraulic conductivity (ft/sec)
            this.kSlope;             // slope of log(K) v. moisture content curve
        }
    }  ;
    
    // LID Storage Layer
    class TStorageLayer
    {
        constructor(){
            this.thickness;          // layer thickness (ft)
            this.voidFrac;           // void volume / total volume
            this.kSat;               // saturated hydraulic conductivity (ft/sec)
            this.clogFactor;         // clogging factor
        }
    }  ;
    
    // Underdrain System (part of Storage Layer)
    class TDrainLayer
    {
        constructor(){
            this.coeff;              // underdrain flow coeff. (in/hr or mm/hr)
            this.expon;              // underdrain head exponent (for in or mm)
            this.offset;             // offset height of underdrain (ft)
            this.delay;              // rain barrel drain delay time (sec)
            this.hOpen;              // head when drain opens (ft)                //(5.1.013)
            this.hClose;             // head when drain closes (ft)               //
            this.qCurve;             // curve controlling flow rate (optional)    //
        }
    }  ;
    
    // Drainage Mat Layer (for green roofs)
    class TDrainMatLayer
    {
        constructor(){
            this.thickness;          // layer thickness (ft)
            this.voidFrac;           // void volume / total volume
            this.roughness;          // Mannings n for green roof drainage mats
            this.alpha;              // slope/roughness term in Manning equation
        }
    }  ;
    
    // LID Process - generic LID design per unit of area
    class TLidProc
    {
        constructor(){
            this.ID;            // identifying name
            this.lidType;       // type of LID
            this.surface = new TSurfaceLayer();       // surface layer parameters
            this.pavement = new TPavementLayer();      // pavement layer parameters
            this.soil = new TSoilLayer();          // soil layer parameters
            this.storage = new TStorageLayer();       // storage layer parameters
            this.drain = new TDrainLayer();         // underdrain system parameters
            this.drainMat = new TDrainMatLayer();      // drainage mat layer
            this.drainRmvl = [];     // underdrain pollutant removals             //(5.1.013)
        }
    }  ;
    
    // Water Balance Statistics
    class TWaterBalance
    {
        constructor(){
            this.inflow;        // total inflow (ft)
            this.evap;          // total evaporation (ft)
            this.infil;         // total infiltration (ft)
            this.surfFlow;      // total surface runoff (ft)
            this.drainFlow;     // total underdrain flow (ft)
            this.initVol;       // initial stored volume (ft)
            this.finalVol;      // final stored volume (ft)
        }
    }  ;
    
    // LID Report File
    class TLidRptFile
    {
        constructor(){
            this.file = new FILE();               // file pointer
            this.wasDry;             // number of successive dry periods
            this.results;//[256];       // results for current time period
        }
    }   ;
    
    // LID Unit - specific LID process applied over a given area
    class TLidUnit
    {
        constructor(){
            this.lidIndex;       // index of LID process
            this.number;         // number of replicate units
            this.area;           // area of single replicate unit (ft2)
            this.fullWidth;      // full top width of single unit (ft)
            this.botWidth;       // bottom width of single unit (ft)
            this.initSat;        // initial saturation of soil & storage layers
            this.fromImperv;     // fraction of impervious area runoff treated
            this.fromPerv;       // fraction of pervious area runoff treated       //(5.1.013)
            this.toPerv;         // 1 if outflow sent to pervious area; 0 if not
            this.drainSubcatch;  // subcatchment receiving drain flow
            this.drainNode;      // node receiving drain flow
            this.rptFile = new TLidRptFile();    // pointer to detailed report file
        
            this.soilInfil = new TGrnAmpt();      // infil. object for biocell soil layer
            this.surfaceDepth;   // depth of ponded water on surface layer (ft)
            this.paveDepth;      // depth of water in porous pavement layer
            this.soilMoisture;   // moisture content of biocell soil layer
            this.storageDepth;   // depth of water in storage layer (ft)
        
            // net inflow - outflow from previous time step for each LID layer (ft/s)
            this.oldFluxRates = new Array(MAX_LAYERS);
        
            this.dryTime;        // time since last rainfall (sec)
            this.oldDrainFlow;   // previous drain flow (cfs)
            this.newDrainFlow;   // current drain flow (cfs)
            this.volTreated;     // total volume treated (ft)                      //(5.1.013)
            this.nextRegenDay;   // next day when unit regenerated                 //
            this.waterBalance = new TWaterBalance();     // water balance quantites
        }
    }  ;
    
    
    //-----------------------------------------------------------------------------
    //   lid.c
    //
    //   Project:  EPA SWMM5
    //   Version:  5.1
    //   Date:     03/20/14   (Build 5.1.001)
    //             05/19/14   (Build 5.1.006)
    //             09/15/14   (Build 5.1.007)
    //             03/19/15   (Build 5.1.008)
    //             04/30/15   (Build 5.1.009)
    //             08/05/15   (Build 5.1.010)
    //             08/01/16   (Build 5.1.011)
    //             03/14/17   (Build 5.1.012)
    //             05/10/18   (Build 5.1.013)
    //             03/01/20   (Build 5.1.014)
    //             04/01/20   (Build 5.1.015)
    //   Author:   L. Rossman (US EPA)
    //
    //   This module handles all data processing involving LID (Low Impact
    //   Development) practices used to treat runoff for individual subcatchments
    //   within a project. The actual computation of LID performance is made by
    //   functions within the lidproc.c module. See LidTypes below for the types
    //   of LIDs that can be modeled.
    //
    //   An LID process is described by the TLidProc data structure and consists of
    //   size-independent design data for the different vertical layers that make
    //   up a specific type of LID. The collection of these LID process designs is
    //   stored in the LidProcs array.
    //
    //   When a member of LidProcs is to be deployed in a particular subcatchment,
    //   its sizing and treatment data are stored in a TLidUnit data structure.
    //   The collection of all TLidUnits deployed in a subcatchment is held in a
    //   TLidGroup list data structure. The LidGroups array contains a TLidGroup
    //   list for each subcatchment in the project.
    //
    //   During a runoff time step, each subcatchment calls the lid_getRunoff()
    //   to compute flux rates and a water balance through each layer
    //   of each LID unit in the subcatchment. The resulting outflows (runoff,
    //   drain flow, evaporation and infiltration) are added to those computed
    //   for the non-LID portion of the subcatchment.
    //
    //   An option exists for the detailed time series of flux rates and storage
    //   levels for a specific LID unit to be written to a text file named by the
    //   user for viewing outside of the SWMM program.
    //
    //   Build 5.1.008:
    //   - More input error reporting added.
    //   - Rooftop Disconnection added to the types of LIDs.
    //   - LID drain flows are now tracked separately.
    //   - LID drain flows can now be routed to separate outlets.
    //   - Check added to insure LID flows not returned to nonexistent pervious area.
    //
    //   Build 5.1.009:
    //   - Fixed bug where LID's could return outflow to non-LID area when LIDs
    //     make up entire subcatchment.
    //
    //   Build 5.1.010:
    //   - Support for new Modified Green Ampt infiltration model added.
    //   - Imported variable HasWetLids now properly initialized.
    //   - Initial state of reporting (lidUnit.rptFile.wasDry) changed to
    //     prevent duplicate printing of first line of detailed report file.
    //
    //   Build 5.1.011:
    //   - The top of the storage layer is no longer used as a limit for an
    //     underdrain offset thus allowing upturned drains to be modeled.
    //   - Column headings for the detailed LID report file were modified.
    //
    //   Build 5.1.012:
    //   - Redefined initialization of wasDry for LID reporting.
    //
    //   Build 5.1.013:
    //   - Support added for LID units treating pervious area runoff.
    //   - Support added for open/closed head levels and multiplier v. head 
    //     control curve for underdrain flow.
    //   - Support added for unclogging permeable pavement at fixed intervals.
    //   - Support added for pollutant removal in underdrain flow.
    //
    //   Build 5.1.014:
    //   - Fixed bug in creating LidProcs when there are no subcatchments.
    //   - Fixed bug in adding underdrain pollutant loads to mass balances.
    //
    //   Build 5.1.015:
    //   - Support added for mutiple infiltration methods within a project.
    //-----------------------------------------------------------------------------
    
    
    ERR_PAVE_LAYER = " - check pavement layer parameters"
    ERR_SOIL_LAYER = " - check soil layer parameters"
    ERR_STOR_LAYER = " - check storage layer parameters"
    ERR_SWALE_SURF = " - check swale surface parameters"
    ERR_GREEN_AMPT = " - check subcatchment Green-Ampt parameters"
    ERR_DRAIN_OFFSET = " - drain offset exceeds storage height"
    ERR_DRAIN_HEADS = " - invalid drain open/closed heads"                   //(5.1.013)
    ERR_SWALE_WIDTH = " - invalid swale width"
    
    //-----------------------------------------------------------------------------
    //  Enumerations
    //-----------------------------------------------------------------------------
    //enum LidLayerTypes {
       SURF = 0                    // surface layer
       SOIL = 1                    // soil layer
       STOR = 2                    // storage layer
       PAVE = 3                    // pavement layer
       DRAINMAT = 4                // drainage mat layer
       DRAIN = 5                   // underdrain system
       REMOVALS = 6               // pollutant removals                             //(5.1.013)
    
    //// Note: DRAINMAT must be placed before DRAIN so the two keywords can
    ///        be distinguished from one another when parsing a line of input. 
    
    LidLayerWords =
        ["SURFACE", "SOIL", "STORAGE", "PAVEMENT", "DRAINMAT", "DRAIN",
         "REMOVALS", null];                                                        //(5.1.013)
    
    LidTypeWords =
        ["BC",                   //bio-retention cell
         "RG",                   //rain garden
         "GR",                   //green roof
         "IT",                   //infiltration trench
         "PP",                   //porous pavement
         "RB",                   //rain barrel
         "VS",                   //vegetative swale
         "RD",                   //rooftop disconnection
         null];
    
    //-----------------------------------------------------------------------------
    //  Data Structures
    //-----------------------------------------------------------------------------
    
    // LID List - list of LID units contained in an LID group
    class  LidList
    {
        constructor(){
            this.lidUnit = new TLidUnit();     // TLidUnit* ptr. to a LID unit
            this.nextLidUnit;                  // LidList*  
        }
    };
    
    class  TLidList
    {
        constructor(){
            this.lidUnit = new TLidUnit();     // TLidUnit* ptr. to a LID unit
            this.nextLidUnit;                  // LidList*  
        }
    };
    
    // LID Group - collection of LID units applied to a specific subcatchment
    class LidGroup
    {
        constructor(){
            this.pervArea;      // amount of pervious area in group (ft2)
            this.flowToPerv;    // total flow sent to pervious area (cfs)
            this.oldDrainFlow;  // total drain flow in previous period (cfs)
            this.newDrainFlow;  // total drain flow in current period (cfs)
            this.lidList;       // TLidList* list of LID units in the group
        }
    };
    
    class TLidGroup
    {
        constructor(){
            this.pervArea;      // amount of pervious area in group (ft2)
            this.flowToPerv;    // total flow sent to pervious area (cfs)
            this.oldDrainFlow;  // total drain flow in previous period (cfs)
            this.newDrainFlow;  // total drain flow in current period (cfs)
            this.lidList;       // TLidList* list of LID units in the group
        }
    };
    
    //-----------------------------------------------------------------------------
    //  Shared Variables
    //-----------------------------------------------------------------------------
    LidProcs = [];            // TLidProc*  array of LID processes
    LidCount;            // number of LID processes
    LidGroups = [];           // TLidGroup* array of LID process groups
    GroupCount;          // number of LID groups (subcatchments)
    
    EvapRate;            // evaporation rate (ft/s)
    NativeInfil;         // native soil infil. rate (ft/s)
    MaxNativeInfil;      // native soil infil. rate limit (ft/s)
    
    //-----------------------------------------------------------------------------
    //  Imported Variables (from SUBCATCH.C)
    //-----------------------------------------------------------------------------
    // Volumes (ft3) for a subcatchment over a time step 
    Vevap;               // evaporation
    Vpevap;              // pervious area evaporation
    Vinfil;              // non-LID infiltration
    VlidInfil;           // infiltration from LID units
    VlidIn;              // impervious area flow to LID units
    VlidOut;             // surface outflow from LID units
    VlidDrain;           // drain outflow from LID units
    VlidReturn;          // LID outflow returned to pervious area
    HasWetLids;          // true if any LIDs are wet
                                           // (from RUNOFF.C)
    
    //-----------------------------------------------------------------------------
    //  External Functions (prototyped in lid.h)
    //-----------------------------------------------------------------------------
    //  lid_create               called by createObjects in project.c
    //  lid_delete               called by deleteObjects in project.c
    //  lid_validate             called by project_validate
    //  lid_initState            called by project_init
    
    //  lid_readProcParams       called by parseLine in input.c
    //  lid_readGroupParams      called by parseLine in input.c
    
    //  lid_setOldGroupState     called by subcatch_setOldState
    //  lid_setReturnQual        called by findLidLoads in surfqual.c
    //  lid_getReturnQual        called by subcatch_getRunon
    
    //  lid_getPervArea          called by subcatch_getFracPerv
    //  lid_getFlowToPerv        called by subcatch_getRunon
    //  lid_getSurfaceDepth      called by subcatch_getDepth
    //  lid_getDepthOnPavement   called by sweptSurfacesDry in subcatch.c
    //  lid_getStoredVolume      called by subcatch_getStorage
    //  lid_getRunon             called by subcatch_getRunon
    //  lid_getRunoff            called by subcatch_getRunoff
    
    //  lid_addDrainRunon        called by subcatch_getRunon
    //  lid_addDrainLoads        called by surfqual_getWashoff
    //  lid_addDrainInflow       called by addLidDrainInflows in routing.c
    
    //  lid_writeSummary         called by inputrpt_writeInput
    //  lid_writeWaterBalance    called by statsrpt_writeReport
    
    //=============================================================================
    // int lidCount, int subcatchCount
    lid_create(lidCount, subcatchCount)
    //
    //  Purpose: creates an array of LID objects.
    //  Input:   n = number of LID processes
    //  Output:  none
    //
    {
        let j;
    
        //... assign null values to LID arrays
        LidProcs = [];
        LidGroups = [];
        LidCount = lidCount;
    
        //... create LID groups
        GroupCount = subcatchCount;
        if ( GroupCount > 0 )
        {
            //LidGroups = (TLidGroup *) calloc(GroupCount, sizeof(TLidGroup));
            for(let i = 0; i < GroupCount; i++){LidGroups.push(new TLidGroup())}
            if ( LidGroups.length == 0 )
            {
                ErrorCode = ERR_MEMORY;
                return;
            }
        }
    
        //... initialize LID groups
        //for (j = 0; j < GroupCount; j++) LidGroups[j] = null;
        
        //... create LID objects
        if ( LidCount == 0 ) return;
        //LidProcs = (TLidProc *) calloc(LidCount, sizeof(TLidProc));
        for(let i = 0; i < LidCount; i++){LidProcs.push(new TLidProc())}
        if ( LidProcs == null )
        {
            ErrorCode = ERR_MEMORY;
            return;
        }
    
        //... initialize LID objects
        for (j = 0; j < LidCount; j++)
        {
            LidProcs[j].lidType = -1;
            LidProcs[j].surface.thickness = 0.0;
            LidProcs[j].surface.voidFrac = 1.0;
            LidProcs[j].surface.roughness = 0.0;
            LidProcs[j].surface.surfSlope = 0.0;
            LidProcs[j].pavement.thickness = 0.0;
            LidProcs[j].soil.thickness = 0.0;
            LidProcs[j].storage.thickness = 0.0;
            LidProcs[j].storage.kSat = 0.0;
            LidProcs[j].drain.coeff = 0.0;
            LidProcs[j].drain.offset = 0.0;
            LidProcs[j].drainMat.thickness = 0.0;
            LidProcs[j].drainMat.roughness = 0.0;
            LidProcs[j].drainRmvl = null;                                          //(5.1.013)
            LidProcs[j].drainRmvl =                                      //
                                    calloc(Nobjects[POLLUT], sizeof(double));      //
            if (LidProcs[j].drainRmvl == null)                                     //
            {                                                                      //
                ErrorCode = ERR_MEMORY;                                            //
                return;                                                            //
            }                                                                      // 
        }
    }
    
    //=============================================================================
    
    lid_delete()
    //
    //  Purpose: deletes all LID objects
    //  Input:   none
    //  Output:  none
    //
    {
        let j;
        for (j = 0; j < GroupCount; j++) freeLidGroup(j);
        FREE(LidGroups);
        for (j = 0; j < LidCount; j++) FREE(LidProcs[j].drainRmvl);                //(5.1.013)
        FREE(LidProcs);
        GroupCount = 0;
        LidCount = 0;
    }
    
    //=============================================================================
    // int j
    freeLidGroup(j)
    //
    //  Purpose: frees all LID units associated with a subcatchment.
    //  Input:   j = group (or subcatchment) index
    //  Output:  none
    //
    {
        let  lidGroup = LidGroups[j];
        let  lidList;
        let  lidUnit;
        let  nextLidUnit;
    
        if ( lidGroup == null ) return;
        lidList = lidGroup.lidList;
        while (lidList)
        {
            lidUnit = lidList.lidUnit;
            if ( lidUnit.rptFile )
            {
                if ( lidUnit.rptFile.file ) fclose(lidUnit.rptFile.file);
                lidUnit.rptFile = null;
            }
            nextLidUnit = lidList.nextLidUnit;
            
            lidUnit = null;
            lidList = null;
            lidList = nextLidUnit;
        }
        lidGroup = [];
        LidGroups[j] = null;
    }
    
    //=============================================================================
    // char* toks[], int ntoks
    lid_readProcParams(toks, ntoks)
    //
    //  Purpose: reads LID process information from line of input data file
    //  Input:   toks = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //
    //  Format for first line that defines a LID process is:
    //    LID_ID  LID_Type
    //
    //  Followed by some combination of lines below depending on LID_Type:
    //    LID_ID  SURFACE   <parameters>
    //    LID_ID  PAVEMENT  <parameters>
    //    LID_ID  SOIL      <parameters>
    //    LID_ID  STORAGE   <parameters>
    //    LID_ID  DRAIN     <parameters>
    //    LID_ID  DRAINMAT  <parameters>
    //    LID_ID  REMOVALS  <parameters>                                           //(5.1.013)
    //
    {
        let j, m;
    
        // --- check for minimum number of tokens
        if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
    
        // --- check that LID exists in database
        j = project_findObject(LID, toks[0]);
        if ( j < 0 ) return error_setInpError(ERR_NAME, toks[0]);
    
        // --- assign ID if not done yet
        if ( LidProcs[j].ID == null )
            LidProcs[j].ID = project_findID(LID, toks[0]);
    
        // --- check if second token is the type of LID
        m = findmatch(toks[1], LidTypeWords);
        if ( m >= 0 )
        {
            LidProcs[j].lidType = m;
            return 0;
        }
    
        // --- check if second token is name of LID layer
        else m = findmatch(toks[1], LidLayerWords);
    
        // --- read input parameters for the identified layer
        switch (m)
        {
        case SURF:  return readSurfaceData(j, toks, ntoks);
        case SOIL:  return readSoilData(j, toks, ntoks);
        case STOR:  return readStorageData(j, toks, ntoks);
        case PAVE:  return readPavementData(j, toks, ntoks);
        case DRAIN: return readDrainData(j, toks, ntoks);
        case DRAINMAT: return readDrainMatData(j, toks, ntoks);
        case REMOVALS: return readRemovalsData(j, toks, ntoks);                    //(5.1.013)
        }
        return error_setInpError(ERR_KEYWORD, toks[1]);
    }
    
    //=============================================================================
    // char* toks[], int ntoks
    lid_readGroupParams(toks, ntoks)
    //
    //  Purpose: reads input data for a LID unit placed in a subcatchment.
    //  Input:   toks = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //
    //  Format of input data line is:
    //    Subcatch_ID  LID_ID  Number  Area  Width  InitSat  FromImp  ToPerv
    //                                              (RptFile  DrainTo  FromPerv)   //(5.1.013)
    //  where:
    //    Subcatch_ID    = name of subcatchment
    //    LID_ID         = name of LID process
    //    Number     (n) = number of replicate units
    //    Area    (x[0]) = area of each unit
    //    Width   (x[1]) = outflow width of each unit
    //    InitSat (x[2]) = % that LID is initially saturated
    //    FromImp (x[3]) = % of impervious runoff sent to LID
    //    ToPerv  (x[4]) = 1 if outflow goes to pervious sub-area; 0 if not
    //    RptFile        = name of detailed results file (optional)
    //    DrainTo        = name of subcatch/node for drain flow (optional)
    //    FromPerv (x[5]) = % of pervious runoff sent to LID                       //(5.1.013)
    //
    {
        let        i, j, k, n;
        let     x = new Array(6);                                                           //(5.1.013)
        let      fname = null;
        let        drainSubcatch = -1, drainNode = -1;
    
        // return facilitators
        let returnObj;
        let returnVal;
    
        //... check for valid number of input tokens
        if ( ntoks < 8 ) return error_setInpError(ERR_ITEMS, "");
    
        //... find subcatchment
        j = project_findObject(SUBCATCH, toks[0]);
        if ( j < 0 ) return error_setInpError(ERR_NAME, toks[0]);
    
        //... find LID process in list of LID processes
        k = project_findObject(LID, toks[1]);
        if ( k < 0 ) return error_setInpError(ERR_NAME, toks[1]);
    
        //... get number of replicates
        n = parseInt(toks[2]);
        if ( n < 0 ) return error_setInpError(ERR_NUMBER, toks[2]);
        if ( n == 0 ) return 0;
    
        //... convert next 4 tokens to doubles
        for (i = 3; i <= 7; i++)
        {
            ////////////////////////////////////
            returnObj = {y: x[i-3]}
            returnVal = getDouble(toks[i], returnObj);
            x[i-3] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[i-3] < 0.0 )
            //if ( null == (x[i-3] = getDouble(toks[i])) || x[i-3] < 0.0 )
                return error_setInpError(ERR_NUMBER, toks[i]);
        }
    
        //... check for valid percentages on tokens 5 & 6 (x[2] & x[3])
        for (i = 2; i <= 3; i++) if ( x[i] > 100.0 )
            return error_setInpError(ERR_NUMBER, toks[i+3]);
    
        //... read optional report file name
        if ( ntoks >= 9 && strcmp(toks[8], "*") != 0 ) fname = toks[8];
    
        //... read optional underdrain outlet
        if ( ntoks >= 10 && strcmp(toks[9], "*") != 0 )
        {
            drainSubcatch = project_findObject(SUBCATCH, toks[9]);
            if ( drainSubcatch < 0 )
            {
                drainNode = project_findObject(NODE, toks[9]);
                if ( drainNode < 0 ) return error_setInpError(ERR_NAME, toks[9]);
            }
        }
    
        //... read percent of pervious area treated by LID unit                    //(5.1.013)
        x[5] = 0.0;                                                                //
        if (ntoks >= 11)                                                           //
        {                                                                          //
            ////////////////////////////////////
            returnObj = {y: x[5]}
            returnVal = getDouble(toks[10], returnObj);
            x[5] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[5] < 0.0 || x[5] > 100.0 )
            //if (null == (x[5] = getDouble(toks[10])) || x[5] < 0.0 || x[5] > 100.0)         //
                return error_setInpError(ERR_NUMBER, toks[10]);                    //
        }                                                                          //
    
        //... create a new LID unit and add it to the subcatchment's LID group
        return addLidUnit(j, k, n, x, fname, drainSubcatch, drainNode);
    }
    
    //=============================================================================
    // int j, int k, int n, double x[], char* fname,
    //    int drainSubcatch, int drainNode
    addLidUnit(j, k, n, x, fname, drainSubcatch, drainNode)
    //
    //  Purpose: adds an LID unit to a subcatchment's LID group.
    //  Input:   j = subcatchment index
    //           k = LID control index
    //           n = number of replicate units
    //           x = LID unit's parameters
    //           fname = name of detailed performance report file
    //           drainSubcatch = index of subcatchment receiving underdrain flow
    //           drainNode = index of node receiving underdrain flow
    //  Output:  returns an error code
    //
    {
        let  lidUnit = [];
        let  lidList = [];
        let lidGroup;
    
        //... create a LID group (pointer to an LidGroup struct)
        //    if one doesn't already exist
        lidGroup = LidGroups[j];
        if ( !lidGroup )
        {
            //lidGroup = (struct LidGroup *) malloc(sizeof(struct LidGroup));
            lidGroup = new LidGroup();
    
            if ( !lidGroup ) return error_setInpError(ERR_MEMORY, "");
            lidGroup.lidList = null;
            LidGroups[j] = lidGroup;
        }
    
        //... create a new LID unit to add to the group
        //lidUnit = (TLidUnit *) malloc(sizeof(TLidUnit));
        lidUnit = new TLidUnit();
        if ( !lidUnit ) return error_setInpError(ERR_MEMORY, "");
        lidUnit.rptFile = null;
    
        //... add the LID unit to the group
        //lidList = (TLidList *) malloc(sizeof(TLidList));
        lidList = new TLidList();
        if ( !lidList )
        {
            //free(lidUnit);
            lidUnit = null;
            return error_setInpError(ERR_MEMORY, "");
        }
        lidList.lidUnit = lidUnit;
        lidList.nextLidUnit = lidGroup.lidList;
        lidGroup.lidList = lidList;
    
        //... assign parameter values to LID unit
        lidUnit.lidIndex     = k;
        lidUnit.number       = n;
        lidUnit.area         = x[0] / SQR(UCF(LENGTH));
        lidUnit.fullWidth    = x[1] / UCF(LENGTH);
        lidUnit.initSat      = x[2] / 100.0;
        lidUnit.fromImperv   = x[3] / 100.0;
        lidUnit.toPerv       = (x[4] > 0.0);
        lidUnit.fromPerv     = x[5] / 100.0;                                      //(5.1.013)
        lidUnit.drainSubcatch = drainSubcatch;
        lidUnit.drainNode     = drainNode;
    
        //... open report file if it was supplied
        if ( fname != null )
        {
            if ( !createLidRptFile(lidUnit, fname) ) 
                return error_setInpError(ERR_RPT_FILE, fname);
        }
        return 0;
    }
    
    //=============================================================================
    // TLidUnit* lidUnit, char* fname
    createLidRptFile(lidUnit, fname)
    {
        let rptFile;
        
        //rptFile = (TLidRptFile *) malloc(sizeof(TLidRptFile));
        rptFile = new TLidRptFile();
        if ( rptFile == null ) return 0;
        lidUnit.rptFile = rptFile;
        rptFile.contents = fopen(fname, "wt");
        if ( rptFile.file == null ) return 0;
        return 1;
    }
    
    //=============================================================================
    // int j, char* toks[], int ntoks
    readSurfaceData(j, toks, ntoks)
    //
    //  Purpose: reads surface layer data for a LID process from line of input
    //           data file
    //  Input:   j = LID process index 
    //           toks = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //
    //  Format of data is:
    //  LID_ID  SURFACE  StorageHt  VegVolFrac  Roughness  SurfSlope  SideSlope  DamHt
    //
    {
        let    i;
        let x = new Array(5);
    
        if ( ntoks < 7 ) return error_setInpError(ERR_ITEMS, "");
        for (i = 2; i < 7; i++)
        {
            ////////////////////////////////////
            returnObj = {y: x[i-2]}
            returnVal = getDouble(toks[i], returnObj);
            x[i-2] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[i-2] < 0.0 )
            //if ( null == (x[i-2] = getDouble(toks[i])) || x[i-2] < 0.0 )
                return error_setInpError(ERR_NUMBER, toks[i]);
        }
        if ( x[1] >= 1.0 ) return error_setInpError(ERR_NUMBER, toks[3]);           
        if ( x[0] == 0.0 ) x[1] = 0.0;
    
        LidProcs[j].surface.thickness     = x[0] / UCF(RAINDEPTH);
        LidProcs[j].surface.voidFrac      = 1.0 - x[1];
        LidProcs[j].surface.roughness     = x[2];
        LidProcs[j].surface.surfSlope     = x[3] / 100.0;
        LidProcs[j].surface.sideSlope     = x[4];
        return 0;
    }
    
    //=============================================================================
    // int j, char* toks[], int ntoks
    readPavementData(j, toks, ntoks)
    //
    //  Purpose: reads pavement layer data for a LID process from line of input
    //           data file
    //  Input:   j = LID process index 
    //           toks = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //
    //  Format of data is:
    //    LID_ID PAVEMENT  Thickness  VoidRatio  FracImperv  Permeability  ClogFactor
    //                                                        (RegenDays RegenDegree) //(5.1.013)
    //
    {
        let    i;
        let x = new Array(7);                                                               //(5.1.013)
    
        // return facilitators
        let returnObj;
        let returnVal;
    
        if ( ntoks < 7 ) return error_setInpError(ERR_ITEMS, "");
        for (i = 2; i < 7; i++)
        {
            ////////////////////////////////////
            returnObj = {y: x[i-2]}
            returnVal = getDouble(toks[i], returnObj);
            x[i-2] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[i-2] < 0.0 )
            //if ( null == (x[i-2] = getDouble(toks[i])) || x[i-2] < 0.0 )
                return error_setInpError(ERR_NUMBER, toks[i]);
        }
    
        // ... read optional clogging regeneration properties                      //(5.1.013)
        x[5] = 0.0;                                                                //
        if (ntoks > 7)                                                             //
        {                
            ////////////////////////////////////
            returnObj = {y: x[5]}
            returnVal = getDouble(toks[7], returnObj);
            x[5] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[5] < 0.0 )                                                          //
            //if (null == (x[5] = getDouble(toks[7])) || x[5] < 0.0)                          //
                return error_setInpError(ERR_NUMBER, toks[7]);                     //
        }                                                                          //
        x[6] = 0.0;                                                                //
        if (ntoks > 8)                                                             //
        {                                                                          //
            ////////////////////////////////////
            returnObj = {y: x[6]}
            returnVal = getDouble(toks[8], returnObj);
            x[6] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[6] < 0.0 || x[6] > 1.0 )
            //if (null == (x[6] = getDouble(toks[8])) || x[6] < 0.0 || x[6] > 1.0)            //
                return error_setInpError(ERR_NUMBER, toks[8]);                     //
        }                                                                          //
    
        //... convert void ratio to void fraction
        x[1] = x[1]/(x[1] + 1.0);
    
        LidProcs[j].pavement.thickness    = x[0] / UCF(RAINDEPTH);
        LidProcs[j].pavement.voidFrac     = x[1];
        LidProcs[j].pavement.impervFrac   = x[2];
        LidProcs[j].pavement.kSat         = x[3] / UCF(RAINFALL);
        LidProcs[j].pavement.clogFactor   = x[4];
        LidProcs[j].pavement.regenDays    = x[5];                                  //(5.1.013)
        LidProcs[j].pavement.regenDegree  = x[6];                                  //
        return 0;
    }
    
    //=============================================================================
    // int j, char* toks[], int ntoks
    readSoilData(j, toks, ntoks)
    //
    //  Purpose: reads soil layer data for a LID process from line of input
    //           data file
    //  Input:   j = LID process index 
    //           toks = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //
    //  Format of data is:
    //    LID_ID  SOIL  Thickness  Porosity  FieldCap  WiltPt Ksat  Kslope  Suction
    //
    {
        let    i;
        let x = new Array(7);
    
        //return facilitators
        let returnObj;
        let returnVal;
    
        if ( ntoks < 9 ) return error_setInpError(ERR_ITEMS, "");
        for (i = 2; i < 9; i++)
        {
            ////////////////////////////////////
            returnObj = {y: x[i-2]}
            returnVal = getDouble(toks[i], returnObj);
            x[i-2] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[i-2] < 0.0 )
            //if ( null == (x[i-2] = getDouble(toks[i])) || x[i-2] < 0.0 )
                return error_setInpError(ERR_NUMBER, toks[i]);
        }
        LidProcs[j].soil.thickness = x[0] / UCF(RAINDEPTH);
        LidProcs[j].soil.porosity  = x[1];
        LidProcs[j].soil.fieldCap  = x[2];
        LidProcs[j].soil.wiltPoint = x[3];
        LidProcs[j].soil.kSat      = x[4] / UCF(RAINFALL);
        LidProcs[j].soil.kSlope    = x[5];
        LidProcs[j].soil.suction   = x[6] / UCF(RAINDEPTH);
        return 0;
    }
    
    //=============================================================================
    // int j, char* toks[], int ntoks
    readStorageData(j, toks, ntoks)
    //
    //  Purpose: reads drainage layer data for a LID process from line of input
    //           data file
    //  Input:   j = LID process index 
    //           toks = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //
    //  Format of data is:
    //    LID_ID STORAGE  Thickness  VoidRatio  Ksat  ClogFactor 
    //
    {
        let    i;
        let x = new Array(6);
    
        // return facilitators
        let returnObj;
        let returnVal;
    
        //... read numerical parameters
        if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");
        for (i = 2; i < 6; i++)
        {
            ////////////////////////////////////
            returnObj = {y: x[i-2]}
            returnVal = getDouble(toks[i], returnObj);
            x[i-2] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[i-2] < 0.0 )
            //if ( null == (x[i-2] = getDouble(toks[i]))  || x[i-2] < 0.0 )
                return error_setInpError(ERR_NUMBER, toks[i]);
        }
    
        //... convert void ratio to void fraction
        x[1] = x[1]/(x[1] + 1.0);
    
        //... save parameters to LID storage layer structure
        LidProcs[j].storage.thickness   = x[0] / UCF(RAINDEPTH);
        LidProcs[j].storage.voidFrac    = x[1];
        LidProcs[j].storage.kSat        = x[2] / UCF(RAINFALL);
        LidProcs[j].storage.clogFactor  = x[3];
        return 0;
    }
     
    //=============================================================================
    // int j, char* toks[], int ntoks
    readDrainData(j, toks, ntoks)
    //
    //  Purpose: reads underdrain data for a LID process from line of input
    //           data file
    //  Input:   j = LID process index 
    //           toks = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //
    //  Format of data is:
    //    LID_ID DRAIN  coeff  expon  offset  delay hOpen hClose curve             //(5.1.013)
    //
    {
        let    i;
        let x = new Array(6);                                                               //(5.1.013)
    
        // return facilitators
        let returnObj;
        let returnVal;
    
        //... read numerical parameters
        if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");
        for (i = 0; i < 6; i++) x[i] = 0.0;                                        //(5.1.013)
        for (i = 2; i < 8; i++)                                                    //
        {
            ////////////////////////////////////
            returnObj = {y: x[i-2]}
            returnVal = getDouble(toks[i], returnObj);
            x[i-2] = returnObj.y;
            ////////////////////////////////////
            if( ntoks > i && !returnVal || x[i-2] < 0.0 )
            //if ( ntoks > i && null == (x[i-2] = getDouble(toks[i])) || x[i-2] < 0.0 )      //(5.1.013)
                return error_setInpError(ERR_NUMBER, toks[i]);
        }
    
        i = -1;                                                                    //(5.1.013)
        if ( ntoks >= 9 )                                                          //
        {                                                                          //
            i = project_findObject(CURVE, toks[8]);                                //
            if (i < 0) return error_setInpError(ERR_NAME, toks[8]);                //
        }                                                                          //
    
        //... save parameters to LID drain layer structure
        LidProcs[j].drain.coeff  = x[0];
        LidProcs[j].drain.expon  = x[1];
        LidProcs[j].drain.offset = x[2] / UCF(RAINDEPTH);
        LidProcs[j].drain.delay  = x[3] * 3600.0;
        LidProcs[j].drain.hOpen  = x[4] / UCF(RAINDEPTH);                          //(5.1.013)
        LidProcs[j].drain.hClose = x[5] / UCF(RAINDEPTH);                          //
        LidProcs[j].drain.qCurve = i;                                              //
        return 0;
    }
     
    //=============================================================================
    // int j, char* toks[], int ntoks
    readDrainMatData(j, toks, ntoks)
    //
    //  Purpose: reads drainage mat data for a LID process from line of input
    //           data file
    //  Input:   j = LID process index 
    //           toks = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //
    //  Format of data is:
    //    LID_ID DRAINMAT  thickness  voidRatio  roughness
    //
    {
        let    i;
        let x = new Array(3);
    
        // return facilitators
        let returnObj;
        let returnVal;
    
        //... read numerical parameters
        if ( ntoks < 5 ) return error_setInpError(ERR_ITEMS, "");
        if ( LidProcs[j].lidType != GREEN_ROOF ) return 0;
        for (i = 2; i < 5; i++)
        {
            ////////////////////////////////////
            returnObj = {y: x[i-2]}
            returnVal = getDouble(toks[i], returnObj);
            x[i-2] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[i-2] < 0.0 )
            //if ( null == (x[i-2] = getDouble(toks[i])) || x[i-2] < 0.0 )
                return error_setInpError(ERR_NUMBER, toks[i]);
        }
    
        //... save parameters to LID drain layer structure
        LidProcs[j].drainMat.thickness = x[0] / UCF(RAINDEPTH);;
        LidProcs[j].drainMat.voidFrac  = x[1];
        LidProcs[j].drainMat.roughness = x[2];
        return 0;
    }
    
    //=============================================================================
    
    ////  This was added to release 5.1.013.  ////                        //(5.1.013)
    // int j, char* toks[], int ntoks
    readRemovalsData(j, toks, ntoks)
    //
    //  Purpose: reads pollutant removal data for a LID process from line of input
    //           data file
    //  Input:   j = LID process index 
    //           toks = array of string tokens
    //           ntoks = number of tokens
    //  Output:  returns error code
    //
    //  Format of data is:
    //    LID_ID REMOVALS  pollut1  %removal1  pollut2  %removal2  ...
    //
    {
        let    i = 2;
        let    p;
        let rmvl;
    
        // return facilitators
        let returnObj;
        let returnVal;
    
        //... start with 3rd token
        if (ntoks < 4) return error_setInpError(ERR_ITEMS, "");
        while (ntoks > i)
        {
            //... find pollutant index from its name
            p = project_findObject(POLLUT, toks[i]);
            if (p < 0) return error_setInpError(ERR_NAME, toks[i]);
    
            //... check that a next token exists
            i++;
            if (ntoks == i) return error_setInpError(ERR_ITEMS, "");
    
            //... get the % removal value from the next token
            ////////////////////////////////////
            returnObj = {y: rmvl}
            returnVal = getDouble(toks[i], returnObj);
            rmvl = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || rmvl < 0.0 || rmvl > 100.0 )
            //if (!(rmvl = getDouble(toks[i])) || rmvl < 0.0 || rmvl > 100.0)
                return error_setInpError(ERR_NUMBER, toks[i]);
    
            //... save the pollutant removal for the LID process as a fraction
            LidProcs[j].drainRmvl[p] = rmvl / 100.0;
            i++;
        }
        return 0;
    }
    //=============================================================================
    
    lid_writeSummary()
    //
    //  Purpose: writes summary of LID processes used to report file.
    //  Input:   none
    //  Output:  none
    //
    {
        let        j, k;
        let     pctArea;
        let  lidUnit; //TLidUnit*
        let  lidList; // TLidList*
        let  lidGroup; //TLidGroup 
        // String formatted values
        let val1, val2, val3, val4, val5, val6
     
        Frpt.contents +=  `\n`;
        Frpt.contents +=  `\n`;
        Frpt.contents +=  `\n  *******************`;
        Frpt.contents +=  `\n  LID Control Summary`;
        Frpt.contents +=  `\n  *******************`;
    
    
        Frpt.contents +=  
    `\n                                   No. of        Unit        Unit      %% Area    %% Imperv      %% Perv`; //(5.1.013)
        Frpt.contents +=                                                                                           //
    `\n  Subcatchment     LID Control      Units        Area       Width     Covered     Treated     Treated`;    //
        Frpt.contents +=                                                                                         //
    `\n  ---------------------------------------------------------------------------------------------------`;    //
    
        for (j = 0; j < GroupCount; j++)
        {
            lidGroup = LidGroups[j];
            if ( lidGroup == null ) continue;
            lidList = lidGroup.lidList;
            while ( lidList )
            {
                lidUnit = lidList.lidUnit;
                k = lidUnit.lidIndex;
                pctArea = lidUnit.area * lidUnit.number / Subcatch[j].area * 100.0;
                Frpt.contents += `\n  ${Subcatch[j].ID.padEnd(16, ' ')} ${LidProcs[k].ID.padEnd(16, ' ')}`
    
                val1 = lidUnit.number.padStart(6, ' ')
                val2 = (lidUnit.area * SQR(UCF(LENGTH))).toFixed(2).padStart(10, ' ')
                val3 = (lidUnit.fullWidth * UCF(LENGTH)).toFixed(2).padStart(10, ' ')
                val4 = pctArea.toFixed(2).padStart(10, ' ')
                val5 = (lidUnit.fromImperv*100.0).toFixed(2).padStart(10, ' ')
                val6 = (lidUnit.fromPerv*100.0).toFixed(2).padStart(10, ' ')
                Frpt.contents += `%6d  %10.2f  %10.2f  %10.2f  %10.2f  %10.2f`  //(5.1.013)
    
                lidList = lidList.nextLidUnit;
            }
        }
    }
    
    //=============================================================================
    
    lid_validate()
    //
    //  Purpose: validates LID process and group parameters.
    //  Input:   none 
    //  Output:  none
    //
    {
        let j;
        for (j = 0; j < LidCount; j++) validateLidProc(j);
        for (j = 0; j < GroupCount; j++) validateLidGroup(j);
    }
    
    //=============================================================================
    // int j
    validateLidProc(j)
    //
    //  Purpose: validates LID process parameters.
    //  Input:   j = LID process index 
    //  Output:  none
    //
    {
        let layerMissing = false;
    
        //... check that LID type was supplied
        if ( LidProcs[j].lidType < 0 )
        {
            report_writeErrorMsg(ERR_LID_TYPE, LidProcs[j].ID);
            return;
        }
    
        //... check that required layers were defined
        switch (LidProcs[j].lidType)
        {
        case BIO_CELL:
        case RAIN_GARDEN:
            if ( LidProcs[j].soil.thickness <= 0.0 ) layerMissing = true;
            break;
        case GREEN_ROOF:
            if ( LidProcs[j].soil.thickness <= 0.0 ) layerMissing = true; 
            if ( LidProcs[j].drainMat.thickness <= 0.0) layerMissing = true;
            break;
        case POROUS_PAVEMENT:
            if ( LidProcs[j].pavement.thickness  <= 0.0 ) layerMissing = true;
            break;
        case INFIL_TRENCH:
            if ( LidProcs[j].storage.thickness <= 0.0 ) layerMissing = true;
            break;
        }
        if ( layerMissing )
        {
            report_writeErrorMsg(ERR_LID_LAYER, LidProcs[j].ID);
            return;
        }
    
        //... check pavement layer parameters
        if ( LidProcs[j].lidType == POROUS_PAVEMENT )
        {
            if ( LidProcs[j].pavement.thickness  <= 0.0 
            ||   LidProcs[j].pavement.kSat       <= 0.0 
            ||   LidProcs[j].pavement.voidFrac   <= 0.0
            ||   LidProcs[j].pavement.voidFrac   >  1.0
            ||   LidProcs[j].pavement.impervFrac >  1.0 )
    
            {
                strcpy(Msg, LidProcs[j].ID);
                strcat(Msg, ERR_PAVE_LAYER);
                report_writeErrorMsg(ERR_LID_PARAMS, Msg);
            }
        }
    
        //... check soil layer parameters
        if ( LidProcs[j].soil.thickness > 0.0 )
        {
            if ( LidProcs[j].soil.porosity      <= 0.0 
            ||   LidProcs[j].soil.fieldCap      >= LidProcs[j].soil.porosity
            ||   LidProcs[j].soil.wiltPoint     >= LidProcs[j].soil.fieldCap
            ||   LidProcs[j].soil.kSat          <= 0.0
            ||   LidProcs[j].soil.kSlope        <  0.0 )
            {
                strcpy(Msg, LidProcs[j].ID);
                strcat(Msg, ERR_SOIL_LAYER);
                report_writeErrorMsg(ERR_LID_PARAMS, Msg);
            }
        }
    
        //... check storage layer parameters
        if ( LidProcs[j].storage.thickness > 0.0 )
        {
            if ( LidProcs[j].storage.voidFrac <= 0.0 ||
                 LidProcs[j].storage.voidFrac > 1.0 )
            {
                strcpy(Msg, LidProcs[j].ID);
                strcat(Msg, ERR_STOR_LAYER);
                report_writeErrorMsg(ERR_LID_PARAMS, Msg);
            }
        }
    
        //... if no storage layer adjust void fraction and drain offset 
        else
        {    
            LidProcs[j].storage.voidFrac = 1.0;
            LidProcs[j].drain.offset = 0.0;
        }
    
        //... check for invalid drain open/closed heads                            //(5.1.013)
        if (LidProcs[j].drain.hOpen > 0.0 &&                                       //
            LidProcs[j].drain.hOpen <= LidProcs[j].drain.hClose)                   //
        {                                                                          //
            strcpy(Msg, LidProcs[j].ID);                                           //
            strcat(Msg, ERR_DRAIN_HEADS);                                          //
            report_writeErrorMsg(ERR_LID_PARAMS, Msg);                             //
        }                                                                          //
    
        //... compute the surface layer's overland flow constant (alpha)
        if ( LidProcs[j].lidType == VEG_SWALE )
        {
            if ( LidProcs[j].surface.roughness * 
                 LidProcs[j].surface.surfSlope <= 0.0 ||
                 LidProcs[j].surface.thickness == 0.0
               )
            {
                strcpy(Msg, LidProcs[j].ID);
                strcat(Msg, ERR_SWALE_SURF);
                report_writeErrorMsg(ERR_LID_PARAMS, Msg);
            }
            else LidProcs[j].surface.alpha = 
                1.49 * Math.sqrt(LidProcs[j].surface.surfSlope) /
                    LidProcs[j].surface.roughness;
        }
        else
        {
            //... compute surface overland flow coeff.
            if ( LidProcs[j].surface.roughness > 0.0 )
                LidProcs[j].surface.alpha = 1.49 / LidProcs[j].surface.roughness *
                                            Math.sqrt(LidProcs[j].surface.surfSlope);
            else LidProcs[j].surface.alpha = 0.0;
        }
    
        //... compute drainage mat layer's flow coeff.
        if ( LidProcs[j].drainMat.roughness > 0.0 )
        {
            LidProcs[j].drainMat.alpha = 1.49 / LidProcs[j].drainMat.roughness *
                                        Math.sqrt(LidProcs[j].surface.surfSlope);
        }
        else LidProcs[j].drainMat.alpha = 0.0;
    
    
        //... convert clogging factors to void volume basis
        if ( LidProcs[j].pavement.thickness > 0.0 )
        {
            LidProcs[j].pavement.clogFactor *= 
                LidProcs[j].pavement.thickness * LidProcs[j].pavement.voidFrac *
                (1.0 - LidProcs[j].pavement.impervFrac);
        }
        if ( LidProcs[j].storage.thickness > 0.0 )
        {
            LidProcs[j].storage.clogFactor *=
                LidProcs[j].storage.thickness * LidProcs[j].storage.voidFrac;
        }
        else LidProcs[j].storage.clogFactor = 0.0;
    
        //... for certain LID types, immediate overflow of excess surface water
        //    occurs if either the surface roughness or slope is zero
        LidProcs[j].surface.canOverflow = true;
        switch (LidProcs[j].lidType)
        {
            case ROOF_DISCON: LidProcs[j].surface.canOverflow = false; break;
            case INFIL_TRENCH:
            case POROUS_PAVEMENT:
            case BIO_CELL:
            case RAIN_GARDEN:
            case GREEN_ROOF:
                if ( LidProcs[j].surface.alpha > 0.0 )
                    LidProcs[j].surface.canOverflow = false;
        }
    
        //... rain barrels have 100% void space and impermeable bottom
        if ( LidProcs[j].lidType == RAIN_BARREL )
        {
            LidProcs[j].storage.voidFrac = 1.0;
            LidProcs[j].storage.kSat = 0.0;
        }
    
        //... set storage layer parameters of a green roof 
        if ( LidProcs[j].lidType == GREEN_ROOF )
        {
            LidProcs[j].storage.thickness = LidProcs[j].drainMat.thickness;
            LidProcs[j].storage.voidFrac = LidProcs[j].drainMat.voidFrac;
            LidProcs[j].storage.clogFactor = 0.0;
            LidProcs[j].storage.kSat = 0.0;
        }
    }
    
    //=============================================================================
    // int j
    validateLidGroup(j)
    //
    //  Purpose: validates properties of LID units grouped in a subcatchment.
    //  Input:   j = subcatchment index 
    //  Output:  returns 1 if data are valid, 0 if not
    //
    {
        let        k;
        let     p = new Array(3);
        let     totalArea = Subcatch[j].area;
        let     totalLidArea = 0.0;
        let     fromImperv = 0.0;
        let     fromPerv = 0.0;                                                 //(5.1.013)
        let  lidUnit;  //TLidUnit*
        let  lidList;  //TLidList*
        let  lidGroup; //TLidGroup  
    
        lidGroup = LidGroups[j];
        if ( lidGroup == null ) return;
        lidList = lidGroup.lidList;
        while ( lidList )
        {
            lidUnit = lidList.lidUnit;
            k = lidUnit.lidIndex;
    
            //... update contributing fractions
            totalLidArea += (lidUnit.area * lidUnit.number);
            fromImperv += lidUnit.fromImperv;
            fromPerv += lidUnit.fromPerv;                                         //(5.1.013)
    
            //... assign biocell soil layer infiltration parameters
            lidUnit.soilInfil.Ks = 0.0;
            if ( LidProcs[k].soil.thickness > 0.0 )
            {
                p[0] = LidProcs[k].soil.suction * UCF(RAINDEPTH);
                p[1] = LidProcs[k].soil.kSat * UCF(RAINFALL);
                p[2] = (LidProcs[k].soil.porosity - LidProcs[k].soil.wiltPoint) *
                       (1.0 - lidUnit.initSat);
                if ( grnampt_setParams((lidUnit.soilInfil), p) == false )
                {
                    strcpy(Msg, LidProcs[k].ID);
                    strcat(Msg, ERR_SOIL_LAYER);
                    report_writeErrorMsg(ERR_LID_PARAMS, Msg);
                }
            }
            
            //... assign vegetative swale infiltration parameters
            if ( LidProcs[k].lidType == VEG_SWALE )
            {
                if ( Subcatch[j].infilModel == GREEN_AMPT ||                       //(5.1.015)
                     Subcatch[j].infilModel == MOD_GREEN_AMPT )                    //(5.1.015)
                {
                    grnampt_getParams(j, p);                                       //(5.1.015)
                    if ( grnampt_setParams((lidUnit.soilInfil), p) == false )
                    {
                        strcpy(Msg, LidProcs[k].ID);
                        strcat(Msg, ERR_GREEN_AMPT);
                        report_writeErrorMsg(ERR_LID_PARAMS, Msg);
                    }
                }
                if ( lidUnit.fullWidth <= 0.0 )
                {
                    strcpy(Msg, LidProcs[k].ID);
                    strcat(Msg, ERR_SWALE_WIDTH);
                    report_writeErrorMsg(ERR_LID_PARAMS, Msg);
                }
            }
    
            //... LID unit cannot send outflow back to subcatchment's
            //    pervious area if none exists
            if ( Subcatch[j].fracImperv >= 0.999 ) lidUnit.toPerv = 0;
    
            //... assign drain outlet if not set by user
            if ( lidUnit.drainNode == -1 && lidUnit.drainSubcatch == -1 )
            {
                lidUnit.drainNode = Subcatch[j].outNode;
                lidUnit.drainSubcatch = Subcatch[j].outSubcatch;
            }
            lidList = lidList.nextLidUnit;
        }
    
        //... check contributing area fractions
        if ( totalLidArea > 1.001 * totalArea )
        {
            report_writeErrorMsg(ERR_LID_AREAS, Subcatch[j].ID);
        }
        if ( fromImperv > 1.001 || fromPerv > 1.001 )                              //(5.1.013)
        {
            report_writeErrorMsg(ERR_LID_CAPTURE_AREA, Subcatch[j].ID);
        }
    
        //... Make subcatchment LID area equal total area if the two are close
        if ( totalLidArea > 0.999 * totalArea ) totalLidArea = totalArea;
        Subcatch[j].lidArea = totalLidArea;
    }
    
    //=============================================================================
    
    lid_initState()
    //
    //  Purpose: initializes the internal state of each LID in a subcatchment.
    //  Input:   none 
    //  Output:  none
    //
    {
        let i, j, k;
        let  lidUnit; //TLidUnit*
        let  lidList; // TLidList*
        let  lidGroup; //TLidGroup
        let     initVol;
        let     initDryTime = StartDryDays * SECperDAY;
    
        HasWetLids = false;
        for (j = 0; j < GroupCount; j++)
        {
            //... check if group exists
            lidGroup = LidGroups[j];
            if ( lidGroup == null ) continue;
    
            //... initialize group variables
            lidGroup.pervArea = 0.0;
            lidGroup.flowToPerv = 0.0;
            lidGroup.oldDrainFlow = 0.0;
            lidGroup.newDrainFlow = 0.0;
    
            //... examine each LID in the group
            lidList = lidGroup.lidList;
            while ( lidList )
            {
                //... initialize depth & moisture content
                lidUnit = lidList.lidUnit;
                k = lidUnit.lidIndex;
                lidUnit.surfaceDepth = 0.0;
                lidUnit.storageDepth = 0.0;
                lidUnit.soilMoisture = 0.0;
                lidUnit.paveDepth = 0.0;
                lidUnit.dryTime = initDryTime;
                lidUnit.volTreated = 0.0;                                         //(5.1.013)
                lidUnit.nextRegenDay = LidProcs[k].pavement.regenDays;            //
                initVol = 0.0;
                if ( LidProcs[k].soil.thickness > 0.0 )
                {
                    lidUnit.soilMoisture = LidProcs[k].soil.wiltPoint + 
                        lidUnit.initSat * (LidProcs[k].soil.porosity -
                        LidProcs[k].soil.wiltPoint);
                    initVol += lidUnit.soilMoisture * LidProcs[k].soil.thickness;
                }
                if ( LidProcs[k].storage.thickness > 0.0 )
                {
                    lidUnit.storageDepth = lidUnit.initSat *
                        LidProcs[k].storage.thickness;
                    initVol += lidUnit.storageDepth * LidProcs[k].storage.voidFrac;
                }
                if ( LidProcs[k].drainMat.thickness > 0.0 )
                {
                    lidUnit.storageDepth = lidUnit.initSat *
                        LidProcs[k].drainMat.thickness;
                    initVol += lidUnit.storageDepth * LidProcs[k].drainMat.voidFrac;
                }
                if ( lidUnit.initSat > 0.0 ) HasWetLids = true;
    
                //... initialize water balance totals
                lidproc_initWaterBalance(lidUnit, initVol);
                lidUnit.volTreated = 0.0;
    
                //... initialize report file for the LID
                if ( lidUnit.rptFile )
                {
                    initLidRptFile(Title[0], LidProcs[k].ID, Subcatch[j].ID, lidUnit);
                }
    
                //... initialize drain flows
                lidUnit.oldDrainFlow = 0.0;
                lidUnit.newDrainFlow = 0.0;
    
                //... set previous flux rates to 0
                for (i = 0; i < MAX_LAYERS; i++)
                {    
                    lidUnit.oldFluxRates[i] = 0.0;
                }
    
                //... initialize infiltration state variables
                if ( lidUnit.soilInfil.Ks > 0.0 )
                    grnampt_initState((lidUnit.soilInfil));
    
                //... add contribution to pervious LID area
                if ( isLidPervious(lidUnit.lidIndex) )
                    lidGroup.pervArea += (lidUnit.area * lidUnit.number);
                lidList = lidList.nextLidUnit;
            }
        }
    }
    
    //=============================================================================
    //int j
     lid_setOldGroupState(j)
    //
    //  Purpose: saves the current drain flow rate for the LIDs in a subcatchment.
    //  Input:   j = subcatchment index 
    //  Output:  none
    //
    {
        let  lidList;  //TLidList*
        if ( LidGroups[j] != null )
        {
            LidGroups[j].oldDrainFlow = LidGroups[j].newDrainFlow;
            LidGroups[j].newDrainFlow = 0.0;
            lidList = LidGroups[j].lidList;
            while (lidList)
            {
                lidList.lidUnit.oldDrainFlow = lidList.lidUnit.newDrainFlow;
                lidList.lidUnit.newDrainFlow = 0.0;
                lidList = lidList.nextLidUnit;
            }
        }
    }
    
    //=============================================================================
    //int k
    isLidPervious(k)
    //
    //  Purpose: determines if a LID process allows infiltration or not.
    //  Input:   k = LID process index 
    //  Output:  returns 1 if process is pervious or 0 if not
    //
    {
        return ( LidProcs[k].storage.thickness == 0.0 ||
                 LidProcs[k].storage.kSat > 0.0 );
    }
    
    //=============================================================================
    // int j
    getSurfaceDepth(j)
    //
    //  Purpose: computes the depth (volume per unit area) of ponded water on the
    //           surface of all LIDs within a subcatchment.
    //  Input:   j = subcatchment index 
    //  Output:  returns volumetric depth of ponded water (ft)
    //
    {
        let    k;
        let depth = 0.0;
        let  lidUnit;  //TLidUnit*
        let  lidList;  // TLidList*
        let lidGroup; //TLidGroup 
    
        lidGroup = LidGroups[j];
        if ( lidGroup == null ) return 0.0;
        if ( Subcatch[j].lidArea == 0.0 ) return 0.0;
        lidList = lidGroup.lidList;
        while ( lidList )
        {
            lidUnit = lidList.lidUnit;
            k = lidUnit.lidIndex;
            depth += lidUnit.surfaceDepth * LidProcs[k].surface.voidFrac *
                     lidUnit.area * lidUnit.number;
            lidList = lidList.nextLidUnit;
        }
        return depth / Subcatch[j].lidArea;
    }
    
    //=============================================================================
    // int j
    lid_getPervArea(j)
    //
    //  Purpose: retrieves amount of pervious LID area in a subcatchment.
    //  Input:   j = subcatchment index
    //  Output:  returns amount of pervious LID area (ft2)
    //
    {
        if ( LidGroups[j] ) return LidGroups[j].pervArea;
        else return 0.0;
    }
    
    //=============================================================================
    // int j
      lid_getFlowToPerv(j)
    //
    //  Purpose: retrieves flow returned from LID treatment to pervious area of
    //           a subcatchment.
    //  Input:   j = subcatchment index
    //  Output:  returns flow returned to pervious area (cfs)
    //
    {
        if ( LidGroups[j] != null ) return LidGroups[j].flowToPerv;
        return 0.0;
    }
    
    //=============================================================================
    // int j
    lid_getStoredVolume(j)
    //
    //  Purpose: computes stored volume of water for all LIDs 
    //           grouped within a subcatchment.
    //  Input:   j = subcatchment index 
    //  Output:  returns stored volume of water (ft3)
    //
    {
        let total = 0.0;
        let  lidUnit; // TLidUnit*
        let  lidList;  // TLidList*
        let  lidGroup; // TLidGroup
    
        lidGroup = LidGroups[j];
        if ( lidGroup == null || Subcatch[j].lidArea == 0.0 ) return 0.0;
        lidList = lidGroup.lidList;
        while ( lidList )
        {
            lidUnit = lidList.lidUnit;
            total += lidUnit.waterBalance.finalVol * lidUnit.area * lidUnit.number;
            lidList = lidList.nextLidUnit;
        }
        return total;
    }
    
    //=============================================================================
    // int j, int timePeriod
     lid_getDrainFlow(j, timePeriod)
    //
    //  Purpose: returns flow from all of a subcatchment's LID drains for
    //           a designated time period
    //  Input:   j = subcatchment index 
    //           timePeriod = either PREVIOUS or CURRENT
    //  Output:  total drain flow (cfs) from the subcatchment.
    {
        if ( LidGroups[j] != null )
        {
            if ( timePeriod == PREVIOUS ) return LidGroups[j].oldDrainFlow;
            else return LidGroups[j].newDrainFlow;
        }
        return 0.0;
    }
    
    //=============================================================================
    
    ////  This was modified for relelase 5.1.013.  ////                   //(5.1.013)
    // int j, double c[], double tStep
     lid_addDrainLoads(j, c, tStep)
    //
    //  Purpose: adds pollutant loads routed from drains to system
    //           mass balance totals.
    //  Input:   j = subcatchment index
    //           c = array of pollutant washoff concentrations (mass/L)
    //           tStep =  time step (sec)
    //  Output:  none.
    //
    {
        let    isRunoffLoad;     // true if drain becomes external runoff load
        let    p;                // pollutant index
        let r;                // pollutant fractional removal 
        let w;                // pollutant mass load (lb or kg)
        let  lidUnit; // TLidUnit*
        let  lidList; // TLidList*
        let  lidGroup;  // TLidGroup
    
        //... check if LID group exists
        lidGroup = LidGroups[j];
        if ( lidGroup != null )
        {
            //... examine each LID unit in the group
            lidList = lidGroup.lidList;
            while ( lidList )
            {
                lidUnit = lidList.lidUnit;
     
                //... see if unit's drain flow becomes external runoff
                isRunoffLoad = (lidUnit.drainNode >= 0 ||
                                lidUnit.drainSubcatch == j);
                
                //... for each pollutant not routed back on to subcatchment surface
                if (!lidUnit.toPerv) for (p = 0; p < Nobjects[POLLUT]; p++)
                {
                    //... get mass load flowing through the drain
                    w = lidUnit.newDrainFlow * c[p] * tStep * LperFT3 * Pollut[p].mcf;
    
                    //... get fractional removal for this load
                    r = LidProcs[lidUnit.lidIndex].drainRmvl[p];
    
                    //... update system mass balance totals
                    massbal_updateLoadingTotals(BMP_REMOVAL_LOAD, p, r*w);
                    if (isRunoffLoad)
                        massbal_updateLoadingTotals(RUNOFF_LOAD, p, w*(1.0 - r));
                }
    
                // process next LID unit in the group
                lidList = lidList.nextLidUnit;
            }
        }
    }
    
    //=============================================================================
    // int j
    lid_addDrainRunon(j)
    //
    //  Purpose: adds drain flows from LIDs in a given subcatchment to the
    //           subcatchments that were designated to receive them 
    //  Input:   j = index of subcatchment contributing underdrain flows
    //  Output:  none.
    //
    {
        let i;                   // index of an LID unit's LID process             //(5.1.013)
        let k;                   // index of subcatchment receiving LID drain flow
        let p;                   // pollutant index
        let q;                // drain flow rate (cfs)
        let w;                // mass of polllutant from drain flow             //(5.1.013)
        let  lidUnit; // TLidUnit*
        let  lidList; // TLidList*
        let  lidGroup;  // TLidGroup
    
        //... check if LID group exists
        lidGroup = LidGroups[j];
        if ( lidGroup != null )
        {
            //... examine each LID in the group
            lidList = lidGroup.lidList;
            while ( lidList )
            {
                //... see if LID's drain discharges to another subcatchment
                lidUnit = lidList.lidUnit;
                i = lidUnit.lidIndex;                                             //(5.1.013)
                k = lidUnit.drainSubcatch;
                if ( k >= 0 && k != j )
                {
                    //... distribute drain flow across subcatchment's areas
                    q = lidUnit.oldDrainFlow;
                    subcatch_addRunonFlow(k, q);
    
                    //... add pollutant loads from drain to subcatchment
                    //    (newQual[] contains loading rate (mass/sec) at this
                    //    point which is converted later on to a concentration)
                    for (p = 0; p < Nobjects[POLLUT]; p++)
                    {
                        w = q * Subcatch[j].oldQual[p] * LperFT3;                  //(5.1.013)
                        w = w * (1.0 - LidProcs[i].drainRmvl[p]);                  //
                        Subcatch[k].newQual[p] += w;                               //
                    }
                }
                lidList = lidList.nextLidUnit;
            }
        }
    }
    
    //=============================================================================
    // int j, double f
     lid_addDrainInflow(j, f)
    //
    //  Purpose: adds LID drain flow to conveyance system nodes 
    //  Input:   j = subcatchment index
    //           f = time interval weighting factor
    //  Output:  none.
    //
    //  Note:    this updates the total lateral flow (Node[].newLatFlow)
    //           and pollutant mass (Node[].newQual[]) inflow seen by nodes that
    //           receive drain flow from the LID units in subcatchment j.
    {
        let        i,            // LID process index                              //(5.1.013)
                   k,            // node index
                   p;            // pollutant index
        let     q,            // drain flow (cfs)
                   w, w1, w2;    // pollutant mass loads (mass/sec)
        let  lidUnit; // TLidUnit*
        let  lidList; // TLidList*
        let  lidGroup; // TLidGroup
    
        //... check if LID group exists
        lidGroup = LidGroups[j];
        if ( lidGroup != null )
        {
            //... examine each LID in the group
            lidList = lidGroup.lidList;
            while ( lidList )
            {
                //... see if LID's drain discharges to conveyance system node
                lidUnit = lidList.lidUnit;
                i = lidUnit.lidIndex;                                             //(5.1.013)
                k = lidUnit.drainNode;
                if ( k >= 0 )
                {
                    //... add drain flow to node's wet weather inflow
                    q = (1.0 - f) * lidUnit.oldDrainFlow + f * lidUnit.newDrainFlow;
                    Node[k].newLatFlow += q;
                    massbal_addInflowFlow(WET_WEATHER_INFLOW, q);
    
                    //... add pollutant load, based on parent subcatchment quality 
                    for (p = 0; p < Nobjects[POLLUT]; p++)
                    {
                        //... get previous & current drain loads
                        w1 = lidUnit.oldDrainFlow * Subcatch[j].oldQual[p];
                        w2 = lidUnit.newDrainFlow * Subcatch[j].newQual[p]; 
    
                        //... add interpolated load to node's wet weather loading
                        w = (1.0 - f) * w1 + f * w2;
                        w = w * (1.0 - LidProcs[i].drainRmvl[p]);                  //(5.1.013)
                        Node[k].newQual[p] += w;
                        massbal_addInflowQual(WET_WEATHER_INFLOW, p, w);
                    }
                }
                lidList = lidList.nextLidUnit;
            }
        }
    }
    
    //=============================================================================
    // int j, double tStep
    lid_getRunoff(j, tStep)
    //
    //  Purpose: computes runoff and drain flows from the LIDs in a subcatchment.
    //  Input:   j     = subcatchment index 
    //           tStep = time step (sec)
    //  Output:  updates following global quantities after LID treatment applied:
    //           Vevap, Vpevap, VlidInfil, VlidIn, VlidOut, VlidDrain.
    //
    {
        let  theLidGroup; // TLidGroup      // group of LIDs placed in the subcatchment
        let  lidList;    // TLidList*       // list of LID units in the group
        let  lidUnit;    // TLidUnit*       // a member of the list of LID units
        let lidArea;               // area of an LID unit
        let qImperv = 0.0;         // runoff from impervious areas (cfs)
        let qPerv = 0.0;           // runoff from pervious areas (cfs)          //(5.1.013)
        let lidInflow = 0.0;       // inflow to an LID unit (ft/s) 
        let qRunoff = 0.0;         // surface runoff from all LID units (cfs)
        let qDrain = 0.0;          // drain flow from all LID units (cfs)
        let qReturn = 0.0;         // LID outflow returned to pervious area (cfs) 
    
        //... return if there are no LID's
        theLidGroup = LidGroups[j];
        if ( !theLidGroup ) return;
        lidList = theLidGroup.lidList;
        if ( !lidList ) return;
    
        //... determine if evaporation can occur
        EvapRate = Evap.rate;
        if ( Evap.dryOnly && Subcatch[j].rainfall > 0.0 ) EvapRate = 0.0;
    
        //... find subcatchment's infiltration rate into native soil
        findNativeInfil(j, tStep);
    
        //... get impervious and pervious area runoff from non-LID
        //    portion of subcatchment (cfs)
        if ( Subcatch[j].area > Subcatch[j].lidArea )
        {    
            qImperv = getImpervAreaRunoff(j);
            qPerv = getPervAreaRunoff(j);                                          //(5.1.013)
        }
    
        //... evaluate performance of each LID unit placed in the subcatchment
        while ( lidList )
        {
            //... find area of the LID unit
            lidUnit = lidList.lidUnit;
            lidArea = lidUnit.area * lidUnit.number;
    
            //... if LID unit has area, evaluate its performance
            if ( lidArea > 0.0 )
            {
                //... find runoff from non-LID area treated by LID area (ft/sec)
                lidInflow = (qImperv * lidUnit.fromImperv +                       //(5.1.013)
                             qPerv * lidUnit.fromPerv) / lidArea;                 //
    
                //... update total runoff volume treated
                VlidIn += lidInflow * lidArea * tStep;
    
                //... add rainfall onto LID inflow (ft/s)
                lidInflow = lidInflow + Subcatch[j].rainfall;
    
                // ... add upstream runon only if LID occupies full subcatchment
                if ( Subcatch[j].area == Subcatch[j].lidArea )
                {
                    lidInflow += Subcatch[j].runon;
                }
    
                //... evaluate the LID unit's performance, updating the LID group's
                //    total surface runoff, drain flow, and flow returned to
                //    pervious area 
                evalLidUnit(j, lidUnit, lidArea, lidInflow, tStep,
                            qRunoff, qDrain, qReturn);
            }
            lidList = lidList.nextLidUnit;
        }
    
        //... save the LID group's total drain & return flows
        theLidGroup.newDrainFlow = qDrain;
        theLidGroup.flowToPerv = qReturn;
    
        //... save the LID group's total surface, drain and return flow volumes
        VlidOut = qRunoff * tStep; 
        VlidDrain = qDrain * tStep;
        VlidReturn = qReturn * tStep;
    }
    
    //=============================================================================
    // int j, double tStep
    findNativeInfil(j, tStep)
    //
    //  Purpose: determines a subcatchment's current infiltration rate into
    //           its native soil.
    //  Input:   j = subcatchment index
    //           tStep    = time step (sec)
    //  Output:  sets values for module-level variables NativeInfil
    //
    {
        let nonLidArea;
    
        //... subcatchment has non-LID pervious area
        nonLidArea = Subcatch[j].area - Subcatch[j].lidArea;
        if ( nonLidArea > 0.0 && Subcatch[j].fracImperv < 1.0 )
        {
            NativeInfil = Vinfil / nonLidArea / tStep;
        }
    
        //... otherwise find infil. rate for the subcatchment's rainfall + runon
        else
        {
            NativeInfil = infil_getInfil(j, tStep,
                                         Subcatch[j].rainfall,
                                         Subcatch[j].runon,
                                         getSurfaceDepth(j));                      //(5.1.015)
        }
    
        //... see if there is any groundwater-imposed limit on infil.
        if ( !IgnoreGwater && Subcatch[j].groundwater )
        {
            MaxNativeInfil = Subcatch[j].groundwater.maxInfilVol / tStep;
        }
        else MaxNativeInfil = BIG;
    }
    
    //=============================================================================
    // int j
    getImpervAreaRunoff(j)
    //
    //  Purpose: computes runoff from impervious area of a subcatchment that
    //           is available for LID treatment.
    //  Input:   j = subcatchment index
    //  Output:  returns runoff flow rate (cfs)
    //
    {
        let    i;
        let q = 0.0,          // runoff rate (ft/sec)
               nonLidArea;       // non-LID area (ft2)
    
        // --- runoff from impervious area w/ & w/o depression storage
        for (i = IMPERV0; i <= IMPERV1; i++)
        {
            q += Subcatch[j].subArea[i].runoff * Subcatch[j].subArea[i].fArea;
        }
    
        // --- adjust for any fraction of runoff sent to pervious area
        if ( Subcatch[j].subArea[IMPERV0].routeTo == TO_PERV &&
             Subcatch[j].fracImperv < 1.0 )
        {
            q *= Subcatch[j].subArea[IMPERV0].fOutlet;
        }
        nonLidArea = Subcatch[j].area - Subcatch[j].lidArea;
        return q * nonLidArea;
    }
    
    //=============================================================================
    
    ////  This was added for release 5.1.013.  ////                       //(5.1.013)
    // int j
    getPervAreaRunoff(j)
    //
    //  Purpose: computes runoff from pervious area of a subcatchment that
    //           is available for LID treatment.
    //  Input:   j = subcatchment index
    //  Output:  returns runoff flow rate (cfs)
    //
    {
        let q = 0.0,          // runoff rate (ft/sec)
               nonLidArea;       // non-LID area (ft2)
    
        // --- runoff from pervious area
        q = Subcatch[j].subArea[PERV].runoff * Subcatch[j].subArea[PERV].fArea;
    
        // --- adjust for any fraction of runoff sent to impervious area
        if (Subcatch[j].subArea[PERV].routeTo == TO_IMPERV &&
            Subcatch[j].fracImperv > 0.0)
        {
            q *= Subcatch[j].subArea[PERV].fOutlet;
        }
        nonLidArea = Subcatch[j].area - Subcatch[j].lidArea;
        return q * nonLidArea;
    }
    
    //=============================================================================
    // int j, TLidUnit* lidUnit, double lidArea, double lidInflow,
    //    double tStep, double *qRunoff, double *qDrain, double *qReturn
    evalLidUnit(j, lidUnit, lidArea, lidInflow,
         tStep, qRunoff, qDrain, qReturn)
    //
    //  Purpose: evaluates performance of a specific LID unit over current time step.
    //  Input:   j         = subcatchment index
    //           lidUnit   = ptr. to LID unit being evaluated
    //           lidArea   = area of LID unit
    //           lidInflow = inflow to LID unit (ft/s)
    //           tStep     = time step (sec)
    //  Output:  qRunoff   = sum of surface runoff from all LIDs (cfs)
    //           qDrain    = sum of drain flows from all LIDs (cfs)
    //           qReturn   = sum of LID flows returned to pervious area (cfs)
    //
    {
        let lidProc;   // TLidProc*    // LID process associated with lidUnit
        let lidRunoff,        // surface runoff from LID unit (cfs)
               lidEvap,          // evaporation rate from LID unit (ft/s)
               lidInfil,         // infiltration rate from LID unit (ft/s)
               lidDrain;         // drain flow rate from LID unit (ft/s & cfs)
    
        //... identify the LID process of the LID unit being analyzed
        lidProc = LidProcs[lidUnit.lidIndex];
    
        //... initialize evap and infil losses
        lidEvap = 0.0;
        lidInfil = 0.0;
    
        //... find surface runoff from the LID unit (in cfs)
        lidRunoff = lidproc_getOutflow(lidUnit, lidProc, lidInflow, EvapRate,
                                      NativeInfil, MaxNativeInfil, tStep,
                                      lidEvap, lidInfil, lidDrain) * lidArea;
        
        //... convert drain flow to CFS
        lidDrain *= lidArea;
    
        //... revise flows if LID outflow returned to pervious area
        if ( lidUnit.toPerv && Subcatch[j].area > Subcatch[j].lidArea )
        {
            //... surface runoff is always returned
            qReturn += lidRunoff;
            lidRunoff = 0.0;
    
            //... drain flow returned if it has same outlet as subcatchment
            if ( lidUnit.drainNode == Subcatch[j].outNode &&
                lidUnit.drainSubcatch == Subcatch[j].outSubcatch )
            {
                qReturn += lidDrain;
                lidDrain = 0.0;
            }
        }
     
        //... update system flow balance if drain flow goes to a
        //    conveyance system node
        if ( lidUnit.drainNode >= 0 )
        {
            massbal_updateRunoffTotals(RUNOFF_DRAINS, lidDrain * tStep);
        }
    
        //... save new drain outflow
        lidUnit.newDrainFlow = lidDrain;
    
        //... update moisture losses (ft3)
        Vevap  += lidEvap * tStep * lidArea;
        VlidInfil += lidInfil * tStep * lidArea;
        if ( isLidPervious(lidUnit.lidIndex) )
        {
            Vpevap += lidEvap * tStep * lidArea;
        }
    
        //... update time since last rainfall (for Rain Barrel emptying)
        if ( Subcatch[j].rainfall > MIN_RUNOFF ) lidUnit.dryTime = 0.0;
        else lidUnit.dryTime += tStep;
    
        //... update LID water balance and save results
        lidproc_saveResults(lidUnit, UCF(RAINFALL), UCF(RAINDEPTH));
    
        //... update LID group totals
        qRunoff += lidRunoff;
        qDrain += lidDrain;
    }
    
    //=============================================================================
    
    lid_writeWaterBalance()
    //
    //  Purpose: writes a LID performance summary table to the project's report file.
    //  Input:   none
    //  Output:  none
    //
    {
        let        j;
        let        k = 0;
        let     ucf = UCF(RAINDEPTH);
        let     inflow;
        let     outflow;
        let     err;
        let  lidUnit; // TLidUnit*
        let  lidList; // TLidList*
        let  lidGroup; // TLidGroup
    
        // String formatting values
        let val1, val2, val3, val4, val5, val6, val7
    
        //... check that project has LIDs
        for ( j = 0; j < GroupCount; j++ )
        {
            if ( LidGroups[j] ) k++;
        }
        if ( k == 0 ) return;
    
        //... write table header
        Frpt.contents +=
        `\n`
        +`\n  ***********************`
        +`\n  LID Performance Summary`
        +`\n  ***********************\n`;
    
        Frpt.contents +=
    `\n  --------------------------------------------------------------------------------------------------------------------`
    +`\n                                         Total      Evap     Infil   Surface    Drain    Initial     Final  Continuity`
    +`\n                                        Inflow      Loss      Loss   Outflow   Outflow   Storage   Storage       Error`;
        if ( UnitSystem == US ) Frpt.contents +=
    `\n  Subcatchment      LID Control             in        in        in        in        in        in        in           %%`;
        else Frpt.contents +=
    +`\n  Subcatchment      LID Control             mm        mm        mm        mm        mm        mm        mm           %%`;
        Frpt.contents +=
    +`\n  --------------------------------------------------------------------------------------------------------------------`;
    
        //... examine each LID unit in each subcatchment
        for ( j = 0; j < GroupCount; j++ )
        {
            lidGroup = LidGroups[j];
            if ( !lidGroup || Subcatch[j].lidArea == 0.0 ) continue;
            lidList = lidGroup.lidList;
            while ( lidList )
            {
                //... write water balance components to report file
                lidUnit = lidList.lidUnit;
                k = lidUnit.lidIndex;
    
                val1 = Subcatch[j].ID.padEnd(16, ' ')
                val2 = LidProcs[k].ID.padEnd(16, ' ')
                Frpt.contents += `\n  ${val1}  ${val2}`
    
                val1 = (lidUnit.waterBalance.inflow*ucf).toFixed(2).padStart(10)
                val2 = (lidUnit.waterBalance.evap*ucf).toFixed(2).padStart(10)
                val3 = (lidUnit.waterBalance.infil*ucf).toFixed(2).padStart(10)
                val4 = (lidUnit.waterBalance.surfFlow*ucf).toFixed(2).padStart(10)
                val5 = (lidUnit.waterBalance.drainFlow*ucf).toFixed(2).padStart(10)
                val6 = (lidUnit.waterBalance.initVol*ucf).toFixed(2).padStart(10)
                val7 = (lidUnit.waterBalance.finalVol*ucf).toFixed(2).padStart(10)
                Frpt.contents += `${val1}${val2}${val3}${val4}${val5}${val6}${val7}`
    
                //... compute flow balance error
                inflow = lidUnit.waterBalance.initVol + 
                         lidUnit.waterBalance.inflow;
                outflow = lidUnit.waterBalance.finalVol +
                          lidUnit.waterBalance.evap +
                          lidUnit.waterBalance.infil +
                          lidUnit.waterBalance.surfFlow +
                          lidUnit.waterBalance.drainFlow;
                if ( inflow > 0.0 ) err = (inflow - outflow) / inflow;
                else                err = 1.0;
                Frpt.contents += `  ${(err*100.0).toFixed(2).padStart(10)}`;
                lidList = lidList.nextLidUnit;
            }
        }
    }
    
    //=============================================================================
    // char* title, char* lidID, char* subcatchID, TLidUnit* lidUnit
    initLidRptFile(title, lidID, subcatchID, lidUnit)
    //
    //  Purpose: initializes the report file used for a specific LID unit
    //  Input:   title = project's title
    //           lidID = LID process name
    //           subcatchID = subcatchment ID name
    //           lidUnit = ptr. to LID unit
    //  Output:  none
    //
    {
        let colCount = 14;
        let head1 = [
            "\n                    \t", "  Elapsed\t",
            "    Total\t", "    Total\t", "  Surface\t", " Pavement\t", "     Soil\t",
            "  Storage\t", "  Surface\t", "    Drain\t", "  Surface\t", " Pavement\t",
            "     Soil\t", "  Storage"];
        let head2 = [
            "\n                    \t", "     Time\t",
            "   Inflow\t", "     Evap\t", "    Infil\t", "     Perc\t", "     Perc\t",
            "    Exfil\t", "   Runoff\t", "  OutFlow\t", "    Level\t", "    Level\t",
            " Moisture\t", "    Level"];
        let units1 = [
            "\nDate        Time    \t", "    Hours\t",
            "    in/hr\t", "    in/hr\t", "    in/hr\t", "    in/hr\t", "    in/hr\t",
            "    in/hr\t", "    in/hr\t", "    in/hr\t", "   inches\t", "   inches\t",
            "  Content\t", "   inches"];
        let units2 = [
            "\nDate        Time    \t", "    Hours\t",
            "    mm/hr\t", "    mm/hr\t", "    mm/hr\t", "    mm/hr\t", "    mm/hr\t",
            "    mm/hr\t", "    mm/hr\t", "    mm/hr\t", "       mm\t", "       mm\t",
            "  Content\t", "       mm"];
        let line9 = " ---------";
        let   i;
        let f = lidUnit.rptFile.contents; //FILE*
    
        //... check that file was opened
        if ( f ==  null ) return;
    
        //... write title lines
        f += "SWMM5 LID Report File\n"
        f += "\nProject:  " + title;
        f += "\nLID Unit: "+lidID+" in Subcatchment "+subcatchID+"\n"
    
        //... write column headings
        for ( i = 0; i < colCount; i++) f += head1[i];
        for ( i = 0; i < colCount; i++) f += head2[i];
        if (  UnitSystem == US )
        {
            for ( i = 0; i < colCount; i++) f += units1[i];
        }
        else for ( i = 0; i < colCount; i++) f += units2[i];
        f += "\n----------- --------";
        for ( i = 1; i < colCount; i++) f += "\t" + line9;
    
        //... initialize LID dryness state
        lidUnit.rptFile.wasDry = 1;
        lidUnit.rptFile.results = "";
    }
    
//-----------------------------------------------------------------------------
//   subcatch.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/19/14  (Build 5.1.000)
//             04/19/14  (Build 5.1.006)
//             03/19/15  (Build 5.1.008)
//             04/30/15  (Build 5.1.009)
//             08/05/15  (Build 5.1.010)
//             08/01/16  (Build 5.1.011)
//             03/14/17  (Build 5.1.012)
//             05/10/18  (Build 5.1.013)
//             05/18/20  (Build 5.1.015)
//   Author:   L. Rossman
//
//   Subcatchment runoff functions.
//
//   Build 5.1.008:
//   - Support added for keeping separate track of drain outflows from LIDs.
//   - Processing of inflow/outflow volumes over a time step was refactored. 
//   - Reported subcatchment runoff includes both surface runoff and LID
//     drain flows, even though latter can be routed elsewhere.
//   - Runon now distributed only over non-LID area of a subcatchment, unless
//     LID covers full area.
//   - Pollutant buildup and washoff functions were moved to surfqual.c.
//
//   Build 5.1.009:
//   - Runon for full LID subcatchment added to statistical summary.
//
//   Build 5.1.010:
//   - Fixed a bug introduced in 5.1.008 that forgot to include LID
//     exfiltration as inflow sent to GW routine.
//
//   Build 5.1.011:
//   - Subcatchment percent imperviousness not allowed to exceed 100.
//
//   Build 5.1.012:
//   - Subcatchment bottom elevation used instead of aquifer's when
//     saving water table value to results file.
//
//   Build 5.1.013:
//   - Rain gage isUsed property now set in subcatch_validate().
//   - Cumulative impervious and pervious area runoff volumes added
//     to subcatchment statistics.
//   - Support added for monthly adjustment of subcatchment's depression
//     storage, pervious N, and infiltration.
//
//   Build 5.1.015: 
//   - Support added for multiple infiltration methods within a project.
//   - Only pervious area depression storage receives monthly adjustment.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Constants 
//-----------------------------------------------------------------------------
MCOEFF    = 1.49;              // constant in Manning Eq.
MEXP      = 1.6666667;         // exponent in Manning Eq.
ODETOL    = 0.0001;            // acceptable error for ODE solver

//-----------------------------------------------------------------------------
// Globally shared variables   
//-----------------------------------------------------------------------------
// Volumes (ft3) for a subcatchment over a time step
Vevap;         // evaporation
Vpevap;        // pervious area evaporation
Vinfil;        // non-LID infiltration
Vinflow;       // non-LID precip + snowmelt + runon + ponded water
Voutflow;      // non-LID runoff to subcatchment's outlet
VlidIn;        // impervious area flow to LID units
VlidInfil;     // infiltration from LID units
VlidOut;       // surface outflow from LID units
VlidDrain;     // drain outflow from LID units
VlidReturn;    // LID outflow returned to pervious area

//-----------------------------------------------------------------------------
// Locally shared variables   
//-----------------------------------------------------------------------------
 theSubarea;  // TSubarea*   // subarea to which getDdDt() is applied
   Dstore;         // monthly adjusted depression storage (ft)  //(5.1.013)
   Alpha;          // monthly adjusted runoff coeff.            //
RunoffRoutingWords = [ w_OUTLET,  w_IMPERV, w_PERV, null];

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)   
//-----------------------------------------------------------------------------
//  subcatch_readParams        (called from parseLine in input.c)
//  subcatch_readSubareaParams (called from parseLine in input.c)
//  subcatch_readLanduseParams (called from parseLine in input.c)
//  subcatch_readInitBuildup   (called from parseLine in input.c)

//  subcatch_validate          (called from project_validate)
//  subcatch_initState         (called from project_init)

//  subcatch_setOldState       (called from runoff_execute)
//  subcatch_getRunon          (called from runoff_execute)
//  subcatch_addRunon          (called from subcatch_getRunon,
//                              lid_addDrainRunon, & runoff_getOutfallRunon)
//  subcatch_getRunoff         (called from runoff_execute)
//  subcatch_hadRunoff         (called from runoff_execute)

//  subcatch_getFracPerv       (called from gwater_initState)
//  subcatch_getStorage        (called from massbal_getRunoffError)
//  subcatch_getDepth          (called from findPondedLoads in surfqual.c)

//  subcatch_getWtdOutflow     (called from addWetWeatherInflows in routing.c)
//  subcatch_getResults        (called from output_saveSubcatchResults)

//=============================================================================
// int j, char* tok[], int ntoks
 subcatch_readParams(j, tok, ntoks)
//
//  Input:   j = subcatchment index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads subcatchment parameters from a tokenized  line of input data.
//
//  Data has format:
//    Name  RainGage  Outlet  Area  %Imperv  Width  Slope CurbLength  Snowpack  
//
{
    let    i, k, m;
    let  id;
    let x = new Array(9);

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check for enough tokens
    if ( ntoks < 8 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that named subcatch exists
    id = project_findID(SUBCATCH, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);

    // --- check that rain gage exists
    k = project_findObject(GAGE, tok[1]);
    if ( k < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    x[0] = k;

    // --- check that outlet node or subcatch exists
    m = project_findObject(NODE, tok[2]);
    x[1] = m;
    m = project_findObject(SUBCATCH, tok[2]);
    x[2] = m;
    if ( x[1] < 0.0 && x[2] < 0.0 )
        return error_setInpError(ERR_NAME, tok[2]);

    // --- read area, %imperv, width, slope, & curb length
    for ( i = 3; i < 8; i++)
    {
        ////////////////////////////////////
        returnObj = {y: x[i]}
        returnVal = getDouble(tok[i], returnObj);
        x[i] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[i] < 0.0 )
        //if ( null == (x[i] = getDouble(tok[i])) || x[i] < 0.0 )
            return error_setInpError(ERR_NUMBER, tok[i]);
    }

    // --- if snowmelt object named, check that it exists
    x[8] = -1;
    if ( ntoks > 8 )
    {
        k = project_findObject(SNOWMELT, tok[8]);
        if ( k < 0 ) return error_setInpError(ERR_NAME, tok[8]);
        x[8] = k;
    }

    // --- assign input values to subcatch's properties
    Subcatch[j].ID = id;
    Subcatch[j].gage        = x[0];
    Subcatch[j].outNode     = x[1];
    Subcatch[j].outSubcatch = x[2];
    Subcatch[j].area        = x[3] / UCF(LANDAREA);
    Subcatch[j].fracImperv  = MIN(x[4], 100.0) / 100.0;
    Subcatch[j].width       = x[5] / UCF(LENGTH);
    Subcatch[j].slope       = x[6] / 100.0;
    Subcatch[j].curbLength  = x[7];
    Subcatch[j].nPervPattern  = -1;                                            //(5.1.013
    Subcatch[j].dStorePattern = -1;                                            //
    Subcatch[j].infilPattern  = -1;                                            //

    // --- create the snow pack object if it hasn't already been created
    if ( x[8] >= 0 )
    {
        if ( !snow_createSnowpack(j, x[8]) )
            return error_setInpError(ERR_MEMORY, "");
    }
    return 0;
}

//=============================================================================
// char* tok[], int ntoks
subcatch_readSubareaParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads subcatchment's subarea parameters from a tokenized 
//           line of input data.
//
//  Data has format:
//    Subcatch  Imperv_N  Perv_N  Imperv_S  Perv_S  PctZero  RouteTo (PctRouted)
//
{
    let    i, j, k, m;
    let x = new Array(7);

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check for enough tokens
    if ( ntoks < 7 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that named subcatch exists
    j = project_findObject(SUBCATCH, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- read in Mannings n, depression storage, & PctZero values
    for (i = 0; i < 5; i++)
    {
        ////////////////////////////////////
        returnObj = {y: x[i]}
        returnVal = getDouble(tok[i+1], returnObj);
        x[i] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal  || x[i] < 0.0 )
        //if ( null == (x[i] = getDouble(tok[i+1]))  || x[i] < 0.0 )
            return error_setInpError(ERR_NAME, tok[i+1]);
    }

    // --- check for valid runoff routing keyword
    m = findmatch(tok[6], RunoffRoutingWords);
    if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[6]);

    // --- get percent routed parameter if present (default is 100)
    x[5] = m;
    x[6] = 1.0;
    if ( ntoks >= 8 )
    {
        ////////////////////////////////////
        returnObj = {y: x[6]}
        returnVal = getDouble(tok[7], returnObj);
        x[6] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[6] < 0.0 || x[6] > 100.0 )
        //if ( null == (x[6] = getDouble(tok[7])) || x[6] < 0.0 || x[6] > 100.0 )
            return error_setInpError(ERR_NUMBER, tok[7]);
        x[6] /= 100.0;
    }

    // --- assign input values to each type of subarea
    Subcatch[j].subArea[IMPERV0].N = x[0];
    Subcatch[j].subArea[IMPERV1].N = x[0];
    Subcatch[j].subArea[PERV].N    = x[1];

    Subcatch[j].subArea[IMPERV0].dStore = 0.0;
    Subcatch[j].subArea[IMPERV1].dStore = x[2] / UCF(RAINDEPTH);
    Subcatch[j].subArea[PERV].dStore    = x[3] / UCF(RAINDEPTH);

    Subcatch[j].subArea[IMPERV0].fArea  = Subcatch[j].fracImperv * x[4] / 100.0;
    Subcatch[j].subArea[IMPERV1].fArea  = Subcatch[j].fracImperv * (1.0 - x[4] / 100.0);
    Subcatch[j].subArea[PERV].fArea     = (1.0 - Subcatch[j].fracImperv);

    // --- assume that all runoff from each subarea goes to subcatch outlet
    for (i = IMPERV0; i <= PERV; i++)
    {
        Subcatch[j].subArea[i].routeTo = TO_OUTLET;
        Subcatch[j].subArea[i].fOutlet = 1.0;
    }

    // --- modify routing if pervious runoff routed to impervious area
    //     (fOutlet is the fraction of runoff not routed)
    
    k = x[5];
    if ( Subcatch[j].fracImperv == 0.0
    ||   Subcatch[j].fracImperv == 1.0 ) k = TO_OUTLET;
    if ( k == TO_IMPERV && Subcatch[j].fracImperv )
    {
        Subcatch[j].subArea[PERV].routeTo = k;
        Subcatch[j].subArea[PERV].fOutlet = 1.0 - x[6];
    }

    // --- modify routing if impervious runoff routed to pervious area
    if ( k == TO_PERV )
    {
        Subcatch[j].subArea[IMPERV0].routeTo = k;
        Subcatch[j].subArea[IMPERV1].routeTo = k;
        Subcatch[j].subArea[IMPERV0].fOutlet = 1.0 - x[6];
        Subcatch[j].subArea[IMPERV1].fOutlet = 1.0 - x[6];
    }
    return 0;
}

//=============================================================================
// char* tok[], int ntoks
subcatch_readLanduseParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads assignment of landuses to subcatchment from a tokenized 
//           line of input data.
//
//  Data has format:
//    Subcatch  landuse  percent .... landuse  percent
//
{
    let     j, k, m;
    let  f;

    // --- check for enough tokens
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that named subcatch exists
    j = project_findObject(SUBCATCH, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- process each pair of landuse - percent items
    for ( k = 2; k <= ntoks; k = k+2)
    {
        // --- check that named land use exists and is followed by a percent
        m = project_findObject(LANDUSE, tok[k-1]);
        if ( m < 0 ) return error_setInpError(ERR_NAME, tok[k-1]);
        if ( k+1 > ntoks ) return error_setInpError(ERR_ITEMS, "");
        ////////////////////////////////////
        returnObj = {y: f}
        returnVal = getDouble(tok[k], returnObj);
        f = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (f = getDouble(tok[k])) )
            return error_setInpError(ERR_NUMBER, tok[k]);

        // --- store land use fraction in subcatch's landFactor property
        Subcatch[j].landFactor[m].fraction = f/100.0;
    }
    return 0;
}

//=============================================================================
// char* tok[], int ntoks
subcatch_readInitBuildup(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads initial pollutant buildup on subcatchment from 
//           tokenized line of input data.
//
//  Data has format:
//    Subcatch  pollut  initLoad .... pollut  initLoad
//
{
    let     j, k, m;
    let  x;

    // --- check for enough tokens
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");

    // --- check that named subcatch exists
    j = project_findObject(SUBCATCH, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- process each pair of pollutant - init. load items
    for ( k = 2; k <= ntoks; k = k+2)
    {
        // --- check for valid pollutant name and loading value
        m = project_findObject(POLLUT, tok[k-1]);
        if ( m < 0 ) return error_setInpError(ERR_NAME, tok[k-1]);
        if ( k+1 > ntoks ) return error_setInpError(ERR_ITEMS, "");
        ////////////////////////////////////
        returnObj = {y: x}
        returnVal = getDouble(tok[k], returnObj);
        x = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x = getDouble(tok[k])) )
            return error_setInpError(ERR_NUMBER, tok[k]);

        // --- store loading in subcatch's initBuildup property
        Subcatch[j].initBuildup[m] = x;
    }
    return 0;
}

//=============================================================================
// int j
 subcatch_validate(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: checks for valid subcatchment input parameters.
//
{
    let     i;
    let  area;
    let  nonLidArea = Subcatch[j].area;

    // --- check for ambiguous outlet name
    if ( Subcatch[j].outNode >= 0 && Subcatch[j].outSubcatch >= 0 )
        report_writeErrorMsg(ERR_SUBCATCH_OUTLET, Subcatch[j].ID);

    // --- validate subcatchment's groundwater component 
    gwater_validate(j);

    // --- validate placement of LIDs in the subcatchment
    nonLidArea -= Subcatch[j].lidArea;

    // --- compute alpha (i.e. WCON in old SWMM) for overland flow
    //     NOTE: the area which contributes to alpha for both imperv
    //     subareas w/ and w/o depression storage is the total imperv area.
    for (i = IMPERV0; i <= PERV; i++)
    {
        if ( i == PERV )
        {
            area = (1.0 - Subcatch[j].fracImperv) * nonLidArea;
        }
        else
        {
             area = Subcatch[j].fracImperv * nonLidArea;
        }
        Subcatch[j].subArea[i].alpha = 0.0;

////  Possible change to how sub-area width should be assigned.  ////
////        area = nonLidArea; 
/////////////////////////////////////////////////////////////////////

        if ( area > 0.0 && Subcatch[j].subArea[i].N > 0.0 )
        {
            Subcatch[j].subArea[i].alpha = MCOEFF * Subcatch[j].width / area *
                Math.sqrt(Subcatch[j].slope) / Subcatch[j].subArea[i].N;
        }
    }

    // --- set isUsed property of subcatchment's rain gage                     //(5.1.013)
    i = Subcatch[j].gage;                                                      //
    if (i >= 0) Gage[i].isUsed = true;                                         //

}

//=============================================================================
// int j
 subcatch_initState(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: Initializes the state of a subcatchment.
//
{
    let    i;

//// isUsed property of subcatchment's rain gage now set in subcatch_validate  //(5.1.013)

    // --- initialize rainfall, runoff, & snow depth
    Subcatch[j].rainfall = 0.0;
    Subcatch[j].oldRunoff = 0.0;
    Subcatch[j].newRunoff = 0.0;
    Subcatch[j].oldSnowDepth = 0.0;
    Subcatch[j].newSnowDepth = 0.0;
    Subcatch[j].runon = 0.0;
    Subcatch[j].evapLoss = 0.0;
    Subcatch[j].infilLoss = 0.0;

    // --- initialize state of infiltration, groundwater, & snow pack objects
    if ( Subcatch[j].infil == j )  infil_initState(j);                         //(5.1.015)
    if ( Subcatch[j].groundwater ) gwater_initState(j);
    if ( Subcatch[j].snowpack )    snow_initSnowpack(j);

    // --- initialize state of sub-areas
    for (i = IMPERV0; i <= PERV; i++)
    {
        Subcatch[j].subArea[i].depth  = 0.0;
        Subcatch[j].subArea[i].inflow = 0.0;
        Subcatch[j].subArea[i].runoff = 0.0;
    }

    // --- initialize runoff quality
    surfqual_initState(j);
}

//=============================================================================
// int j
subcatch_setOldState(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: replaces old state of subcatchment with new state.
//
{
    let i;
    Subcatch[j].oldRunoff = Subcatch[j].newRunoff;
    Subcatch[j].oldSnowDepth = Subcatch[j].newSnowDepth;
    for (i = IMPERV0; i <= PERV; i++)
    {
        Subcatch[j].subArea[i].inflow = 0.0;
    }
    for (i = 0; i < Nobjects[POLLUT]; i++)
    {
        Subcatch[j].oldQual[i] = Subcatch[j].newQual[i];
        Subcatch[j].newQual[i] = 0.0;
    }
    lid_setOldGroupState(j);
}

//=============================================================================
// int j
subcatch_getFracPerv(j)
//
//  Purpose: determines what fraction of subcatchment area, including any LID
//           area, is pervious.
//  Input:   j = subcatchment index
//  Output:  returns fraction of area with pervious cover
//
{
    let fracPerv = 1.0 - Subcatch[j].fracImperv;

    if ( Subcatch[j].lidArea > 0.0 )
    {
        fracPerv = (fracPerv * (Subcatch[j].area - Subcatch[j].lidArea) + 
                    lid_getPervArea(j)) / Subcatch[j].area;
        fracPerv = MIN(fracPerv, 1.0);
    }
    return fracPerv;
}

//=============================================================================
// int j
subcatch_getStorage(j)
//
//  Input:   j = subcatchment index
//  Output:  returns total volume of stored water (ft3)
//  Purpose: finds total volume of water stored on a subcatchment's surface
//           and its LIDs at the current time.
//
{
    let    i;
    let v = 0.0;

    for ( i = IMPERV0; i <= PERV; i++)
    {
        v += Subcatch[j].subArea[i].depth * Subcatch[j].subArea[i].fArea;
    }
    return v * (Subcatch[j].area - Subcatch[j].lidArea) +
           lid_getStoredVolume(j);
}

//=============================================================================
// int j
subcatch_getRunon(j)
//
//  Input:   j = subcatchment index
//  Output:  none
//  Purpose: Routes runoff from a subcatchment to its outlet subcatchment
//           or between its subareas.
//
{
    let    k;                          // outlet subcatchment index
    let    p;                          // pollutant index
    let q;                          // runon to outlet subcatchment (ft/sec)
    let q1, q2;                     // runoff from imperv. areas (ft/sec)
    let pervArea;                   // subcatchment pervious area (ft2)

    // --- add previous period's runoff from this subcatchment to the
    //     runon of the outflow subcatchment, if it exists
    k = Subcatch[j].outSubcatch;
    q = Subcatch[j].oldRunoff;
    if ( k >= 0 && k != j )
    {
        subcatch_addRunonFlow(k, q);
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            Subcatch[k].newQual[p] += q * Subcatch[j].oldQual[p] * LperFT3;
        }
    }

    // --- add any LID underdrain flow sent from this subcatchment to
    //     other subcatchments
    if ( Subcatch[j].lidArea > 0.0 ) lid_addDrainRunon(j);

    // --- add to sub-area inflow any outflow from other subarea in previous period
    //     (NOTE: no transfer of runoff pollutant load, since runoff loads are
    //     based on runoff flow from entire subcatchment.)

    // --- Case 1: imperv -. perv
    if ( Subcatch[j].fracImperv < 1.0 &&
         Subcatch[j].subArea[IMPERV0].routeTo == TO_PERV )
    {
        // --- add area-wtd. outflow from imperv1 subarea to perv area inflow
        q1 = Subcatch[j].subArea[IMPERV0].runoff *
             Subcatch[j].subArea[IMPERV0].fArea;
        q2 = Subcatch[j].subArea[IMPERV1].runoff *
             Subcatch[j].subArea[IMPERV1].fArea;
        q = q1 + q2;
        Subcatch[j].subArea[PERV].inflow += q *
             (1.0 - Subcatch[j].subArea[IMPERV0].fOutlet) /
             Subcatch[j].subArea[PERV].fArea;
    }

    // --- Case 2: perv -. imperv
    if ( Subcatch[j].fracImperv > 0.0 &&
         Subcatch[j].subArea[PERV].routeTo == TO_IMPERV &&
         Subcatch[j].subArea[IMPERV1].fArea > 0.0 )
    {
        q = Subcatch[j].subArea[PERV].runoff;
        Subcatch[j].subArea[IMPERV1].inflow +=
            q * (1.0 - Subcatch[j].subArea[PERV].fOutlet) *
            Subcatch[j].subArea[PERV].fArea /
            Subcatch[j].subArea[IMPERV1].fArea;
    }

    // --- Add any return flow from LID units to pervious subarea
    if ( Subcatch[j].lidArea > 0.0 && Subcatch[j].fracImperv < 1.0 )
    {
        pervArea = Subcatch[j].subArea[PERV].fArea *
                   (Subcatch[j].area - Subcatch[j].lidArea);
        q = lid_getFlowToPerv(j);
        if ( pervArea > 0.0 )
        {
            Subcatch[j].subArea[PERV].inflow += q / pervArea;
        }
    }
}

//=============================================================================
// int k, double q
 subcatch_addRunonFlow(k, q)
//
//  Input:   k = subcatchment index
//           q = runon flow rate (cfs) to subcatchment k
//  Output:  none
//  Purpose: Updates the total runon flow (ft/s) seen by a subcatchment that
//           receives runon flow from an upstream subcatchment.
//
{
    let i;
    let nonLidArea;

    // --- distribute runoff from upstream subcatchment (in cfs)
    //     uniformly over the non-LID area of current subcatchment (ft/sec)
    if ( Subcatch[k].area <= 0.0 ) return;
    nonLidArea = Subcatch[k].area - Subcatch[k].lidArea; 
    if ( nonLidArea > 0.0 ) q = q / nonLidArea;
    else                    q = q / Subcatch[k].area;
    Subcatch[k].runon += q;

    // --- assign this flow to the 3 types of subareas
    for (i = IMPERV0; i <= PERV; i++)
    {
        Subcatch[k].subArea[i].inflow += q;
    }
}

//=============================================================================
// int j, double tStep
subcatch_getRunoff(j, tStep)
//
//  Input:   j = subcatchment index
//           tStep = time step (sec)
//  Output:  returns total runoff produced by subcatchment (ft/sec)
//  Purpose: Computes runoff & new storage depth for subcatchment.
//
//  The 'runoff' value returned by this is the total runoff
//  generated (in ft/sec) by the subcatchment before any internal
//  re-routing is applied. It is used to compute pollutant washoff.
//
//  The 'outflow' value computed here (in cfs) is the surface runoff
//  that actually leaves the subcatchment after any LID controls are
//  applied and is saved to Subcatch[j].newRunoff. 
//
{
    let    i;                          // subarea index
    let nonLidArea;                 // non-LID portion of subcatch area (ft2)
    let area;                       // sub-area or subcatchment area (ft2)
    let netPrecip = new Array(3);               // subarea net precipitation (ft/sec)
    let vRain;                      // rainfall (+ snowfall) volume (ft3)
    let vRunon    = 0.0;            // runon volume from other areas (ft3)
    let vOutflow  = 0.0;            // runoff volume leaving subcatch (ft3)
    let runoff    = 0.0;            // total runoff flow on subcatch (cfs)
    let evapRate  = 0.0;            // potential evaporation rate (ft/sec)
    let subAreaRunoff;              // sub-area runoff rate (cfs)           //(5.1.013)
    let vImpervRunoff = 0.0;        // impervious area runoff volume (ft3)  //
    let vPervRunoff = 0.0;          // pervious area runoff volume (ft3)    //

    // ret facil
    let returnObj;
    let returnVal;

    // --- initialize shared water balance variables
    Vevap     = 0.0;
    Vpevap    = 0.0;
    Vinfil    = 0.0;
    Voutflow  = 0.0;
    VlidIn    = 0.0;
    VlidInfil = 0.0;
    VlidOut   = 0.0;
    VlidDrain = 0.0;
    VlidReturn = 0.0;

    // --- find volume of inflow to non-LID portion of subcatchment as existing
    //     ponded water + any runon volume from upstream areas;
    //     rainfall and snowmelt will be added as each sub-area is analyzed
    nonLidArea = Subcatch[j].area - Subcatch[j].lidArea;
    vRunon = Subcatch[j].runon * tStep * nonLidArea;
    Vinflow = vRunon + subcatch_getDepth(j) * nonLidArea;

    // --- find LID runon only if LID occupies full subcatchment
    if ( nonLidArea == 0.0 )
        vRunon = Subcatch[j].runon * tStep * Subcatch[j].area;

    // --- get net precip. (rainfall + snowfall + snowmelt) on the 3 types
    //     of subcatchment sub-areas and update Vinflow with it
    ////////////////////////////////////
    returnObj = {netPrecip: netPrecip}
    returnVal = getNetPrecip(j, returnObj, tStep);
    netPrecip = returnObj.netPrecip;
    ////////////////////////////////////
    //getNetPrecip(j, netPrecip, tStep);

    // --- find potential evaporation rate
    if ( Evap.dryOnly && Subcatch[j].rainfall > 0.0 ) evapRate = 0.0;
    else evapRate = Evap.rate;

    // --- set monthly infiltration adjustment factor                          //(5.1.013)
    infil_setInfilFactor(j);                                                   //(5.1.013)

    // --- examine each type of sub-area (impervious w/o depression storage,
    //     impervious w/ depression storage, and pervious)
    if ( nonLidArea > 0.0 ) for (i = IMPERV0; i <= PERV; i++)
    {
        // --- get runoff from sub-area updating Vevap, Vpevap,
        //     Vinfil & Voutflow)
        area = nonLidArea * Subcatch[j].subArea[i].fArea;
        Subcatch[j].subArea[i].runoff =
            getSubareaRunoff(j, i, area, netPrecip[i], evapRate, tStep);
        subAreaRunoff = Subcatch[j].subArea[i].runoff * area;                  //(5.1.013)
        if (i == PERV) vPervRunoff = subAreaRunoff * tStep;                    //
        else           vImpervRunoff += subAreaRunoff * tStep;                 //
        runoff += subAreaRunoff;                                               //
    }

    // --- evaluate any LID treatment provided (updating Vevap,
    //     Vpevap, VlidInfil, VlidIn, VlidOut, & VlidDrain)
    if ( Subcatch[j].lidArea > 0.0 )
    {
        lid_getRunoff(j, tStep);
    }

    // --- update groundwater levels & flows if applicable
    if ( !IgnoreGwater && Subcatch[j].groundwater )
    {
        gwater_getGroundwater(j, Vpevap, Vinfil+VlidInfil, tStep);
    }

    // --- save subcatchment's total loss rates (ft/s)
    area = Subcatch[j].area;
    Subcatch[j].evapLoss = Vevap / tStep / area;
    Subcatch[j].infilLoss = (Vinfil + VlidInfil) / tStep / area;

    // --- find net surface runoff volume
    //     (VlidDrain accounts for LID drain flows)
    vOutflow = Voutflow      // runoff from all non-LID areas
               - VlidIn      // runoff treated by LID units
               + VlidOut;    // runoff from LID units
    Subcatch[j].newRunoff = vOutflow / tStep;

    // --- obtain external precip. volume (without any snowmelt)
    vRain = Subcatch[j].rainfall * tStep * area;

    // --- update the cumulative stats for this subcatchment
    stats_updateSubcatchStats(j, vRain, vRunon, Vevap, Vinfil + VlidInfil,
        vImpervRunoff, vPervRunoff, vOutflow + VlidDrain,                      //(5.1.013)
        Subcatch[j].newRunoff + VlidDrain/tStep);

    // --- include this subcatchment's contribution to overall flow balance
    //     only if its outlet is a drainage system node
    if ( Subcatch[j].outNode == -1 && Subcatch[j].outSubcatch != j )
    {
        vOutflow = 0.0;
    }

    // --- update mass balances
    massbal_updateRunoffTotals(RUNOFF_RAINFALL, vRain);
    massbal_updateRunoffTotals(RUNOFF_EVAP, Vevap);
    massbal_updateRunoffTotals(RUNOFF_INFIL, Vinfil+VlidInfil);
    massbal_updateRunoffTotals(RUNOFF_RUNOFF, vOutflow);

    // --- return area-averaged runoff (ft/s)
    return runoff / area;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {netPrecip: val1}
//let returnVal = getNetPrecip(j, returnObj, tStep);
//val1 = returnObj.netPrecip;
////////////////////////////////////
getNetPrecip(j, inObj, tStep)
//void getNetPrecip(int j, double* netPrecip, double tStep)
{
//
//  Purpose: Finds combined rainfall + snowmelt on a subcatchment.
//  Input:   j = subcatchment index
//           tStep = time step (sec)
//  Output:  netPrecip = rainfall + snowmelt over each type of subarea (ft/s)
//
    let    i, k;
    let rainfall = 0.0;             // rainfall (ft/sec)
    let snowfall = 0.0;             // snowfall (ft/sec)

    // ret facil
    let returnObj;
    let returnVal;

    // --- get current rainfall or snowfall from rain gage (in ft/sec)
    k = Subcatch[j].gage;
    if ( k >= 0 )
    {
        ////////////////////////////////////
        returnObj = {rainfall: rainfall, snowfall: snowfall}
        returnVal = gage_getPrecip(k, returnObj)
        rainfall = returnObj.rainfall;
        snowfall = returnObj.snowfall;
        ////////////////////////////////////
        //gage_getPrecip(k, rainfall, snowfall);
    }

    // --- assign total precip. rate to subcatch's rainfall property
    Subcatch[j].rainfall = rainfall + snowfall;

    // --- determine net precipitation input (netPrecip) to each sub-area

    // --- if subcatch has a snowpack, then base netPrecip on possible snow melt
    if ( Subcatch[j].snowpack && !IgnoreSnowmelt )
    {
        Subcatch[j].newSnowDepth = 
            snow_getSnowMelt(j, rainfall, snowfall, tStep, inObj.netPrecip);
    }

    // --- otherwise netPrecip is just sum of rainfall & snowfall
    else
    {
        for (i=IMPERV0; i<=PERV; i++) inObj.netPrecip[i] = rainfall + snowfall;
    }
}

//=============================================================================
// int j
subcatch_getDepth(j)
//
//  Input:   j = subcatchment index
//  Output:  returns average depth of ponded water (ft)
//  Purpose: finds average depth of water over the non-LID portion of a
//           subcatchment
//
{
    let    i;
    let fArea;
    let depth = 0.0;

    for (i = IMPERV0; i <= PERV; i++)
    {
        fArea = Subcatch[j].subArea[i].fArea;
        if ( fArea > 0.0 ) depth += Subcatch[j].subArea[i].depth * fArea;
    }
    return depth;
}

//=============================================================================
// int j, double f
subcatch_getWtdOutflow(j, f)
//
//  Input:   j = subcatchment index
//           f = weighting factor.
//  Output:  returns weighted runoff value
//  Purpose: computes wtd. combination of old and new subcatchment runoff.
//
{
    if ( Subcatch[j].area == 0.0 ) return 0.0;
    return (1.0 - f) * Subcatch[j].oldRunoff + f * Subcatch[j].newRunoff;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {x: val1}
//let returnVal = subcatch_getResults(j, f, returnObj)
//val1 = returnObj.x;
////////////////////////////////////
 subcatch_getResults(j, f, inObj)
//void  subcatch_getResults(int j, double f, float x[])
//
//  Input:   j = subcatchment index
//           f = weighting factor
//  Output:  x = array of results
//  Purpose: computes wtd. combination of old and new subcatchment results.
//
{
    let    p;                          // pollutant index
    let    k;                          // rain gage index
    let f1 = 1.0 - f;
    let z;
    let runoff;
    let gw;   // TGroundwater*               // ptr. to groundwater object

    // --- retrieve rainfall for current report period
    k = Subcatch[j].gage;
    if ( k >= 0 ) inObj.x[SUBCATCH_RAINFALL] = Gage[k].reportRainfall;
    else          inObj.x[SUBCATCH_RAINFALL] = 0.0;

    // --- retrieve snow depth
    z = ( f1 * Subcatch[j].oldSnowDepth +
          f * Subcatch[j].newSnowDepth ) * UCF(RAINDEPTH);
          inObj.x[SUBCATCH_SNOWDEPTH] = z;

    // --- retrieve runoff and losses
    inObj.x[SUBCATCH_EVAP] = (Subcatch[j].evapLoss * UCF(EVAPRATE));
    inObj.x[SUBCATCH_INFIL] = (Subcatch[j].infilLoss * UCF(RAINFALL));
    runoff = f1 * Subcatch[j].oldRunoff + f * Subcatch[j].newRunoff;

    // --- add any LID drain flow to reported runoff
    if ( Subcatch[j].lidArea > 0.0 )
    {
        runoff += f1 * lid_getDrainFlow(j, PREVIOUS) +
                  f * lid_getDrainFlow(j, CURRENT);
    }

    // --- if runoff is really small, report it as zero
    if ( runoff < MIN_RUNOFF * Subcatch[j].area ) runoff = 0.0;
    inObj.x[SUBCATCH_RUNOFF] = (runoff * UCF(FLOW));

    // --- retrieve groundwater results
    gw = Subcatch[j].groundwater;
    if ( gw )
    {
        z = (f1 * gw.oldFlow + f * gw.newFlow) * Subcatch[j].area * UCF(FLOW);
        inObj.x[SUBCATCH_GW_FLOW] = z;
        z = (gw.bottomElev + gw.lowerDepth) * UCF(LENGTH);
        inObj.x[SUBCATCH_GW_ELEV] = z;
        z = gw.theta;
        inObj.x[SUBCATCH_SOIL_MOIST] = z;
    }
    else
    {
        inObj.x[SUBCATCH_GW_FLOW] = 0.0;
        inObj.x[SUBCATCH_GW_ELEV] = 0.0;
        inObj.x[SUBCATCH_SOIL_MOIST]  = 0.0;
    }

    // --- retrieve pollutant washoff
    if ( !IgnoreQuality ) for (p = 0; p < Nobjects[POLLUT]; p++ )
    {
        if ( runoff == 0.0 ) z = 0.0;
        else z = f1 * Subcatch[j].oldQual[p] + f * Subcatch[j].newQual[p];
        inObj.x[SUBCATCH_WASHOFF+p] = z;
    }
}


//=============================================================================
//                              SUB-AREA METHODS
//=============================================================================
// int j, int i, double area, double precip, double evap,
//    double tStep
getSubareaRunoff(j, i, area, precip, evap, tStep)
//
//  Purpose: computes runoff & losses from a subarea over the current time step.
//  Input:   j = subcatchment index
//           i = subarea index
//           area = sub-area area (ft2)
//           precip = rainfall + snowmelt over subarea (ft/sec)
//           evap = evaporation (ft/sec)
//           tStep = time step (sec)
//  Output:  returns runoff rate from the sub-area (cfs);
//           updates shared variables Vinflow, Vevap, Vpevap, Vinfil & Voutflow.
//
{
    let    tRunoff;                 // time over which runoff occurs (sec)
    let    surfMoisture;            // surface water available (ft/sec)
    let    surfEvap;                // evap. used for surface water (ft/sec)
    let    infil = 0.0;             // infiltration rate (ft/sec)
    let    runoff = 0.0;            // runoff rate (ft/sec)
    let subarea;  // TSubarea*               // pointer to subarea being analyzed

    // ret facil
    let returnObj;
    let returnVal;

    // --- no runoff if no area
    if ( area == 0.0 ) return 0.0;

    // --- assign pointer to current subarea
    subarea = Subcatch[j].subArea[i];

    // --- assume runoff occurs over entire time step
    tRunoff = tStep;

    // --- determine evaporation loss rate
    surfMoisture = subarea.depth / tStep;
    surfEvap = Math.min(surfMoisture, evap);

    // --- compute infiltration loss rate
    if ( i == PERV ) {
        ////////////////////////////////////
        returnObj = {subarea: subarea}
        returnVal = getSubareaInfil(j, returnObj, precip, tStep)
        subarea = returnObj.subarea;
        ////////////////////////////////////
        infil = returnVal;
        //infil = getSubareaInfil(j, subarea, precip, tStep);
    }

    // --- add precip to other subarea inflows
    subarea.inflow += precip;
    surfMoisture += subarea.inflow;

    // --- update total inflow, evaporation & infiltration volumes
    Vinflow += precip * area * tStep;
    Vevap += surfEvap * area * tStep;
    if ( i == PERV ) Vpevap += Vevap;
    Vinfil += infil * area * tStep;

    // --- assign adjusted runoff coeff. & storage to shared variables         //(5.1.013)
    Alpha = subarea.alpha;                                                    //
    Dstore = subarea.dStore;                                                  //
    adjustSubareaParams(i, j);                                                 // 

    // --- if losses exceed available moisture then no ponded water remains
    if ( surfEvap + infil >= surfMoisture )
    {
        subarea.depth = 0.0;
    }

    // --- otherwise reduce inflow by losses and update depth
    //     of ponded water and time over which runoff occurs
    else
    {
        subarea.inflow -= surfEvap + infil;
        ////////////////////////////////////
        returnObj = {subarea: subarea, dt: tRunoff}
        returnVal = updatePondedDepth(returnObj)
        subarea = returnObj.subarea;
        tRunoff = returnObj.dt
        ////////////////////////////////////
        //updatePondedDepth(subarea, tRunoff);
    }

    // --- compute runoff based on updated ponded depth
    runoff = findSubareaRunoff(subarea, tRunoff);

    // --- compute runoff volume leaving subcatchment for mass balance purposes
    //     (fOutlet is the fraction of this subarea's runoff that goes to the
    //     subcatchment outlet as opposed to another subarea of the subcatchment)
    Voutflow += subarea.fOutlet * runoff * area * tStep;
    return runoff;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {subarea: val1}
//let returnVal = getSubareaInfil(j, returnObj, precip, tStep)
//val1 = returnObj.subarea;
////////////////////////////////////
getSubareaInfil(j, inObj, precip, tStep)
//double getSubareaInfil(int j, TSubarea* subarea, double precip, double tStep)
//
//  Purpose: computes infiltration rate at current time step.
//  Input:   j = subcatchment index
//           subarea = ptr. to a subarea
//           precip = rainfall + snowmelt over subarea (ft/sec)
//           tStep = time step (sec)
//  Output:  returns infiltration rate (ft/s)
//
{
    let infil = 0.0;                     // actual infiltration rate (ft/sec)

    // --- compute infiltration rate 
    infil = infil_getInfil(j, tStep, precip,                                   //(5.1.015)
                            inObj.subarea.inflow, inObj.subarea.depth);

    // --- limit infiltration rate by available void space in unsaturated
    //     zone of any groundwater aquifer
    if ( !IgnoreGwater && Subcatch[j].groundwater )
    {
        infil = MIN(infil,
                    Subcatch[j].groundwater.maxInfilVol/tStep);
    }
    return infil;
}

//=============================================================================
// TSubarea* subarea, double tRunoff
findSubareaRunoff(subarea, tRunoff)
//
//  Purpose: computes runoff (ft/s) from subarea after current time step.
//  Input:   subarea = ptr. to a subarea
//           tRunoff = time step over which runoff occurs (sec)
//  Output:  returns runoff rate (ft/s)
//
{
    let xDepth = subarea.depth - Dstore;                                   //(5.1.013)
    let runoff = 0.0;

    if ( xDepth > ZERO )
    {
        // --- case where nonlinear routing is used
        if ( subarea.N > 0.0 )
        {
            runoff = Alpha * Math.pow(xDepth, MEXP);                                //(5.1.013)
        }

        // --- case where no routing is used (Mannings N = 0)
        else
        {
            runoff = xDepth / tRunoff;
            subarea.depth = Dstore;                                           //(5.1.013)
        }
    }
    else
    {    
        runoff = 0.0;
    }
    return runoff;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {subarea: val1, dt: val2}
//let returnVal = updatePondedDepth(returnObj)
//val1 = returnObj.subarea;
//val2 = returnObj.dt
////////////////////////////////////
updatePondedDepth(inObj)
//void updatePondedDepth(TSubarea* subarea, double* dt)
//
//  Input:   subarea = ptr. to a subarea,
//           dt = time step (sec)
//  Output:  dt = time ponded depth is above depression storage (sec)
//  Purpose: computes new ponded depth over subarea after current time step.
//
{
    let ix = inObj.subarea.inflow;       // excess inflow to subarea (ft/sec)
    let dx;                         // depth above depression storage (ft)
    let tx = inObj.dt;                   // time over which dx > 0 (sec)
    
    // --- see if not enough inflow to fill depression storage (dStore)
    if ( inObj.subarea.depth + ix*tx <= Dstore )                                    //(5.1.013)
    {
        inObj.subarea.depth += ix * tx;
    }

    // --- otherwise use the ODE solver to integrate flow depth
    else
    {
        // --- if depth < Dstore then fill up Dstore & reduce time step        //(5.1.013)
        dx = Dstore - inObj.subarea.depth;                                          //
        if ( dx > 0.0 && ix > 0.0 )
        {
            tx -= dx / ix;
            inObj.subarea.depth = Dstore;                                           //(5.1.013)
        }

        // --- now integrate depth over remaining time step tx
        if ( Alpha > 0.0 && tx > 0.0 )                                         //(5.1.013)
        {
            theSubarea = inObj.subarea;
            // Make an array out of subarea.depth in order to pass
            // depth to odesolve_integrate
            let val1 = new Array(1);
            val1[0] = inObj.subarea.depth;
            odesolve_integrate(val1, 1, 0, tx, ODETOL, tx,
                               getDdDt);
            inObj.subarea.depth = val1[0];
        }
        else
        {
            if ( tx < 0.0 ) tx = 0.0;
            inObj.subarea.depth += ix * tx;
        }
    }

    // --- do not allow ponded depth to go negative
    if ( inObj.subarea.depth < 0.0 ) inObj.subarea.depth = 0.0;

    // --- replace original time step with time ponded depth
    //     is above depression storage
    inObj.dt = tx;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {v1: val1, v2: val2}
//let returnVal = getDdDt(t, returnObj)
//val1 = returnObj.v1;
//val2 = returnObj.v2
////////////////////////////////////
 getDdDt(t, inObj)
//void  getDdDt(double t, double* d, double* dddt)
//
//  Input:   t = current time (not used)
//           d = stored depth (ft)
//  Output   dddt = derivative of d with respect to time
//  Purpose: evaluates derivative of stored depth w.r.t. time
//           for the subarea whose runoff is being computed.
//
{
    let ix = theSubarea.inflow;
    //let rx = inObj.d - Dstore;                                                   //(5.1.013)
    let rx = inObj.v1[0] - Dstore; 
    if ( rx < 0.0 )
    {
        rx = 0.0;
    }
    else
    {
        rx = Alpha * Math.pow(rx, MEXP);                                            //(5.1.013)
    }
    //inObj.dddt = ix - rx;
    thisdddt = ix - rx
    inObj.v2[0] = thisdddt;
}

//=============================================================================

////  New added to release 5.1.013.  ////                             //(5.1.013)
// int i, int j
adjustSubareaParams(i, j)
//
//  Input:   i = type of subarea being analyzed
//           j = index of current subcatchment being analyzed
//  Output   adjusted values of module-level variables Dstore & Alpha
//  Purpose: adjusts a pervious subarea's depression storage and its           //(5.1.015)
//           runoff coeff. by month of the year.
//
{
    let p;              // monthly pattern index
    let m;              // current month of the year
    let f;           // adjustment factor

    if (i == PERV)                                                             //(5.1.015)
    {
        // --- depression storage adjustment
        p = Subcatch[j].dStorePattern;
        if (p >= 0 && Pattern[p].type == MONTHLY_PATTERN)
        {
            m = datetime_monthOfYear(getDateTime(OldRunoffTime)) - 1;
            f = Pattern[p].factor[m];
            if (f >= 0.0) Dstore *= f;
        }

        // --- roughness adjustment to runoff coeff.                           //(5.1.015)
        p = Subcatch[j].nPervPattern;
        if (p >= 0 && Pattern[p].type == MONTHLY_PATTERN)                      //(5.1.015)
        {
            m = datetime_monthOfYear(getDateTime(OldRunoffTime)) - 1;
            f = Pattern[p].factor[m];
            if (f <= 0.0) Alpha = 0.0;
            else          Alpha /= f;
        }
    }
}

//-----------------------------------------------------------------------------
//   stats.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             09/15/14   (Build 5.1.007)
//             03/19/15   (Build 5.1.008)
//             08/01/16   (Build 5.1.011)
//             03/14/17   (Build 5.1.012)
//             05/10/18   (Build 5.1.013)
//             04/01/20   (Build 5.1.015)
//   Author:   L. Rossman (EPA)
//             R. Dickinson (CDM)
//
//   Simulation statistics functions.
//
//   Build 5.1.007:
//   - Exfiltration losses added to storage node statistics.
//
//   Build 5.1.008:
//   - Support for updating groundwater statistics added.
//   - Support for updating maximum reported nodal depths added.
//   - OpenMP parallelization applied to updating node and link flow statistics.
//   - Updating of time that conduit is upstrm/dnstrm full was modified.
//
//   Build 5.1.011:
//   - Surcharging is now evaluated only under dynamic wave flow routing and
//     storage nodes cannot be classified as surcharged.
//
//   Build 5.1.012:
//   - Time step statistics now evaluated only in non-steady state periods.
//   - Check for full conduit flow now accounts for number of barrels.
//
//   Build 5.1.013:
//   - Include omp.h protected against lack of compiler support for OpenMP.
//   - Statistics on impervious and pervious runoff totals added.
//   - Storage nodes with a non-zero surcharge depth (e.g. enclosed tanks)
//     can now be classified as being surcharged.
//
//   Build 5.1.015:
//   - Fixes bug in summary statistics when Report Start date > Start Date.
//   - Fixes failure to initialize all subcatchment groundwater statistics.
//   - Support added for grouped freqency table of routing time steps.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
MAX_STATS = 5
//static TSysStats       SysStats;
//static TMaxStats       MaxMassBalErrs[MAX_STATS];
//static TMaxStats       MaxCourantCrit[MAX_STATS];
//static TMaxStats       MaxFlowTurns[MAX_STATS];
//static double          SysOutfallFlow;
SysStats = new TSysStats();
MaxMassBalErrs = [];
for(i = 0; i < MAX_STATS; i++){MaxMassBalErrs.push(new TMaxStats())}
MaxCourantCrit = [];
for(i = 0; i < MAX_STATS; i++){MaxCourantCrit.push(new TMaxStats())}
MaxFlowTurns = [];
for(i = 0; i < MAX_STATS; i++){MaxFlowTurns.push(new TMaxStats())}
SysOutfallFlow;

//-----------------------------------------------------------------------------
//  Exportable variables (shared with statsrpt.c)
//-----------------------------------------------------------------------------
//TSubcatchStats* SubcatchStats;
//TNodeStats*     NodeStats;
//TLinkStats*     LinkStats;
//TStorageStats*  StorageStats;
//TOutfallStats*  OutfallStats;
///TPumpStats*     PumpStats;
//double          MaxOutfallFlow;
//double          MaxRunoffFlow;

SubcatchStats = [];
NodeStats = [];
LinkStats = [];
StorageStats = [];
OutfallStats = [];
PumpStats = [];
MaxOutfallFlow;
MaxRunoffFlow;

//-----------------------------------------------------------------------------
//  Imported variables
//-----------------------------------------------------------------------------
//extern double*         NodeInflow;     // defined in massbal.c
//extern double*         NodeOutflow;    // defined in massbal.c

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  stats_open                    (called from swmm_start in swmm5.c)
//  stats_close                   (called from swmm_end in swmm5.c)
//  stats_report                  (called from swmm_end in swmm5.c)
//  stats_updateSubcatchStats     (called from subcatch_getRunoff)
//  stats_updateGwaterStats       (called from gwater_getGroundwater)
//  stats_updateFlowStats         (called from routing_execute)
//  stats_updateCriticalTimeCount (called from getVariableStep in dynwave.c)
//  stats_updateMaxNodeDepth      (called from output_saveNodeResults)

//=============================================================================

 stats_open()
//
//  Input:   none
//  Output:  returns an error code
//  Purpose: opens the simulation statistics system.
//
{
    let j, k;
    let timeStepDelta;                                                      //(5.1.015)
    let logMaxTimeStep;                                                     //(5.1.015)
    let logMinTimeStep;                                                     //(5.1.015)

    // --- set all pointers to null
    NodeStats = [];
    LinkStats = [];
    StorageStats = [];
    OutfallStats = [];
    PumpStats = [];

    // --- allocate memory for & initialize subcatchment statistics
    SubcatchStats = [];
    if ( Nobjects[SUBCATCH] > 0 )
    {
        //SubcatchStats = (TSubcatchStats *) calloc(Nobjects[SUBCATCH],
        //                                       sizeof(TSubcatchStats));
        for(let i = 0; i < Nobjects[SUBCATCH]; i++){SubcatchStats.push(new TSubcatchStats())}
        if ( !SubcatchStats )
        {
            report_writeErrorMsg(ERR_MEMORY, "");
            return ErrorCode;
        }
        for (j=0; j<Nobjects[SUBCATCH]; j++)
        {
            SubcatchStats[j].precip  = 0.0;
            SubcatchStats[j].runon   = 0.0;
            SubcatchStats[j].evap    = 0.0;
            SubcatchStats[j].infil   = 0.0;
            SubcatchStats[j].runoff  = 0.0;
            SubcatchStats[j].maxFlow = 0.0;
            SubcatchStats[j].impervRunoff = 0.0;                               //(5.1.013)
            SubcatchStats[j].pervRunoff   = 0.0;                               //
        }

        for (j=0; j<Nobjects[SUBCATCH]; j++)
        {
            if ( Subcatch[j].groundwater == null ) continue;
            Subcatch[j].groundwater.stats.avgUpperMoist = 0.0;
            Subcatch[j].groundwater.stats.avgWaterTable = 0.0;
            Subcatch[j].groundwater.stats.infil = 0.0;
            Subcatch[j].groundwater.stats.latFlow = 0.0;
            Subcatch[j].groundwater.stats.deepFlow = 0.0;
            Subcatch[j].groundwater.stats.evap = 0.0;
            Subcatch[j].groundwater.stats.maxFlow = 0.0;
            Subcatch[j].groundwater.stats.finalUpperMoist = 0.0;              //(5.1.015)
            Subcatch[j].groundwater.stats.finalWaterTable = 0.0;              //
        }
    }

    // --- allocate memory for node & link stats
    if ( Nobjects[LINK] > 0 )
    {
        //NodeStats = (TNodeStats *) calloc(Nobjects[NODE], sizeof(TNodeStats));
        //LinkStats = (TLinkStats *) calloc(Nobjects[LINK], sizeof(TLinkStats));
        for(let i = 0; i < Nobjects[NODE]; i++){NodeStats.push(new TNodeStats())}
        for(let i = 0; i < Nobjects[LINK]; i++){LinkStats.push(new TLinkStats())}
        if ( !NodeStats || !LinkStats )
        {
            report_writeErrorMsg(ERR_MEMORY, "");
            return ErrorCode;
        }
    }

    // --- initialize node stats
    if ( NodeStats ) for ( j = 0; j < Nobjects[NODE]; j++ )
    {
        NodeStats[j].avgDepth = 0.0;
        NodeStats[j].maxDepth = 0.0;
        NodeStats[j].maxDepthDate = StartDateTime;
        NodeStats[j].maxRptDepth = 0.0;
        NodeStats[j].volFlooded = 0.0;
        NodeStats[j].timeFlooded = 0.0;
        NodeStats[j].timeSurcharged = 0.0;
        NodeStats[j].timeCourantCritical = 0.0;
        NodeStats[j].totLatFlow = 0.0;
        NodeStats[j].maxLatFlow = 0.0;
        NodeStats[j].maxInflow = 0.0;
        NodeStats[j].maxOverflow = 0.0;
        NodeStats[j].maxPondedVol = 0.0;
        NodeStats[j].maxInflowDate = StartDateTime;
        NodeStats[j].maxOverflowDate = StartDateTime;
    }

    // --- initialize link stats
    if ( LinkStats ) for ( j = 0; j < Nobjects[LINK]; j++ )
    {
        LinkStats[j].maxFlow = 0.0;
        LinkStats[j].maxVeloc = 0.0;
        LinkStats[j].maxDepth = 0.0;
        LinkStats[j].timeSurcharged = 0.0;
        LinkStats[j].timeFullUpstream = 0.0;
        LinkStats[j].timeFullDnstream = 0.0;
        LinkStats[j].timeFullFlow = 0.0;
        LinkStats[j].timeCapacityLimited = 0.0;
        LinkStats[j].timeCourantCritical = 0.0;
        for (k=0; k<MAX_FLOW_CLASSES; k++)
            LinkStats[j].timeInFlowClass[k] = 0.0;
        LinkStats[j].flowTurns = 0;
        LinkStats[j].flowTurnSign = 0;
    }

    // --- allocate memory for & initialize storage unit statistics
    if ( Nnodes[STORAGE] > 0 )
    {
        //StorageStats = (TStorageStats *) calloc(Nnodes[STORAGE],
        //                   sizeof(TStorageStats));
        for(let i = 0; i < Nnodes[STORAGE]; i++){StorageStats.push(new TStorageStats())}
        if ( !StorageStats )
        {
            report_writeErrorMsg(ERR_MEMORY, "");
            return ErrorCode;
        }
        else for ( k = 0; k < Nobjects[NODE]; k++ )
        {
            if ( Node[k].type != STORAGE ) continue;
            j = Node[k].subIndex;
            StorageStats[j].initVol = Node[k].newVolume;
            StorageStats[j].avgVol = 0.0;
            StorageStats[j].maxVol = 0.0;
            StorageStats[j].maxFlow = 0.0;
            StorageStats[j].evapLosses = 0.0;
            StorageStats[j].exfilLosses = 0.0;
            StorageStats[j].maxVolDate = StartDateTime;
        }
    }

    // --- allocate memory for & initialize outfall statistics
    if ( Nnodes[OUTFALL] > 0 )
    {
        //OutfallStats = (TOutfallStats *) calloc(Nnodes[OUTFALL],
        //                   sizeof(TOutfallStats));
        for(let i = 0; i < Nnodes[OUTFALL]; i++){OutfallStats.push(new TOutfallStats())}
        if ( !OutfallStats )
        {
            report_writeErrorMsg(ERR_MEMORY, "");
            return ErrorCode;
        }
        else for ( j = 0; j < Nnodes[OUTFALL]; j++ )
        {
            OutfallStats[j].avgFlow = 0.0;
            OutfallStats[j].maxFlow = 0.0;
            OutfallStats[j].totalPeriods = 0;
            if ( Nobjects[POLLUT] > 0 )
            {
                OutfallStats[j].totalLoad = new Array(Nobjects[POLLUT]); //(double *) calloc(Nobjects[POLLUT], sizeof(double));
                if ( !OutfallStats[j].totalLoad )
                {
                    report_writeErrorMsg(ERR_MEMORY, "");
                    return ErrorCode;
                }
                for (k=0; k<Nobjects[POLLUT]; k++)
                    OutfallStats[j].totalLoad[k] = 0.0;
            }
            else OutfallStats[j].totalLoad = null;
        }
    }

    // --- allocate memory & initialize pumping statistics
    if ( Nlinks[PUMP] > 0 ) 
    { 
        //PumpStats = (TPumpStats *) calloc(Nlinks[PUMP], sizeof(TPumpStats));
        for(let i = 0; i < Nlinks[PUMP]; i++){PumpStats.push(new TPumpStats())}
        if ( !PumpStats ) 
        {
            report_writeErrorMsg(ERR_MEMORY, "");
            return ErrorCode;
        }
        else for ( j = 0; j < Nlinks[PUMP]; j++ )
        {
            PumpStats[j].utilized = 0.0;
            PumpStats[j].minFlow  = 0.0;
            PumpStats[j].avgFlow  = 0.0;
            PumpStats[j].maxFlow  = 0.0; 
            PumpStats[j].volume   = 0.0;
            PumpStats[j].energy   = 0.0;
            PumpStats[j].startUps = 0;
            PumpStats[j].offCurveLow = 0.0; 
            PumpStats[j].offCurveHigh = 0.0;
        } 
    } 

    // --- initialize system stats
    MaxRunoffFlow = 0.0;
    MaxOutfallFlow = 0.0;
    SysStats.maxTimeStep = 0.0;
    SysStats.minTimeStep = RouteStep;
    SysStats.avgTimeStep = 0.0;
    SysStats.avgStepCount = 0.0;
    SysStats.steadyStateCount = 0.0;

    // --- divide range between min and max routing time steps into            //(5.1.015)
    //     equal intervals using a logarithmic scale                           //
    logMaxTimeStep = Math.log10(RouteStep);                                         //
    logMinTimeStep = Math.log10(MinRouteStep);                                      //
    timeStepDelta = (logMaxTimeStep - logMinTimeStep) / (TIMELEVELS-1);        //
    SysStats.timeStepIntervals[0] = RouteStep;                                 //
    for (j = 1; j < TIMELEVELS; j++)                                           //
    {                                                                          //
        SysStats.timeStepIntervals[j] =                                        //
            Math.pow(10., logMaxTimeStep - j * timeStepDelta);                      //
        SysStats.timeStepCounts[j] = 0;                                        //
    }                                                                          //
    SysStats.timeStepIntervals[TIMELEVELS - 1] = MinRouteStep;                 //
    return 0;
}

//=============================================================================

 stats_close()
//
//  Input:   none
//  Output:  
//  Purpose: closes the simulation statistics system.
//
{
    let j;

    FREE(SubcatchStats);
    FREE(NodeStats);
    FREE(LinkStats);
    FREE(StorageStats); 
    if ( OutfallStats )
    {
        for ( j=0; j<Nnodes[OUTFALL]; j++ )
            FREE(OutfallStats[j].totalLoad);
        FREE(OutfallStats);
    }
    FREE(PumpStats);
}

//=============================================================================

 stats_report()
//
//  Input:   none
//  Output:  none
//  Purpose: reports simulation statistics.
//
{
    // --- report flow routing accuracy statistics
    if ( Nobjects[LINK] > 0 && RouteModel != NO_ROUTING )
    {
        stats_findMaxStats();
        report_writeMaxStats(MaxMassBalErrs, MaxCourantCrit, MAX_STATS);
        report_writeMaxFlowTurns(MaxFlowTurns, MAX_STATS);
        report_writeSysStats(SysStats);
    }

    // --- report summary statistics
    statsrpt_writeReport();
}

//=============================================================================
// int j, double rainVol, double runonVol,
//double evapVol, double infilVol,
//double impervVol, double pervVol,
//double runoffVol, double runoff
  stats_updateSubcatchStats(j, rainVol, runonVol,
                                  evapVol, infilVol,
	                              impervVol, pervVol,
                                  runoffVol, runoff)
//
//  Input:   j = subcatchment index
//           rainVol   = rainfall + snowfall volume (ft3)
//           runonVol  = runon volume from other subcatchments (ft3)
//           evapVol   = evaporation volume (ft3)
//           infilVol  = infiltration volume (ft3)
//           impervVol = impervious runoff volume (ft3)
//           pervVol   = pervious runoff volume (ft3)
//           runoffVol = runoff volume (ft3)
//           runoff    = runoff rate (cfs)
//  Output:  none
//  Purpose: updates totals of runoff components for a specific subcatchment.
//
{
    SubcatchStats[j].precip += rainVol;
    SubcatchStats[j].runon  += runonVol;
    SubcatchStats[j].evap   += evapVol;
    SubcatchStats[j].infil  += infilVol;
	SubcatchStats[j].runoff += runoffVol;
    SubcatchStats[j].maxFlow = Math.max(SubcatchStats[j].maxFlow, runoff);
	SubcatchStats[j].impervRunoff += impervVol;                                //(5.1.013)
	SubcatchStats[j].pervRunoff += pervVol;                                    //
}

//=============================================================================
// int j, double infil, double evap, double latFlow,
//   double deepFlow, double theta, double waterTable,
//   double tStep
 stats_updateGwaterStats(j, infil, evap, latFlow,
                               deepFlow, theta, waterTable,
                               tStep)
{
    Subcatch[j].groundwater.stats.infil += infil * tStep;
    Subcatch[j].groundwater.stats.evap += evap * tStep;
    Subcatch[j].groundwater.stats.latFlow += latFlow * tStep;
    Subcatch[j].groundwater.stats.deepFlow += deepFlow * tStep;
    Subcatch[j].groundwater.stats.avgUpperMoist += theta * tStep;
    Subcatch[j].groundwater.stats.avgWaterTable += waterTable * tStep;
    Subcatch[j].groundwater.stats.finalUpperMoist = theta;
    Subcatch[j].groundwater.stats.finalWaterTable = waterTable;
    if ( Math.abs(latFlow) > Math.abs(Subcatch[j].groundwater.stats.maxFlow) )
    {
        Subcatch[j].groundwater.stats.maxFlow = latFlow;
    }
}

//=============================================================================

 stats_updateMaxRunoff()
//
//   Input:   none
//   Output:  updates global variable MaxRunoffFlow
//   Purpose: updates value of maximum system runoff rate.
//
{
    let j;
    let sysRunoff = 0.0;
    
    for (j=0; j<Nobjects[SUBCATCH]; j++) sysRunoff += Subcatch[j].newRunoff;
    MaxRunoffFlow = Math.max(MaxRunoffFlow, sysRunoff);
}    

//=============================================================================
// int j, double depth
  stats_updateMaxNodeDepth(j, depth)
//
//   Input:   j = node index
//            depth = water depth at node at current reporting time (ft)
//   Output:  none
//   Purpose: updates a node's maximum depth recorded at reporting times.
//
{
    if ( NodeStats != null )
        NodeStats[j].maxRptDepth = MAX(NodeStats[j].maxRptDepth, depth);
}

//=============================================================================
// double tStep, DateTime aDate, int stepCount,
//    int steadyState
  stats_updateFlowStats(tStep, aDate, stepCount,
                              steadyState)
//
//  Input:   tStep = routing time step (sec)
//           aDate = current date/time
//           stepCount = # steps required to solve routing at current time period
//           steadyState = true if steady flow conditions exist
//  Output:  none
//  Purpose: updates various flow routing statistics at current time period.
//
{
    let   j;

    // --- update stats only after reporting period begins
    if ( aDate < ReportStart ) return;
    SysOutfallFlow = 0.0;

    // --- update node & link stats
//#pragma omp parallel num_threads(NumThreads)
//{
//    #pragma omp for
//    for ( j=0; j<Nobjects[NODE]; j++ )
//        stats_updateNodeStats(j, tStep, aDate);
//    #pragma omp for
//    for ( j=0; j<Nobjects[LINK]; j++ )
//        stats_updateLinkStats(j, tStep, aDate);
//}

    // --- update count of times in steady state
    ReportStepCount++;
    SysStats.steadyStateCount += steadyState;

    // --- update time step stats if not in steady state
	if ( steadyState == false )
	{
        // --- skip initial time step for min. value)
        if ( OldRoutingTime > 0 )
        {
            SysStats.minTimeStep = Math.min(SysStats.minTimeStep, tStep);

            // --- locate interval that logged time step falls in              //(5.1.015)
            //     and update its count                                        //
            for (j = 1; j < TIMELEVELS; j++)                                   //
                if (tStep >= SysStats.timeStepIntervals[j])                    //
                {                                                              //
                    SysStats.timeStepCounts[j]++;                              //
                    break;                                                     //
                }                                                              //
        }
        SysStats.avgTimeStep += tStep;
        SysStats.maxTimeStep = Math.max(SysStats.maxTimeStep, tStep);

        // --- update iteration step count stats
        SysStats.avgStepCount += stepCount;
	}

    // --- update max. system outfall flow
    MaxOutfallFlow = Math.max(MaxOutfallFlow, SysOutfallFlow);
}

//=============================================================================
// int node, int link
stats_updateCriticalTimeCount(node, link)
//
//  Input:   node = node index
//           link = link index
//  Output:  none
//  Purpose: updates count of times a node or link was time step-critical.
//
{
    if      ( node >= 0 ) NodeStats[node].timeCourantCritical += 1.0;
    else if ( link >= 0 ) LinkStats[link].timeCourantCritical += 1.0;
}

//=============================================================================
// int j, double tStep, DateTime aDate
stats_updateNodeStats(j, tStep, aDate)
//
//  Input:   j = node index
//           tStep = routing time step (sec)
//           aDate = current date/time
//  Output:  none
//  Purpose: updates flow statistics for a node.
//
{
    let    k, p;
    let newVolume = Node[j].newVolume;
    let newDepth = Node[j].newDepth;
    let yCrown = Node[j].crownElev - Node[j].invertElev;
    let    canPond = (AllowPonding && Node[j].pondedArea > 0.0);

    // --- update depth statistics
    NodeStats[j].avgDepth += newDepth;
    if ( newDepth > NodeStats[j].maxDepth )
    {
        NodeStats[j].maxDepth = newDepth;
        NodeStats[j].maxDepthDate = aDate;
    }
    
    // --- update flooding, ponding, and surcharge statistics
    if ( Node[j].type != OUTFALL )
    {
        if ( newVolume > Node[j].fullVolume || Node[j].overflow > 0.0 )
        {
            NodeStats[j].timeFlooded += tStep;
            NodeStats[j].volFlooded += Node[j].overflow * tStep;
            if ( canPond ) NodeStats[j].maxPondedVol =
                MAX(NodeStats[j].maxPondedVol,
                    (newVolume - Node[j].fullVolume));
        }

        // --- for dynamic wave routing, classify a node as                    //(5.1.013)
        //     surcharged if its water level exceeds its crown elev.
        if (RouteModel == DW)                                                  //(5.1.013)
        {
            if ((Node[j].type != STORAGE || Node[j].surDepth > 0.0) &&         //(5.1.013)
                newDepth + Node[j].invertElev + FUDGE >= Node[j].crownElev)
            {
                NodeStats[j].timeSurcharged += tStep;
            }
        }
    }

    // --- update storage statistics
    if ( Node[j].type == STORAGE )
    {
        k = Node[j].subIndex;
        StorageStats[k].avgVol += newVolume;
        StorageStats[k].evapLosses += 
            Storage[Node[j].subIndex].evapLoss; 
        StorageStats[k].exfilLosses +=
            Storage[Node[j].subIndex].exfilLoss; 

        newVolume = MIN(newVolume, Node[j].fullVolume);
        if ( newVolume > StorageStats[k].maxVol )
        {
            StorageStats[k].maxVol = newVolume;
            StorageStats[k].maxVolDate = aDate;
        }
        StorageStats[k].maxFlow = MAX(StorageStats[k].maxFlow, Node[j].outflow);
    }

    // --- update outfall statistics
    if ( Node[j].type == OUTFALL ) 
    {
        k = Node[j].subIndex;
        if ( Node[j].inflow >= MIN_RUNOFF_FLOW )
        {
            OutfallStats[k].avgFlow += Node[j].inflow;
            OutfallStats[k].maxFlow = MAX(OutfallStats[k].maxFlow, Node[j].inflow);
            OutfallStats[k].totalPeriods++;
        }
        for (p=0; p<Nobjects[POLLUT]; p++)
        {
            OutfallStats[k].totalLoad[p] += Node[j].inflow * 
            Node[j].newQual[p] * tStep;
        }
        SysOutfallFlow += Node[j].inflow;
    }

    // --- update inflow statistics
    NodeStats[j].totLatFlow += ( (Node[j].oldLatFlow + Node[j].newLatFlow) * 
                                 0.5 * tStep );
    if ( Math.abs(Node[j].newLatFlow) > Math.abs(NodeStats[j].maxLatFlow) )
        NodeStats[j].maxLatFlow = Node[j].newLatFlow;
    if ( Node[j].inflow > NodeStats[j].maxInflow )
    {
        NodeStats[j].maxInflow = Node[j].inflow;
        NodeStats[j].maxInflowDate = aDate;
    }

    // --- update overflow statistics
    if ( Node[j].overflow > NodeStats[j].maxOverflow )
    {
        NodeStats[j].maxOverflow = Node[j].overflow;
        NodeStats[j].maxOverflowDate = aDate;
    }
}

//=============================================================================
// int j, double tStep, DateTime aDate
 stats_updateLinkStats(j, tStep, aDate)
//
//  Input:   j = link index
//           tStep = routing time step (sec)
//           aDate = current date/time
//  Output:  none
//  Purpose: updates flow statistics for a link.
//
{
    let    k;
    let q, v;
    let dq;

    // --- update max. flow
    dq = Link[j].newFlow - Link[j].oldFlow;
    q = Math.abs(Link[j].newFlow);
    if ( q > LinkStats[j].maxFlow )
    {
        LinkStats[j].maxFlow = q;
        LinkStats[j].maxFlowDate = aDate;
    }

    // --- update max. velocity
    v = link_getVelocity(j, q, Link[j].newDepth);
    if ( v > LinkStats[j].maxVeloc )
    {
        LinkStats[j].maxVeloc = v;
    }

    // --- update max. depth
    if ( Link[j].newDepth > LinkStats[j].maxDepth )
    {
        LinkStats[j].maxDepth = Link[j].newDepth;
    }

    if ( Link[j].type == PUMP )
    {
        if ( q >= Link[j].qFull )
            LinkStats[j].timeFullFlow += tStep;
        if ( q > MIN_RUNOFF_FLOW )
        {
            k = Link[j].subIndex;
            PumpStats[k].minFlow = MIN(PumpStats[k].minFlow, q);
            PumpStats[k].maxFlow = LinkStats[j].maxFlow;
            PumpStats[k].avgFlow += q;
            PumpStats[k].volume += q*tStep;
            PumpStats[k].utilized += tStep;
            PumpStats[k].energy += link_getPower(j)*tStep/3600.0;
            if ( Link[j].flowClass == DN_DRY )
                PumpStats[k].offCurveLow += tStep;
            if ( Link[j].flowClass == UP_DRY )
                PumpStats[k].offCurveHigh += tStep;
            if ( Link[j].oldFlow < MIN_RUNOFF_FLOW )
                PumpStats[k].startUps++;
            PumpStats[k].totalPeriods++;
            LinkStats[j].timeSurcharged += tStep;
            LinkStats[j].timeFullUpstream += tStep;
            LinkStats[j].timeFullDnstream += tStep;
        }
    }
    else if ( Link[j].type == CONDUIT )
    {

        // --- update time under normal flow & inlet control 
        if ( Link[j].normalFlow ) LinkStats[j].timeNormalFlow += tStep;
        if ( Link[j].inletControl ) LinkStats[j].timeInletControl += tStep;
    
        // --- update flow classification distribution
        k = Link[j].flowClass;
        if ( k >= 0 && k < MAX_FLOW_CLASSES )
        {
            ++LinkStats[j].timeInFlowClass[k];
        }

        // --- update time conduit is full
        k = Link[j].subIndex;
        if ( q >= Link[j].qFull * Conduit[k].barrels )
            LinkStats[j].timeFullFlow += tStep; 
        if ( Conduit[k].capacityLimited )
            LinkStats[j].timeCapacityLimited += tStep;

        switch (Conduit[k].fullState)
        {
        case ALL_FULL:
            LinkStats[j].timeSurcharged += tStep;
            LinkStats[j].timeFullUpstream += tStep;
            LinkStats[j].timeFullDnstream += tStep;
            break;
        case UP_FULL:
            LinkStats[j].timeFullUpstream += tStep;
            break;
        case DN_FULL:
            LinkStats[j].timeFullDnstream += tStep;
        }
    }

    // --- update flow turn count
    k = LinkStats[j].flowTurnSign;
    LinkStats[j].flowTurnSign = SGN(dq);
    if ( Math.abs(dq) > 0.001 &&  k * LinkStats[j].flowTurnSign < 0 )
            LinkStats[j].flowTurns++;
}

//=============================================================================

 stats_findMaxStats()
//
//  Input:   none
//  Output:  none
//  Purpose: finds nodes & links with highest mass balance errors
//           & highest times Courant time-step critical.
//
{
    let    j;
    let x;
    let stepCount = ReportStepCount - SysStats.steadyStateCount;            //(5.1.015)

    // --- initialize max. stats arrays
    for (j=0; j<MAX_STATS; j++)
    {
        MaxMassBalErrs[j].objType = NODE;
        MaxMassBalErrs[j].index   = -1;
        MaxMassBalErrs[j].value   = -1.0;
        MaxCourantCrit[j].index   = -1;
        MaxCourantCrit[j].value   = -1.0;
        MaxFlowTurns[j].index     = -1; 
        MaxFlowTurns[j].value     = -1.0;
    }

    // --- find links with most flow turns 
    if ( stepCount > 2 )                                                       //(5.1.015)
    {
        for (j=0; j<Nobjects[LINK]; j++)
        {
            x = 100.0 * LinkStats[j].flowTurns / (2./3.*(stepCount-2));        //(5.1.015)
            stats_updateMaxStats(MaxFlowTurns, LINK, j, x);
        }
    }

    // --- find nodes with largest mass balance errors
    for (j=0; j<Nobjects[NODE]; j++)
    {
        // --- skip terminal nodes and nodes with negligible inflow
        if ( Node[j].degree <= 0  ) continue;
        if ( NodeInflow[j] <= 0.1 ) continue;

        // --- evaluate mass balance error
        //     (Note: NodeInflow & NodeOutflow include any initial and final
        //            stored volumes, respectively).
        if ( NodeInflow[j]  > 0.0 )
            x = 1.0 - NodeOutflow[j] / NodeInflow[j];
        else if ( NodeOutflow[j] > 0.0 ) x = -1.0;
        else                             x = 0.0;
        stats_updateMaxStats(MaxMassBalErrs, NODE, j, 100.0*x);
    }

    // --- stop if not using a variable time step
    if ( RouteModel != DW || CourantFactor == 0.0 ) return;

    // --- find nodes most frequently Courant critical
    if ( stepCount == 0 ) return;                                              //(5.1.015)
    for (j=0; j<Nobjects[NODE]; j++)
    {
        x = NodeStats[j].timeCourantCritical / stepCount;                      //(5.1.015)
        stats_updateMaxStats(MaxCourantCrit, NODE, j, 100.0*x);
    }

    // --- find links most frequently Courant critical
    for (j=0; j<Nobjects[LINK]; j++)
    {
        x = LinkStats[j].timeCourantCritical / stepCount;                      //(5.1.015)
        stats_updateMaxStats(MaxCourantCrit, LINK, j, 100.0*x);
    }
}

//=============================================================================
// TMaxStats maxStats[], int i, int j, double x
 stats_updateMaxStats(maxStats, i, j, x)
//
//  Input:   maxStats[] = array of critical statistics values
//           i = object category (NODE or LINK)
//           j = object index
//           x = value of statistic for the object
//  Output:  none
//  Purpose: updates the collection of most critical statistics
//
{
    let   k;
    //TMaxStats maxStats1, maxStats2;
    let maxStats1 = new TMaxStats();
    let maxStats2 = new TMaxStats();

    maxStats1.objType = i;
    maxStats1.index   = j;
    maxStats1.value   = x;
    for (k=0; k<MAX_STATS; k++)
    {
        if ( Math.abs(maxStats1.value) > Math.abs(maxStats[k].value) )
        {
            maxStats2 = maxStats[k];
            maxStats[k] = maxStats1;
            maxStats1 = maxStats2;
        }
    }
}

//-----------------------------------------------------------------------------
//   kinwave.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14  (Build 5.1.001)
//             03/19/15  (Build 5.1.008)
//             03/01/20  (Build 5.1.014)
//   Author:   L. Rossman (EPA)
//             M. Tryby (EPA)
//
//   Kinematic wave flow routing functions.
//
//   Build 5.1.008:
//   - Conduit inflow passed to that computes conduit losses.
//
//   Build 5.1.014:
//   - Arguments to link_getLossRate changed.
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//  Constants 
//-----------------------------------------------------------------------------
WX      = 0.6;     // distance weighting
WT      = 0.6;     // time weighting
EPSIL   = 0.001;   // convergence criterion

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
  Beta1;
  C1;
  C2;
  Afull;
  Qfull;
//static TXsect*  pXsect;
pXsect;

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  kinwave_execute  (called by flowrout_execute)
////////////////////////////////////
//let returnObj = {qinflow: qin, qoutflow: qout}
//let returnVal = kinwave_execute(j, returnObj, tStep);
//qin  = returnObj.qinflow;
//qout = returnObj.qoutflow;
////////////////////////////////////
//=============================================================================
// int j, double* qinflow, double* qoutflow, double tStep
kinwave_execute(j,  inObj, tStep)
//
//  Input:   j = link index
//           qinflow = inflow at current time (cfs)
//           tStep = time step (sec)
//  Output:  qoutflow = outflow at current time (cfs),
//           returns number of iterations used
//  Purpose: finds outflow over time step tStep given flow entering a
//           conduit using Kinematic Wave flow routing.
//
//
//                               ^ q3 
//  t                            |   
//  |          qin, ain |-------------------| qout, aout
//  |                   |  Flow --.        |
//  |---. x     q1, a1 |-------------------| q2, a2
//
//
{
    if(inObj.qinflow > 0){
        let xxx = 0;
    }
    if(j === 3 ){
        let xxx = 0;
    }
    let    k;
    let    result = 1;
    let dxdt, dq;
    let ain, aout;
    let qin, qout;
    let a1, a2, q1, q2, q3;

    let returnObj;
    let returnVal;

    // --- no routing for non-conduit link
    inObj.qoutflow = inObj.qinflow; 
    if ( Link[j].type != CONDUIT ) return result;

    // --- no routing for dummy xsection
    if ( Link[j].xsect.type == DUMMY ) return result;

    // --- assign module-level variables
    pXsect = Link[j].xsect;
    Qfull = Link[j].qFull;
    Afull = Link[j].xsect.aFull;
    k = Link[j].subIndex;
    Beta1 = Conduit[k].beta / Qfull;
 
    // --- normalize previous flows
    q1 = Conduit[k].q1 / Qfull;
    q2 = Conduit[k].q2 / Qfull;

    // --- normalize inflow
    qin = inObj.qinflow / Conduit[k].barrels / Qfull;

    // --- compute evaporation and infiltration loss rate
	q3 = link_getLossRate(j, qin*Qfull) / Qfull;                               //(5.1.014)

    // --- normalize previous areas
    a1 = Conduit[k].a1 / Afull;
    a2 = Conduit[k].a2 / Afull;

    // --- use full area when inlet flow >= full flow
    if ( qin >= 1.0 ) ain = 1.0;

    // --- get normalized inlet area corresponding to inlet flow
    else ain = xsect_getAofS(pXsect, qin/Beta1) / Afull;

    // --- check for no flow
    if ( qin <= TINY && q2 <= TINY )
    {
        qout = 0.0;
        aout = 0.0;
    }

    // --- otherwise solve finite difference form of continuity eqn.
    else
    {
        // --- compute constant factors
        dxdt = link_getLength(j) / tStep * Afull / Qfull;
        dq   = q2 - q1;
        C1   = dxdt * WT / WX;
        C2   = (1.0 - WT) * (ain - a1);
        C2   = C2 - WT * a2;
        C2   = C2 * dxdt / WX;
        C2   = C2 + (1.0 - WX) / WX * dq - qin;
        C2   = C2 + q3 / WX;

        // --- starting guess for aout is value from previous time step
        aout = a2;

        // --- solve continuity equation for aout
        ////////////////////////////////////
        returnObj = {aout: aout}
        returnVal = solveContinuity(qin, ain, returnObj);
        aout  = returnObj.aout;
        ////////////////////////////////////
        //result = solveContinuity(qin, ain, aout);
        result = returnVal;

        // --- report error if continuity eqn. not solved
        if ( result == -1 )
        {
            report_writeErrorMsg(ERR_KINWAVE, Link[j].ID);
            return 1;
        }
        if ( result <= 0 ) result = 1;

        // --- compute normalized outlet flow from outlet area
        qout = Beta1 * xsect_getSofA(pXsect, aout*Afull);
        if ( qin > 1.0 ) qin = 1.0;
    }

    // --- save new flows and areas
    Conduit[k].q1 = qin * Qfull;
    Conduit[k].a1 = ain * Afull;
    Conduit[k].q2 = qout * Qfull;
    Conduit[k].a2 = aout * Afull;
    Conduit[k].fullState =
        link_getFullState(Conduit[k].a1, Conduit[k].a2, Afull);
    inObj.qinflow  = Conduit[k].q1 * Conduit[k].barrels;
    inObj.qoutflow = Conduit[k].q2 * Conduit[k].barrels;
    return result;
}

//=============================================================================
// double qin, double ain, double* aout
////////////////////////////////////
//let returnObj = {aout: aout}
//let returnVal = solveContinuity(j, ain, returnObj);
//aout  = returnObj.aout;
////////////////////////////////////
//solveContinuity(qin, ain, aout)
solveContinuity(qin, ain, inObj)
//
//  Input:   qin = upstream normalized flow
//           ain = upstream normalized area
//           aout = downstream normalized area
//  Output:  new value for aout; returns an error code
//  Purpose: solves continuity equation f(a) = Beta1*S(a) + C1*a + C2 = 0
//           for 'a' using the Newton-Raphson root finder function.
//           Return code has the following meanings:
//           >= 0 number of evaluations used
//           -1   Newton failed
//           -2   flow always above max. flow
//           -3   flow always below zero
//
//     Note: pXsect (pointer to conduit's cross-section), and constants Beta1,
//           C1, and C2 are module-level shared variables assigned values
//           in kinwave_execute().
//
{
    let    n;                          // # evaluations or error code
    let aLo, aHi, aTmp;             // lower/upper bounds on a
    let fLo, fHi;                   // lower/upper bounds on f
    let tol = EPSIL;                // absolute convergence tol.

    // ret facil
    let returnObj;
    let returnVal;

    // --- first determine bounds on 'a' so that f(a) passes through 0.

    // --- set upper bound to area at full flow
    aHi = 1.0;
    fHi = 1.0 + C1 + C2;

    // --- try setting lower bound to area where section factor is maximum
    aLo = xsect_getAmax(pXsect) / Afull;
    if ( aLo < aHi )
    {
        fLo = ( Beta1 * pXsect.sMax ) + (C1 * aLo) + C2;
    }
    else fLo = fHi;

    // --- if fLo and fHi have same sign then set lower bound to 0
    if ( fHi*fLo > 0.0 )
    {
        aHi = aLo;
        fHi = fLo;
        aLo = 0.0;
        fLo = C2;
    }

    // --- proceed with search for root if fLo and fHi have different signs
    if ( fHi*fLo <= 0.0 )
    {
        // --- start search at midpoint of lower/upper bounds
        //     if initial value outside of these bounds
		if ( inObj.aout < aLo || inObj.aout > aHi ) inObj.aout = 0.5*(aLo + aHi);

        // --- if fLo > fHi then switch aLo and aHi
        if ( fLo > fHi )
        {
            aTmp = aLo;
            aLo  = aHi;
            aHi  = aTmp;
        }

        // --- call the Newton root finder method passing it the 
        //     evalContinuity to evaluate the function
        //     and its derivatives
        ////////////////////////////////////
        returnObj = {rts: inObj.aout, p: null}
        returnVal = findroot_Newton(aLo, aHi, returnObj, tol, evalContinuity)
        inObj.aout = returnObj.rts;
        ////////////////////////////////////
        n = returnVal;
        //n = findroot_Newton(aLo, aHi, inObj.aout, tol, evalContinuity, null);

        // --- check if root finder succeeded
        if ( n <= 0 ) n = -1;
    }

    // --- if lower/upper bound functions both negative then use full flow
    else if ( fLo < 0.0 )
    {
        if ( qin > 1.0 ) inObj.aout = ain;
        else inObj.aout = 1.0;
        n = -2;
    }

    // --- if lower/upper bound functions both positive then use no flow
    else if ( fLo > 0 )
    {
        inObj.aout = 0.0;
        n = -3;
    }
    else n = -1;
    return n;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {f: val1, df: val2, p: val3}
//let returnVal = evalContinuity(a, returnObj)
//val1 = returnObj.f;
//val2 = returnObj.df;
//val3 = returnObj.p;
////////////////////////////////////
evalContinuity(a, inObj)
//void evalContinuity(double a, double* f, double* df, void* p)
//
//  Input:   a = outlet normalized area
//  Output:  f = value of continuity eqn.
//           df = derivative of continuity eqn.
//  Purpose: computes value of continuity equation (f) and its derivative (df)
//           w.r.t. normalized area for link with normalized outlet area 'a'.
//
{
    inObj.f  = (Beta1 * xsect_getSofA(pXsect, a*Afull)) + (C1 * a) + C2;
    inObj.df = (Beta1 * Afull * xsect_getdSdA(pXsect, a*Afull)) + C1;
}

//=============================================================================

//-----------------------------------------------------------------------------
//   controls.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/21/14 (Build 5.1.001)
//             03/19/15 (Build 5.1.008)
//             04/30/15 (Build 5.1.009)
//             08/05/15 (Build 5.1.010)
//             08/01/16 (Build 5.1.011)
//   Author:   L. Rossman
//
//   Rule-based controls functions.
//
//   Control rules have the format:
//     RULE name
//     IF <premise>
//     AND / OR <premise>
//     etc.
//     THEN <action>
//     AND  <action>
//     etc.
//     ELSE <action>
//     AND  <action>
//     etc.
//     PRIORITY <p>
//
//   <premise> consists of:
//      <variable> <relational operator> value / <variable>
//   where <variable> is <object type> <id name> <attribute>
//   E.g.: Node 123 Depth > 4.5
//         Node 456 Depth < Node 123 Depth
//
//   <action> consists of:
//      <variable> = setting
//   E.g.: Pump abc status = OFF
//         Weir xyz setting = 0.5
//
//  Build 5.1.008:
//  - Support added for r.h.s. variables in rule premises.
//  - Node volume added as a premise variable.
//
//  Build 5.1.009:
//  - Fixed problem with parsing a RHS premise variable.
//
//  Build 5.1.010:
//  - Support added for link TIMEOPEN & TIMECLOSED premises.
//
//  Build 5.1.011:
//  - Support added for DAYOFYEAR attribute.
//  - Modulated controls no longer included in reported control actions.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
//enum RuleState    {
    r_RULE = 0;
    r_IF = 1; 
    r_AND = 2; 
    r_OR = 3;
    r_THEN = 4;
    r_ELSE = 5;
    r_PRIORITY = 6;
    r_ERROR = 7;
    //enum RuleObject   {
    r_NODE = 0; 
    r_LINK = 1 
    r_CONDUIT = 2 
    r_PUMP = 3;
    r_ORIFICE = 4
    r_WEIR = 5
    r_OUTLET = 6
    r_SIMULATION
    //enum RuleAttrib   {
    r_DEPTH = 0
    r_HEAD = 1
    r_VOLUME = 2
    r_INFLOW = 3
    r_FLOW = 4
    r_STATUS = 5
    r_SETTING = 6
    r_TIMEOPEN = 7
    r_TIMECLOSED = 8
    r_TIME = 9
    r_DATE = 10
    r_CLOCKTIME = 11
    r_DAYOFYEAR = 12
    r_DAY = 13
    r_MONTH = 14
    //enum RuleRelation {
    EQ = 0
    NE = 1
    LT = 2
    LE = 3
    GT = 4
    GE = 5
    //enum RuleSetting  {
    r_CURVE = 0
    r_TIMESERIES = 1
    r_PID = 2
    r_NUMERIC = 3
    
    ObjectWords =
        ["NODE", "LINK", "CONDUIT", "PUMP", "ORIFICE", "WEIR", "OUTLET",
         "SIMULATION", null];
    AttribWords =
        ["DEPTH", "HEAD", "VOLUME", "INFLOW", "FLOW", "STATUS", "SETTING",
         "TIMEOPEN", "TIMECLOSED","TIME", "DATE", "CLOCKTIME", "DAYOFYEAR", 
         "DAY", "MONTH", null]; 
    RelOpWords = ["=", "<>", "<", "<=", ">", ">=", null];
    StatusWords  = ["OFF", "ON", null];
    ConduitWords = ["CLOSED", "OPEN", null];
    SettingTypeWords = ["CURVE", "TIMESERIES", "PID", null];
    
    //-----------------------------------------------------------------------------                  
    // Data Structures
    //-----------------------------------------------------------------------------
    // Rule Premise Variable
    class TVariable
    {
        constructor(){
            this.node;            // index of a node (-1 if N/A)
            this.link;            // index of a link (-1 if N/A)
            this.attribute;       // type of attribute for node/link
        }
    };
    
    // Rule Premise Clause 
    class TPremise
    {
        constructor(){
            this.type;                 // clause type (IF/AND/OR)
            this.lhs= new TVariable();     // left hand side variable
            this.rhs= new TVariable();     // right hand side variable 
            this.relation;             // relational operator (>, <, =, etc)
            this.value;                // right hand side value
            this.next = new TPremise();       // next premise clause of rule
        }
    };
    
    // Rule Action Clause
    class  TAction              
    {
        constructor(){this.rule;             // index of rule that action belongs to
            this.link;             // index of link being controlled
            this.attribute;        // attribute of link being controlled
            this.curve;            // index of curve for modulated control
            this.tseries;          // index of time series for modulated control
            this.value;            // control setting for link attribute
            this.kp
            this.ki
            this.kd;       // coeffs. for PID modulated control
            this.e1
            this.e2;           // PID set point error from previous time steps
            this.nex = new  TAction();    // next action clause of rule
        }
    };
    
    // List of Control Actions
    class  TActionList          
    {
        constructor(){
            this.action = new TAction();
            this.next = new TActionList();
        }
    };
    
    // Control Rule
    class  TRule
    {
        constructor(){
            this.ID;                        // rule ID
            this.priority;                  // priority level
            this.firstPremise = new  TPremise() ;    // pointer to first premise of rule
            this.lastPremise = new  TPremise();     // pointer to last premise of rule
            this.thenActions = new  TAction();     // linked list of actions if true
            this.elseActions = new  TAction();     // linked list of actions if false
        }
    };
    
    //-----------------------------------------------------------------------------
    //  Shared variables
    //-----------------------------------------------------------------------------
    //struct   TRule*       Rules;           // array of control rules
    Rules = []
    //struct   TActionList* ActionList;      // linked list of control actions
    ActionList;
         InputState;                   // state of rule interpreter
         RuleCount;                    // total number of rules
      ControlValue;                 // value of controller variable
      SetPoint;                     // value of controller setpoint
    CurrentDate;                  // current date in whole days 
    CurrentTime;                  // current time of day (decimal)
    
    //-----------------------------------------------------------------------------
    //  External functions (declared in funcs.h)
    //-----------------------------------------------------------------------------
    //     controls_create
    //     controls_delete
    //     controls_addRuleClause
    //     controls_evaluate
    
    //=============================================================================
    // int n
     controls_create(n)
    //
    //  Input:   n = total number of control rules
    //  Output:  returns error code
    //  Purpose: creates an array of control rules.
    //
    {
        let r;
        ActionList = null;
        InputState = r_PRIORITY;
        RuleCount = n;
        if ( n == 0 ) return 0;
        //Rules = (struct TRule *) calloc(RuleCount, sizeof(struct TRule));
        for(let i = 0; i < RuleCount; i++){Rules.push(new TRule())}
        if (Rules == null) return ERR_MEMORY;
        for ( r=0; r<RuleCount; r++ )
        {
            Rules[r].ID = null;
            Rules[r].firstPremise = null;
            Rules[r].lastPremise = null;
            Rules[r].thenActions = null;
            Rules[r].elseActions = null;
            Rules[r].priority = 0.0;    
        }
        return 0;
    }
    
    //=============================================================================
    // void
    controls_delete()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: deletes all control rules.
    //
    {
       if ( RuleCount == 0 ) return;
       deleteActionList();
       deleteRules();
    }
    
    //=============================================================================
    // int r, int keyword, char* tok[], int nToks
     controls_addRuleClause(r, keyword, tok, nToks)
    //
    //  Input:   r = rule index
    //           keyword = the clause's keyword code (IF, THEN, etc.)
    //           tok = an array of string tokens that comprises the clause
    //           nToks = number of tokens
    //  Output:  returns an error  code
    //  Purpose: addd a new clause to a control rule.
    //
    {
        // return facilitators
        let returnObj;
        let returnVal;
    
        switch (keyword)
        {
          case r_RULE:
            if ( Rules[r].ID == null )
                Rules[r].ID = project_findID(CONTROL, tok[1]);
            InputState = r_RULE;
            if ( nToks > 2 ) return ERR_RULE;
            return 0;
    
          case r_IF:
            if ( InputState != r_RULE ) return ERR_RULE;
            InputState = r_IF;
            return addPremise(r, r_AND, tok, nToks);
    
          case r_AND:
            if ( InputState == r_IF ) return addPremise(r, r_AND, tok, nToks);
            else if ( InputState == r_THEN || InputState == r_ELSE )
                return addAction(r, tok, nToks);
            else return ERR_RULE;
    
          case r_OR:
            if ( InputState != r_IF ) return ERR_RULE;
            return addPremise(r, r_OR, tok, nToks);
    
          case r_THEN:
            if ( InputState != r_IF ) return ERR_RULE;
            InputState = r_THEN;
            return addAction(r, tok, nToks);
    
          case r_ELSE:
            if ( InputState != r_THEN ) return ERR_RULE;
            InputState = r_ELSE;
            return addAction(r, tok, nToks);
    
          case r_PRIORITY:
            if ( InputState != r_THEN && InputState != r_ELSE ) return ERR_RULE;
            InputState = r_PRIORITY;
            ////////////////////////////////////
            returnObj = {y: Rules[r].priority}
            returnVal = getDouble(tok[1], returnObj);
            Rules[r].priority = returnObj.y;
            ////////////////////////////////////
            if(!returnVal)
            //if ( !getDouble(tok[1], Rules[r].priority) ) 
                return ERR_NUMBER;
            if ( nToks > 2 ) return ERR_RULE;
            return 0;
        }
        return 0;
    }
    
    //=============================================================================
    // DateTime currentTime, DateTime elapsedTime, double tStep
    controls_evaluate(currentTime, elapsedTime, tStep)
    //
    //  Input:   currentTime = current simulation date/time
    //           elapsedTime = decimal days since start of simulation
    //           tStep = simulation time step (days)
    //  Output:  returns number of new actions taken
    //  Purpose: evaluates all control rules at current time of the simulation.
    //
    {
        let    r;                          // control rule index
        let    result;                     // true if rule premises satisfied
        //struct TPremise* p;                // pointer to rule premise clause
        //struct TAction*  a;                // pointer to rule action clause
        let p;
        let a;
    
        // --- save date and time to shared variables
        CurrentDate = Math.floor(currentTime);
        CurrentTime = currentTime - Math.floor(currentTime);
        ElapsedTime = elapsedTime;
    
        // --- evaluate each rule
        if ( RuleCount == 0 ) return 0;
        clearActionList();
        for (r=0; r<RuleCount; r++)
        {
            // --- evaluate rule's premises
            result = true;
            p = Rules[r].firstPremise;
            while (p)
            {
                if ( p.type == r_OR )
                {
                    if ( result == false )
                        result = evaluatePremise(p, tStep);
                }
                else
                {
                    if ( result == false ) break;
                    result = evaluatePremise(p, tStep);
                }
                p = p.next;
            }    
    
            // --- if premises true, add THEN clauses to action list
            //     else add ELSE clauses to action list
            if ( result == true ) a = Rules[r].thenActions;
            else                  a = Rules[r].elseActions;
            while (a)
            {
                updateActionValue(a, currentTime, tStep);
                updateActionList(a);
                a = a.next;
            }
        }
    
        // --- execute actions on action list
        if ( ActionList ) return executeActionList(currentTime);
        else return 0;
    }
    
    //=============================================================================
    // int r, int type, char* tok[], int nToks
     addPremise(r, type, tok, nToks)
    //
    //  Input:   r = control rule index
    //           type = type of premise (IF, AND, OR)
    //           tok = array of string tokens containing premise statement
    //           nToks = number of string tokens
    //  Output:  returns an error code
    //  Purpose: adds a new premise to a control rule.
    //
    {
        let relation, n, err = 0;
        let value = MISSING;
        //struct TPremise* p;
        //struct TVariable v1;
        //struct TVariable v2;
        let p// = new TPremise();
        let v1 = new TVariable();
        let v2 = new TVariable();
    
        // --- check for minimum number of tokens
        if ( nToks < 5 ) return ERR_ITEMS;
    
        // --- get LHS variable
        n = 1;
        err = getPremiseVariable(tok, n, v1);
        if ( err > 0 ) return err;
    
        // --- get relational operator
        n++;
        relation = findExactMatch(tok[n], RelOpWords);
        if ( relation < 0 ) return error_setInpError(ERR_KEYWORD, tok[n]);
        n++;
    
        // --- initialize RHS variable
        v2.attribute = -1;
        v2.link = -1;
        v2.node = -1;
    
        // --- check that more tokens remain
        if ( n >= nToks ) return error_setInpError(ERR_ITEMS, "");
            
        // --- see if a RHS variable is supplied
        if ( findmatch(tok[n], ObjectWords) >= 0 && n + 3 >= nToks )
        {
            err = getPremiseVariable(tok, n, v2);
            if ( err > 0 ) return ERR_RULE;
            if ( v1.attribute != v2.attribute)
                report_writeWarningMsg(WARN11, Rules[r].ID);
        }
    
        // --- otherwise get value to which LHS variable is compared to
        else
        {
            err = getPremiseValue(tok[n], v1.attribute, value);
            n++;
        }
        if ( err > 0 ) return err;
    
        // --- make sure another clause is not on same line
        if ( n < nToks && findmatch(tok[n], RuleKeyWords) >= 0 ) return ERR_RULE;
    
        // --- create the premise object
        //p = (struct TPremise *) malloc(sizeof(struct TPremise));
        p = new TPremise();
        if ( !p ) return ERR_MEMORY;
        p.type      = type;
        p.lhs   = v1;
        p.rhs   = v2;
        p.relation  = relation;
        p.value     = value;
        p.next      = null;
        if ( Rules[r].firstPremise == null )
        {
            Rules[r].firstPremise = p;
        }
        else
        {
            Rules[r].lastPremise.next = p;
        }
        Rules[r].lastPremise = p;
        return 0;
    }
    
    //=============================================================================
    // char* tok[], int* k, struct TVariable* v
    getPremiseVariable(tok, k, v)
    //
    //  Input:   tok = array of string tokens containing premise statement
    //           k = index of current token
    //  Output:  returns an error code; updates k to new current token and
    //           places identity of specified variable in v
    //  Purpose: parses a variable (e.g., Node 123 Depth) specified in a
    //           premise clause of a control rule.
    //
    {
        let    n = k;
        let    node = -1;
        let    link = -1;
        let    obj, attrib;
    
        // --- get object type
        obj = findmatch(tok[n], ObjectWords);
        if ( obj < 0 ) return error_setInpError(ERR_KEYWORD, tok[n]);
    
        // --- get object index from its name
        n++;
        switch (obj)
        {
          case r_NODE:
            node = project_findObject(NODE, tok[n]);
            if ( node < 0 ) return error_setInpError(ERR_NAME, tok[n]);
            break;
    
          case r_LINK:
          case r_CONDUIT:
          case r_PUMP:
          case r_ORIFICE:
          case r_WEIR:
          case r_OUTLET:
            link = project_findObject(LINK, tok[n]);
            if ( link < 0 ) return error_setInpError(ERR_NAME, tok[n]);
            break;
          default: n--;
        }
        n++;
    
        // --- get attribute index from its name
        attrib = findmatch(tok[n], AttribWords);
        if ( attrib < 0 ) return error_setInpError(ERR_KEYWORD, tok[n]);
    
        // --- check that attribute belongs to object type
        if ( obj == r_NODE ) switch (attrib)
        {
          case r_DEPTH:
          case r_HEAD:
          case r_VOLUME:
          case r_INFLOW: break;
          default: return error_setInpError(ERR_KEYWORD, tok[n]);
        }
    
        // --- check for link TIMEOPEN & TIMECLOSED attributes
        else if ( link >= 0  &&
                ( (attrib == r_TIMEOPEN ||
                   attrib == r_TIMECLOSED)
                ))
        {
     
        }
    
        else if ( obj == r_LINK || obj == r_CONDUIT ) switch (attrib)
        {
          case r_STATUS:
          case r_DEPTH:
          case r_FLOW: break;
          default: return error_setInpError(ERR_KEYWORD, tok[n]);
        }
        else if ( obj == r_PUMP ) switch (attrib)
        {
          case r_FLOW:
          case r_STATUS: break;
          default: return error_setInpError(ERR_KEYWORD, tok[n]);
        }
        else if ( obj == r_ORIFICE || obj == r_WEIR ||
                  obj == r_OUTLET ) switch (attrib)
        {
          case r_SETTING: break;
          default: return error_setInpError(ERR_KEYWORD, tok[n]);
        }
        else switch (attrib)
        {
          case r_TIME:
          case r_DATE:
          case r_CLOCKTIME:
          case r_DAY:
          case r_MONTH:
          case r_DAYOFYEAR: break;
          default: return error_setInpError(ERR_KEYWORD, tok[n]);
        }
    
        // --- populate variable structure
        v.node      = node;
        v.link      = link;
        v.attribute = attrib;
        k = n;
        return 0;
    }
    
    //=============================================================================
    //char* token, int attrib, double* value
    getPremiseValue(token, attrib, value)
    //
    //  Input:   token = a string token
    //           attrib = index of a node/link attribute
    //  Output:  value = attribute value;
    //           returns an error code;
    //  Purpose: parses the numerical value of a particular node/link attribute
    //           in the premise clause of a control rule.
    //
    {
        // return facilitators
        let returnObj;
        let returnVal;
    
        let   strDate = ''; 
        switch (attrib)
        {
          case r_STATUS:
            value = findmatch(token, StatusWords);
            if ( value < 0.0 ) value = findmatch(token, ConduitWords);
            if ( value < 0.0 ) return error_setInpError(ERR_KEYWORD, token);
            break;
    
          case r_TIME:
          case r_CLOCKTIME:
          case r_TIMEOPEN:
          case r_TIMECLOSED:
            ////////////////////////////////////
            let returnObj = {t: value}
            let returnVal = datetime_strToTime(token, returnObj);
            vaule = returnObj.t;
            ////////////////////////////////////
            if ( !returnVal )
            //if ( !datetime_strToTime(token, value) )
                return error_setInpError(ERR_DATETIME, token);
            break;
    
          case r_DATE:
            if ( !datetime_strToDate(token, value) )
                return error_setInpError(ERR_DATETIME, token);
            break;
    
          case r_DAY:
            ////////////////////////////////////
            returnObj = {y: value}
            returnVal = getDouble(token, returnObj);
            value = returnObj.y;
            ////////////////////////////////////
            if(!returnVal)
            //if ( !getDouble(token, value) ) 
                return error_setInpError(ERR_NUMBER, token);
            if ( value < 1.0 || value > 7.0 )
                 return error_setInpError(ERR_DATETIME, token);
            break;
    
          case r_MONTH:
            ////////////////////////////////////
            returnObj = {y: value}
            returnVal = getDouble(token, returnObj);
            value = returnObj.y;
            ////////////////////////////////////
            if(!returnVal)
            //if ( !getDouble(token, value) )
                return error_setInpError(ERR_NUMBER, token);
            if ( value < 1.0 || value > 12.0 )
                 return error_setInpError(ERR_DATETIME, token);
            break;
    
          case r_DAYOFYEAR:
            strncpy(strDate, token, 6);
            strDate += "/1947";
            if ( datetime_strToDate(strDate, value) )
            {
                value = datetime_dayOfYear(value);
            }
            else{
                ////////////////////////////////////
                returnObj = {y: value}
                returnVal = getDouble(token, returnObj);
                value = returnObj.y;
                ////////////////////////////////////
                if(!returnVal || value < 1 || value > 365 )
                //if ( !getDouble(token, value) || value < 1 || value > 365 )
                    return error_setInpError(ERR_DATETIME, token);
            } 
            break;
           
          default:
            ////////////////////////////////////
            returnObj = {y: value}
            returnVal = getDouble(token, returnObj);
            value = returnObj.y;
            ////////////////////////////////////
            if(!returnVal) 
            //if ( !getDouble(token, value) )
                return error_setInpError(ERR_NUMBER, token);
        }
        return 0;
    }
    
    //=============================================================================
    // int r, char* tok[], int nToks
     addAction(r, tok, nToks)
    //
    //  Input:   r = control rule index
    //           tok = array of string tokens containing action statement
    //           nToks = number of string tokens
    //  Output:  returns an error code
    //  Purpose: adds a new action to a control rule.
    //
    {
        let    obj, link, attrib;
        let    curve = -1, tseries = -1;
        let    n;
        let    err;
        let    values = [1.0, 0.0, 0.0];
    
        let a// = new TAction();
    
        // --- check for proper number of tokens
        if ( nToks < 6 ) return error_setInpError(ERR_ITEMS, "");
    
        // --- check for valid object type
        obj = findmatch(tok[1], ObjectWords);
        if ( obj != r_LINK && obj != r_CONDUIT && obj != r_PUMP && 
             obj != r_ORIFICE && obj != r_WEIR && obj != r_OUTLET )
            return error_setInpError(ERR_KEYWORD, tok[1]);
    
        // --- check that object name exists and is of correct type
        link = project_findObject(LINK, tok[2]);
        if ( link < 0 ) return error_setInpError(ERR_NAME, tok[2]);
        switch (obj)
        {
          case r_CONDUIT:
        if ( Link[link].type != CONDUIT )
            return error_setInpError(ERR_NAME, tok[2]);
        break;
          case r_PUMP:
            if ( Link[link].type != PUMP )
                return error_setInpError(ERR_NAME, tok[2]);
            break;
          case r_ORIFICE:
            if ( Link[link].type != ORIFICE )
                return error_setInpError(ERR_NAME, tok[2]);
            break;
          case r_WEIR:
            if ( Link[link].type != WEIR )
                return error_setInpError(ERR_NAME, tok[2]);
            break;
          case r_OUTLET:
            if ( Link[link].type != OUTLET )
                return error_setInpError(ERR_NAME, tok[2]);
            break;
        }
    
        // --- check for valid attribute name
        attrib = findmatch(tok[3], AttribWords);
        if ( attrib < 0 ) return error_setInpError(ERR_KEYWORD, tok[3]);
    
        // --- get control action setting
        if ( obj == r_CONDUIT )
        {
            if ( attrib == r_STATUS )
            {
                values[0] = findmatch(tok[5], ConduitWords);
                if ( values[0] < 0.0 )
                    return error_setInpError(ERR_KEYWORD, tok[5]);
            }
            else return error_setInpError(ERR_KEYWORD, tok[3]);
        }
    
        else if ( obj == r_PUMP )
        {
            if ( attrib == r_STATUS )
            {
                values[0] = findmatch(tok[5], StatusWords);
                if ( values[0] < 0.0 )
                    return error_setInpError(ERR_KEYWORD, tok[5]);
            }
            else if ( attrib == r_SETTING )
            {
                err = setActionSetting(tok, nToks, curve, tseries,
                                       attrib, values);
                if ( err > 0 ) return err;
            }
            else return error_setInpError(ERR_KEYWORD, tok[3]);
        }
    
        else if ( obj == r_ORIFICE || obj == r_WEIR || obj == r_OUTLET )
        {
            if ( attrib == r_SETTING )
            {
               err = setActionSetting(tok, nToks, curve, tseries,
                                      attrib, values);
               if ( err > 0 ) return err;
               if (  attrib == r_SETTING
               && (values[0] < 0.0 || values[0] > 1.0) ) 
                   return error_setInpError(ERR_NUMBER, tok[5]);
            }
            else return error_setInpError(ERR_KEYWORD, tok[3]);
        }
        else return error_setInpError(ERR_KEYWORD, tok[1]);
    
        // --- check if another clause is on same line
        n = 6;
        if ( curve >= 0 || tseries >= 0 ) n = 7;
        if ( attrib == r_PID ) n = 9;
        if ( n < nToks && findmatch(tok[n], RuleKeyWords) >= 0 ) return ERR_RULE;
    
        // --- create the action object
        //a = (struct TAction *) malloc(sizeof(struct TAction));
        a = new TAction();
        if ( !a ) return ERR_MEMORY;
        a.rule      = r;
        a.link      = link;
        a.attribute = attrib;
        a.curve     = curve;
        a.tseries   = tseries;
        a.value     = values[0];
        if ( attrib == r_PID )
        {
            a.kp = values[0];
            a.ki = values[1];
            a.kd = values[2];
            a.e1 = 0.0;
            a.e2 = 0.0;
        }
        if ( InputState == r_THEN )
        {
            a.next = Rules[r].thenActions;
            Rules[r].thenActions = a;
        }
        else
        {
            a.next = Rules[r].elseActions;
            Rules[r].elseActions = a;
        }
        return 0;
    }
    
    //=============================================================================
    // char* tok[], int nToks, int* curve, int* tseries,
    //     int* attrib, double values[]
     setActionSetting(tok, nToks, curve, tseries,
                           attrib, values)
    //
    //  Input:   tok = array of string tokens containing action statement
    //           nToks = number of string tokens
    //  Output:  curve = index of controller curve
    //           tseries = index of controller time series
    //           attrib = r_PID if PID controller used
    //           values = values of control settings
    //           returns an error code
    //  Purpose: identifies how control actions settings are determined.
    //
    {
        let k, m;
    
        // --- see if control action is determined by a Curve or Time Series
        if (nToks < 6) return error_setInpError(ERR_ITEMS, "");
        k = findmatch(tok[5], SettingTypeWords);
        if ( k >= 0 && nToks < 7 ) return error_setInpError(ERR_ITEMS, "");
        switch (k)
        {
    
        // --- control determined by a curve - find curve index
        case r_CURVE:
            m = project_findObject(CURVE, tok[6]);
            if ( m < 0 ) return error_setInpError(ERR_NAME, tok[6]);
            curve = m;
            break;
    
        // --- control determined by a time series - find time series index
        case r_TIMESERIES:
            m = project_findObject(TSERIES, tok[6]);
            if ( m < 0 ) return error_setInpError(ERR_NAME, tok[6]);
            tseries = m;
            Tseries[m].refersTo = CONTROL;
            break;
    
        // --- control determined by PID controller 
        case r_PID:
            if (nToks < 9) return error_setInpError(ERR_ITEMS, "");
            for (m=6; m<=8; m++)
            {
                ////////////////////////////////////
                returnObj = {y: values[m-6]}
                returnVal = getDouble(tok[m], returnObj);
                values[m-6] = returnObj.y;
                ////////////////////////////////////
                if(!returnVal) 
                //if ( !getDouble(tok[m], values[m-6]) )
                    return error_setInpError(ERR_NUMBER, tok[m]);
            }
            attrib = r_PID;
            break;
    
        // --- direct numerical control is used
        default:
            ////////////////////////////////////
            returnObj = {y: values[0]}
            returnVal = getDouble(tok[5], returnObj);
            values[0] = returnObj.y;
            ////////////////////////////////////
            if(!returnVal) 
            //if ( !getDouble(tok[5], values[0]) )
                return error_setInpError(ERR_NUMBER, tok[5]);
        }
        return 0;
    }
    
    //=============================================================================
    // struct TAction* a, DateTime currentTime, double dt
     updateActionValue(a, currentTime, dt)
    //
    //  Input:   a = an action object
    //           currentTime = current simulation date/time (days)
    //           dt = time step (days)
    //  Output:  none
    //  Purpose: updates value of actions found from Curves or Time Series.
    //
    {
        // ret facil
        let returnObj;
        let returnVal;
        
        if ( a.curve >= 0 )
        {
            a.value = table_lookup(Curve[a.curve], ControlValue);
        }
        else if ( a.tseries >= 0 )
        {
            ////////////////////////////////////
            returnObj = {table: Tseries[a.tseries]}
            returnVal = table_tseriesLookup(returnObj, currentTime, true);
            Tseries[a.tseries] = returnObj.table;
            ////////////////////////////////////
            a.value = returnVal;
            //a.value = table_tseriesLookup(Tseries[a.tseries], currentTime, true);
        }
        else if ( a.attribute == r_PID )
        {
            a.value = getPIDSetting(a, dt);
        }
    }
    
    //=============================================================================
    // struct TAction* a, double dt
    getPIDSetting(a, dt)
    //
    //  Input:   a = an action object
    //           dt = current time step (days)
    //  Output:  returns a new link setting 
    //  Purpose: computes a new setting for a link subject to a PID controller.
    //
    //  Note:    a.kp = gain coefficient,
    //           a.ki = integral time (minutes)
    //           a.k2 = derivative time (minutes)
    //           a.e1 = error from previous time step
    //           a.e2 = error from two time steps ago
    {
        let e0, setting;
        let p, i, d, update;
        let tolerance = 0.0001;
    
        // --- convert time step from days to minutes
        dt *= 1440.0;
    
        // --- determine relative error in achieving controller set point
        e0 = SetPoint - ControlValue;
        if ( Math.abs(e0) > TINY )
        {
            if ( SetPoint != 0.0 ) e0 = e0/SetPoint;
            else                   e0 = e0/ControlValue;
        }
    
        // --- reset previous errors to 0 if controller gets stuck
        if (Math.abs(e0 - a.e1) < tolerance)
        {
            a.e2 = 0.0;
            a.e1 = 0.0;
        }
    
        // --- use the recursive form of the PID controller equation to
        //     determine the new setting for the controlled link
        p = (e0 - a.e1);
        if ( a.ki == 0.0 ) i = 0.0;
        else i = e0 * dt / a.ki;
        d = a.kd * (e0 - 2.0*a.e1 + a.e2) / dt;
        update = a.kp * (p + i + d);
        if ( Math.abs(update) < tolerance ) update = 0.0;
        setting = Link[a.link].targetSetting + update;
    
        // --- update previous errors
        a.e2 = a.e1;
        a.e1 = e0;
    
        // --- check that new setting lies within feasible limits
        if ( setting < 0.0 ) setting = 0.0;
        if (Link[a.link].type != PUMP && setting > 1.0 ) setting = 1.0;
        return setting;
    }
    
    //=============================================================================
    // struct TAction* a
    updateActionList(a)
    //
    //  Input:   a = an action object
    //  Output:  none
    //  Purpose: adds a new action to the list of actions to be taken.
    //
    {
        //struct TActionList* listItem;
        //struct TAction* a1;
        let listItem;
        let a1;
        let priority = Rules[a.rule].priority;
    
        // --- check if link referred to in action is already listed
        listItem = ActionList;
        while ( listItem )
        {
            a1 = listItem.action;
            if ( !a1 ) break;
            if ( a1.link == a.link )
            {
                // --- replace old action if new action has higher priority
                if ( priority > Rules[a1.rule].priority ) listItem.action = a;
                return;
            }
            listItem = listItem.next;
        }
    
        // --- action not listed so add it to ActionList
        if ( !listItem )
        {
            //listItem = (struct TActionList *) malloc(sizeof(struct TActionList));
            listItem = new TActionList()
            listItem.next = ActionList;
            ActionList = listItem;
        }
        listItem.action = a;
    }
    
    //=============================================================================
    // DateTime currentTime
    executeActionList(currentTime)
    //
    //  Input:   currentTime = current date/time of the simulation
    //  Output:  returns number of new actions taken
    //  Purpose: executes all actions required by fired control rules.
    //
    {
        //struct TActionList* listItem;
        //struct TActionList* nextItem;
        //struct TAction* a1;
        let listItem;
        let nextItem;
        let a1;
        let count = 0;
    
        listItem = ActionList;
        while ( listItem )
        {
            a1 = listItem.action;
            if ( !a1 ) break;
            if ( a1.link >= 0 )
            {
                if ( Link[a1.link].targetSetting != a1.value )
                {
                    Link[a1.link].targetSetting = a1.value;
                    if ( RptFlags.controls && a1.curve < 0 
                         && a1.tseries < 0 && a1.attribute != r_PID )
                        report_writeControlAction(currentTime, Link[a1.link].ID,
                                                  a1.value, Rules[a1.rule].ID);
                    count++;
                }
            }
            nextItem = listItem.next;
            listItem = nextItem;
        }
        return count;
    }
    
    //=============================================================================
    // struct TPremise* p, double tStep
    evaluatePremise(p, tStep)
    //
    //  Input:   p = a control rule premise condition
    //           tStep = current time step (days)
    //  Output:  returns true if the condition is true or false otherwise
    //  Purpose: evaluates the truth of a control rule premise condition.
    //
    {
        let lhsValue, rhsValue;
        let    result = false;
    
        lhsValue = getVariableValue(p.lhsVar);
        if ( p.value == MISSING ) rhsValue = getVariableValue(p.rhsVar);
        else                       rhsValue = p.value;
        if ( lhsValue == MISSING || rhsValue == MISSING ) return false;
        switch (p.lhsVar.attribute)
        {
        case r_TIME:
        case r_CLOCKTIME:
            return compareTimes(lhsValue, p.relation, rhsValue, tStep/2.0); 
        case r_TIMEOPEN:
        case r_TIMECLOSED:
            result = compareTimes(lhsValue, p.relation, rhsValue, tStep/2.0);
            ControlValue = lhsValue * 24.0;  // convert time from days to hours
            return result;
        default:
            return compareValues(lhsValue, p.relation, rhsValue);
        }
    }
    
    //=============================================================================
    // struct TVariable v
    getVariableValue(v)
    {
        let i = v.node;
        let j = v.link;
    
        switch ( v.attribute )
        {
          case r_TIME:
            return ElapsedTime;
            
          case r_DATE:
            return CurrentDate;
    
          case r_CLOCKTIME:
            return CurrentTime;
    
          case r_DAY:
            return datetime_dayOfWeek(CurrentDate);
    
          case r_MONTH:
            return datetime_monthOfYear(CurrentDate);
    
          case r_DAYOFYEAR:
            return datetime_dayOfYear(CurrentDate);
    
          case r_STATUS:
            if ( j < 0 ||
                (Link[j].type != CONDUIT && Link[j].type != PUMP) ) return MISSING;
            else return Link[j].setting;
            
          case r_SETTING:
            if ( j < 0 || (Link[j].type != ORIFICE && Link[j].type != WEIR) )
                return MISSING;
            else return Link[j].setting;
    
          case r_FLOW:
            if ( j < 0 ) return MISSING;
            else return Link[j].direction*Link[j].newFlow*UCF(FLOW);
    
          case r_DEPTH:
            if ( j >= 0 ) return Link[j].newDepth*UCF(LENGTH);
            else if ( i >= 0 )
                return Node[i].newDepth*UCF(LENGTH);
            else return MISSING;
    
          case r_HEAD:
            if ( i < 0 ) return MISSING;
            return (Node[i].newDepth + Node[i].invertElev) * UCF(LENGTH);
    
          case r_VOLUME:
            if ( i < 0 ) return MISSING;
            return (Node[i].newVolume * UCF(VOLUME));
    
          case r_INFLOW:
            if ( i < 0 ) return MISSING;
            else return Node[i].newLatFlow*UCF(FLOW);
    
          case r_TIMEOPEN:
              if ( j < 0 ) return MISSING;
              if ( Link[j].setting <= 0.0 ) return MISSING;
              return CurrentDate + CurrentTime - Link[j].timeLastSet;
    
          case r_TIMECLOSED:
              if ( j < 0 ) return MISSING;
              if ( Link[j].setting > 0.0 ) return MISSING;
              return CurrentDate + CurrentTime - Link[j].timeLastSet;
    
          default: return MISSING;
        }
    }
    
    //=============================================================================
    // double lhsValue, int relation, double rhsValue, double halfStep
    compareTimes(lhsValue, relation, rhsValue, halfStep)
    //
    //  Input:   lhsValue = date/time value on left hand side of relation
    //           relation = relational operator code (see RuleRelation enumeration)
    //           rhsValue = date/time value on right hand side of relation 
    //           halfStep = 1/2 the current time step (days)
    //  Output:  returns true if time relation is satisfied
    //  Purpose: evaluates the truth of a relation between two date/times.
    //
    {
        if ( relation == EQ )
        {
            if ( lhsValue >= rhsValue - halfStep
            &&   lhsValue < rhsValue + halfStep ) return true;
            return false;
        }
        else if ( relation == NE )
        {
            if ( lhsValue < rhsValue - halfStep
            ||   lhsValue >= rhsValue + halfStep ) return true;
            return false;
        }
        else return compareValues(lhsValue, relation, rhsValue);
    }
    
    //=============================================================================
    // double lhsValue, int relation, double rhsValue
    compareValues(lhsValue, relation, rhsValue)
    //  Input:   lhsValue = value on left hand side of relation
    //           relation = relational operator code (see RuleRelation enumeration)
    //           rhsValue = value on right hand side of relation 
    //  Output:  returns true if relation is satisfied
    //  Purpose: evaluates the truth of a relation between two values.
    {
        SetPoint = rhsValue;
        ControlValue = lhsValue;
        switch (relation)
        {
          case EQ: if ( lhsValue == rhsValue ) return true; break;
          case NE: if ( lhsValue != rhsValue ) return true; break;
          case LT: if ( lhsValue <  rhsValue ) return true; break;
          case LE: if ( lhsValue <= rhsValue ) return true; break;
          case GT: if ( lhsValue >  rhsValue ) return true; break;
          case GE: if ( lhsValue >= rhsValue ) return true; break;
        }
        return false;
    }
    
    //=============================================================================
    // void
    clearActionList()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: clears the list of actions to be executed.
    //
    {
        //struct TActionList* listItem;
        let listItem;
        listItem = ActionList;
        while ( listItem )
        {
            listItem.action = null;
            listItem = listItem.next;
        }
    }
    
    //=============================================================================
    // void
     deleteActionList()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: frees the memory used to hold the list of actions to be executed.
    //
    {
        //struct TActionList* listItem;
        //struct TActionList* nextItem;
        let listItem;
        let nextItem;
        listItem = ActionList;
        while ( listItem )
        {
            nextItem = listItem.next;
            listItem = null;
            listItem = nextItem;
        }
        ActionList = null;
    }
    
    //=============================================================================
    // void
     deleteRules()
    //
    //  Input:   none
    //  Output:  none
    //  Purpose: frees the memory used for all of the control rules.
    //
    {
       //struct TPremise* p;
       //struct TPremise* pnext;
       //struct TAction*  a;
       //struct TAction*  anext;
       let p;
       let pnext;
       let a;
       let anext;
       let r;
    
       for (r=0; r<RuleCount; r++)
       {
          p = Rules[r].firstPremise;
          while ( p )
          {
             pnext = p.next;
             p = null;
             p = pnext;
          }
          a = Rules[r].thenActions;
          while (a )
          {
             anext = a.next;
             a = null;
             a = anext;
          }
          a = Rules[r].elseActions;
          while (a )
          {
             anext = a.next;
             a = null;
             a = anext;
          }
       }
       FREE(Rules);
       RuleCount = 0;
    }
    
    //=============================================================================
    // char *s, char *keyword[]
     findExactMatch(s, keyword)
    //
    //  Input:   s = character string
    //           keyword = array of keyword strings
    //  Output:  returns index of keyword which matches s or -1 if no match found  
    //  Purpose: finds exact match between string and array of keyword strings.
    //
    {
       let i = 0;
       while (keyword[i] != null)
       {
          if ( strcomp(s, keyword[i]) ) return(i);
          i++;
       }
       return(-1);
    }
    
    //=============================================================================
    
//-----------------------------------------------------------------------------
//   project.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/19/14  (Build 5.1.000)
//             04/14/14  (Build 5.1.004)
//             09/15/14  (Build 5.1.007)
//             03/19/15  (Build 5.1.008)
//             04/30/15  (Build 5.1.009)
//             08/01/16  (Build 5.1.011)
//             03/14/17  (Build 5.1.012)
//             05/10/18  (Build 5.1.013)
//             04/01/20  (Build 5.1.015)
//   Author:   L. Rossman
//
//   Project management functions.
//
//   This module provides project-related services such as:
//   o opening a new project and reading its input data
//   o allocating and freeing memory for project objects
//   o setting default values for object properties and options
//   o initializing the internal state of all objects
//   o managing hash tables for identifying objects by ID name
//
//   Build 5.1.004:
//   - Ignore RDII option added.
//
//   Build 5.1.007:
//   - Default monthly adjustments for climate variables included.
//   - User-supplied GW flow equations initialized to null.
//   - Storage node exfiltration object initialized to null.
//   - Freeing of memory used for storage node exfiltration included.
//
//   Build 5.1.008:
//   - Constants used for dynamic wave routing moved to dynwave.c.
//   - Input processing of minimum time step & number of
//     parallel threads for dynamic wave routing added.
//   - Default values of hyd. conductivity adjustments added.
//   - Freeing of memory used for outfall pollutant load added.
//
//   Build 5.1.009:
//   - Fixed bug in computing total duration introduced in 5.1.008.
//
//   Build 5.1.011:
//   - Memory management of hydraulic event dates array added.
//
//   Build 5.1.012:
//   - Minimum conduit slope option initialized to 0 (none).
//   - NO/YES no longer accepted as options for NORMAL_FLOW_LIMITED.
//
//   Build 5.1.013:
//   - omp_get_num_threads protected against lack of compiler
//     support for OpenMP.
//   - Rain gage validation now performed after subcatchment validation.
//   - More robust parsing of MinSurfarea option provided.
//   - Support added for new RuleStep analysis option.
//
//   Build 5.1.015: 
//   - Support added for multiple infiltration methods within a project.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
Htable = new Array(MAX_OBJ_TYPES); // Hash tables for object ID names
MemPoolAllocated;      // true if memory pool allocated 
root = new alloc_root_t();
/*
**  root - Pointer to the current pool.
*/
//static alloc_root_t *root;
//class alloc_root_s
//{
    //alloc_hdr_t *first,    /* First header in pool */
    //            *current;  /* Current header       */
//    constructor(){
//        this.first;
////        this.current;
//    }
//}  //alloc_root_t;

//class alloc_root_t
//{
//    constructor(){
//        this.first;
//        this.current;
//   }
//}  

/*
**  alloc_hdr_t - Header for each block of memory.
*/

//class alloc_hdr_s
//{
    //struct alloc_hdr_s *next;   /* Next Block          */
    //char               *block,  /* Start of block      */
    //                   *free,   /* Next free in block  */
    //                   *end;    /* block + block size  */
//    constructor(){
//        this.next;
//        this.block;
//        this.free;
//        this.end;
//    }
//}  //alloc_hdr_t;

//class alloc_hdr_t
//{
//    constructor(){
//        this.next;
//        this.block;
//        this.free;
////        this.end;
 //   }
//} 

//-----------------------------------------------------------------------------
//  External Functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  project_open           (called from swmm_open in swmm5.c)
//  project_close          (called from swmm_close in swmm5.c)
//  project_readInput      (called from swmm_open in swmm5.c)
//  project_readOption     (called from readOption in input.c)
//  project_validate       (called from swmm_open in swmm5.c)
//  project_init           (called from swmm_start in swmm5.c)
//  project_addObject      (called from addObject in input.c)
//  project_createMatrix   (called from openFileForInput in iface.c)
//  project_freeMatrix     (called from iface_closeRoutingFiles)
//  project_findObject
//  project_findID

//=============================================================================

project_open(f1, f2, f3)
//
//  Input:   f1 = pointer to name of input file
//           f2 = pointer to name of report file
//           f3 = pointer to name of binary output file
//  Output:  none
//  Purpose: opens a new SWMM project.
//
{
    initPointers();
    setDefaults();
    openFiles(f1, f2, f3);
}

//=============================================================================

project_readInput()
//
//  Input:   none
//  Output:  none
//  Purpose: retrieves project data from input file.
//
{
    // --- create hash tables for fast retrieval of objects by ID names
    createHashTables();

    // --- count number of objects in input file and create them
    input_countObjects();
    createObjects();

    // --- read project data from input file
    input_readData();
    if ( ErrorCode ) return;

    // --- establish starting & ending date/time
    StartDateTime = StartDate + StartTime;
    EndDateTime   = EndDate + EndTime;
    ReportStart   = ReportStartDate + ReportStartTime;
    ReportStart   = Math.max(ReportStart, StartDateTime);

    // --- check for valid starting & ending date/times
    if ( EndDateTime <= StartDateTime )
    {
        report_writeErrorMsg(ERR_START_DATE, "");
    }
    else if ( EndDateTime <= ReportStart )
    {
        report_writeErrorMsg(ERR_REPORT_DATE, "");
    }
    else
    {
        // --- compute total duration of simulation in seconds
        TotalDuration = Math.floor((EndDateTime - StartDateTime) * SECperDAY);

        // --- reporting step must be <= total duration
        if ( ReportStep > TotalDuration )
        {
            ReportStep = TotalDuration;
        }

        // --- reporting step can't be < routing step
        if ( ReportStep < RouteStep )
        {
            report_writeErrorMsg(ERR_REPORT_STEP, "");
        }

        // --- convert total duration to milliseconds
        TotalDuration *= 1000.0;
    }
}

//=============================================================================

project_validate()
//
//  Input:   none
//  Output:  none
//  Purpose: checks validity of project data.
//
{
    let i;
    let j;
    let err;

    // --- validate Curves and TimeSeries
    for ( i=0; i<Nobjects[CURVE]; i++ )
    {
         err = table_validate(Curve[i]);
         if ( err ) report_writeErrorMsg(ERR_CURVE_SEQUENCE, Curve[i].ID);
    }
    for ( i=0; i<Nobjects[TSERIES]; i++ )
    {
        err = table_validate(Tseries[i]);
        if ( err ) report_writeTSeriesErrorMsg(err, Tseries[i]);
    }

    // --- validate hydrology objects
    //     (NOTE: order is important !!!!)
    climate_validate();
    lid_validate();
    if ( Nobjects[SNOWMELT] == 0 ) IgnoreSnowmelt = true;
    if ( Nobjects[AQUIFER]  == 0 ) IgnoreGwater   = true;
    for ( i=0; i<Nobjects[AQUIFER]; i++ )  gwater_validateAquifer(i);
    for ( i=0; i<Nobjects[SUBCATCH]; i++ ) subcatch_validate(i);
    for ( i=0; i<Nobjects[GAGE]; i++ )     gage_validate(i);                   //(5.1.013)
    for ( i=0; i<Nobjects[SNOWMELT]; i++ ) snow_validateSnowmelt(i);

    // --- compute geometry tables for each shape curve
    j = 0;
    for ( i=0; i<Nobjects[CURVE]; i++ )
    {
        if ( Curve[i].curveType == SHAPE_CURVE )
        {
            Curve[i].refersTo = j;
            Shape[j].curve = i;
            if ( !shape_validate(Shape[j], Curve[i]) )
                report_writeErrorMsg(ERR_CURVE_SEQUENCE, Curve[i].ID);
            j++;
        }
    }

    // --- validate links before nodes, since the latter can
    //     result in adjustment of node depths
    for ( i=0; i<Nobjects[NODE]; i++) Node[i].oldDepth = Node[i].fullDepth;
    for ( i=0; i<Nobjects[LINK]; i++) link_validate(i);
    for ( i=0; i<Nobjects[NODE]; i++) node_validate(i);

    // --- adjust time steps if necessary
    if ( DryStep < WetStep )
    {
        report_writeWarningMsg(WARN06, "");
        DryStep = WetStep;
    }
    if ( RouteStep > WetStep )
    {
        report_writeWarningMsg(WARN07, "");
        RouteStep = WetStep;
    }

    // --- adjust individual reporting flags to match global reporting flag
    if ( RptFlags.subcatchments == ALL )
        for (i=0; i<Nobjects[SUBCATCH]; i++) Subcatch[i].rptFlag = true;
    if ( RptFlags.nodes == ALL )
        for (i=0; i<Nobjects[NODE]; i++) Node[i].rptFlag = true;
    if ( RptFlags.links == ALL )
        for (i=0; i<Nobjects[LINK]; i++) Link[i].rptFlag = true;

    // --- validate dynamic wave options
    //if ( RouteModel == DW ) dynwave_validate();

    if ( Nobjects[LINK] < 4 * NumThreads ) NumThreads = 1;                     //(5.1.008)

}

//=============================================================================

project_close()
//
//  Input:   none
//  Output:  none
//  Purpose: closes a SWMM project.
//
{
    deleteObjects();
    deleteHashTables();
}

//=============================================================================

 project_init()
//
//  Input:   none
//  Output:  returns an error code
//  Purpose: initializes the internal state of all objects.
// 
{
    let j;
    climate_initState();
    lid_initState();
    for (j=0; j<Nobjects[TSERIES]; j++)  table_tseriesInit(Tseries[j]);
    for (j=0; j<Nobjects[GAGE]; j++)     gage_initState(j);
    for (j=0; j<Nobjects[SUBCATCH]; j++) subcatch_initState(j);
    for (j=0; j<Nobjects[NODE]; j++)     node_initState(j);
    for (j=0; j<Nobjects[LINK]; j++)     link_initState(j);
    return ErrorCode;
}

//=============================================================================

project_addObject(type,  id, n)
//
//  Input:   type = object type
//           id   = object ID string
//           n    = object index
//  Output:  returns 0 if object already added, 1 if not, -1 if hashing fails
//  Purpose: adds an object ID to a hash table
//
{
    let  result;
    let  len;
    let  newID;

    if(type == 13){
        let x = 0;
    }

    // --- do nothing if object already placed in hash table
    if ( project_findObject(type, id) >= 0 ) return 0;

    // --- use memory from the hash tables' common memory pool to store
    //     a copy of the object's ID string
    newID = id;

    // --- insert object's ID into the hash table for that type of object
    result = HTinsert(Htable[type], newID, n);
    if ( result == 0 ) result = -1;
    return result;
}

//=============================================================================

project_findObject(type, id)
//
//  Input:   type = object type
//           id   = object ID
//  Output:  returns index of object with given ID, or -1 if ID not found
//  Purpose: uses hash table to find index of an object with a given ID.
//
{
    return HTfind(Htable[type], id);
}

//=============================================================================

project_findID(type, id)
//
//  Input:   type = object type
//           id   = ID name being sought
//  Output:  returns pointer to location where object's ID string is stored
//  Purpose: uses hash table to find address of given string entry.
//
{
    return HTfindKey(Htable[type], id);
}

//=============================================================================

project_createMatrix(nrows, ncols)
//
//  Input:   nrows = number of rows (0-based)
//           ncols = number of columns (0-based)
//  Output:  returns a pointer to a matrix
//  Purpose: allocates memory for a matrix of doubles.
//
{
    let i,j;
    let a;

    // --- allocate pointers to rows
    a = new Array(nrows);
    
    // --- allocate rows and set pointers to them
    for ( i = 1; i < nrows; i++ ) a[i] = a[i-1] + ncols;

    for ( i = 0; i < nrows; i++)
    {
        for ( j = 0; j < ncols; j++) a[i][j] = 0.0;
    }
    
    // --- return pointer to array of pointers to rows
    return a;
}

//=============================================================================

project_freeMatrix(a)
//
//  Input:   a = matrix of floats
//  Output:  none
//  Purpose: frees memory allocated for a matrix of doubles.
//
{
    a = null;
}

//=============================================================================

project_readOption(s1, s2)
//
//  Input:   s1 = option keyword
//           s2 = string representation of option's value
//  Output:  returns error code
//  Purpose: reads a project option from a pair of string tokens.
//
//  NOTE:    all project options have default values assigned in setDefaults().
//
{
    let k, m, h, s;
    let tStep;
    let strDate;
    let aTime;
    let aDate;

    //return facilitators
    let returnObj;
    let returnVal;

    // --- determine which option is being read
    k = findmatch(s1, OptionWords);
    if ( k < 0 ) return error_setInpError(ERR_KEYWORD, s1);
    switch ( k )
    {
      // --- choice of flow units
      case FLOW_UNITS:
        m = findmatch(s2, FlowUnitWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, s2);
        FlowUnits = m;
        if ( FlowUnits <= MGD ) UnitSystem = US;
        else                    UnitSystem = SI;
        break;

      // --- choice of infiltration modeling method
      case INFIL_MODEL:
        m = findmatch(s2, InfilModelWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, s2);
        InfilModel = m;
        break;

      // --- choice of flow routing method
      case ROUTE_MODEL:
        m = findmatch(s2, RouteModelWords);
        if ( m < 0 ) m = findmatch(s2, OldRouteModelWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, s2);
        if ( m == NO_ROUTING ) IgnoreRouting = true;
        else RouteModel = m;
        if ( RouteModel == EKW ) RouteModel = KW;
        break;

      // --- simulation start date
      case START_DATE:

        ////////////////////////////////////
        returnObj = {d: StartDate}
        returnVal = datetime_strToDate(s2, returnObj);
        StartDate = returnObj.d;
        ////////////////////////////////////
        if ( !returnVal)
        {
            return error_setInpError(ERR_DATETIME, s2);
        }
        break;

      // --- simulation start time of day
      case START_TIME:
        ////////////////////////////////////
        returnObj = {t: StartTime}
        returnVal = datetime_strToTime(s2, returnObj);
        StartTime = returnObj.t;
        ////////////////////////////////////
        //if ( (StartTime = datetime_strToTime(s2, StartTime)) == null)
        if(!returnVal)
        {
            return error_setInpError(ERR_DATETIME, s2);
        }
        break;

      // --- simulation ending date
      case END_DATE:
        ////////////////////////////////////
        returnObj = {d: EndDate}
        returnVal = datetime_strToDate(s2, returnObj);
        EndDate = returnObj.d;
        ////////////////////////////////////
        if (!returnVal) 
        {
            return error_setInpError(ERR_DATETIME, s2);
        }
        break;

      // --- simulation ending time of day
      case END_TIME:
        ////////////////////////////////////
        returnObj = {t: EndTime}
        returnVal = datetime_strToTime(s2, returnObj);
        EndTime = returnObj.t;
        ////////////////////////////////////
        //if ( (EndTime = datetime_strToTime(s2, EndTime)) == null)
        if(!returnVal)
        {
            return error_setInpError(ERR_DATETIME, s2);
        }
        break;

      // --- reporting start date
      case REPORT_START_DATE:
        ////////////////////////////////////
        returnObj = {d: ReportStartDate}
        returnVal = datetime_strToDate(s2, returnObj);
        ReportStartDate = returnObj.d;
        ////////////////////////////////////
        //if ( (ReportStartDate = datetime_strToDate(s2, ReportStartDate)) == null)
        if(!returnVal)
        {
            return error_setInpError(ERR_DATETIME, s2);
        }
        break;

      // --- reporting start time of day
      case REPORT_START_TIME:
        ////////////////////////////////////
        returnObj = {t: ReportStartTime}
        returnVal = datetime_strToTime(s2, returnObj);
        ReportStartTime = returnObj.t;
        ////////////////////////////////////
        //if ( (ReportStartTime = datetime_strToTime(s2, ReportStartTime)) == null)
        if(!returnVal)
        {
            return error_setInpError(ERR_DATETIME, s2);
        }
        break;

      // --- day of year when street sweeping begins or when it ends
      //     (year is arbitrarily set to 1947 so that the dayOfYear
      //      can be applied)
      case SWEEP_START:
      case SWEEP_END:
        strDate = s2;
        strDate += "/1947";
        ////////////////////////////////////
        returnObj = {d: aDate}
        returnVal = datetime_strToDate(strDate, returnObj);
        aDate = returnObj.d;
        ////////////////////////////////////
        if ( !returnVal )
        {
            return error_setInpError(ERR_DATETIME, s2);
        }
        m = datetime_dayOfYear(aDate);
        if ( k == SWEEP_START ) SweepStart = m;
        else SweepEnd = m;
        break;

      // --- number of antecedent dry days
      case START_DRY_DAYS:
        StartDryDays = parseFloat(s2);
        if ( StartDryDays < 0.0 )
        {
            return error_setInpError(ERR_NUMBER, s2);
        }
        break;

      // --- runoff or reporting time steps
      //     (input is in hrs:min:sec format, time step saved as seconds)
      case WET_STEP:
      case DRY_STEP:
      case REPORT_STEP:
      case RULE_STEP:                                                          //(5.1.013)
        ////////////////////////////////////
        returnObj = {t: aTime}
        returnVal = datetime_strToTime(s2, returnObj);
        aTime = returnObj.t;
        ////////////////////////////////////
        //if ( (tStep = datetime_strToTime(s2, aTime)) == null)
        if(!returnVal)
        {
            return error_setInpError(ERR_NUMBER, s2);
        }
        //datetime_decodeTime(aTime, h, m, s);
        ////////////////////////////////////
        returnObj = {h: h, m: m, s: s}
        datetime_decodeTime(aTime, returnObj);
        h = returnObj.h;
        m = returnObj.m;
        s = returnObj.s;
        ////////////////////////////////////
        h += 24*Math.floor(aTime);
        s = s + 60*m + 3600*h;

        // --- RuleStep allowed to be 0 while other time steps must be > 0     //(5.1.013)
        if (k == RULE_STEP)                                                    //      
        {                                                                      //
            if (s < 0) return error_setInpError(ERR_NUMBER, s2);               //
        }                                                                      //
        else if ( s <= 0 ) return error_setInpError(ERR_NUMBER, s2);           //

        switch ( k )
        {
          case WET_STEP:     WetStep = s;     break;
          case DRY_STEP:     DryStep = s;     break;
          case REPORT_STEP:  ReportStep = s;  break;
          case RULE_STEP:    RuleStep = s;    break;                           //(5.1.013)
        }
        break;

      // --- type of damping applied to inertial terms of dynamic wave routing
      case INERT_DAMPING:
        m = findmatch(s2, InertDampingWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, s2);
        else InertDamping = m;
        break;

      // --- Yes/No options (NO = 0, YES = 1)
      case ALLOW_PONDING:
      case SLOPE_WEIGHTING:
      case SKIP_STEADY_STATE:
      case IGNORE_RAINFALL:
      case IGNORE_SNOWMELT:
      case IGNORE_GWATER:
      case IGNORE_ROUTING:
      case IGNORE_QUALITY:
      case IGNORE_RDII:
        m = findmatch(s2, NoYesWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, s2);
        switch ( k )
        {
          case ALLOW_PONDING:     AllowPonding    = m;  break;
          case SLOPE_WEIGHTING:   SlopeWeighting  = m;  break;
          case SKIP_STEADY_STATE: SkipSteadyState = m;  break;
          case IGNORE_RAINFALL:   IgnoreRainfall  = m;  break;
          case IGNORE_SNOWMELT:   IgnoreSnowmelt  = m;  break;
          case IGNORE_GWATER:     IgnoreGwater    = m;  break;
          case IGNORE_ROUTING:    IgnoreRouting   = m;  break;
          case IGNORE_QUALITY:    IgnoreQuality   = m;  break;
          case IGNORE_RDII:       IgnoreRDII      = m;  break;
        }
        break;

      case NORMAL_FLOW_LTD: 
        m = findmatch(s2, NormalFlowWords); 
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, s2);
        NormalFlowLtd = m;
        break;

      case FORCE_MAIN_EQN:
        m = findmatch(s2, ForceMainEqnWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, s2);
        ForceMainEqn = m;
        break;

      case LINK_OFFSETS:
        m = findmatch(s2, LinkOffsetWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, s2);
        LinkOffsets = m;
        break;

      // --- compatibility option for selecting solution method for
      //     dynamic wave flow routing (NOT CURRENTLY USED)
      case COMPATIBILITY:
        if      ( strcomp(s2, "3") ) Compatibility = SWMM3;
        else if ( strcomp(s2, "4") ) Compatibility = SWMM4;
        else if ( strcomp(s2, "5") ) Compatibility = SWMM5;
        else return error_setInpError(ERR_KEYWORD, s2);
        break;

      // --- routing or lengthening time step (in decimal seconds)
      //     (lengthening time step is used in Courant stability formula
      //     to artificially lengthen conduits for dynamic wave flow routing
      //     (a value of 0 means that no lengthening is used))
      case ROUTE_STEP:
      case LENGTHENING_STEP:
        //if ( (tStep = getDouble(s2, tStep)) == null )
        if(s2.includes(':'))
        {
            ////////////////////////////////////
            returnObj = {t: aTime}
            returnVal = datetime_strToTime(s2, returnObj);
            aTime = returnObj.t;
            ////////////////////////////////////
            //if ( (tStep = datetime_strToTime(s2, aTime)) == null)
            if(!returnVal)
            {
                return error_setInpError(ERR_NUMBER, s2);
            }
            else
            {
                //datetime_decodeTime(aTime, h, m, s);
                ////////////////////////////////////
                returnObj = {h: h, m: m, s: s}
                datetime_decodeTime(aTime, returnObj);
                h = returnObj.h;
                m = returnObj.m;
                s = returnObj.s;
                ////////////////////////////////////
                h += 24*Math.floor(aTime);
                s = s + 60*m + 3600*h;
                tStep = s;
            }
        } else {
            ////////////////////////////////////
            returnObj = {y: tStep}
            returnVal = getDouble(s2, returnObj);
            tStep = returnObj.y;
            ////////////////////////////////////
        }
        if ( k == ROUTE_STEP )
        {
            if ( tStep <= 0.0 ) return error_setInpError(ERR_NUMBER, s2);
            RouteStep = tStep;
        }
        else LengtheningStep = MAX(0.0, tStep);
        break;

     // --- minimum variable time step for dynamic wave routing
      case MIN_ROUTE_STEP:
        ////////////////////////////////////
        returnObj = {y: MinRouteStep}
        returnVal = getDouble(s2, returnObj);
        MinRouteStep = returnObj.y;
        ////////////////////////////////////
        if ( !returnVal || MinRouteStep < 0.0 )
        //if ( !getDouble(s2, &MinRouteStep) || MinRouteStep < 0.0 )
            return error_setInpError(ERR_NUMBER, s2);
        break;

      case NUM_THREADS:
        m = parseInt(s2);
        if ( m < 0 ) return error_setInpError(ERR_NUMBER, s2);
        NumThreads = m;
        break;

      // --- safety factor applied to variable time step estimates under
      //     dynamic wave flow routing (value of 0 indicates that variable
      //     time step option not used)
      case VARIABLE_STEP:
        ////////////////////////////////////
        returnObj = {y: CourantFactor}
        returnVal = getDouble(s2, returnObj);
        CourantFactor = returnObj.y;
        ////////////////////////////////////
        if ( !returnVal )
        //if ( (CourantFactor = getDouble(s2)) == null )
            return error_setInpError(ERR_NUMBER, s2);
        if ( CourantFactor < 0.0 || CourantFactor > 2.0 )
            return error_setInpError(ERR_NUMBER, s2);
        break;

      // --- minimum surface area (ft2 or sq. meters) associated with nodes
      //     under dynamic wave flow routing 
      case MIN_SURFAREA:
        ////////////////////////////////////
        returnObj = {y: MinSurfArea}
        returnVal = getDouble(s2, returnObj);
        MinSurfArea = returnObj.y;
        ////////////////////////////////////
        if ( !returnVal )
        //if ((MinSurfArea = getDouble(s2)) == null)                                     //(5.1.013)
            return error_setInpError(ERR_NUMBER, s2);                          //(5.1.013)
        if (MinSurfArea < 0.0)                                                 //(5.1.013)
            return error_setInpError(ERR_NUMBER, s2);                          //(5.1.013)
        break;

      // --- minimum conduit slope (%)
      case MIN_SLOPE:
        ////////////////////////////////////
        returnObj = {y: MinSlope}
        returnVal = getDouble(s2, returnObj);
        MinSlope = returnObj.y;
        ////////////////////////////////////
        if ( !returnVal )
        //if ( (MinSlope = getDouble(s2) ) == null)
            return error_setInpError(ERR_NUMBER, s2);
        if ( MinSlope < 0.0 || MinSlope >= 100 )
            return error_setInpError(ERR_NUMBER, s2);
        MinSlope /= 100.0;
        break;

      // --- maximum trials / time step for dynamic wave routing
      case MAX_TRIALS:
        m = parseInt(s2);
        if ( m < 0 ) return error_setInpError(ERR_NUMBER, s2);
        MaxTrials = m;
        break;

      // --- head convergence tolerance for dynamic wave routing
      case HEAD_TOL:
        ////////////////////////////////////
        returnObj = {y: HeadTol}
        returnVal = getDouble(s2, returnObj);
        HeadTol = returnObj.y;
        ////////////////////////////////////
        if ( !returnVal )
        //if ( (HeadTol = getDouble(s2) ) == null)
        {
            return error_setInpError(ERR_NUMBER, s2);
        }
        break;

      // --- steady state tolerance on system inflow - outflow
      case SYS_FLOW_TOL:
        ////////////////////////////////////
        returnObj = {y: SysFlowTol}
        returnVal = getDouble(s2, returnObj);
        SysFlowTol = returnObj.y;
        ////////////////////////////////////
        if ( !returnVal )
        //if ( (SysFlowTol = getDouble(s2) ) == null)
        {
            return error_setInpError(ERR_NUMBER, s2);
        }
        SysFlowTol /= 100.0;
        break;

      // --- steady state tolerance on nodal lateral inflow
      case LAT_FLOW_TOL:
        ////////////////////////////////////
        returnObj = {y: LatFlowTol}
        returnVal = getDouble(s2, returnObj);
        LatFlowTol = returnObj.y;
        ////////////////////////////////////
        if ( !returnVal )
        //if ( (LatFlowTol = getDouble(s2) ) == null)
        {
            return error_setInpError(ERR_NUMBER, s2);
        }
        LatFlowTol /= 100.0;
        break;

      // --- method used for surcharging in dynamic wave flow routing          //(5.1.013)
      case SURCHARGE_METHOD:
          m = findmatch(s2, SurchargeWords);
          if (m < 0) return error_setInpError(ERR_KEYWORD, s2);
          SurchargeMethod = m;
          break;

      case TEMPDIR: // Temporary Directory
        TempDir =  s2;
        break;

    }
    return 0;
}

//=============================================================================

initPointers()
//
//  Input:   none
//  Output:  none
//  Purpose: assigns null to all dynamic arrays for a new project.
//
{
    Gage     = [];
    Subcatch = [];
    Node     = [];
    Outfall  = [];
    Divider  = [];
    Storage  = [];
    Link     = [];
    Conduit  = [];
    Pump     = [];
    Orifice  = [];
    Weir     = [];
    Outlet   = [];
    Pollut   = [];
    Landuse  = [];
    Pattern  = [];
    Curve    = [];
    Tseries  = [];
    Transect = [];
    Shape    = [];
    Aquifer    = [];
    UnitHyd    = [];
    Snowmelt   = [];
    Event      = [];
    MemPoolAllocated = [];
}

//=============================================================================

setDefaults()
//
//  Input:   none
//  Output:  none
//  Purpose: assigns default values to project variables.
//
{
   let i, j;

   // Project title & temp. file path
   for (i = 0; i < MAXTITLE; i++) Title[i] = "";
   TempDir = "";

   // Interface files
   Frain.mode      = SCRATCH_FILE;     // Use scratch rainfall file
   Fclimate.mode   = NO_FILE; 
   Frunoff.mode    = NO_FILE;
   Frdii.mode      = NO_FILE;
   Fhotstart1.mode = NO_FILE;
   Fhotstart2.mode = NO_FILE;
   Finflows.mode   = NO_FILE;
   Foutflows.mode  = NO_FILE;
   /*Frain.file      = null;
   Fclimate.file   = null;
   Frunoff.file    = null;
   Frdii.file      = null;
   Fhotstart1.file = null;
   Fhotstart2.file = null;
   Finflows.file   = null;
   Foutflows.file  = null;
   Fout.file       = null;*/
   Frain.contents      = null;
   Fclimate.contents   = null;
   Frunoff.contents    = null;
   Frdii.contents      = null;
   Fhotstart1.contents = null;
   Fhotstart2.contents = null;
   Finflows.contents   = null;
   Foutflows.contents  = null;
   Fout.contents       = null;
   Fout.mode       = NO_FILE;

   // Analysis options
   UnitSystem      = US;               // US unit system
   FlowUnits       = CFS;              // CFS flow units
   InfilModel      = HORTON;           // Horton infiltration method
   RouteModel      = KW;               // Kin. wave flow routing method
   SurchargeMethod = EXTRAN;           // Use EXTRAN method for surcharging    //(5.1.013)
   CrownCutoff     = 0.96;                                                     //(5.1.013)
   AllowPonding    = false;            // No ponding at nodes
   InertDamping    = SOME;             // Partial inertial damping
   NormalFlowLtd   = BOTH;             // Default normal flow limitation
   ForceMainEqn    = H_W;              // Hazen-Williams eqn. for force mains
   LinkOffsets     = DEPTH_OFFSET;     // Use depth for link offsets
   LengtheningStep = 0;                // No lengthening of conduits
   CourantFactor   = 0.0;              // No variable time step 
   MinSurfArea     = 0.0;              // Force use of default min. surface area
   MinSlope        = 0.0;              // No user supplied minimum conduit slope
   SkipSteadyState = false;            // Do flow routing in steady state periods 
   IgnoreRainfall  = false;            // Analyze rainfall/runoff
   IgnoreRDII      = false;            // Analyze RDII
   IgnoreSnowmelt  = false;            // Analyze snowmelt 
   IgnoreGwater    = false;            // Analyze groundwater 
   IgnoreRouting   = false;            // Analyze flow routing
   IgnoreQuality   = false;            // Analyze water quality
   WetStep         = 300;              // Runoff wet time step (secs)
   DryStep         = 3600;             // Runoff dry time step (secs)
   RuleStep        = 0;                // Rules evaluated at each routing step
   RouteStep       = 300.0;            // Routing time step (secs)
   MinRouteStep    = 0.5;              // Minimum variable time step (sec)
   ReportStep      = 900;              // Reporting time step (secs)
   StartDryDays    = 0.0;              // Antecedent dry days
   MaxTrials       = 0;                // Force use of default max. trials 
   HeadTol         = 0.0;              // Force use of default head tolerance
   SysFlowTol      = 0.05;             // System flow tolerance for steady state
   LatFlowTol      = 0.05;             // Lateral flow tolerance for steady state
   NumThreads      = 0;                // Number of parallel threads to use
   NumEvents       = 0;                // Number of detailed routing events

   // Deprecated options
   SlopeWeighting  = true;             // Use slope weighting 
   Compatibility   = SWMM4;            // Use SWMM 4 up/dn weighting method

   // Starting & ending date/time
   StartDate       = datetime_encodeDate(2004, 1, 1);
   StartTime       = datetime_encodeTime(0,0,0);
   StartDateTime   = StartDate + StartTime;
   EndDate         = StartDate;
   EndTime         = 0.0;
   ReportStartDate = NO_DATE;
   ReportStartTime = NO_DATE;
   SweepStart      = 1;
   SweepEnd        = 365;

   // Reporting options
   RptFlags.input         = false;
   RptFlags.continuity    = true;
   RptFlags.flowStats     = true;
   RptFlags.controls      = false;
   RptFlags.subcatchments = false;
   RptFlags.nodes         = false;
   RptFlags.links         = false;
   RptFlags.nodeStats     = false;
   RptFlags.averages      = false;

   // Temperature data
   Temp.dataSource  = NO_TEMP;
   Temp.tSeries     = -1;
   Temp.ta          = 70.0;
   Temp.elev        = 0.0;
   Temp.anglat      = 40.0;
   Temp.dtlong      = 0.0;
   Temp.tmax        = MISSING;

   // Wind speed data
   Wind.type = MONTHLY_WIND;
   for (let i=0; i<12; i++ ) Wind.aws[i] = 0.0;

   // Snowmelt parameters
   Snow.snotmp      = 34.0;
   Snow.tipm        = 0.5;
   Snow.rnm         = 0.6;

   // Snow areal depletion curves for pervious and impervious surfaces
   for ( i=0; i<2; i++ )
   {
       for ( j=0; j<10; j++) Snow.adc[i][j] = 1.0;
   }

   // Evaporation rates
   Evap.type = CONSTANT_EVAP;
   for (i=0; i<12; i++)
   {
       Evap.monthlyEvap[i] = 0.0;
       Evap.panCoeff[i]    = 1.0;
   }
   Evap.recoveryPattern = -1;
   Evap.recoveryFactor  = 1.0; 
   Evap.tSeries = -1;
   Evap.dryOnly = false;

   // Climate adjustments
   for (i = 0; i < 12; i++)
   {
       Adjust.temp[i] = 0.0;   // additive adjustments
       Adjust.evap[i] = 0.0;   // additive adjustments
       Adjust.rain[i] = 1.0;   // multiplicative adjustments
       Adjust.hydcon[i] = 1.0; // hyd. conductivity adjustments
   }
   Adjust.rainFactor = 1.0;
   Adjust.hydconFactor = 1.0;
}

//=============================================================================

openFiles(f1, f2, f3)
//
//  Input:   f1 = name of input file
//           f2 = name of report file
//           f3 = name of binary output file
//  Output:  none
//  Purpose: opens a project's input and report files.
//
{
    // --- initialize file pointers to null
    /*Finp.file = null;
    Frpt.file = null;
    Fout.file = null;*/

    // --- initialize file contents to empty
    Finp.contents = '';
    Frpt.contents = '';
    Fout.contents = '';

    // --- save file names
    Finp.name = f1;
    Frpt.name = f2;
    Fout.name = f3;

    // --- check that file names are not identical
    if (strcomp(f1, f2) || strcomp(f1, f3) || strcomp(f2, f3))
    {
        writecon(FMT11);
        ErrorCode = ERR_FILE_NAME;
        return;
    }

    // --- open input and report files
    if ((Finp.contents = fopen(f1,"rt")) == null)
    {
        writecon(FMT12);
        writecon(f1);
        ErrorCode = ERR_INP_FILE;
        return;
    }
    
    
    /*if ((Frpt.file = fopen(f2,"wt")) == null)
    {
       writecon(FMT13);
       ErrorCode = ERR_RPT_FILE;
       return;
    }*/
}

//=============================================================================

createObjects()
//
//  Input:   none
//  Output:  none
//  Purpose: allocates memory for project's objects.
//
//  NOTE: number of each type of object has already been determined in
//        project_readInput().
//
{
    let j, k;

    // --- allocate memory for each category of object
    if ( ErrorCode ) return;
    for(let i = 0; i < Nobjects[GAGE]; i++){Gage.push(new TGage())}
    for(let i = 0; i < Nobjects[SUBCATCH]; i++){Subcatch.push(new TSubcatch())}
    for(let i = 0; i < Nobjects[NODE]; i++){Node.push(new TNode())}
    for(let i = 0; i < Nnodes[OUTFALL]; i++){Outfall.push(new TOutfall())}
    for(let i = 0; i < Nnodes[DIVIDER]; i++){Divider.push(new TDivider())}
    for(let i = 0; i < Nnodes[STORAGE]; i++){Storage.push(new TStorage())}
    for(let i = 0; i < Nobjects[LINK]; i++){Link.push(new TLink())}
    for(let i = 0; i < Nlinks[CONDUIT]; i++){Conduit.push(new TConduit())}
    for(let i = 0; i < Nlinks[PUMP]; i++){Pump.push(new TPump())}
    for(let i = 0; i < Nlinks[ORIFICE]; i++){Orifice.push(new TOrifice())}
    for(let i = 0; i < Nlinks[WEIR]; i++){Weir.push(new TWeir())}
    for(let i = 0; i < Nlinks[OUTLET]; i++){Outlet.push(new TOutlet())}
    for(let i = 0; i < Nobjects[POLLUT]; i++){Pollut.push(new TPollut())}
    for(let i = 0; i < Nobjects[LANDUSE]; i++){Landuse.push(new TLanduse())}
    for(let i = 0; i < Nobjects[TIMEPATTERN]; i++){Pattern.push(new TPattern())}
    for(let i = 0; i < Nobjects[CURVE]; i++){Curve.push(new TTable())}
    for(let i = 0; i < Nobjects[TSERIES]; i++){Tseries.push(new TTable())}
    for(let i = 0; i < Nobjects[AQUIFER]; i++){Aquifer.push(new TAquifer())}
    for(let i = 0; i < Nobjects[UNITHYD]; i++){UnitHyd.push(new TUnitHyd())}
    for(let i = 0; i < Nobjects[SNOWMELT]; i++){Snowmelt.push(new TSnowmelt())}
    for(let i = 0; i < Nobjects[SHAPE]; i++){Shape.push(new TShape())}

    //thing.item = 0;
    // --- create array of detailed routing event periods
    Event = new Array(NumEvents+1);
    for(let i = 0; i < NumEvents+1; i++){
        Event[i] = new TEvent();
    }
    Event[NumEvents].start = BIG;
    Event[NumEvents].end = BIG + 1.0;

    // --- create LID objects
    lid_create(Nobjects[LID], Nobjects[SUBCATCH]);

    // --- create control rules
    ErrorCode = controls_create(Nobjects[CONTROL]);
    if ( ErrorCode ) return;

    // --- create cross section transects
    ErrorCode = transect_create(Nobjects[TRANSECT]);
    if ( ErrorCode ) return;

    // --- allocate memory for infiltration data
    infil_create(Nobjects[SUBCATCH]);                                          //(5.1.015)

    // --- allocate memory for water quality state variables
    for (let j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        Subcatch[j].initBuildup = new Array(Nobjects[POLLUT]);
        Subcatch[j].oldQual = new Array(Nobjects[POLLUT]);
        Subcatch[j].newQual = new Array(Nobjects[POLLUT]);
        Subcatch[j].pondedQual = new Array(Nobjects[POLLUT]);
        Subcatch[j].totalLoad  = new Array(Nobjects[POLLUT]);
    }
    for (let j = 0; j < Nobjects[NODE]; j++)
    {
        Node[j].oldQual = new Array(Nobjects[POLLUT]);
        Node[j].newQual = new Array(Nobjects[POLLUT]);
        Node[j].extInflow = null;
        Node[j].dwfInflow = null;
        Node[j].rdiiInflow = null;
        Node[j].treatment = null;
    }
    for (let j = 0; j < Nobjects[LINK]; j++)
    {
        Link[j].oldQual = new Array(Nobjects[POLLUT]);
        Link[j].newQual = new Array(Nobjects[POLLUT]);
        Link[j].totalLoad = new Array(Nobjects[POLLUT]);
    }

    // --- allocate memory for land use buildup/washoff functions
    for (let j = 0; j < Nobjects[LANDUSE]; j++)
    {
        //Landuse[j].buildupFunc = new Array(Nobjects[POLLUT]);
        //Landuse[j].washoffFunc = new Array(Nobjects[POLLUT]);
        for(i = 0; i < Nobjects[POLLUT]; i++){Landuse[j].buildupFunc.push(new TBuildup())}
        for(i = 0; i < Nobjects[POLLUT]; i++){Landuse[j].washoffFunc.push(new TWashoff())}
    }

    // --- allocate memory for subcatchment landuse factors
    for (let j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        for(let i = 0; i < Nobjects[LANDUSE]; i++){Subcatch[j].landFactor.push(new TLandFactor())}
        
        for (let k = 0; k < Nobjects[LANDUSE]; k++)
        {
            //Subcatch[j].landFactor[k].buildup = new Array(Nobjects[POLLUT]);
            for(let ii = 0; ii < Nobjects[POLLUT]; ii++){Subcatch[j].landFactor[k].buildup.push(new TBuildup())}
        
        }
    }

    // --- initialize buildup & washoff functions
    for (let j = 0; j < Nobjects[LANDUSE]; j++)
    {
        for (let k = 0; k < Nobjects[POLLUT]; k++)
        {
            Landuse[j].buildupFunc[k].funcType = NO_BUILDUP;
            Landuse[j].buildupFunc[k].normalizer = PER_AREA;
            Landuse[j].washoffFunc[k].funcType = NO_WASHOFF;
        }
    }

    // --- initialize rain gage properties
    for (let j = 0; j < Nobjects[GAGE]; j++)
    {
        Gage[j].tSeries = -1;
        Gage[j].fname = "";
    }

    // --- initialize subcatchment properties
    for (let j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        Subcatch[j].outSubcatch = -1;
        Subcatch[j].outNode     = -1;
        Subcatch[j].infil       = -1;
        Subcatch[j].groundwater = null;
        Subcatch[j].gwLatFlowExpr = null;
        Subcatch[j].gwDeepFlowExpr = null;
        Subcatch[j].snowpack    = null;
        Subcatch[j].lidArea     = 0.0;
        for (let k = 0; k < Nobjects[POLLUT]; k++)
        {
            Subcatch[j].initBuildup[k] = 0.0;
        }
    }

    // --- initialize RDII unit hydrograph properties
    for ( let j = 0; j < Nobjects[UNITHYD]; j++ ) rdii_initUnitHyd(j);

    // --- initialize snowmelt properties
    for ( let j = 0; j < Nobjects[SNOWMELT]; j++ ) snow_initSnowmelt(j);

    // --- initialize storage node exfiltration
    for (let j = 0; j < Nnodes[STORAGE]; j++) Storage[j].exfil = null;

    // --- initialize link properties
    for (let j = 0; j < Nobjects[LINK]; j++)
    {
        Link[j].xsect = new TXsect();
        Link[j].xsect.type   = -1;
        Link[j].cLossInlet   = 0.0;
        Link[j].cLossOutlet  = 0.0;
        Link[j].cLossAvg     = 0.0;
        Link[j].hasFlapGate  = false;
    }
    for (let j = 0; j < Nlinks[PUMP]; j++) Pump[j].pumpCurve  = -1;

    // --- initialize reporting flags
    for (let j = 0; j < Nobjects[SUBCATCH]; j++) Subcatch[j].rptFlag = false;
    for (let j = 0; j < Nobjects[NODE]; j++) Node[j].rptFlag = false;
    for (let j = 0; j < Nobjects[LINK]; j++) Link[j].rptFlag = false;

    //  --- initialize curves, time series, and time patterns
    for (let j = 0; j < Nobjects[CURVE]; j++)   table_init(Curve[j]);
    for (let j = 0; j < Nobjects[TSERIES]; j++) table_init(Tseries[j]);
    for (let j = 0; j < Nobjects[TIMEPATTERN]; j++) inflow_initDwfPattern(j);
}

//=============================================================================

deleteObjects()
//
//  Input:   none
//  Output:  none
//  Purpose: frees memory allocated for a project's objects.
//
//  NOTE: care is taken to first free objects that are properties of another
//        object before the latter is freed (e.g., we must free a
//        subcatchment's land use factors before freeing the subcatchment).
//
{
    let j, k;

    // --- free memory for landuse factors & groundwater
    if ( Subcatch ) for (let j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        for (k = 0; k < Nobjects[LANDUSE]; k++)
        {
            FREE(Subcatch[j].landFactor[k].buildup);
        }
        FREE(Subcatch[j].landFactor);
        FREE(Subcatch[j].groundwater);
        gwater_deleteFlowExpression(j);
        FREE(Subcatch[j].snowpack);
    }

    // --- free memory for buildup/washoff functions
    if ( Landuse ) for (let j = 0; j < Nobjects[LANDUSE]; j++)
    {
        FREE(Landuse[j].buildupFunc);
        FREE(Landuse[j].washoffFunc)
    }

    // --- free memory for water quality state variables
    if ( Subcatch ) for (let j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        FREE(Subcatch[j].initBuildup);
        FREE(Subcatch[j].oldQual);
        FREE(Subcatch[j].newQual);
        FREE(Subcatch[j].pondedQual);
        FREE(Subcatch[j].totalLoad);
    }
    if ( Node ) for (let j = 0; j < Nobjects[NODE]; j++)
    {
        FREE(Node[j].oldQual);
        FREE(Node[j].newQual);
    }
    if ( Link ) for (let j = 0; j < Nobjects[LINK]; j++)
    {
        FREE(Link[j].oldQual);
        FREE(Link[j].newQual);
        FREE(Link[j].totalLoad);
    }

    // --- free memory used for rainfall infiltration
    infil_delete();

    // --- free memory used for storage exfiltration
    if ( Node ) for (let j = 0; j < Nnodes[STORAGE]; j++)
    {
        if ( Storage[j].exfil )
        {
            FREE(Storage[j].exfil.btmExfil);
            FREE(Storage[j].exfil.bankExfil);
            FREE(Storage[j].exfil);
        }
    }

    // --- free memory used for outfall pollutants loads
    if ( Node ) for (let j = 0; j < Nnodes[OUTFALL]; j++)
        FREE(Outfall[j].wRouted);

    // --- free memory used for nodal inflows & treatment functions
    if ( Node ) for (let j = 0; j < Nobjects[NODE]; j++)
    {
        inflow_deleteExtInflows(j);
        inflow_deleteDwfInflows(j);
        rdii_deleteRdiiInflow(j);
        treatmnt_delete(j);
    }

    // --- delete table entries for curves and time series
    if ( Tseries ) for (let j = 0; j < Nobjects[TSERIES]; j++)
        table_deleteEntries(Tseries[j]);
    if ( Curve ) for (let j = 0; j < Nobjects[CURVE]; j++)
        table_deleteEntries(Curve[j]);

    // --- delete cross section transects
    transect_delete();

    // --- delete control rules
    controls_delete();

    // --- delete LIDs
    lid_delete();

    // --- now free each major category of object
    FREE(Gage);
    FREE(Subcatch);
    FREE(Node);
    FREE(Outfall);
    FREE(Divider);
    FREE(Storage);
    FREE(Link);
    FREE(Conduit);
    FREE(Pump);
    FREE(Orifice);
    FREE(Weir);
    FREE(Outlet);
    FREE(Pollut);
    FREE(Landuse);
    FREE(Pattern);
    FREE(Curve);
    FREE(Tseries);
    FREE(Aquifer);
    FREE(UnitHyd);
    FREE(Snowmelt);
    FREE(Shape);
    FREE(Event);
}

//=============================================================================
// I'm not certain any of the hdr object is useful in JavaScript.
/*AllocHdr() {
    let hdr = new alloc_hdr_t();
    let block;

    block = '';
    hdr.block = block;
    hdr.free = block;
    hdr.next = null;
    hdr.end = block + ALLOC_BLOCK_SIZE;
}*/

createHashTables()
//
//  Input:   none
//  Output:  returns error code
//  Purpose: allocates memory for object ID hash tables
//  Note: I don't this this is useful in JavaScript.
//
{   let  j;
    MemPoolAllocated = false;
    for (j = 0; j < MAX_OBJ_TYPES ; j++)
    {
        Htable[j] = HTcreate();
        if ( Htable[j] == null ) report_writeErrorMsg(ERR_MEMORY, "");
    }
    
    /*root.first = AllocHdr();
    root.current = root.first;
    newpool = root;*/


    // --- initialize memory pool used to store object ID's
    // -- Not sure this is necessary in JavaScript.
    //if ( root == null || root.first == null) report_writeErrorMsg(ERR_MEMORY, "");
    //else 
    if ( AllocInit() == null ) report_writeErrorMsg(ERR_MEMORY, "");
    else MemPoolAllocated = true;
}

//=============================================================================

deleteHashTables()
//
//  Input:   none
//  Output:  none
//  Purpose: frees memory allocated for object ID hash tables
//
{
    let  j;
    for (let j = 0; j < MAX_OBJ_TYPES; j++)
    {
        if ( Htable[j] != null ) HTfree(Htable[j]);
    }

    // --- free object ID memory pool
    if ( MemPoolAllocated ) AllocFreePool();
}

//=============================================================================


//-----------------------------------------------------------------------------
//   report.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/21/2014  (Build 5.1.001)
//             04/14/14    (Build 5.1.004)
//             09/15/14    (Build 5.1.007)
//             04/02/15    (Build 5.1.008)
//             08/01/16    (Build 5.1.011)
//             03/14/17    (Build 5.1.012)
//             05/10/18    (Build 5.1.013)
//             03/01/20    (Build 5.1.014)
//             05/18/20    (Build 5.1.015)
//   Author:   L. Rossman (EPA)
//
//   Report writing functions.
//
//   Build 5.1.004:
//   - Ignore RDII option reported.
//
//   Build 5.1.007:
//   - Total exfiltration loss reported.
//
//   Build 5.1.008:
//   - Number of threads option reported.
//   - LID drainage volume and outfall runon reported.
//   - "Internal Outflow" label changed to "Flooding Loss" in Flow Routing
//     Continuity table.
//   - Exfiltration loss added into Quality Routing Continuity table.
//
//   Build 5.1.011:
//   - Blank line added after writing project title.
//   - Text of error message saved to global variable ErrorMsg.
//   - Global variable Warnings incremented after warning message issued.
//
//   Build 5.1.012:
//   - System time step statistics adjusted for time in steady state.
//
//   Build 5.1.013:
//   - Parsing of AVERAGES report option added to report_readOptions().
//   - Name of surcharge method reported in report_writeOptions().
//   - Missing format specifier added to fprintf() in report_writeErrorCode.
//
//   Build 5.1.014:
//   - Fixed bug in confusing keywords with ID names in report_readOptions().
//
//   Build 5.1.015:
//   - Fixes bug in summary statistics when Report Start date > Start Date.
//   - Support added for grouped freqency table of routing time steps.
//-----------------------------------------------------------------------------
WRITE(x) {(report_writeLine((x)))}
LINE_10 = "----------"
LINE_12 = "------------"
LINE_51 = "---------------------------------------------------"
LINE_64 = "----------------------------------------------------------------"


//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
SysTime;

//-----------------------------------------------------------------------------
//  Imported variables
//-----------------------------------------------------------------------------
SubcatchResults;         // Results vectors defined in OUTPUT.C
NodeResults;             //  "
LinkResults;             //  "
ErrString;               // defined in ERROR.C

//=============================================================================

report_readOptions(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads reporting options from a line of input
//
{
    let  k;
    let  j, m, t;
    if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
    k = findmatch(tok[0], ReportWords);
    if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[0]);
    switch ( k )
    {
      case 0: // Input
        m = findmatch(tok[1], NoYesWords);
        if      ( m == YES ) RptFlags.input = TRUE;
        else if ( m == NO )  RptFlags.input = FALSE;
        else                 return error_setInpError(ERR_KEYWORD, tok[1]);
        return 0;

      case 1: // Continuity
        m = findmatch(tok[1], NoYesWords);
        if      ( m == YES ) RptFlags.continuity = TRUE;
        else if ( m == NO )  RptFlags.continuity = FALSE;
        else                 return error_setInpError(ERR_KEYWORD, tok[1]);
        return 0;

      case 2: // Flow Statistics
        m = findmatch(tok[1], NoYesWords);
        if      ( m == YES ) RptFlags.flowStats = TRUE;
        else if ( m == NO )  RptFlags.flowStats = FALSE;
        else                 return error_setInpError(ERR_KEYWORD, tok[1]);
        return 0;

      case 3: // Controls
        m = findmatch(tok[1], NoYesWords);
        if      ( m == YES ) RptFlags.controls = TRUE;
        else if ( m == NO )  RptFlags.controls = FALSE;
        else                 return error_setInpError(ERR_KEYWORD, tok[1]);
        return 0;

      case 4:  m = SUBCATCH;  break;  // Subcatchments
      case 5:  m = NODE;      break;  // Nodes
      case 6:  m = LINK;      break;  // Links

      case 7: // Node Statistics
        m = findmatch(tok[1], NoYesWords);
        if      ( m == YES ) RptFlags.nodeStats = TRUE;
        else if ( m == NO )  RptFlags.nodeStats = FALSE;
        else                 return error_setInpError(ERR_KEYWORD, tok[1]);
        return 0;

      case 8: // Averages                                                      //(5.1.013)
        m = findmatch(tok[1], NoYesWords);                                     //
        if      (m == YES) RptFlags.averages = TRUE;                           //
        else if (m == NO)  RptFlags.averages = FALSE;                          //
        else               return error_setInpError(ERR_KEYWORD, tok[1]);      //
        return 0;                                                              //

      default: return error_setInpError(ERR_KEYWORD, tok[1]);
    }

    if (strcomp(tok[1], w_NONE))
        k = NONE;
    else if (strcomp(tok[1], w_ALL))
        k = ALL;
    else
    {
        k = SOME;
        for (t = 1; t < ntoks; t++)
        {
            j = project_findObject(m, tok[t]);
            if ( j < 0 ) return error_setInpError(ERR_NAME, tok[t]);
            switch ( m )
            {
              case SUBCATCH:  Subcatch[j].rptFlag = TRUE;  break;
              case NODE:      Node[j].rptFlag = TRUE;  break;
              case LINK:      Link[j].rptFlag = TRUE;  break;
            }
        }
    }
    switch ( m )
    {
      case SUBCATCH: RptFlags.subcatchments = k;  break;
      case NODE:     RptFlags.nodes = k;  break;
      case LINK:     RptFlags.links = k;  break;
    }
    return 0;
}

//=============================================================================
// char *line
report_writeLine(line)
//
//  Input:   line = line of text
//  Output:  none
//  Purpose: writes line of text to report file.
//
{
    //if ( Frpt.file ) Frpt.contents += "\n  %s", line);
    if ( Frpt.contents ) Frpt.contents += "\n  " + line;
}

//=============================================================================
format_time(s) {
    dtFormat = new Intl.DateTimeFormat('en-GB', {
        timeStyle: 'medium',
        timeZone: 'UTC'
    });

    return dtFormat.format(new Date(s * 1e3));
}
report_writeSysTime()
//
//  Input:   none
//  Output:  none
//  Purpose: writes starting/ending processing times to report file.
//
{
    let    theTime = new Array(9);
    let  elapsedTime;
    let  endTime;
    if ( Frpt.contents )
    {
        //Frpt.contents += FMT20.format(ctime(SysTime));
        Frpt.contents += format_time(SysTime);
        endTime = Math.floor(Date.now() / 1000);;
        //Frpt.contents += FMT20a.format(ctime(endTime));
        Frpt.contents += format_time(endTime);
        elapsedTime = endTime - SysTime;
        Frpt.contents += FMT21;
        if ( elapsedTime < 1.0 ) Frpt.contents += "< 1 sec" //Frpt.contents += "< 1 sec");
        else
        {
            elapsedTime /= SECperDAY;
            if (elapsedTime >= 1.0)
            {
                //Frpt.contents += "%d.", floor(elapsedTime));
                Frpt.contents += `${elapsedTime}`
                elapsedTime -= Math.floor(elapsedTime);
            }
            theTime = datetime_timeToStr(elapsedTime, theTime);
            //Frpt.contents += "%s", theTime);
            Frpt.contents += `${theTime}`
        }
    }
}


//=============================================================================
//      SIMULATION OPTIONS REPORTING
//=============================================================================

report_writeLogo()
//
//  Input:   none
//  Output:  none
//  Purpose: writes report header lines to report file.
//
{
    Frpt.contents += FMT08;
    Frpt.contents += FMT09;
    Frpt.contents += FMT10;
    SysTime = Math.floor(Date.now() / 1000);                    // Save starting wall clock time
}

//=============================================================================

report_writeTitle()
//
//  Input:   none
//  Output:  none
//  Purpose: writes project title to report file.
//
{
    let i;
    let lineCount = 0;
    if ( ErrorCode ) {return};
    for (i=0; i<MAXTITLE; i++) if ( Title[i].length > 0 )
    {
        WRITE(Title[i]);
        lineCount++;
    }
    if ( lineCount > 0 ) WRITE("");
}

//=============================================================================

report_writeOptions()
//
//  Input:   none
//  Output:  none
//  Purpose: writes analysis options in use to report file.
//
{
    let str;
    WRITE("");
    WRITE("*********************************************************");
    WRITE("NOTE: The summary statistics displayed in this report are");
    WRITE("based on results found at every computational time step,  ");
    WRITE("not just on results from each reporting time step.");
    WRITE("*********************************************************");
    WRITE("");
    WRITE("****************");
    WRITE("Analysis Options");
    WRITE("****************");
    Frpt.contents += `\n  Flow Units ............... ${FlowUnitWords[FlowUnits]}`
    Frpt.contents += "\n  Process Models:";
    Frpt.contents += "\n    Rainfall/Runoff ........ ";
    if ( IgnoreRainfall || Nobjects[GAGE] == 0 )
        Frpt.contents += "NO";
    else Frpt.contents += "YES";

    Frpt.contents += "\n    RDII ................... ";
    if ( IgnoreRDII || Nobjects[UNITHYD] == 0 )
        Frpt.contents += "NO";
    else Frpt.contents += "YES";

    Frpt.contents += "\n    Snowmelt ............... ";
    if ( IgnoreSnowmelt || Nobjects[SNOWMELT] == 0 )
        Frpt.contents += "NO";
    else Frpt.contents += "YES";
    Frpt.contents += "\n    Groundwater ............ ";
    if ( IgnoreGwater || Nobjects[AQUIFER] == 0 )
        Frpt.contents += "NO";
    else Frpt.contents += "YES";
    Frpt.contents += "\n    Flow Routing ........... ";
    if ( IgnoreRouting || Nobjects[LINK] == 0 )
        Frpt.contents += "NO";
    else
    {
        Frpt.contents += "YES";
        Frpt.contents += "\n    Ponding Allowed ........ ";
        if ( AllowPonding ) Frpt.contents += "YES"
        else                Frpt.contents += "NO";
    }
    Frpt.contents += "\n    Water Quality .......... ";
    if ( IgnoreQuality || Nobjects[POLLUT] == 0 )
        Frpt.contents += "NO";
    else Frpt.contents += "YES";

    if ( Nobjects[SUBCATCH] > 0 )
    Frpt.contents += `\n  Infiltration Method ...... ${InfilModelWords[InfilModel]}`
    if ( Nobjects[LINK] > 0 )
    Frpt.contents += `\n  Flow Routing Method ...... ${RouteModelWords[RouteModel]}`

    if (RouteModel == DW)                                                      //(5.1.013)
    Frpt.contents += `\n  Surcharge Method ......... ${SurchargeWords[SurchargeMethod]}`                                      //(5.1.013)

    str = datetime_dateToStr(StartDate, str);
    Frpt.contents += `\n  Starting Date ............ ${str}`
    str = datetime_timeToStr(StartTime, str);
    Frpt.contents += ` ${str}`
    str = datetime_dateToStr(EndDate, str);
    Frpt.contents += `\n  Ending Date .............. ${str}`
    str = datetime_timeToStr(EndTime, str);
    Frpt.contents += ` ${str}`
    Frpt.contents += `\n  Antecedent Dry Days ...... ${StartDryDays.toFixed(1)}`;
    str = datetime_timeToStr(datetime_encodeTime(0, 0, ReportStep), str);
    Frpt.contents += `\n  Report Time Step ......... ${str}`
    if ( Nobjects[SUBCATCH] > 0 )
    {
        str = datetime_timeToStr(datetime_encodeTime(0, 0, WetStep), str);
        Frpt.contents += `\n  Wet Time Step ............ ${str}`
        str = datetime_timeToStr(datetime_encodeTime(0, 0, DryStep), str);
        Frpt.contents += `\n  Dry Time Step ............ ${str}`
    }
    if ( Nobjects[LINK] > 0 )
    {
        Frpt.contents += `\n  Routing Time Step ........ ${RouteStep.toFixed(2)} sec`;
		if ( RouteModel == DW )
		{
		Frpt.contents += `\n  Variable Time Step ....... `
		if ( CourantFactor > 0.0 ) Frpt.contents += "YES"
		else                       Frpt.contents += "NO"
		Frpt.contents += `\n  Maximum Trials ........... ${MaxTrials}`
        Frpt.contents += `\n  Number of Threads ........ ${NumThreads}`
		Frpt.contents += `\n  Head Tolerance ........... ${(HeadTol*UCF(LENGTH)).toFixed(6)} `;
		if ( UnitSystem == US ) Frpt.contents += "ft"
		else                    Frpt.contents += "m"
		}
    }
    WRITE("");
}


//=============================================================================
//      RAINFALL FILE REPORTING
//=============================================================================
// int i
// TRainStats* r
report_writeRainStats(i,  r)
//
//  Input:   i = rain gage index
//           r = rain file summary statistics
//  Output:  none
//  Purpose: writes summary of rain data read from file to report file.
//
{
    let date1 = "***********";
    let date2 = "***********";
    if ( i < 0 )
    {
        WRITE("");
        WRITE("*********************");
        WRITE("Rainfall File Summary");
        WRITE("*********************");
        Frpt.contents +=
"\n  Station    First        Last         Recording   Periods    Periods    Periods";
        Frpt.contents +=
"\n  ID         Date         Date         Frequency  w/Precip    Missing    Malfunc.";
        Frpt.contents +=
"\n  -------------------------------------------------------------------------------\n";
    }
    else
    {
        if ( r.startDate != NO_DATE ) date1 = datetime_dateToStr(r.startDate, date1);
        if ( r.endDate   != NO_DATE ) date2 = datetime_dateToStr(r.endDate, date2);
        Frpt.contents += `  ${staID} ${date1}  ${date2}  ${Gage[i].rainInterval/60} min    ${r.periodsRain}     ${r.periodsMissing}     ${r.periodsMalfunc}\n`
    }
}


//=============================================================================
//      RDII REPORTING
//=============================================================================
// double rainVol
// double rdiiVol
report_writeRdiiStats(rainVol, rdiiVol)
//
//  Input:   rainVol = total rainfall volume over sewershed
//           rdiiVol = total RDII volume produced
//  Output:  none
//  Purpose: writes summary of RDII inflow to report file.
//
{
    let ratio;
    let ucf1, ucf2;

    ucf1 = UCF(LENGTH) * UCF(LANDAREA);
    if ( UnitSystem == US) ucf2 = MGDperCFS / SECperDAY;
    else                   ucf2 = MLDperCFS / SECperDAY;

    WRITE(``);
    Frpt.contents +=
    `\n  **********************           Volume        Volume`;
    if ( UnitSystem == US) Frpt.contents +=
    `\n  Rainfall Dependent I/I        acre-feet      10^6 gal`;
    else Frpt.contents +=
    `\n  Rainfall Dependent I/I        hectare-m      10^6 ltr`;
    Frpt.contents +=
    `\n  **********************        ---------     ---------`;

    Frpt.contents += `\n  Sewershed Rainfall ......${(rainVol * ucf1).toFixed(3).padStart(14, ' ')}${(rainVol * ucf2).toFixed(3).padStart(14, ' ')}`

    Frpt.contents += `\n  RDII Produced ...........${(rdiiVol * ucf1).toFixed(3).padStart(14, ' ')}${(rdiiVol * ucf2).toFixed(3).padStart(14, ' ')}`

    if ( rainVol == 0.0 ) ratio = 0.0;
    else ratio = rdiiVol / rainVol;
    Frpt.contents += `\n  RDII Ratio ..............${(ratio).toFixed(3).padStart(14, ' ')}`
    WRITE(``);
}


//=============================================================================
//      CONTROL ACTIONS REPORTING
//=============================================================================

  report_writeControlActionsHeading()
{
    WRITE("");
    WRITE("*********************");
    WRITE("Control Actions Taken");
    WRITE("*********************");
    Frpt.contents += "\n";
}

//=============================================================================
// DateTime aDate, 
// char* linkID, 
// double value,
// char* ruleID
  report_writeControlAction(aDate, linkID, value, ruleID)
//
//  Input:   aDate  = date/time of rule action
//           linkID = ID of link being controlled
//           value  = new status value of link
//           ruleID = ID of rule implementing the action
//  Output:  none
//  Purpose: reports action taken by a control rule.
//
{
    let     theDate;
    let     theTime;
    theDate = datetime_dateToStr(aDate, theDate);
    theTime = datetime_timeToStr(aDate, theTime);
    let val1 = theDate.padStart(11, ' ')
    let val2 = theTime.padStart(8, ' ')
    let val3 = linkID
    let val4 = value.toFixed(2).padStart(6)
    let val5 = ruleID
    Frpt.contents +=
            `  ${val1}: ${val2} Link ${val3} setting changed to ${val5} by Control ${val5}\n`
}


//=============================================================================
//      CONTINUITY ERROR REPORTING
//=============================================================================
// TRunoffTotals* totals, 
// double totalArea
report_writeRunoffError(totals, totalArea)
//
//  Input:  totals = accumulated runoff totals
//          totalArea = total area of all subcatchments
//  Output:  none
//  Purpose: writes runoff continuity error to report file.
//
{
    // Values for string translation
    let val1 = 0;
    let val2 = 0;

    if ( Frunoff.mode == USE_FILE )
    {
        WRITE("");
        Frpt.contents +=
        "\n  **************************"
        +"\n  Runoff Quantity Continuity"
        +"\n  **************************"
        +`\n  Runoff supplied by interface file ${Frunoff.name}`
        WRITE("");
        return;
    }

    if ( totalArea == 0.0 ) return;
    WRITE("");

    Frpt.contents +=
    "\n  **************************        Volume         Depth";
    if ( UnitSystem == US) Frpt.contents += 
    "\n  Runoff Quantity Continuity     acre-feet        inches";
    else Frpt.contents += 
    "\n  Runoff Quantity Continuity     hectare-m            mm";
    Frpt.contents += 
    "\n  **************************     ---------       -------";

    if ( totals.initStorage > 0.0 )
    {
        val1 = (totals.initStorage * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
        val2 = (totals.initStorage / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
        Frpt.contents += `\n  Initial LID Storage ......${val1}${val2}`;
    }

    if ( Nobjects[SNOWMELT] > 0 )
    {
        val1 = (totals.initSnowCover * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
        val2 = (totals.initSnowCover / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
        Frpt.contents += `\n  Initial Snow Cover .......${val1}${val2}`;
    }

    val1 = (totals.rainfall * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.rainfall / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Total Precipitation ......${val1}${val2}`;

    if ( totals.runon > 0.0 )
    {
        val1 = (totals.runon * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
        val2 = (totals.runon / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
        Frpt.contents += `\n  Outfall Runon ............${val1}${val2}`;
    }

    val1 = (totals.evap * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.evap / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Evaporation Loss .........${val1}${val2}`

    val1 = (totals.infil * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.infil / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Infiltration Loss ........${val1}${val2}`;

    val1 = (totals.runoff * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.runoff / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Surface Runoff ...........${val1}${val2}`

    if ( totals.drains > 0.0 )
    {
        val1 = (totals.drains * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
        val2 = (totals.drains / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
        Frpt.contents += `\n  LID Drainage .............${val1}${val2}`
    }

    if ( Nobjects[SNOWMELT] > 0 )
    {
        val1 = (totals.snowRemoved * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
        val2 = (totals.snowRemoved / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
        Frpt.contents += `\n  Snow Removed .............${val1}${val2}`

        val1 = (totals.finalSnowCover * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
        val2 = (totals.finalSnowCover / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
        Frpt.contents += `\n  Final Snow Cover .........${val1}${val2}`
    }

    val1 = (totals.finalStorage * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.finalStorage / totalArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Final Storage ............${val1}${val2}`

    Frpt.contents += `\n  Continuity Error (%%) .....${totals.pctError}`
    WRITE(``);
}

//=============================================================================
// TLoadingTotals* totals
report_writeLoadingError(totals)
//
//  Input:   totals = accumulated pollutant loading totals
//           area = total area of all subcatchments
//  Output:  none
//  Purpose: writes runoff loading continuity error to report file.
//
{
    let p1, p2;
    p1 = 1;
    p2 = MIN(5, Nobjects[POLLUT]);
    while ( p1 <= Nobjects[POLLUT] )
    {
        report_LoadingErrors(p1-1, p2-1, totals);
        p1 = p2 + 1;
        p2 = p1 + 4;
        p2 = MIN(p2, Nobjects[POLLUT]);
    }
}

//=============================================================================
// int p1, 
// int p2, 
// TLoadingTotals* totals
report_LoadingErrors(p1, p2, totals)
//
//  Input:   p1 = index of first pollutant to report
//           p2 = index of last pollutant to report
//           totals = accumulated pollutant loading totals
//           area = total area of all subcatchments
//  Output:  none
//  Purpose: writes runoff loading continuity error to report file for
//           up to 5 pollutants at a time.
//
{
    let    i;
    let    p;
    let cf = 1.0;
    let   units;

    WRITE("");
    Frpt.contents += "\n  **************************";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += Pollut[p].ID.padStart(14, ' ')
    }
    Frpt.contents += "\n  Runoff Quality Continuity ";
    for (p = p1; p <= p2; p++)
    {
        i = UnitSystem;
        if ( Pollut[p].units == COUNT ) i = 2;
        units = LoadUnitsWords[i];
        Frpt.contents += units.padStart(14, ' ');
    }
    Frpt.contents += "\n  **************************";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += "    ----------";
    }

    Frpt.contents += "\n  Initial Buildup ..........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (totals[p].initLoad*cf).toFixed(3).padStart(14, ' ');
    }
    Frpt.contents += "\n  Surface Buildup ..........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (totals[p].buildup*cf).toFixed(3).padStart(14, ' ');
    }
    Frpt.contents += "\n  Wet Deposition ...........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (totals[p].deposition*cf).toFixed(3).padStart(14, ' ');
    }
    Frpt.contents += "\n  Sweeping Removal .........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (totals[p].sweeping*cf).toFixed(3).padStart(14, ' ');
    }
    Frpt.contents += "\n  Infiltration Loss ........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (totals[p].infil*cf).toFixed(3).padStart(14, ' ');
    }
    Frpt.contents += "\n  BMP Removal ..............";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (totals[p].bmpRemoval*cf).toFixed(3).padStart(14, ' ');
    }
    Frpt.contents += "\n  Surface Runoff ...........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (totals[p].runoff*cf).toFixed(3).padStart(14, ' ');
    }
    Frpt.contents += "\n  Remaining Buildup ........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (totals[p].finalLoad*cf).toFixed(3).padStart(14, ' ');
    }
    Frpt.contents += "\n  Continuity Error (%%) .....";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (totals[p].pctError).toFixed(3).padStart(14, ' ');
    }
    WRITE("");
}

//=============================================================================
// TGwaterTotals* totals, 
// double gwArea
report_writeGwaterError(totals, gwArea)
//
//  Input:   totals = accumulated groundwater totals
//           gwArea = total area of all subcatchments with groundwater
//  Output:  none
//  Purpose: writes groundwater continuity error to report file.
//
{
    // values for strings
    let val1 = 0;
    let val2 = 0;

    WRITE("");
    Frpt.contents += 
    "\n  **************************        Volume         Depth";
    if ( UnitSystem == US) Frpt.contents += 
    "\n  Groundwater Continuity         acre-feet        inches";
    else Frpt.contents += 
    "\n  Groundwater Continuity         hectare-m            mm";
    Frpt.contents += 
    "\n  **************************     ---------       -------";
    val1 = (totals.initStorage * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.initStorage / gwArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Initial Storage ..........${val1}${val2}`

    val1 = (totals.infil * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.infil / gwArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Infiltration .............${val1}${val2}`

    val1 = (totals.upperEvap * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.upperEvap / gwArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Upper Zone ET ............${val1}${val2}`
            
    val1 = (totals.lowerEvap * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.lowerEvap / gwArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Lower Zone ET ............${val1}${val2}`
            
    val1 = (totals.lowerPerc * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.lowerPerc / gwArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Deep Percolation .........${val1}${val2}`
            
    val1 = (totals.gwater * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.gwater / gwArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Groundwater Flow .........${val1}${val2}`
            
    val1 = (totals.finalStorage * UCF(LENGTH) * UCF(LANDAREA)).toFixed(3).padStart(14, ' ');
    val2 = (totals.finalStorage / gwArea * UCF(RAINDEPTH)).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Final Storage ............${val1}${val2}`
            
    Frpt.contents += `\n  Continuity Error (%%) .....${totals.pctError}`

    WRITE("");
}

//=============================================================================
// TRoutingTotals *totals
report_writeFlowError(totals)
//
//  Input:  totals = accumulated flow routing totals
//  Output:  none
//  Purpose: writes flow routing continuity error to report file.
//
{
    let ucf1, ucf2;

    // String formatting variables
    let val1, val2;

    ucf1 = UCF(LENGTH) * UCF(LANDAREA);
    if ( UnitSystem == US) ucf2 = MGDperCFS / SECperDAY;
    else                   ucf2 = MLDperCFS / SECperDAY;

    WRITE("");
    Frpt.contents += 
    "\n  **************************        Volume        Volume";
    if ( UnitSystem == US) Frpt.contents += 
    "\n  Flow Routing Continuity        acre-feet      10^6 gal";
    else Frpt.contents += 
    "\n  Flow Routing Continuity        hectare-m      10^6 ltr";
    Frpt.contents += 
    "\n  **************************     ---------     ---------";

    val1 = (totals.dwInflow * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.dwInflow * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Dry Weather Inflow .......${val1}${val2}`

    val1 = (totals.wwInflow * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.wwInflow * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Wet Weather Inflow .......${val1}${val2}`

    val1 = (totals.gwInflow * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.gwInflow * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Groundwater Inflow .......${val1}${val2}`
    
    val1 = (totals.iiInflow * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.iiInflow * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  RDII Inflow ..............${val1}${val2}`

    val1 = (totals.exInflow * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.exInflow * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  External Inflow ..........${val1}${val2}`

    val1 = (totals.outflow * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.outflow * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  External Outflow .........${val1}${val2}`

    val1 = (totals.flooding * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.flooding * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Flooding Loss ............${val1}${val2}`

    val1 = (totals.evapLoss * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.evapLoss * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Evaporation Loss .........${val1}${val2}`

    val1 = (totals.seepLoss * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.seepLoss * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Exfiltration Loss ........${val1}${val2}`

    val1 = (totals.initStorage * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.initStorage * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Initial Stored Volume ....${val1}${val2}`

    val1 = (totals.finalStorage * ucf1).toFixed(3).padStart(14, ' ');
    val2 = (totals.finalStorage * ucf2).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Final Stored Volume ......${val1}${val2}`

    val1 = (totals.pctError).toFixed(3).padStart(14, ' ');
    Frpt.contents += `\n  Continuity Error (%%) .....${val1}`
    WRITE("");
}

//=============================================================================
// TRoutingTotals* QualTotals
report_writeQualError(QualTotals)
//
//  Input:   totals = accumulated quality routing totals for each pollutant
//  Output:  none
//  Purpose: writes quality routing continuity error to report file.
//
{
    let p1, p2;
    p1 = 1;
    p2 = MIN(5, Nobjects[POLLUT]);
    while ( p1 <= Nobjects[POLLUT] )
    {
        report_QualErrors(p1-1, p2-1, QualTotals);
        p1 = p2 + 1;
        p2 = p1 + 4;
        p2 = MIN(p2, Nobjects[POLLUT]);
    }
}

//=============================================================================
// int p1, 
// int p2, 
// TRoutingTotals* QualTotals
report_QualErrors(p1, p2, QualTotals)
{
    let   i;
    let   p;
    let  units;

    // String formatting variables
    let val, val2;

    WRITE("");
    Frpt.contents += "\n  **************************";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += Pollut[p].ID.padStart(14, ' ');
    }
    Frpt.contents += "\n  Quality Routing Continuity";
    for (p = p1; p <= p2; p++)
    {
        i = UnitSystem;
        if ( Pollut[p].units == COUNT ) i = 2;
        //strcpy(units, LoadUnitsWords[i]);
        units = LoadUnitsWords[i];
        Frpt.contents += units.padStart(14, ' ');
    }
    Frpt.contents += "\n  **************************";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += "    ----------";
    }

    Frpt.contents += "\n  Dry Weather Inflow .......";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].dwInflow).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  Wet Weather Inflow .......";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].wwInflow).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  Groundwater Inflow .......";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].gwInflow).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  RDII Inflow ..............";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].iiInflow).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  External Inflow ..........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += ( QualTotals[p].exInflow).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  External Outflow .........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].outflow).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  Flooding Loss ............";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].flooding).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  Exfiltration Loss ........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].seepLoss).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  Mass Reacted .............";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].reacted).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  Initial Stored Mass ......";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].initStorage).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  Final Stored Mass ........";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].finalStorage).toFixed(3).padStart(14, ' ');
    }

    Frpt.contents += "\n  Continuity Error (%%) .....";
    for (p = p1; p <= p2; p++)
    {
        Frpt.contents += (QualTotals[p].pctError).toFixed(3).padStart(14, ' ');
    }
    WRITE("");
}

//=============================================================================
// TMaxStats maxMassBalErrs[], 
// TMaxStats maxCourantCrit[],
// int nMaxStats
report_writeMaxStats(maxMassBalErrs, maxCourantCrit, nMaxStats)
//
//  Input:   maxMassBal[] = nodes with highest mass balance errors
//           maxCourantCrit[] = nodes most often Courant time step critical
//           maxLinkTimes[] = links most often Courant time step critical
//           nMaxStats = number of most critical nodes/links saved
//  Output:  none
//  Purpose: lists nodes & links with highest mass balance errors and
//           time Courant time step critical
//
{
    let i, j, k;

    if ( RouteModel != DW || Nobjects[LINK] == 0 ) return;
    if ( nMaxStats <= 0 ) return;
    if ( maxMassBalErrs[0].index >= 0 )
    {
        WRITE("");
        WRITE("*************************");
        WRITE("Highest Continuity Errors");
        WRITE("*************************");
        for (i=0; i<nMaxStats; i++)
        {
            j = maxMassBalErrs[i].index;
            if ( j < 0 ) continue;
            Frpt.contents += `\n  Node "+Node[j].ID+" (${maxMassBalErrs[i].value.toFixed(2)}%%)`
        }
        WRITE("");
    }

    if ( CourantFactor == 0.0 ) return;
    WRITE("");
    WRITE("***************************");
    WRITE("Time-Step Critical Elements");
    WRITE("***************************");
    k = 0;
    for (i=0; i<nMaxStats; i++)
    {
        j = maxCourantCrit[i].index;
        if ( j < 0 ) continue;
        k++;
        if ( maxCourantCrit[i].objType == NODE )
             Frpt.contents += "\n  Node " + Node[j].ID;
        else Frpt.contents += "\n  Link " + Link[j].ID;
        Frpt.contents += ` (${maxCourantCrit[i].value.toFixed(2)}%%)`
    }
    if ( k == 0 ) Frpt.contents += "\n  None";
    WRITE("");
}

//=============================================================================
// TMaxStats flowTurns[], 
// int nMaxStats
report_writeMaxFlowTurns(flowTurns, nMaxStats)
//
//  Input:   flowTurns[] = links with highest number of flow turns
//           nMaxStats = number of links in flowTurns[]
//  Output:  none
//  Purpose: lists links with highest number of flow turns (i.e., fraction
//           of time periods where the flow is higher (or lower) than the
//           flows in the previous and following periods).
//
{
    let i, j;

    if ( Nobjects[LINK] == 0 ) return;
    WRITE("");
    WRITE("********************************");
    WRITE("Highest Flow Instability Indexes");
    WRITE("********************************");
    if ( nMaxStats <= 0 || flowTurns[0].index <= 0 )
        Frpt.contents += "\n  All links are stable.";
    else
    {
        for (i=0; i<nMaxStats; i++)
        {
            j = flowTurns[i].index;
            if ( j < 0 ) continue;
            Frpt.contents += "\n  Link "+Link[j].ID+` (${flowTurns[i].value.toFixed(0)}%.0f)`
        }
    }
    WRITE("");
}

//=============================================================================
// TSysStats* sysStats
report_writeSysStats(sysStats)
//
//  Input:   sysStats = simulation statistics for overall system
//  Output:  none
//  Purpose: writes simulation statistics for overall system to report file.
//
// ${sysStats.minTimeStep.toFixed(2).padStart(7, ' ')}
{
    let x;
    let eventStepCount;  // Routing steps taken during reporting period   //(5.1.015)

    eventStepCount = ReportStepCount - sysStats.steadyStateCount;           //(5.1.015)
    if ( Nobjects[LINK] == 0 || TotalStepCount == 0
        || eventStepCount == 0.0 ) return; 
    WRITE("");
    WRITE("*************************");
    WRITE("Routing Time Step Summary");
    WRITE("*************************");
    Frpt.contents += 
        `\n  Minimum Time Step           :  ${sysStats.minTimeStep.toFixed(2).padStart(7, ' ')} sec`
    Frpt.contents += 
        `\n  Average Time Step           :  ${(sysStats.avgTimeStep / eventStepCount).toFixed(2).padStart(7, ' ')} sec`
    Frpt.contents += 
        `\n  Maximum Time Step           :  ${sysStats.maxTimeStep.toFixed(2).padStart(7, ' ')} sec`
    x = (1.0 - sysStats.avgTimeStep * 1000.0 / NewRoutingTime) * 100.0;
    Frpt.contents += 
        `\n  Percent in Steady State     :  ${MIN(x, 100.0).toFixed(2).padStart(7, ' ')}`;
    Frpt.contents += 
        `\n  Average Iterations per Step :  ${(sysStats.avgStepCount / eventStepCount).toFixed(2).padStart(7, ' ')}`
    Frpt.contents += 
        `\n  Percent Not Converging      :  ${(100.0 * NonConvergeCount / eventStepCount).toFixed(2).padStart(7, ' ')}`

    // --- write grouped frequency table of variable routing time steps        //(5.1.015)
    if (RouteModel == DW && CourantFactor > 0.0)                               //
        report_RouteStepFreq(sysStats);                                        //
    WRITE("");
}

//=============================================================================
// TSysStats* sysStats
////  New added to release 5.1.015.  ////                             //(5.1.015)
report_RouteStepFreq(sysStats)
//
//  Input:   sysStats = simulation statistics for overall system
//  Output:  none
//  Purpose: writes grouped frequency table of routing time steps to report file.
//
{
    let totalSteps = 0.0;
    let    i;

    for (i = 1; i < TIMELEVELS; i++)
        totalSteps += sysStats.timeStepCounts[i];
    Frpt.contents += 
        "\n  Time Step Frequencies       :";
    for (i = 1; i < TIMELEVELS; i++){
        let val1 = sysStats.timeStepIntervals[i-1].toFixed(3).padStart(6, ' ')
        let val2 = sysStats.timeStepIntervals[i].toFixed(3).padStart(6, ' ')
        let val3 = (100.0 * (sysStats.timeStepCounts[i]) / totalSteps).toFixed(2).padStart(7, ' ')
        Frpt.contents += 
            `\n     ${val1} - ${val2} sec      :  ${val3} %%`
    }
}


//=============================================================================
//      SIMULATION RESULTS REPORTING
//=============================================================================

report_writeReport()
//
//  Input:   none
//  Output:  none
//  Purpose: writes simulation results to report file.
//
{
    if ( ErrorCode ) return;
    if ( Nperiods == 0 ) return;
    if ( RptFlags.subcatchments != NONE
         && ( IgnoreRainfall == FALSE ||
              IgnoreSnowmelt == FALSE ||
              IgnoreGwater == FALSE)
       ) report_Subcatchments();

    if ( IgnoreRouting == TRUE && IgnoreQuality == TRUE ) return;
    if ( RptFlags.nodes != NONE ) report_Nodes();
    if ( RptFlags.links != NONE ) report_Links();
}

//=============================================================================

report_Subcatchments()
//
//  Input:   none
//  Output:  none
//  Purpose: writes results for selected subcatchments to report file.
//
{
    let      j, p, k;
    let      period;
    let days;
    let     theDate;
    let     theTime;
    let      hasSnowmelt = (Nobjects[SNOWMELT] > 0 && !IgnoreSnowmelt);
    let      hasGwater   = (Nobjects[AQUIFER] > 0  && !IgnoreGwater);
    let      hasQuality  = (Nobjects[POLLUT] > 0 && !IgnoreQuality);

    if ( Nobjects[SUBCATCH] == 0 ) return;
    WRITE("");
    WRITE("********************");
    WRITE("Subcatchment Results");
    WRITE("********************");
    k = 0;
    for (j = 0; j < Nobjects[SUBCATCH]; j++)
    {
        if ( Subcatch[j].rptFlag == TRUE )
        {
            report_SubcatchHeader(Subcatch[j].ID);
            for ( period = 1; period <= Nperiods; period++ )
            {
                output_readDateTime(period, days);
                theDate = datetime_dateToStr(days, theDate);
                theTime = datetime_timeToStr(days, theTime);
                output_readSubcatchResults(period, k);

                let val1 = theDate.padStart(11, ' ')
                let val2 = theTime.padStart(8, ' ')
                let val3 = SubcatchResults[SUBCATCH_RAINFALL].toFixed(3).padStart(10, ' ')
                let val4 = (SubcatchResults[SUBCATCH_EVAP]/24.0 + SubcatchResults[SUBCATCH_INFIL]).toFixed(3).padStart(10, ' ')
                let val5 = SubcatchResults[SUBCATCH_RUNOFF].toFixed(4).padStart(10, ' ')
                Frpt.contents += `\n  ${val1} ${val2} ${val3}${val4}${val5}`
                if ( hasSnowmelt )
                    Frpt.contents += `  ${SubcatchResults[SUBCATCH_SNOWDEPTH].toFixed(3).padStart(10, ' ')}`
                        
                if ( hasGwater )
                    Frpt.contents += `${SubcatchResults[SUBCATCH_GW_ELEV].toFixed(3).padStart(10, ' ')}${SubcatchResults[SUBCATCH_GW_FLOW].toFixed(4).padStart(10, ' ')}`
                if ( hasQuality )
                    for (p = 0; p < Nobjects[POLLUT]; p++)
                        Frpt.contents += SubcatchResults[SUBCATCH_WASHOFF+p].toFixed(3).padStart(10, ' ')
            }
            WRITE("");
            k++;
        }
    }
}

//=============================================================================
// char *id
 report_SubcatchHeader(id)
//
//  Input:   id = subcatchment ID name
//  Output:  none
//  Purpose: writes table headings for subcatchment results to report file.
//
{
    let i;
    let hasSnowmelt = (Nobjects[SNOWMELT] > 0 && !IgnoreSnowmelt);
    let hasGwater   = (Nobjects[AQUIFER] > 0  && !IgnoreGwater);
    let hasQuality  = (Nobjects[POLLUT] > 0 && !IgnoreQuality);

    // --- print top border of header
    WRITE("");
    Frpt.contents += "\n  <<< Subcatchment "+id+" >>>"
    WRITE(LINE_51);
    if ( hasSnowmelt  > 0 ) Frpt.contents += LINE_12;
    if ( hasGwater )
    {
        Frpt.contents += LINE_10;
        Frpt.contents += LINE_10;
    }
    if ( hasQuality )
    {
        for (i = 0; i < Nobjects[POLLUT]; i++) Frpt.contents += LINE_10;
    }

    // --- print first line of column headings
    Frpt.contents += 
    "\n  Date        Time        Precip.    Losses    Runoff";
    if ( hasSnowmelt ) Frpt.contents += "  Snow Depth";
    if ( hasGwater   ) Frpt.contents += "  GW Elev.   GW Flow";
    if ( hasQuality ) for (i = 0; i < Nobjects[POLLUT]; i++)
        Frpt.contents += Pollut[i].ID.padStart(10, ' ');

    // --- print second line of column headings
    if ( UnitSystem == US ) Frpt.contents += 
    `\n                            in/hr     in/hr ${FlowUnitWords[FlowUnits].padStart(9, ' ')}`
    else Frpt.contents += 
    `\n                            mm/hr     mm/hr ${FlowUnitWords[FlowUnits].padStart(9, ' ')}`
    if ( hasSnowmelt )
    {
        if ( UnitSystem == US ) Frpt.contents += "      inches";
        else                    Frpt.contents += "     mmeters";
    }
    if ( hasGwater )
    {
        if ( UnitSystem == US )
            Frpt.contents += `      feet ${FlowUnitWords[FlowUnits].padStart(9, ' ')}`
        else
            Frpt.contents += `    meters ${FlowUnitWords[FlowUnits].padStart(9, ' ')}`
    }
    if ( hasQuality ) for (i = 0; i < Nobjects[POLLUT]; i++)
        Frpt.contents += QualUnitsWords[Pollut[i].units].padStart(10, ' ')

    // --- print lower border of header
    WRITE(LINE_51);
    if ( hasSnowmelt ) Frpt.contents += LINE_12;
    if ( hasGwater )
    {
        Frpt.contents += LINE_10;
        Frpt.contents += LINE_10;
    }
    if ( hasQuality ) for (i = 0; i < Nobjects[POLLUT]; i++)
        Frpt.contents += LINE_10;
}

//=============================================================================

report_Nodes()
//
//  Input:   none
//  Output:  none
//  Purpose: writes results for selected nodes to report file.
//
{
    let      j, p, k;
    let      period;
    let days;
    let     theDate;
    let     theTime;

    if ( Nobjects[NODE] == 0 ) return;
    WRITE("");
    WRITE("************");
    WRITE("Node Results");
    WRITE("************");
    k = 0;
    for (j = 0; j < Nobjects[NODE]; j++)
    {
        if ( Node[j].rptFlag == TRUE )
        {
            report_NodeHeader(Node[j].ID);
            for ( period = 1; period <= Nperiods; period++ )
            {
                output_readDateTime(period, days);
                theDate = datetime_dateToStr(days, theDate);
                theTime = datetime_timeToStr(days, theTime);
                output_readNodeResults(period, k);

                let val1 = theDate.padStart(11, ' ')
                let val2 = theTime.padStart(8, ' ')
                let val3 = NodeResults[NODE_INFLOW].toFixed(3).padStart(9, ' ')
                let val4 = NodeResults[NODE_OVERFLOW].toFixed(3).padStart(9, ' ')
                let val5 = NodeResults[NODE_DEPTH].toFixed(3).padStart(9, ' ')
                let val6 = NodeResults[NODE_HEAD].toFixed(3).padStart(9, ' ')
                Frpt.contents += `\n  ${val1} ${val2}  ${val3} ${val4} ${val5} ${val6}`
                if ( !IgnoreQuality ) for (p = 0; p < Nobjects[POLLUT]; p++)
                    Frpt.contents += NodeResults[NODE_QUAL + p].toFixed(3).padStart(9, ' ')
            }
            WRITE("");
            k++;
        }
    }
}

//=============================================================================
// char *id
 report_NodeHeader(id)
//
//  Input:   id = node ID name
//  Output:  none
//  Purpose: writes table headings for node results to report file.
//
{
    let i;
    let lengthUnits;
    WRITE("");
    Frpt.contents += "\n  <<< Node "+id+" >>>"
    WRITE(LINE_64);
    for (i = 0; i < Nobjects[POLLUT]; i++) Frpt.contents += LINE_10;

    Frpt.contents += 
    "\n                           Inflow  Flooding     Depth      Head";
    if ( !IgnoreQuality ) for (i = 0; i < Nobjects[POLLUT]; i++)
        Frpt.contents += Pollut[i].ID.padStart(10, ' ')
    if ( UnitSystem == US) lengthUnits = "feet";
    else lengthUnits = "meters";

    let val1 = FlowUnitWords[FlowUnits].padStart(9, ' ')
    let val2 = FlowUnitWords[FlowUnits].padStart(9, ' ')
    let val3 = lengthUnits.padStart(9, ' ')
    let val4 = lengthUnits.padStart(9, ' ')
    Frpt.contents += 
    `\n  Date        Time      ${val1} ${val2} ${val3} ${val4}`
    if ( !IgnoreQuality ) for (i = 0; i < Nobjects[POLLUT]; i++)
        Frpt.contents += QualUnitsWords[Pollut[i].units].padStart(10, ' ')

    WRITE(LINE_64);
    if ( !IgnoreQuality )
        for (i = 0; i < Nobjects[POLLUT]; i++) Frpt.contents += LINE_10;
}

//=============================================================================

report_Links()
//
//  Input:   none
//  Output:  none
//  Purpose: writes results for selected links to report file.
//
{
    let      j, p, k;
    let      period;
    let days;
    let     theDate;
    let     theTime;

    if ( Nobjects[LINK] == 0 ) return;
    WRITE("");
    WRITE("************");
    WRITE("Link Results");
    WRITE("************");
    k = 0;
    for (j = 0; j < Nobjects[LINK]; j++)
    {
        if ( Link[j].rptFlag == TRUE )
        {
            report_LinkHeader(Link[j].ID);
            for ( period = 1; period <= Nperiods; period++ )
            {
                output_readDateTime(period, days);
                theDate = datetime_dateToStr(days, theDate);
                theTime = datetime_timeToStr(days, theTime);
                output_readLinkResults(period, k);

                let val1 = theDate.padStart(11, ' ')
                let val2 = theTime.padStart(8, ' ')
                let val3 = LinkResults[LINK_FLOW].toFixed(3).padStart(9, ' ')
                let val4 = LinkResults[LINK_VELOCITY].toFixed(3).padStart(9, ' ')
                let val5 = LinkResults[LINK_DEPTH].toFixed(3).padStart(9, ' ')
                let val6 = LinkResults[LINK_CAPACITY].toFixed(3).padStart(9, ' ')
                Frpt.contents += `\n  ${val1} ${val2}  ${val3} ${val4} ${val5} ${val6}`
                if ( !IgnoreQuality ) for (p = 0; p < Nobjects[POLLUT]; p++)
                    Frpt.contents += " " + LinkResults[LINK_QUAL + p].toFixed(3).padStart(9, ' ');
            }
            WRITE("");
            k++;
        }
    }
}

//=============================================================================
// char *id
 report_LinkHeader(id)
//
//  Input:   id = link ID name
//  Output:  none
//  Purpose: writes table headings for link results to report file.
//
{
    let i;
    WRITE("");
    Frpt.contents += "\n  <<< Link "+id+" >>>";
    WRITE(LINE_64);
    for (i = 0; i < Nobjects[POLLUT]; i++) Frpt.contents += LINE_10;

    Frpt.contents += 
    "\n                             Flow  Velocity     Depth  Capacity/";
    if ( !IgnoreQuality ) for (i = 0; i < Nobjects[POLLUT]; i++)
        Frpt.contents += Pollut[i].ID.padStart(10, ' ');

    if ( UnitSystem == US )
        Frpt.contents += 
        `\n  Date        Time     ${FlowUnitWords[FlowUnits].padStart(10, ' ')}    ft/sec      feet   Setting `;
    else
        Frpt.contents += 
        `\n  Date        Time     ${FlowUnitWords[FlowUnits].padStart(10, ' ')}     m/sec    meters   Setting `;

    if ( !IgnoreQuality ) for (i = 0; i < Nobjects[POLLUT]; i++)
        Frpt.contents += " " + QualUnitsWords[Pollut[i].units].padStart(9, ' ');

    WRITE(LINE_64);
    if ( !IgnoreQuality )
        for (i = 0; i < Nobjects[POLLUT]; i++) Frpt.contents += LINE_10;
}


//=============================================================================
//      ERROR REPORTING
//=============================================================================
// int code, 
// char* s
report_writeErrorMsg(code, s)
//
//  Input:   code = error code
//           s = error message text
//  Output:  none
//  Purpose: writes error message to report file.
//
{
    if ( Frpt.contents )
    {
        WRITE("");
        Frpt.contents += error_getMsg(code) + s;
    }
    ErrorCode = code;

    // --- save message to ErrorMsg if it's not for a line of input data
    if ( ErrorCode <= ERR_INPUT || ErrorCode >= ERR_FILE_NAME )
    {                                                
        ErrorMsg = error_getMsg(ErrorCode) + s;
    }
}

//=============================================================================

report_writeErrorCode()
//
//  Input:   none
//  Output:  none
//  Purpose: writes error message to report file.
//
{
    if ( Frpt.contents )
    {
        if ( (ErrorCode >= ERR_MEMORY && ErrorCode <= ERR_TIMESTEP)
        ||   (ErrorCode >= ERR_FILE_NAME && ErrorCode <= ERR_OUT_FILE)
        ||   (ErrorCode == ERR_SYSTEM) )
            Frpt.contents += error_getMsg(ErrorCode);                 //(5.1.013)
    }
}

//=============================================================================
// int k, int sect, char* line, long lineCount
report_writeInputErrorMsg(k, sect, line, lineCount)
//
//  Input:   k = error code
//           sect = number of input data section where error occurred
//           line = line of data containing the error
//           lineCount = line number of data file containing the error
//  Output:  none
//  Purpose: writes input error message to report file.
//
{
    if ( Frpt.contents )
    {
        report_writeErrorMsg(k, ErrString);
        if ( sect < 0 ) Frpt.contents += lineCount.toString();
        else            Frpt.contents += lineCount.toString() + SectWords[sect];
        Frpt.contents += "\n  " + line;
    }
}

//=============================================================================
// char* msg, char* id
report_writeWarningMsg(msg, id)
//
//  Input:   msg = text of warning message
//           id = ID name of object that message refers to
//  Output:  none
//  Purpose: writes a warning message to the report file.
//
{
    Frpt.contents += "\n  "+msg+" "+ id;
    Warnings++;
}

//=============================================================================
// int code, TTable *tseries
report_writeTSeriesErrorMsg(code, tseries)
//
//  Input:   tseries = pointer to a time series
//  Output:  none
//  Purpose: writes the date where a time series' data is out of order.
//
{
    let     theDate;
    let     theTime;
    let x;

    if (code == ERR_CURVE_SEQUENCE)
    {
        x = tseries.x2;
        theDate = datetime_dateToStr(x, theDate);
        theTime = datetime_timeToStr(x, theTime);
        report_writeErrorMsg(ERR_TIMESERIES_SEQUENCE, tseries.ID);
        Frpt.contents += " at "+theDate+" "+theTime+"."
    }
    else report_writeErrorMsg(code, tseries.ID);
}

//-----------------------------------------------------------------------------
//   statsrpt.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14 (Build 5.1.001)
//             09/15/14 (Build 5.1.007)
//             03/19/15 (Build 5.1.008)
//             04/30/15 (Build 5.1.009)
//             08/01/16 (Build 5.1.011)
//             05/10/18 (Build 5.1.013)
//             04/01/20 (Build 5.1.015)
//   Author:   L. Rossman
//
//   Report writing functions for summary statistics.
//
//   Build 5.1.008:
//   - New Groundwater Summary table added.
//   - Reported Max. Depth added to Node Depth Summary table.
//
//   Build 5.1.009:
//   - Units on column heading in Node Inflow Summary table fixed.
//
//   Build 5.1.011:
//   - Redundant units conversion on max. reported node depth removed.
//   - Node Surcharge table only produced for dynamic wave routing.
//
//   Build 5.1.013:
//   - Pervious and impervious runoff added to Subcatchment Runoff Summary.
//
//   Build 5.1.015:
//   - Fixes bug in summary statistics when Report Start date > Start Date.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Imported variables
//-----------------------------------------------------------------------------
/*extern TSubcatchStats* SubcatchStats;          // defined in STATS.C
extern TNodeStats*     NodeStats;
extern TLinkStats*     LinkStats;
extern TStorageStats*  StorageStats;
extern TOutfallStats*  OutfallStats;
extern TPumpStats*     PumpStats;
extern double          MaxOutfallFlow;
extern double          MaxRunoffFlow;
extern double*         NodeInflow;             // defined in MASSBAL.C
extern double*         NodeOutflow;            // defined in massbal.c
*/


WRITE(x) {report_writeLine((x))}

FlowFmt = '';
Vcf;

// string formatting function
// can take in a number or a string
// returns a string with a ' ' padding
formatFloat(num, padding, floatingPoints){
    return num.toFixed(floatingPoints).padStart(padding);
}

// string formatting function
// replaces FlowFmt constant
flowFmt(num){
    // --- set number of decimal places for reporting flow values
    if ( FlowUnits == MGD || FlowUnits == CMS ) {
        return num.toFixed(3).padStart(9);
    }
    else {
        return num.toFixed(2).padStart(9);
    }
}

//=============================================================================

statsrpt_writeReport()
//
//  Input:   none
//  Output:  none
//  Purpose: reports simulation summary statistics.
//
{
    // --- set number of decimal places for reporting flow values
    if ( FlowUnits == MGD || FlowUnits == CMS ) FlowFmt = "%9.3f"
    else FlowFmt = "%9.2f";

    // --- volume conversion factor from ft3 to Mgal or Mliters
    if (UnitSystem == US) Vcf = 7.48 / 1.0e6;
    else                  Vcf = 28.317 / 1.0e6;

    // --- report summary results for subcatchment runoff 
    if ( Nobjects[SUBCATCH] > 0 )
    {
        if ( !IgnoreRainfall ||
             (Nobjects[SNOWMELT] > 0 && !IgnoreSnowmelt) ||
             (Nobjects[AQUIFER] > 0  && !IgnoreGwater) )
        {
            writeSubcatchRunoff();
            lid_writeWaterBalance();
            if ( !IgnoreGwater ) writeGroundwater();
            if ( Nobjects[POLLUT] > 0 && !IgnoreQuality) writeSubcatchLoads();
        }
    }

    // --- report summary results for flow routing
    if ( Nobjects[LINK] > 0 && !IgnoreRouting )
    {
        writeNodeDepths();
        writeNodeFlows();
        if ( RouteModel == DW ) writeNodeSurcharge();
        writeNodeFlooding();
        writeStorageVolumes();
        writeOutfallLoads();
        writeLinkFlows();
        writeFlowClass();
        writeLinkSurcharge();
        writePumpFlows();
        if ( Nobjects[POLLUT] > 0 && !IgnoreQuality) writeLinkLoads();
    }
}

//=============================================================================

writeSubcatchRunoff()
{
    let    j;
    let a, x, r;

    if ( Nobjects[SUBCATCH] == 0 ) return;
    WRITE("");
    WRITE("***************************");
    WRITE("Subcatchment Runoff Summary");
    WRITE("***************************");
    WRITE("");
    Frpt.contents += 

////////  Segment below modified for release 5.1.013.  /////////

`\n  ------------------------------------------------------------------------------------------------------------------------------`+
`\n                            Total      Total      Total      Total     Imperv       Perv      Total       Total     Peak  Runoff`+
`\n                           Precip      Runon       Evap      Infil     Runoff     Runoff     Runoff      Runoff   Runoff   Coeff`;
    if ( UnitSystem == US ) Frpt.contents +=
`\n  Subcatchment                 in         in         in         in         in         in         in    ${VolUnitsWords[UnitSystem].padStart(8, ' ')}      ${FlowUnitWords[FlowUnits].padStart(3, ' ')}`
    else Frpt.contents +=
`\n  Subcatchment                 mm         mm         mm         mm         mm         mm         mm    ${VolUnitsWords[UnitSystem].padStart(8, ' ')}      ${FlowUnitWords[FlowUnits].padStart(3, ' ')}`
    Frpt.contents +=
`\n  ------------------------------------------------------------------------------------------------------------------------------`;

/////////////////////////////////////////////////////////////////

    for ( j = 0; j < Nobjects[SUBCATCH]; j++ )
    {
        a = Subcatch[j].area;
        if ( a == 0.0 ) continue;
        Frpt.contents += `\n  ${Subcatch[j].ID.padStart(20, ' ')}`
        
        x = SubcatchStats[j].precip * UCF(RAINDEPTH);
        Frpt.contents += ` ${(x/a).toFixed(2).padStart(10, ' ')}`
        
        x = SubcatchStats[j].runon * UCF(RAINDEPTH);
        Frpt.contents += ` ${(x/a).toFixed(2).padStart(10, ' ')}`
        
        x = SubcatchStats[j].evap * UCF(RAINDEPTH);
        Frpt.contents += ` ${(x/a).toFixed(2).padStart(10, ' ')}`
        
        x = SubcatchStats[j].infil * UCF(RAINDEPTH); 
        Frpt.contents += ` ${(x/a).toFixed(2).padStart(10, ' ')}`
    
        x = SubcatchStats[j].impervRunoff * UCF(RAINDEPTH); 
        Frpt.contents += ` ${(x/a).toFixed(2).padStart(10, ' ')}`                   //
        
        x = SubcatchStats[j].pervRunoff * UCF(RAINDEPTH); 
        Frpt.contents += ` ${(x/a).toFixed(2).padStart(10, ' ')}`                    //
        
        x = SubcatchStats[j].runoff * UCF(RAINDEPTH);
        Frpt.contents += ` ${(x/a).toFixed(2).padStart(10, ' ')}`
        
        x = SubcatchStats[j].runoff * Vcf;
        Frpt.contents += ` ${(x).toFixed(2).padStart(12, ' ')}`
        
        x = SubcatchStats[j].maxFlow * UCF(FLOW);
        Frpt.contents += ` ${(x).toFixed(2).padStart(8, ' ')}`
        
        r = SubcatchStats[j].precip + SubcatchStats[j].runon;
        if ( r > 0.0 ) r = SubcatchStats[j].runoff / r;
        Frpt.contents += ` ${(r).toFixed(3).padStart(8, ' ')}`
    }
    WRITE("");
}

//=============================================================================
// void
   writeGroundwater()
{
    let i, j;
    let count = 0;
    let totalSeconds = NewRunoffTime / 1000.;
    let x =  new Array(9);

    if ( Nobjects[SUBCATCH] == 0 ) return;
    for ( j = 0; j < Nobjects[SUBCATCH]; j++ )
    {
        if ( Subcatch[j].groundwater != NULL ) count++;
    }
    if ( count == 0 ) return;

    WRITE("");
    WRITE("*******************");
    WRITE("Groundwater Summary");
    WRITE("*******************");
    WRITE("");
    Frpt.contents +=

`\n  -----------------------------------------------------------------------------------------------------`+
`\n                                            Total    Total  Maximum  Average  Average    Final    Final`+
`\n                          Total    Total    Lower  Lateral  Lateral    Upper    Water    Upper    Water`+
`\n                          Infil     Evap  Seepage  Outflow  Outflow   Moist.    Table   Moist.    Table`;
    if ( UnitSystem == US ) Frpt.contents +=
`\n  Subcatchment               in       in       in       in      ${FlowUnitWords[FlowUnits].padEnd(3, ' ')}                ft                ft`
    else Frpt.contents +=
`\n  Subcatchment               mm       mm       mm       mm      ${FlowUnitWords[FlowUnits].padEnd(3, ' ')}                 m                 m`
    Frpt.contents +=
`\n  -----------------------------------------------------------------------------------------------------`;

    for ( j = 0; j < Nobjects[SUBCATCH]; j++ )
    {
        if ( Subcatch[j].area == 0.0 || Subcatch[j].groundwater == NULL ) continue;
        Frpt.contents += `\n  ${Subcatch[j].ID.padStart(20, ' ')}`;
        x[0] = Subcatch[j].groundwater.stats.infil * UCF(RAINDEPTH);
        x[1] = Subcatch[j].groundwater.stats.evap * UCF(RAINDEPTH);
        x[2] = Subcatch[j].groundwater.stats.deepFlow * UCF(RAINDEPTH);
        x[3] = Subcatch[j].groundwater.stats.latFlow * UCF(RAINDEPTH);
        x[4] = Subcatch[j].groundwater.stats.maxFlow * UCF(FLOW) * Subcatch[j].area;
        x[5] = Subcatch[j].groundwater.stats.avgUpperMoist / totalSeconds;
        x[6] = Subcatch[j].groundwater.stats.avgWaterTable * UCF(LENGTH) /
               totalSeconds;
        x[7] = Subcatch[j].groundwater.stats.finalUpperMoist;
        x[8] = Subcatch[j].groundwater.stats.finalWaterTable * UCF(LENGTH);
        for (i = 0; i < 9; i++) Frpt.contents += ` ${( x[i]).toFixed(2).padStart(8, ' ')}`
    }
    WRITE(``);
}

//=============================================================================

writeSubcatchLoads()
{
    let i, j, p;
    let x;
    let totals = []; 
    let  units;
    let  subcatchLine = "--------------------";
    let  pollutLine   = "--------------";

    // --- create an array to hold total loads for each pollutant
    //totals = (double *) calloc(Nobjects[POLLUT], sizeof(double));
    totals = new Array(Nobjects[POLLUT]);
    if ( totals )
    {
        // --- print the table headings 
        WRITE(``);
        WRITE("****************************");
        WRITE("Subcatchment Washoff Summary");
        WRITE("****************************");
        WRITE(``);
        Frpt.contents += "\n  " + subcatchLine;
        for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents += "%s" + pollutLine;
        Frpt.contents += "\n                      ";
        for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents += Pollut[p].ID.padStart(14, ' ');
        Frpt.contents += "\n  Subcatchment        ";
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            i = UnitSystem;
            if ( Pollut[p].units == COUNT ) i = 2;
            units = LoadUnitsWords[i]
            Frpt.contents += units.padStart(14, ' ');
            totals[p] = 0.0;
        }
        Frpt.contents += "\n  " + subcatchLine;
        for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents +=  pollutLine;

        // --- print the pollutant loadings from each subcatchment
        for ( j = 0; j < Nobjects[SUBCATCH]; j++ )
        {
            Frpt.contents += "\n  " + Subcatch[j].ID.padEnd(20, ' ');
            for (p = 0; p < Nobjects[POLLUT]; p++)
            {
                x = Subcatch[j].totalLoad[p];
                totals[p] += x;
                if ( Pollut[p].units == COUNT ) x = Math.log10(x);
                Frpt.contents +=  x.toFixed(3).padStart(14, ' ')
            }
        }

        // --- print the total loading of each pollutant
        Frpt.contents +=  "\n  " + subcatchLine
        for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents +=  pollutLine
        Frpt.contents +=  "\n  System              "
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            x = totals[p];
            if ( Pollut[p].units == COUNT ) x = Math.log10(x);
            Frpt.contents +=  x.toFixed(3).padStart(14, ' ')
        }
        //free(totals);
        totals = [];
        WRITE("");
    }
}

//=============================================================================

writeNodeDepths()
//
//  Input:   none
//  Output:  none
//  Purpose: writes simulation statistics for nodes to report file.
//
{
    let j, days, hrs, mins;
    let returnObj;
    if ( Nobjects[LINK] == 0 ) return;

    WRITE(``);
    WRITE(`******************`);
    WRITE(`Node Depth Summary`);
    WRITE(`******************`);
    WRITE(``);

    Frpt.contents +=  
`\n  ---------------------------------------------------------------------------------`+
`\n                                 Average  Maximum  Maximum  Time of Max    Reported`+
`\n                                   Depth    Depth      HGL   Occurrence   Max Depth`;
    if ( UnitSystem == US ) Frpt.contents +=  
`\n  Node                 Type         Feet     Feet     Feet  days hr:min        Feet`;
    else Frpt.contents +=  
`\n  Node                 Type       Meters   Meters   Meters  days hr:min      Meters`;
    Frpt.contents +=  
`\n  ---------------------------------------------------------------------------------`;

    for ( j = 0; j < Nobjects[NODE]; j++ )
    {
        Frpt.contents +=  `\n  `+  Node[j].ID.padEnd(20, ' ')
        Frpt.contents +=  ` %-9s `, NodeTypeWords[Node[j].type].padEnd(9, ' ')

        ////////////////////////////////////////
        returnObj = {days: days, hrs: hrs, mins: mins}
        getElapsedTime(NodeStats[j].maxDepthDate, returnObj)
        days = returnObj.days
        hrs = returnObj.hrs
        mins = returnObj.mins
        ////////////////////////////////////////
        //getElapsedTime(NodeStats[j].maxDepthDate, &days, &hrs, &mins);

        val1 = (NodeStats[j].avgDepth / ReportStepCount * UCF(LENGTH)).toFixed(2).padStart(7, ' ')              //(5.1.015)
        val2 = (NodeStats[j].maxDepth * UCF(LENGTH)).toFixed(2).padStart(7, ' ')
        val3 = ((NodeStats[j].maxDepth + Node[j].invertElev) * UCF(LENGTH)).toFixed(2).padStart(7, ' ')
        val4 = (days.toString()).padStart(4, ' ')
        val5 = (hrs.toString()).padStart(2, '0')
        val6 = (mins.toString()).padStart(2, '0')
        val7 = (NodeStats[j].maxRptDepth).toFixed(2).padStart(10, ' ')
        Frpt.contents +=  `${val1}  ${val2}  ${val3}  ${val4}  ${val5}:${val6}  ${val7}`
    }
    WRITE(``);
}

//=============================================================================

writeNodeFlows()
//
//  Input:   none
//  Output:  none
//  Purpose: writes flow statistics for nodes to report file.
//
{
    let j;
    let days1, hrs1, mins1;

    // return object
    let returnObj;

    WRITE(``);
    WRITE(`*******************`);
    WRITE(`Node Inflow Summary`);
    WRITE(`*******************`);
    WRITE(``);

    let val1 = FlowUnitWords[FlowUnits].padStart(3, ' ')
    let val2 = FlowUnitWords[FlowUnits].padStart(4, ' ')
    let val3 = VolUnitsWords[UnitSystem].padStart(8, ' ')
    let val4 = VolUnitsWords[UnitSystem].padStart(8, ' ')
    Frpt.contents +=  
`\n  -------------------------------------------------------------------------------------------------`+
`\n                                  Maximum  Maximum                  Lateral       Total        Flow`+
`\n                                  Lateral    Total  Time of Max      Inflow      Inflow     Balance`+
`\n                                   Inflow   Inflow   Occurrence      Volume      Volume       Error`+
`\n  Node                 Type           ${val1}      ${val2}  days hr:min    ${val3}s    ${val4}     Percent`

    Frpt.contents +=  
`\n  -------------------------------------------------------------------------------------------------`

    for ( j = 0; j < Nobjects[NODE]; j++ )
    {
        Frpt.contents += `\n  ` + Node[j].ID.padEnd(20, ' ')
        Frpt.contents += ` ` + NodeTypeWords[Node[j].type].padEnd(9);
        ////////////////////////////////////////
        returnObj = {days: days1, hrs: hrs1, mins: mins1}
        getElapsedTime(NodeStats[j].maxInflowDate, returnObj)
        days1 = returnObj.days
        hrs1 = returnObj.hrs
        mins1 = returnObj.mins
        ////////////////////////////////////////
        //getElapsedTime(NodeStats[j].maxInflowDate, &days1, &hrs1, &mins1);
        Frpt.contents += flowFmt(NodeStats[j].maxLatFlow * UCF(FLOW));
        Frpt.contents += flowFmt(NodeStats[j].maxInflow * UCF(FLOW));
        
        Frpt.contents += `  ${days1.toString().padStart(4, ' ')}  ${hrs1.toString().padStart(2, '0')}:${mins1.toString().padStart(2, '0')}`;
        Frpt.contents += (NodeStats[j].totLatFlow * Vcf).toExponential(8).padStart(12);
        Frpt.contents += (NodeInflow[j] * Vcf).toExponential(8).padStart(12);
        if ( Math.abs(NodeOutflow[j]) < 1.0 )
            Frpt.contents += ((NodeInflow[j]-NodeOutflow[j])*Vcf*1.0e6).toFixed(3).padStart(12, ' ') + ` ` +
                VolUnitsWords2[UnitSystem].padStart(3, ' ')
        else
            Frpt.contents += ((NodeInflow[j]-NodeOutflow[j]) /
                                          NodeOutflow[j]*100.).toFixed(3).padStart(12, ' ') 
    }
    WRITE(``);
}

//=============================================================================

writeNodeSurcharge()
{
    let    j, n = 0;
    let t, d1, d2;

    WRITE(``);
    WRITE(`**********************`);
    WRITE(`Node Surcharge Summary`);
    WRITE(`**********************`);
    WRITE(``);

    for ( j = 0; j < Nobjects[NODE]; j++ )
    {
        if ( Node[j].type == OUTFALL ) continue;
        if ( NodeStats[j].timeSurcharged == 0.0 ) continue;
        t = MAX(0.01, (NodeStats[j].timeSurcharged / 3600.0));
        if ( n == 0 )
        {
            WRITE(`Surcharging occurs when water rises above the top of the highest conduit.`);
            Frpt.contents += 
`\n  ---------------------------------------------------------------------`+
`\n                                               Max. Height   Min. Depth`+
`\n                                   Hours       Above Crown    Below Rim`;
    if ( UnitSystem == US ) Frpt.contents += 
`\n  Node                 Type      Surcharged           Feet         Feet`;
    else Frpt.contents += 
`\n  Node                 Type      Surcharged         Meters       Meters`;
    Frpt.contents += 
`\n  ---------------------------------------------------------------------`;
            n = 1;
        }
        Frpt.contents += `\n  ` + Node[j].ID.padEnd(20, ' ');
        Frpt.contents += ` %-9s`, NodeTypeWords[Node[j].type].padEnd(9, ' ');
        d1 = NodeStats[j].maxDepth + Node[j].invertElev - Node[j].crownElev;
        if ( d1 < 0.0 ) d1 = 0.0;
        d2 = Node[j].fullDepth - NodeStats[j].maxDepth;
        if ( d2 < 0.0 ) d2 = 0.0;
        Frpt.contents += `  ${t.toFixed(2).padStart(9, ' ')}      ${(d1*UCF(LENGTH)).toFixed(3).padStart(9, ' ')}    ${(d2*UCF(LENGTH)).toFixed(3).padStart(9, ' ')}`
    }
    if ( n == 0 ) WRITE(`No nodes were surcharged.`);
    WRITE(``);
}

//=============================================================================

writeNodeFlooding()
{
    let    j, n = 0;
    let    days, hrs, mins;
    let t;

    // return object for write functions
    let returnObj;

    WRITE(``);
    WRITE(`*********************`);
    WRITE(`Node Flooding Summary`);
    WRITE(`*********************`);
    WRITE(``);

    for ( j = 0; j < Nobjects[NODE]; j++ )
    {
        if ( Node[j].type == OUTFALL ) continue;
        if ( NodeStats[j].timeFlooded == 0.0 ) continue;
        t = Math.max(0.01, (NodeStats[j].timeFlooded / 3600.0));

        if ( n == 0 )
        {
            WRITE(`Flooding refers to all water that overflows a node, whether it ponds or not.`);
            Frpt.contents += 
`\n  --------------------------------------------------------------------------`+
`\n                                                             Total   Maximum`+
`\n                                 Maximum   Time of Max       Flood    Ponded`+
`\n                        Hours       Rate    Occurrence      Volume`
            if ( RouteModel == DW ) Frpt.contents += `     Depth`;
            else                    Frpt.contents += `    Volume`;
            Frpt.contents += 
`\n  Node                 Flooded       ${FlowUnitWords[FlowUnits].padStart(3, ' ')}   days hr:min    ${VolUnitsWords[UnitSystem].padStart(8, ' ')}`
            if ( RouteModel == DW )      Frpt.contents +=  `    ${PondingUnitsWords[UnitSystem].padStart(6, ' ')}`
            else if ( UnitSystem == US ) Frpt.contents +=  `  1000 ft3`;
            else                         Frpt.contents +=  `   1000 m3`;
            Frpt.contents += 
`\n  --------------------------------------------------------------------------`;
            n = 1;
        }
        Frpt.contents +=  `\n  `+ Node[j].ID.padEnd(20);
        Frpt.contents +=  ` ${t.toFixed(2).padStart(7, ' ')} `;
        Frpt.contents += flowFmt(NodeStats[j].maxOverflow * UCF(FLOW));

        returnObj = {days: days, hrs: hrs, mins: mins}
        getElapsedTime(NodeStats[j].maxOverflowDate, returnObj)
        days = returnObj.days
        hrs = returnObj.hrs
        mins = returnObj.mins
        //getElapsedTime(NodeStats[j].maxOverflowDate, &days, &hrs, &mins);
        Frpt.contents += `   ${days.padStart(4, ' ')}  ${hrs.padStart(2, '0')}:${mins.padStart(2, '0')}`
        Frpt.contents += (NodeStats[j].volFlooded * Vcf).toFixed(3).padStart(12, ' ');
        if ( RouteModel == DW )
            Frpt.contents += ` ` +
                ((NodeStats[j].maxDepth - Node[j].fullDepth) * UCF(LENGTH)).toFixed(3).padStart(9, ' ')
        else
            Frpt.contents += ` `+ 
                (NodeStats[j].maxPondedVol / 1000.0 * UCF(VOLUME)).toFixed(3).padStart(9, ' ')
    }

    if ( n == 0 ) WRITE(`No nodes were flooded.`);
    WRITE(``);
}

//=============================================================================

writeStorageVolumes()
//
//  Input:   none
//  Output:  none
//  Purpose: writes simulation statistics for storage units to report file.
//
{
    let    j, k, days, hrs, mins;
    let avgVol, maxVol, pctAvgVol, pctMaxVol;
    let addedVol, pctEvapLoss, pctSeepLoss;

    if ( Nnodes[STORAGE] > 0 )
    {
        WRITE(``);
        WRITE(`**********************`);
        WRITE(`Storage Volume Summary`);
        WRITE(`**********************`);
        WRITE(``);

        Frpt.contents += 
`\n  --------------------------------------------------------------------------------------------------`+
`\n                         Average     Avg  Evap Exfil       Maximum     Max    Time of Max    Maximum`+
`\n                          Volume    Pcnt  Pcnt  Pcnt        Volume    Pcnt     Occurrence    Outflow`
        if ( UnitSystem == US ) Frpt.contents += 
`\n  Storage Unit          1000 ft3    Full  Loss  Loss      1000 ft3    Full    days hr:min        `
        else Frpt.contents += 
`\n  Storage Unit           1000 m3    Full  Loss  Loss       1000 m3    Full    days hr:min        `
        Frpt.contents +=  FlowUnitWords[FlowUnits].padStart(3, ' ')
        Frpt.contents += 
`\n  --------------------------------------------------------------------------------------------------`

        for ( j = 0; j < Nobjects[NODE]; j++ )
        {
            if ( Node[j].type != STORAGE ) continue;
            k = Node[j].subIndex;
            Frpt.contents += `\n  ` + Node[j].ID.padEnd(20, ' ')
            avgVol = StorageStats[k].avgVol / ReportStepCount;         //(5.1.015)
            maxVol = StorageStats[k].maxVol;
            pctMaxVol = 0.0;
            pctAvgVol = 0.0;
            if ( Node[j].fullVolume > 0.0 )
            {
                pctAvgVol = avgVol / Node[j].fullVolume * 100.0;
                pctMaxVol = maxVol / Node[j].fullVolume * 100.0;
            }
            pctEvapLoss = 0.0;
            pctSeepLoss = 0.0;
            addedVol = NodeInflow[j] + StorageStats[k].initVol;
            if ( addedVol > 0.0 )
            {
                pctEvapLoss = StorageStats[k].evapLosses / addedVol * 100.0;
                pctSeepLoss = StorageStats[k].exfilLosses / addedVol * 100.0;
            }

            let val1 = (avgVol*UCF(VOLUME)/1000.0).toFixed(3).padStart(10, ' ')
            let val2 = pctAvgVol.toFixed(0).padStart(4, ' ')
            let val3 = pctEvapLoss.toFixed(0).padStart(4, ' ')
            let val4 = pctSeepLoss.toFixed(0).padStart(4, ' ')
            let val5 = (maxVol*UCF(VOLUME)/1000.0).toFixed(3).padStart(10, ' ')
            let val6 = pctMaxVol.toFixed(0).padStart(4, ' ')
            Frpt.contents += `${val1}    ${val2}  ${val3}  ${val4}    ${val5}    ${val6}`

            let returnObj = {days: days, hrs: hrs, mins: mins}
            getElapsedTime(StorageStats[k].maxVolDate, returnObj)
            days = returnObj.days
            hrs = returnObj.hrs
            mins = returnObj.mins
            //getElapsedTime(StorageStats[k].maxVolDate, &days, &hrs, &mins);
            Frpt.contents += `    ${days.padStart(4, ' ')}  ${hrs.padStart(2, '0')}:${mins.padStart(2, '0')}  `
            Frpt.contents += flowFmt(StorageStats[k].maxFlow*UCF(FLOW));
        }
        WRITE(``);
    }
}

//=============================================================================

writeOutfallLoads()
//
//  Input:   node
//  Output:  none
//  Purpose: writes simulation statistics for outfall nodess to report file.
//
{
    let  units;
    let  i, j, k, p;
    let  x;
    let  outfallCount, flowCount;
    let  flowSum, freqSum, volSum;
    totals = [];

    if ( Nnodes[OUTFALL] > 0 )
    {
        // --- initial totals
        //totals = (double *) calloc(Nobjects[POLLUT], sizeof(double));
        totals = new Array(Nobjects[POLLUT]);
        for (p=0; p<Nobjects[POLLUT]; p++) totals[p] = 0.0;
        flowSum = 0.0;
        freqSum = 0.0;
        volSum  = 0.0;

        // --- print table title
        WRITE(``);
        WRITE(`***********************`);
        WRITE(`Outfall Loading Summary`);
        WRITE(`***********************`);
        WRITE(``);

        // --- print table column headers
        Frpt.contents += 
 `\n  -----------------------------------------------------------`; 
        for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents +=  `--------------`;
        Frpt.contents += 
 `\n                         Flow       Avg       Max       Total`;
        for (p=0; p<Nobjects[POLLUT]; p++) Frpt.contents += `         Total`;
        Frpt.contents += 
 `\n                         Freq      Flow      Flow      Volume`;
        for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents +=  Pollut[p].ID.padStart(14, ' ');
        
        let val1 = FlowUnitWords[FlowUnits].padStart(3, ' ')
        let val2 = FlowUnitWords[FlowUnits].padStart(3, ' ')
        let val3 = VolUnitsWords[UnitSystem].padStart(8, ' ')
        Frpt.contents += 
 `\n  Outfall Node           Pcnt       ${val1}       ${val2}    ${val3}`

        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            i = UnitSystem;
            if ( Pollut[p].units == COUNT ) i = 2;
            units = LoadUnitsWords[i];
            Frpt.contents += units.padStart(14, ' ')
        }
        Frpt.contents += 
 `\n  -----------------------------------------------------------`;
        for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents += `--------------`;

        // --- identify each outfall node
        for (j=0; j<Nobjects[NODE]; j++)
        {
            if ( Node[j].type != OUTFALL ) continue;
            k = Node[j].subIndex;
            flowCount = OutfallStats[k].totalPeriods;

            // --- print node ID, flow freq., avg. flow, max. flow & flow vol.
            Frpt.contents += `\n  ` + Node[j].ID.padEnd(20, ' ')
            x = 100.*flowCount/ReportStepCount;                        //(5.1.015)
            Frpt.contents += x.toFixed(2).padStart(7)
            freqSum += x;
            if ( flowCount > 0 )
                x = OutfallStats[k].avgFlow*UCF(FLOW)/flowCount;
            else
                x = 0.0;
            flowSum += x;

            Frpt.contents += ` `
            Frpt.contents += flowFmt(x);
            Frpt.contents += ` `;
            Frpt.contents += flowFmt(OutfallStats[k].maxFlow*UCF(FLOW));
            Frpt.contents += (NodeInflow[j] * Vcf).toFixed(3).padStart(12, ' ')
            volSum += NodeInflow[j];

            // --- print load of each pollutant for outfall
            for (p=0; p<Nobjects[POLLUT]; p++)
            {
                x = OutfallStats[k].totalLoad[p] * LperFT3 * Pollut[p].mcf;
                totals[p] += x;
                if ( Pollut[p].units == COUNT ) x = LOG10(x);
                Frpt.contents += x.toFixed(3).padStart(14, ' ')
            }
        }

        // --- print total outfall loads
        outfallCount = Nnodes[OUTFALL];
        Frpt.contents += 
 `\n  -----------------------------------------------------------`; 
        for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents += `--------------`;

        Frpt.contents += `\n  System              ${(freqSum/outfallCount).toFixed(2).padStart(7, ' ')} `
        Frpt.contents += flowFmt(flowSum);
        Frpt.contents += ` `;
        Frpt.contents += flowFmt(MaxOutfallFlow*UCF(FLOW));
        Frpt.contents += (volSum * Vcf).toFixed(3).padStart(12, ' ')

        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            x = totals[p];
            if ( Pollut[p].units == COUNT ) x = LOG10(x);
            Frpt.contents += x.toFixed(3).padStart(14)
        }
        WRITE(``);
        //free(totals);
        totals = [];
    } 
}

//=============================================================================

writeLinkFlows()
//
//  Input:   none
//  Output:  none
//  Purpose: writes simulation statistics for links to report file.
//
{
    let j, k, days, hrs, mins;
    let v, fullDepth;

    if (Nobjects[LINK] == 0) return;
    WRITE(``);
    WRITE(`********************`);
    WRITE(`Link Flow Summary`);
    WRITE(`********************`);
    WRITE(``);

    Frpt.contents += 
        `\n  -----------------------------------------------------------------------------`+
        `\n                                 Maximum  Time of Max   Maximum    Max/    Max/`+
        `\n                                  |Flow|   Occurrence   |Veloc|    Full    Full`
    if (UnitSystem == US) Frpt.contents += 
        `\n  Link                 Type          ${FlowUnitWords[FlowUnits].padStart(3)}  days hr:min    ft/sec    Flow   Depth`
    else Frpt.contents += 
        `\n  Link                 Type          ${FlowUnitWords[FlowUnits].padStart(3)}  days hr:min     m/sec    Flow   Depth`
        Frpt.contents += 
        `\n  -----------------------------------------------------------------------------`

    for (j = 0; j < Nobjects[LINK]; j++)
    {
        // --- print link ID
        k = Link[j].subIndex;
        Frpt.contents += `\n  ` + Link[j].ID.padEnd(20, ' ') 

        // --- print link type
        if (Link[j].xsect.type == DUMMY) Frpt.contents +=  ` DUMMY   `;
        else if (Link[j].xsect.type == IRREGULAR) Frpt.contents += ` CHANNEL `;
        else Frpt.contents += ` ${LinkTypeWords[Link[j].type].padEnd(7, ' ')} `;

        // --- print max. flow & time of occurrence
        let returnObj = {days: days, hrs: hrs, mins: mins}
        getElapsedTime(LinkStats[j].maxFlowDate, returnObj)
        days = returnObj.days
        hrs = returnObj.hrs
        mins = returnObj.mins
        //getElapsedTime(LinkStats[j].maxFlowDate, &days, &hrs, &mins);
        Frpt.contents += flowFmt(LinkStats[j].maxFlow*UCF(FLOW));
        Frpt.contents += `  ${days.toString().padStart(4, ' ')}  ${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`

        // --- print max flow / flow capacity for pumps
        if (Link[j].type == PUMP && Link[j].qFull > 0.0)
        {
            Frpt.contents +=  `          `
            Frpt.contents +=  `  ` + 
                (LinkStats[j].maxFlow / Link[j].qFull).toFixed(2).padStart(6, ' ');
            continue;
        }

        // --- stop printing for dummy conduits
        if (Link[j].xsect.type == DUMMY) continue;

        // --- stop printing for outlet links (since they don't have xsections)
        if (Link[j].type == OUTLET) continue;

        // --- print max velocity & max/full flow for conduits
        if (Link[j].type == CONDUIT)
        {
            v = LinkStats[j].maxVeloc*UCF(LENGTH);
            if (v > 50.0) Frpt.contents +=  `    >50.00`;
            else Frpt.contents +=  `   ` + v.toFixed(2).padStart(7, ' ')
            Frpt.contents +=  `  ` +
                (LinkStats[j].maxFlow / Link[j].qFull / Conduit[k].barrels).toFixed(2).padStart(6, ' ');
        }
        else Frpt.contents +=  `                  `;

        // --- print max/full depth
        fullDepth = Link[j].xsect.yFull;
        if (Link[j].type == ORIFICE &&
            Orifice[k].type == BOTTOM_ORIFICE) fullDepth = 0.0;
        if (fullDepth > 0.0)
        {
            Frpt.contents +=  `  ` + (LinkStats[j].maxDepth / fullDepth).toFixed(2).padStart(6);
        }
        else Frpt.contents +=  `        `;
    }
    WRITE(``);
}

//=============================================================================

writeFlowClass()
//
//  Input:   none
//  Output:  none
//  Purpose: writes flow classification fro each conduit to report file.
//
{
    let   i, j, k;

    if ( RouteModel != DW ) return;
    WRITE(``);
    WRITE(`***************************`);
    WRITE(`Flow Classification Summary`);
    WRITE(`***************************`);
    WRITE(``);
    Frpt.contents +=  
`\n  -------------------------------------------------------------------------------------`
`\n                      Adjusted    ---------- Fraction of Time in Flow Class ---------- `
`\n                       /Actual         Up    Down  Sub   Sup   Up    Down  Norm  Inlet `
`\n  Conduit               Length    Dry  Dry   Dry   Crit  Crit  Crit  Crit  Ltd   Ctrl  `
`\n  -------------------------------------------------------------------------------------`;
    for ( j = 0; j < Nobjects[LINK]; j++ )
    {
        if ( Link[j].type != CONDUIT ) continue;
        if ( Link[j].xsect.type == DUMMY ) continue;
        k = Link[j].subIndex;
        Frpt.contents += `\n  ` + Link[j].ID.padEnd(20, ' ')
        Frpt.contents += `  ${(Conduit[k].modLength / Conduit[k].length).toFixed(2).padStart(6)} `
        for ( i=0; i<MAX_FLOW_CLASSES; i++ )
        {
            Frpt.contents += `  ` +
                (LinkStats[j].timeInFlowClass[i] /= ReportStepCount).toFixed(2).padStart(4);   //(5.1.015)
        }
        Frpt.contents += `  ` + (LinkStats[j].timeNormalFlow /
                                      (NewRoutingTime/1000.0)).toFixed(2).padStart(4)
        Frpt.contents += `  ` + (LinkStats[j].timeInletControl /
                                      (NewRoutingTime/1000.0)).toFixed(2).padStart(4)
    }
    WRITE(``);
}

//=============================================================================

writeLinkSurcharge()
{
    let    i, j, n = 0;
    let t = new Array(5);

    WRITE(``);
    WRITE(`*************************`);
    WRITE(`Conduit Surcharge Summary`);
    WRITE(`*************************`);
    WRITE(``);
    for ( j = 0; j < Nobjects[LINK]; j++ )
    {
        if ( Link[j].type != CONDUIT ||
             Link[j].xsect.type == DUMMY ) continue; 
        t[0] = LinkStats[j].timeSurcharged / 3600.0;
        t[1] = LinkStats[j].timeFullUpstream / 3600.0;
        t[2] = LinkStats[j].timeFullDnstream / 3600.0;
        t[3] = LinkStats[j].timeFullFlow / 3600.0;
        if ( t[0] + t[1] + t[2] + t[3] == 0.0 ) continue;
        t[4] = LinkStats[j].timeCapacityLimited / 3600.0;
        for (i=0; i<5; i++) t[i] = Math.max(0.01, t[i]);
        if (n == 0)
        {
            Frpt.contents +=  
`\n  ----------------------------------------------------------------------------`+
`\n                                                           Hours        Hours `+
`\n                         --------- Hours Full --------   Above Full   Capacity`+
`\n  Conduit                Both Ends  Upstream  Dnstream   Normal Flow   Limited`+
`\n  ----------------------------------------------------------------------------`;
            n = 1;
        }
        Frpt.contents += `\n  ` + Link[j].ID.padEnd(20, ' ');
        let val1 = t[0].toFixed(2).padStart(8, ' ')
        let val2 = t[1].toFixed(2).padStart(8, ' ')
        let val3 = t[2].toFixed(2).padStart(8, ' ')
        let val4 = t[3].toFixed(2).padStart(8, ' ')
        let val5 = t[4].toFixed(2).padStart(8, ' ')
        Frpt.contents += `    ${val1}  ${val2}  ${val3}  ${val4}     ${val5}`
    }
    if ( n == 0 ) WRITE(`No conduits were surcharged.`);
    WRITE(``);
}

//=============================================================================

writePumpFlows()
//
//  Input:   none
//  Output:  none
//  Purpose: writes simulation statistics for pumps to report file.
//
{
    let    j, k;
    let avgFlow, pctUtilized, pctOffCurve1, pctOffCurve2, totalSeconds;
    // String formatting variables
    let var1, var2, var3, var4, var5, var6, var7;

    if ( Nlinks[PUMP] == 0 ) return;

    WRITE(``);
    WRITE(`***************`);
    WRITE(`Pumping Summary`);
    WRITE(`***************`);
    WRITE(``);


    var1 = FlowUnitWords[FlowUnits].padStart(3, ' ')
    var2 = FlowUnitWords[FlowUnits].padStart(3, ' ')
    var3 = FlowUnitWords[FlowUnits].padStart(3, ' ')
    var4 = VolUnitsWords[UnitSystem].padStart(8, ' ')
    Frpt.contents += 
`\n  ---------------------------------------------------------------------------------------------------------`+
`\n                                                  Min       Avg       Max     Total     Power    %% Time Off`+
`\n                        Percent   Number of      Flow      Flow      Flow    Volume     Usage    Pump Curve`+
`\n  Pump                 Utilized   Start-Ups       ${var1}       ${var2}       ${var3}  ${var4}     Kw-hr    Low   High`+
`\n  ---------------------------------------------------------------------------------------------------------`
    for ( j = 0; j < Nobjects[LINK]; j++ )
    {
        if ( Link[j].type != PUMP ) continue;
        k = Link[j].subIndex;
        Frpt.contents += `\n  ` + Link[j].ID.padEnd(20, ' ')
        totalSeconds = NewRoutingTime / 1000.0;
        pctUtilized = PumpStats[k].utilized / totalSeconds * 100.0;
        avgFlow = PumpStats[k].avgFlow;
        if ( PumpStats[k].totalPeriods > 0 )
            avgFlow /=  PumpStats[k].totalPeriods;
        
        var1 = pctUtilized.toFixed(2).padStart(8, ' ')
        var2 = PumpStats[k].startUps.padStart(10, ' ')
        var3 = (PumpStats[k].minFlow*UCF(FLOW)).toFixed(2).padStart(9, ' ')
        var4 = (avgFlow*UCF(FLOW)).toFixed(2).padStart(9, ' ')
        var5 = (PumpStats[k].maxFlow*UCF(FLOW)).toFixed(2).padStart(9, ' ')
        var6 = (PumpStats[k].volume*Vcf).toFixed(3).padStart(9, ' ')
        var7 = PumpStats[k].energy.toFixed(2).padStart(9, ' ')
        Frpt.contents += ` %8.2f  %10d %9.2f %9.2f %9.2f %9.3f %9.2f`

        pctOffCurve1 = PumpStats[k].offCurveLow;
        pctOffCurve2 = PumpStats[k].offCurveHigh;
        if ( PumpStats[k].utilized > 0.0 )
        {
            pctOffCurve1 = pctOffCurve1 / PumpStats[k].utilized * 100.0;
            pctOffCurve2 = pctOffCurve2 / PumpStats[k].utilized * 100.0;
        }
        var1 = pctOffCurve1.toFixed(1).padStart(6, ' ')
        var2 = pctOffCurve2.toFixed(1).padStart(6, ' ')
        Frpt.contents += ` %6.1f %6.1f` 
    }
    WRITE(``);
}

//=============================================================================

writeLinkLoads()
{
    let i, j, p;
    let x;
    let  units;
    let  linkLine = `--------------------`;
    let  pollutLine   = `--------------`;
    
    // --- print the table headings 
    WRITE(``);
    WRITE(`***************************`);
    WRITE(`Link Pollutant Load Summary`);
    WRITE(`***************************`);
    WRITE(``);
    Frpt.contents += `\n  ` + linkLine;
    for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents += pollutLine;
    Frpt.contents += `\n                      `;
    for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents += Pollut[p].ID.padStart(14, ' ');
    Frpt.contents += `\n  Link                `;
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        i = UnitSystem;
        if ( Pollut[p].units == COUNT ) i = 2;
        units = LoadUnitsWords[i];
        Frpt.contents += units.padStart(14, ' ');
    }
    Frpt.contents += `\n ` + linkLine;
    for (p = 0; p < Nobjects[POLLUT]; p++) Frpt.contents +=  pollutLine;
    
    // --- print the pollutant loadings carried by each link
    for ( j = 0; j < Nobjects[LINK]; j++ )
    {
        Frpt.contents += `\n  ` + Link[j].ID.padEnd(20, ' ');
        for (p = 0; p < Nobjects[POLLUT]; p++)
        {
            x = Link[j].totalLoad[p] * LperFT3 * Pollut[p].mcf;
            if ( Pollut[p].units == COUNT ) x = Math.log10(x);
            if ( x < 10000. ) Frpt.contents += x.toFixed(3).padStart(14);
            else Frpt.contents += `%14.3e`, x.toExponential().padStart(14);
        }
    }
    WRITE(``);
    }


//-----------------------------------------------------------------------------
//   link.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//             09/15/14   (Build 5.1.007)
//             03/19/15   (Build 5.1.008)
//             08/05/15   (Build 5.1.010)
//             08/01/16   (Build 5.1.011)
//             03/14/17   (Build 5.1.012)
//             05/10/18   (Build 5.1.013)
//             03/01/20   (Build 5.1.014)
//   Author:   L. Rossman (EPA)
//             M. Tryby (EPA)
//
//   Conveyance system link functions
//
//   Build 5.1.007:
//   - Optional surcharging of weirs introduced.
//
//   Build 5.1.008:
//   - Bug in finding flow through surcharged weir fixed.
//   - Bug in finding if conduit is upstrm/dnstrm full fixed.
//   - Monthly conductivity adjustment applied to conduit seepage.
//   - Conduit seepage limited by conduit's flow rate.
//
//   Build 5.1.010:
//   - Support added for new ROADWAY_WEIR object.
//   - Time of last setting change initialized for links.
//
//   Build 5.1.011:
//   - Crest elevation of regulator links raised to downstream invert.
//   - Fixed converting roadWidth weir parameter to internal units.
//   - Weir shape parameter deprecated.
//   - Extra geometric parameters ignored for non-conduit open rectangular
//     cross sections.
//
//   Build 5.1.012:
//   - Conduit seepage rate now based on flow width, not wetted perimeter.
//   - Formula for side flow weir corrected.
//   - Crest length contraction adjustments corrected.
//
//   Build 5.1.013:
//   - Maximum depth adjustments made for storage units that can surcharge.
//   - Support added for head-dependent weir coefficient curves.
//   - Adjustment of regulator link crest offset to match downstream node invert
//     now only done for Dynamic Wave flow routing.
//
//  Build 5.1.014:
//  - Conduit evap. and seepage losses initialized to 0 in conduit_initState()
//    and not allowed to exceed current flow rate in conduit_getLossRate().
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
MIN_DELTA_Z = 0.001; // minimum elevation change for conduit
                                         // slopes (ft)

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  link_readParams        (called by parseLine in input.c)
//  link_readXsectParams   (called by parseLine in input.c)
//  link_readLossParams    (called by parseLine in input.c)
//  link_validate          (called by project_validate in project.c)
//  link_initState         (called by initObjects in swmm5.c)
//  link_setOldHydState    (called by routing_execute in routing.c)
//  link_setOldQualState   (called by routing_execute in routing.c)
//  link_setTargetSetting  (called by routing_execute in routing.c)
//  link_setSetting        (called by routing_execute in routing.c)
//  link_getResults        (called by output_saveLinkResults)
//  link_getLength         (called in dwflow.c, kinwave.c & flowrout.c)
//  link_getFroude         (called in dwflow.c)
//  link_getInflow         (called in flowrout.c & dynwave.c)
//  link_setOutfallDepth   (called in flowrout.c & dynwave.c)
//  link_getYcrit          (called by link_setOutfallDepth & in dwflow.c)
//  link_getYnorm          (called by conduit_initState, link_setOutfallDepth & in dwflow.c)
//  link_getVelocity       (called by link_getResults & stats_updateLinkStats)
//  link_getPower          (called by stats_updateLinkStats in stats.c)
//  link_getLossRate       (called in dwflow.c, kinwave.c & flowrout.c)


//=============================================================================

link_readParams(j, type, k, tok, ntoks)
//
//  Input:   j     = link index
//           type  = link type code
//           k     = link type index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads parameters for a specific type of link from a
//           tokenized line of input data.
//
{
    switch ( type )
    {
      case CONDUIT: return conduit_readParams(j, k, tok, ntoks);
      case PUMP:    return pump_readParams(j, k, tok, ntoks);
      case ORIFICE: return orifice_readParams(j, k, tok, ntoks);
      case WEIR:    return weir_readParams(j, k, tok, ntoks);
      case OUTLET:  return outlet_readParams(j, k, tok, ntoks);
      default: return 0;
    }
}

//=============================================================================

link_readXsectParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads a link's cross section parameters from a tokenized
//           line of input data.
//
{
    let    i, j, k;
    let x = new Array(4);

    // return facilitators
    let returnObj;
    let returnVal;

    // --- get index of link
    if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");
    j = project_findObject(LINK, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);

    // --- get code of xsection shape
    k = findmatch(tok[1], XsectTypeWords);
    if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);

    // --- assign default number of barrels to conduit
    if ( Link[j].type == CONDUIT ) Conduit[Link[j].subIndex].barrels = 1;

    // --- assume link is not a culvert
    Link[j].xsect.culvertCode = 0;

    // --- for irregular shape, find index of transect object
    if ( k == IRREGULAR )
    {
        i = project_findObject(TRANSECT, tok[2]);
        if ( i < 0 ) return error_setInpError(ERR_NAME, tok[2]);
        Link[j].xsect.type = k;
        Link[j].xsect.transect = i;
    }
    else
    {
        // --- parse max. depth & shape curve for a custom shape
        if ( k == CUSTOM )
        {
            ////////////////////////////////////
            returnObj = {y: x[0]}
            returnVal = getDouble(tok[2], returnObj);
            x[0] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[0] <= 0.0 )
            //if ( null == (x[0] = getDouble(tok[2])) || x[0] <= 0.0 )
               return error_setInpError(ERR_NUMBER, tok[2]);
            i = project_findObject(CURVE, tok[3]);
            if ( i < 0 ) return error_setInpError(ERR_NAME, tok[3]);
            Link[j].xsect.type = k;
            Link[j].xsect.transect = i;
            Link[j].xsect.yFull = x[0] / UCF(LENGTH);
        }

        // --- parse and save geometric parameters
        else for (i = 2; i <= 5; i++)
        {
            ////////////////////////////////////
            returnObj = {y: x[i-2]}
            returnVal = getDouble(tok[i], returnObj);
            x[i-2] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal )
            //if ( null == ( x[i-2] = getDouble(tok[i])) )
                return error_setInpError(ERR_NUMBER, tok[i]);
        }

        // --- ignore extra parameters for non-conduit open rectangular shapes 
        if ( Link[j].type != CONDUIT && k == RECT_OPEN )
        {
            x[2] = 0.0;
            x[3] = 0.0;
        }
        if ( !xsect_setParams(Link[j].xsect, k, x, UCF(LENGTH)) )
        {
            return error_setInpError(ERR_NUMBER, "");
        }

        // --- parse number of barrels if present
        if ( Link[j].type == CONDUIT && ntoks >= 7 )
        {
            i = parseInt(tok[6]);
            if ( i <= 0 ) return error_setInpError(ERR_NUMBER, tok[6]);
            else Conduit[Link[j].subIndex].barrels = i;
        }

        // --- parse culvert code if present
        if ( Link[j].type == CONDUIT && ntoks >= 8 )
        {
            i = parseInt(tok[7]);
            if ( i < 0 ) return error_setInpError(ERR_NUMBER, tok[7]);
            else Link[j].xsect.culvertCode = i;
        }

    }
    return 0;
}

//=============================================================================

link_readLossParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads local loss parameters for a link from a tokenized
//           line of input data.
//
//  Format:  LinkID  cInlet  cOutlet  cAvg  FlapGate(YES/NO)  SeepRate
//
{
    let    i, j, k;
    let x = new Array(3);
    let seepRate = 0.0;

    // return facilitators
    let returnObj;
    let returnVal;

    if ( ntoks < 4 ) return error_setInpError(ERR_ITEMS, "");
    j = project_findObject(LINK, tok[0]);
    if ( j < 0 ) return error_setInpError(ERR_NAME, tok[0]);
    for (i=1; i<=3; i++)
    {
        ////////////////////////////////////
        returnObj = {y: x[i-1]}
        returnVal = getDouble(tok[i], returnObj);
        x[i-1] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[i-1] < 0.0 )
        //if ( null == (x[i-1] = getDouble(tok[i])) || x[i-1] < 0.0 )
        return error_setInpError(ERR_NUMBER, tok[i]);
    }
    k = 0;
    if ( ntoks >= 5 )
    {
        k = findmatch(tok[4], NoYesWords);
        if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[4]);
    }
    if ( ntoks >= 6 )
    {
        ////////////////////////////////////
        returnObj = {y: seepRate}
        returnVal = getDouble(tok[5], returnObj);
        seepRate = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (seepRate = getDouble(tok[5])) )
            return error_setInpError(ERR_NUMBER, tok[5]);
    }
    Link[j].cLossInlet   = x[0];
    Link[j].cLossOutlet  = x[1];
    Link[j].cLossAvg     = x[2];
    Link[j].hasFlapGate  = k;
    Link[j].seepRate     = seepRate / UCF(RAINFALL);
    return 0;
}

//=============================================================================

 link_setParams(j, type, n1, n2, k, x)
//
//  Input:   j   = link index
//           type = link type code
//           n1   = index of upstream node
//           n2   = index of downstream node
//           k    = index of link's sub-type
//           x    = array of parameter values
//  Output:  none
//  Purpose: sets parameters for a link.
//
{
    Link[j].node1       = n1;
    Link[j].node2       = n2;
    Link[j].type        = type;
    Link[j].subIndex    = k;
    Link[j].offset1     = 0.0;
    Link[j].offset2     = 0.0;
    Link[j].q0          = 0.0;
    Link[j].qFull       = 0.0;
    Link[j].setting     = 1.0;
    Link[j].targetSetting = 1.0;
    Link[j].hasFlapGate = 0;
    Link[j].qLimit      = 0.0;         // 0 means that no limit is defined
    Link[j].direction   = 1;

    switch (type)
    {
      case CONDUIT:
        Conduit[k].length    = x[0] / UCF(LENGTH);
        Conduit[k].modLength = Conduit[k].length;
        Conduit[k].roughness = x[1];
        Link[j].offset1      = x[2] / UCF(LENGTH);
        Link[j].offset2      = x[3] / UCF(LENGTH);
        Link[j].q0           = x[4] / UCF(FLOW);
        Link[j].qLimit       = x[5] / UCF(FLOW);
        break;

      case PUMP:
        Pump[k].pumpCurve    = x[0];
        Link[j].hasFlapGate  = FALSE;
        Pump[k].initSetting  = x[1];
        Pump[k].yOn          = x[2] / UCF(LENGTH);
        Pump[k].yOff         = x[3] / UCF(LENGTH);
        Pump[k].xMin         = 0.0;
        Pump[k].xMax         = 0.0;
        break;

      case ORIFICE:
        Orifice[k].type      = x[0];
        Link[j].offset1      = x[1] / UCF(LENGTH);
        Link[j].offset2      = Link[j].offset1;
        Orifice[k].cDisch    = x[2];
        Link[j].hasFlapGate  = (x[3] > 0.0) ? 1 : 0;
        Orifice[k].orate     = x[4] * 3600.0;
        break;

      case WEIR:
        Weir[k].type         = x[0];
        Link[j].offset1      = x[1] / UCF(LENGTH);
        Link[j].offset2      = Link[j].offset1;
        Weir[k].cDisch1      = x[2];
        Link[j].hasFlapGate  = (x[3] > 0.0) ? 1 : 0;
        Weir[k].endCon       = x[4];
        Weir[k].cDisch2      = x[5];
        Weir[k].canSurcharge = x[6];
        Weir[k].roadWidth    = x[7] / UCF(LENGTH);
        Weir[k].roadSurface  = x[8];
        Weir[k].cdCurve      = x[9];                                      //(5.1.013)
        break;

      case OUTLET:
        Link[j].offset1      = x[0] / UCF(LENGTH);
        Link[j].offset2      = Link[j].offset1;
        Outlet[k].qCoeff     = x[1];
        Outlet[k].qExpon     = x[2];
        Outlet[k].qCurve     = x[3];
        Link[j].hasFlapGate  = (x[4] > 0.0) ? 1 : 0;
        Outlet[k].curveType  = x[5];

        xsect_setParams(Link[j].xsect, DUMMY, null, 0.0);
        break;

    }
}

//=============================================================================

 link_validate(j)
//
//  Input:   j = link index
//  Output:  none
//  Purpose: validates a link's properties.
//
{
    let   n;

    if ( LinkOffsets == ELEV_OFFSET ) link_convertOffsets(j);
    switch ( Link[j].type )
    {
      case CONDUIT: conduit_validate(j, Link[j].subIndex); break;
      case PUMP:    pump_validate(j, Link[j].subIndex);    break;
      case ORIFICE: orifice_validate(j, Link[j].subIndex); break;
      case WEIR:    weir_validate(j, Link[j].subIndex);    break;
    }

    // --- check if crest of regulator opening < invert of downstream node
    switch ( Link[j].type )
    {
      case ORIFICE:
      case WEIR:
      case OUTLET:
          if ( Node[Link[j].node1].invertElev + Link[j].offset1 <
               Node[Link[j].node2].invertElev )
          {
              if (RouteModel == DW)                                            //(5.1.013)
              {
                  Link[j].offset1 = Node[Link[j].node2].invertElev -
                                    Node[Link[j].node1].invertElev;
                  report_writeWarningMsg(WARN10b, Link[j].ID);                 //(5.1.013)
              }
              else report_writeWarningMsg(WARN10a, Link[j].ID);                //(5.1.013)
          }
    }    

    // --- force max. depth of end nodes to be >= link crown height
    //     at non-storage nodes

    // --- skip pumps and bottom orifices
    if ( Link[j].type == PUMP ||
         (Link[j].type == ORIFICE &&
          Orifice[Link[j].subIndex].type == BOTTOM_ORIFICE) ) return;

    // --- extend upstream node's full depth to link's crown elevation
    n = Link[j].node1;
    if ( Node[n].type != STORAGE || Node[n].surDepth > 0.0 )                   //(5.1.013)
    {
        Node[n].fullDepth = MAX(Node[n].fullDepth,
                            Link[j].offset1 + Link[j].xsect.yFull);
    }

    // --- do same for downstream node only for conduit links
    n = Link[j].node2;
    if ( (Node[n].type != STORAGE || Node[n].surDepth > 0.0) &&                //(5.1.013)
            Link[j].type == CONDUIT )
    {
        Node[n].fullDepth = MAX(Node[n].fullDepth,
                            Link[j].offset2 + Link[j].xsect.yFull);
    }
}

//=============================================================================

link_convertOffsets(j)
//
//  Input:   j = link index
//  Output:  none
//  Purpose: converts offset elevations to offset heights for a link.
//
{
    let elev;

    elev = Node[Link[j].node1].invertElev;
    Link[j].offset1 = link_getOffsetHeight(j, Link[j].offset1, elev);
    if ( Link[j].type == CONDUIT )
    {
        elev = Node[Link[j].node2].invertElev;
        Link[j].offset2 = link_getOffsetHeight(j, Link[j].offset2, elev);
    }
    else Link[j].offset2 = Link[j].offset1;
}

//=============================================================================

link_getOffsetHeight(j, offset, elev)
//
//  Input:   j = link index
//           offset = link elevation offset (ft)
//           elev   = node invert elevation (ft)
//  Output:  returns offset distance above node invert (ft)
//  Purpose: finds offset height for one end of a link.
//
{
    if ( offset <= MISSING || Link[j].type == PUMP) return 0.0;
    offset -= elev;
    if ( offset >= 0.0 ) return offset;
    if ( offset >= -MIN_DELTA_Z ) return 0.0;
    report_writeWarningMsg(WARN03, Link[j].ID);
    return 0.0;
}

//=============================================================================

link_initState(j)
//
//  Input:   j = link index
//  Output:  none
//  Purpose: initializes a link's state variables at start of simulation.
//
{
    let   p;

    // --- initialize hydraulic state
    Link[j].oldFlow   = Link[j].q0;
    Link[j].newFlow   = Link[j].q0;
    Link[j].oldDepth  = 0.0;
    Link[j].newDepth  = 0.0;
    Link[j].oldVolume = 0.0;
    Link[j].newVolume = 0.0;
    Link[j].setting   = 1.0;
    Link[j].targetSetting = 1.0;
    Link[j].timeLastSet = StartDate;
    Link[j].inletControl  = FALSE;
    Link[j].normalFlow    = FALSE;
    if ( Link[j].type == CONDUIT ) conduit_initState(j, Link[j].subIndex);
    if ( Link[j].type == PUMP    ) pump_initState(j, Link[j].subIndex);

    // --- initialize water quality state
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        Link[j].oldQual[p] = 0.0;
        Link[j].newQual[p] = 0.0;
		Link[j].totalLoad[p] = 0.0;
    }
}

//=============================================================================

 link_getInflow(j)
//
//  Input:   j = link index
//  Output:  returns link flow rate (cfs)
//  Purpose: finds total flow entering a link during current time step.
//
{
    if ( Link[j].setting == 0 ) return 0.0;
    switch ( Link[j].type )
    {
      case CONDUIT: return conduit_getInflow(j);
      case PUMP:    return pump_getInflow(j);
      case ORIFICE: return orifice_getInflow(j);
      case WEIR:    return weir_getInflow(j);
      case OUTLET:  return outlet_getInflow(j);
      default:      return node_getOutflow(Link[j].node1, j);
    }
}

//=============================================================================

link_setOldHydState(j)
//
//  Input:   j = link index
//  Output:  none
//  Purpose: replaces link's old hydraulic state values with current ones.
//
{
    let k;

    Link[j].oldDepth  = Link[j].newDepth;
    Link[j].oldFlow   = Link[j].newFlow;
    Link[j].oldVolume = Link[j].newVolume;

    if ( Link[j].type == CONDUIT )
    {
        k = Link[j].subIndex;
        Conduit[k].q1Old = Conduit[k].q1;
        Conduit[k].q2Old = Conduit[k].q2;
    }
}

//=============================================================================

link_setOldQualState(j)
//
//  Input:   j = link index
//  Output:  none
//  Purpose: replaces link's old water quality state values with current ones.
//
{
    let p;
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        Link[j].oldQual[p] = Link[j].newQual[p];
        Link[j].newQual[p] = 0.0;
    }
}

//=============================================================================

link_setTargetSetting(j)
//
//  Input:   j = link index
//  Output:  none
//  Purpose: updates a link's target setting.
//
{
    let k, n1;
    if ( Link[j].type == PUMP )
    {
        k = Link[j].subIndex;
        n1 = Link[j].node1;
        Link[j].targetSetting = Link[j].setting;
        if ( Pump[k].yOff > 0.0 &&
             Link[j].setting > 0.0 &&
             Node[n1].newDepth < Pump[k].yOff ) Link[j].targetSetting = 0.0;
        if ( Pump[k].yOn > 0.0 &&
             Link[j].setting == 0.0 &&
             Node[n1].newDepth > Pump[k].yOn )  Link[j].targetSetting = 1.0;
    }
}

//=============================================================================

link_setSetting(j, tstep)
//
//  Input:   j = link index
//           tstep = time step over which setting is adjusted
//  Output:  none
//  Purpose: updates a link's setting as a result of a control action.
//
{
    if ( Link[j].type == ORIFICE ) orifice_setSetting(j, tstep);
    else if ( Link[j].type == WEIR ) weir_setSetting(j);
    else Link[j].setting = Link[j].targetSetting;
}

//=============================================================================

link_setFlapGate(j, n1, n2, q)
//
//  Input:   j = link index
//           n1 = index of node on upstream end of link
//           n2 = index of node on downstream end of link
//           q = signed flow value (value and units don't matter)
//  Output:  returns TRUE if there is reverse flow through a flap gate
//           associated with the link.
//  Purpose: based on the sign of the flow, determines if a flap gate
//           associated with the link should close or not.
//
{
    let    n = -1;

    // --- check for reverse flow through link's flap gate
    if ( Link[j].hasFlapGate )
    {
        if ( q * Link[j].direction < 0.0 ) return TRUE;
    }

    // --- check for Outfall with flap gate node on inflow end of link
    if ( q < 0.0 ) n = n2;
    if ( q > 0.0 ) n = n1;
    if ( n >= 0 &&
         Node[n].type == OUTFALL &&
         Outfall[Node[n].subIndex].hasFlapGate ) return TRUE;
    return FALSE;
}

//=============================================================================

link_getResults(j, f, x)
//
//  Input:   j = link index
//           f = time weighting factor
//  Output:  x = array of weighted results
//  Purpose: retrieves time-weighted average of old and new results for a link.
//
{
    let     p;                     // pollutant index
    let     y,                     // depth
            q,                     // flow
            u,                     // velocity
            v,                     // volume
            c;                     // capacity, setting or concentration
    let     f1 = 1.0 - f;

    y = f1*Link[j].oldDepth + f*Link[j].newDepth;
    q = f1*Link[j].oldFlow + f*Link[j].newFlow;
    v = f1*Link[j].oldVolume + f*Link[j].newVolume;
    u = link_getVelocity(j, q, y);
    c = 0.0;
    if (Link[j].type == CONDUIT)
    {
        if (Link[j].xsect.type != DUMMY)
            c = xsect_getAofY(Link[j].xsect, y) / Link[j].xsect.aFull;
    }
    else c = Link[j].setting;

    // --- override time weighting for pump flow between on/off states
    if (Link[j].type == PUMP && Link[j].oldFlow*Link[j].newFlow == 0.0)
    {
        if ( f >= f1 ) q = Link[j].newFlow;
        else           q = Link[j].oldFlow;
    }

    y *= UCF(LENGTH);
    v *= UCF(VOLUME);
    q *= UCF(FLOW) * Link[j].direction;
    u *= UCF(LENGTH) * Link[j].direction;
    x[LINK_DEPTH]    = y;
    x[LINK_FLOW]     = q;
    x[LINK_VELOCITY] = u;
    x[LINK_VOLUME]   = v;
    x[LINK_CAPACITY] = c;

    if ( !IgnoreQuality ) for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        c = f1*Link[j].oldQual[p] + f*Link[j].newQual[p];
        x[LINK_QUAL+p] = c;
    }
}

//=============================================================================

link_setOutfallDepth(j)
//
//  Input:   j = link index
//  Output:  none
//  Purpose: sets depth at outfall node connected to link j.
//
{
    let  k;                         // conduit index
    let  n;                         // outfall node index
    let  z;                         // invert offset height (ft)
    let  q;                         // flow rate (cfs)
    let  yCrit = 0.0;               // critical flow depth (ft)
    let  yNorm = 0.0;               // normal flow depth (ft)

    // --- find which end node of link is an outfall
    if ( Node[Link[j].node2].type == OUTFALL )
    {
        n = Link[j].node2;
        z = Link[j].offset2;
    }
    else if ( Node[Link[j].node1].type == OUTFALL )
    {
        n = Link[j].node1;
        z = Link[j].offset1;
    }
    else return;

    // --- find both normal & critical depth for current flow
    if ( Link[j].type == CONDUIT )
    {
        k = Link[j].subIndex;
        q = Math.abs(Link[j].newFlow / Conduit[k].barrels);
        yNorm = link_getYnorm(j, q);
        yCrit = link_getYcrit(j, q);
    }

    // --- set new depth at node
    node_setOutletDepth(n, yNorm, yCrit, z);
}

//=============================================================================

link_getYcrit(j, q)
//
//  Input:   j = link index
//           q = link flow rate (cfs)
//  Output:  returns critical depth (ft)
//  Purpose: computes critical depth for given flow rate.
//
{
    return xsect_getYcrit(Link[j].xsect, q);
}

//=============================================================================

link_getYnorm(j, q)
//
//  Input:   j = link index
//           q = link flow rate (cfs)
//  Output:  returns normal depth (ft)
//  Purpose: computes normal depth for given flow rate.
//
{
    let    k;
    let s, a, y;

    if ( Link[j].type != CONDUIT ) return 0.0;
    if ( Link[j].xsect.type == DUMMY ) return 0.0;
    q = Math.abs(q);
    k = Link[j].subIndex;
    if ( q > Conduit[k].qMax ) q = Conduit[k].qMax;
    if ( q <= 0.0 ) return 0.0;
    s = q / Conduit[k].beta;
    a = xsect_getAofS(Link[j].xsect, s);
    y = xsect_getYofA(Link[j].xsect, a);
    return y;
}

//=============================================================================

link_getLength(j)
//
//  Input:   j = link index
//  Output:  returns length (ft)
//  Purpose: finds true length of a link.
//
{
    if ( Link[j].type == CONDUIT ) return conduit_getLength(j);
    return 0.0;
}

//=============================================================================

link_getVelocity(j, flow, depth)
//
//  Input:   j     = link index
//           flow  = link flow rate (cfs)
//           depth = link flow depth (ft)
//  Output:  returns flow velocity (fps)
//  Purpose: finds flow velocity given flow and depth.
//
{
    let area;
    let veloc = 0.0;
    let    k;

    if ( depth <= 0.01 ) return 0.0;
    if ( Link[j].type == CONDUIT )
    {
        k = Link[j].subIndex;
        flow /= Conduit[k].barrels;
        area = xsect_getAofY(Link[j].xsect, depth);
        if (area > FUDGE ) veloc = flow / area;
    }
    return veloc;
}

//=============================================================================

link_getFroude(j, v, y)
//
//  Input:   j = link index
//           v = flow velocity (fps)
//           y = flow depth (ft)
//  Output:  returns Froude Number
//  Purpose: computes Froude Number for given velocity and flow depth
//
{
    xsect = new TXsect();
    xsect = Link[j].xsect;

    // --- return 0 if link is not a conduit
    if ( Link[j].type != CONDUIT ) return 0.0;

    // --- return 0 if link empty or closed conduit is full
    if ( y <= FUDGE ) return 0.0;
    if ( !xsect_isOpen(xsect.type) &&
         xsect.yFull - y <= FUDGE ) return 0.0;

    // --- compute hydraulic depth
    y = xsect_getAofY(xsect, y) / xsect_getWofY(xsect, y);

    // --- compute Froude No.
    return Math.abs(v) / Math.sqrt(GRAVITY * y);
}

//=============================================================================

link_getPower(j)
//
//  Input:   j = link index
//  Output:  returns power consumed by link in kwatts
//  Purpose: computes power consumed by head loss (or head gain) of
//           water flowing through a link
//
{
    let    n1 = Link[j].node1;
    let    n2 = Link[j].node2;
    let dh = (Node[n1].invertElev + Node[n1].newDepth) -
                (Node[n2].invertElev + Node[n2].newDepth);
    let q =  Math.abs(Link[j].newFlow);
    return Math.abs(dh) * q / 8.814 * KWperHP;
}

//=============================================================================

link_getLossRate(j, q)                                       //(5.1.014)
//
//  Input:   j = link index
//           q = flow rate (ft3/sec)
//           tstep = time step (sec)
//  Output:  returns uniform loss rate in link (ft3/sec)
//  Purpose: computes rate at which flow volume is lost in a link due to
//           evaporation and seepage.
//
{
    if ( Link[j].type == CONDUIT ) return conduit_getLossRate(j, q);           //(5.1.014)
    else return 0.0;
}

//=============================================================================

 link_getFullState(a1, a2, aFull)
//
//  Input:   a1 = upstream link area (ft2)
//           a2 = downstream link area (ft2)
//           aFull = area of full conduit
//  Output:  returns fullness state of a link
//  Purpose: determines if a link is upstream, downstream or completely full.
//  
{
    if ( a1 >= aFull )
    {
        if ( a2 >= aFull ) return ALL_FULL;
        else return UP_FULL;
    }
    if ( a2 >= aFull ) return DN_FULL;
    return 0;
}

//=============================================================================
//                    C O N D U I T   M E T H O D S
//=============================================================================

 conduit_readParams(j, k, tok, ntoks)
//
//  Input:   j = link index
//           k = conduit index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads conduit parameters from a tokenzed line of input.
//
{
    let n1, n2;
    let x = new Array(6);
    let id;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check for valid ID and end node IDs
    if ( ntoks < 7 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(LINK, tok[0]);                // link ID
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);
    n1 = project_findObject(NODE, tok[1]);            // upstrm. node
    if ( n1 < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    n2 = project_findObject(NODE, tok[2]);            // dwnstrm. node
    if ( n2 < 0 ) return error_setInpError(ERR_NAME, tok[2]);

    // --- parse length & Mannings N
    ////////////////////////////////////
    returnObj = {y: x[0]}
    returnVal = getDouble(tok[3], returnObj);
    x[0] = returnObj.y;
    ////////////////////////////////////
    if( !returnVal )
    //if ( null == (x[0] = getDouble(tok[3])) )
        return error_setInpError(ERR_NUMBER, tok[3]);
    ////////////////////////////////////
    returnObj = {y: x[1]}
    returnVal = getDouble(tok[4], returnObj);
    x[1] = returnObj.y;
    ////////////////////////////////////
    if( !returnVal )
    //if ( null == (x[1] = getDouble(tok[4])) )
        return error_setInpError(ERR_NUMBER, tok[4]);

    // --- parse offsets
    if ( LinkOffsets == ELEV_OFFSET && tok[5] == '*' ) x[2] = MISSING;
    else{
        ////////////////////////////////////
        returnObj = {y: x[2]}
        returnVal = getDouble(tok[5], returnObj);
        x[2] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[2] = getDouble(tok[5])) )
            return error_setInpError(ERR_NUMBER, tok[5]);
    } 
    if ( LinkOffsets == ELEV_OFFSET && tok[6] == '*' ) x[3] = MISSING;
    else{
        ////////////////////////////////////
        returnObj = {y: x[3]}
        returnVal = getDouble(tok[6], returnObj);
        x[3] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[3] = getDouble(tok[6])) )
            return error_setInpError(ERR_NUMBER, tok[6]);
    }

   // --- parse optional parameters
    x[4] = 0.0;                                       // init. flow
    if ( ntoks >= 8 )
    {
        ////////////////////////////////////
        returnObj = {y: x[4]}
        returnVal = getDouble(tok[7], returnObj);
        x[4] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[4] = getDouble(tok[7])) )
            return error_setInpError(ERR_NUMBER, tok[7]);
    }
    x[5] = 0.0;
    if ( ntoks >= 9 )
    {
        ////////////////////////////////////
        returnObj = {y: x[5]}
        returnVal = getDouble(tok[8], returnObj);
        x[5] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[5] = getDouble(tok[8])) )
            return error_setInpError(ERR_NUMBER, tok[8]);
    }

    // --- add parameters to data base
    Link[j].ID = id;
    link_setParams(j, CONDUIT, n1, n2, k, x);
    return 0;
}

//=============================================================================

 conduit_validate(j, k)
//
//  Input:   j = link index
//           k = conduit index
//  Output:  none
//  Purpose: validates a conduit's properties.
//
{
    let aa;
    let lengthFactor, roughness, slope;

    // --- a storage node cannot have a dummy outflow link
    if ( Link[j].xsect.type == DUMMY && RouteModel == DW )
    {
        if ( Node[Link[j].node1].type == STORAGE )
        {
            report_writeErrorMsg(ERR_DUMMY_LINK, Node[Link[j].node1].ID);
            return;
        }
    }

    // --- if custom xsection, then set its parameters
    if ( Link[j].xsect.type == CUSTOM )
        xsect_setCustomXsectParams(Link[j].xsect);

    // --- if irreg. xsection, assign transect roughness to conduit
    if ( Link[j].xsect.type == IRREGULAR )
    {
        xsect_setIrregXsectParams(Link[j].xsect);
        Conduit[k].roughness = Transect[Link[j].xsect.transect].roughness;
    }

    // --- if force main xsection, adjust units on D-W roughness height
    if ( Link[j].xsect.type == FORCE_MAIN )
    {
        if ( ForceMainEqn == D_W ) Link[j].xsect.rBot /= UCF(RAINDEPTH);
        if ( Link[j].xsect.rBot <= 0.0 )
            report_writeErrorMsg(ERR_XSECT, Link[j].ID);
    }

    // --- check for valid length & roughness
    if ( Conduit[k].length <= 0.0 )
        report_writeErrorMsg(ERR_LENGTH, Link[j].ID);
    if ( Conduit[k].roughness <= 0.0 )
        report_writeErrorMsg(ERR_ROUGHNESS, Link[j].ID);
    if ( Conduit[k].barrels <= 0 )
        report_writeErrorMsg(ERR_BARRELS, Link[j].ID);

    // --- check for valid xsection
    if ( Link[j].xsect.type != DUMMY )
    {
        if ( Link[j].xsect.type < 0 )
            report_writeErrorMsg(ERR_NO_XSECT, Link[j].ID);
        else if ( Link[j].xsect.aFull <= 0.0 )
            report_writeErrorMsg(ERR_XSECT, Link[j].ID);
    }
    if ( ErrorCode ) return;

    // --- check for negative offsets
    if ( Link[j].offset1 < 0.0 )
    {
        report_writeWarningMsg(WARN03, Link[j].ID);
        Link[j].offset1 = 0.0;
    }
	if ( Link[j].offset2 < 0.0 )
    {
        report_writeWarningMsg(WARN03, Link[j].ID);
        Link[j].offset2 = 0.0;
    }

    // --- adjust conduit offsets for partly filled circular xsection
    if ( Link[j].xsect.type == FILLED_CIRCULAR )
    {
        Link[j].offset1 += Link[j].xsect.yBot;
        Link[j].offset2 += Link[j].xsect.yBot;
    }

    // --- compute conduit slope
    slope = conduit_getSlope(j);
    Conduit[k].slope = slope;

    // --- reverse orientation of conduit if using dynamic wave routing
    //     and slope is negative
    if ( RouteModel == DW &&
         slope < 0.0 &&
         Link[j].xsect.type != DUMMY )
    {
        conduit_reverse(j, k);
    }

    // --- get equivalent Manning roughness for Force Mains
    //     for use when pipe is partly full
    roughness = Conduit[k].roughness;
    if ( RouteModel == DW && Link[j].xsect.type == FORCE_MAIN )
    {
        roughness = forcemain_getEquivN(j, k);
    }

    // --- adjust roughness for meandering natural channels
    if ( Link[j].xsect.type == IRREGULAR )
    {
        lengthFactor = Transect[Link[j].xsect.transect].lengthFactor;
        roughness *= Math.sqrt(lengthFactor);
    }

    // --- lengthen conduit if lengthening option is in effect
    lengthFactor = 1.0;
    if ( RouteModel == DW &&
         LengtheningStep > 0.0 &&
         Link[j].xsect.type != DUMMY )
    {
        lengthFactor = conduit_getLengthFactor(j, k, roughness);
    }

    if ( lengthFactor != 1.0 )
    {
        Conduit[k].modLength = lengthFactor * conduit_getLength(j);
        slope /= lengthFactor;
        roughness = roughness / Math.sqrt(lengthFactor);
    }

    // --- compute roughness factor used when computing friction
    //     slope term in Dynamic Wave flow routing

    // --- special case for non-Manning Force Mains
    //     (roughness factor for full flow is saved in xsect.sBot)
    if ( RouteModel == DW && Link[j].xsect.type == FORCE_MAIN )
    {
        Link[j].xsect.sBot =
            forcemain_getRoughFactor(j, lengthFactor);
    }
    Conduit[k].roughFactor = GRAVITY * Math.pow(roughness/PHI, 2);

    // --- compute full flow through cross section
    if ( Link[j].xsect.type == DUMMY ) Conduit[k].beta = 0.0;
    else Conduit[k].beta = PHI * Math.sqrt(Math.abs(slope)) / roughness;
    Link[j].qFull = Link[j].xsect.sFull * Conduit[k].beta;
    Conduit[k].qMax = Link[j].xsect.sMax * Conduit[k].beta;

    // --- see if flow is supercritical most of time
    //     by comparing normal & critical velocities.
    //     (factor of 0.3 is for circular pipe 95% full)
    // NOTE: this factor was used in the past for a modified version of
    //       Kinematic Wave routing but is now deprecated.
    aa = Conduit[k].beta / Math.sqrt(32.2) *
         Math.pow(Link[j].xsect.yFull, 0.1666667) * 0.3;
    if ( aa >= 1.0 ) Conduit[k].superCritical = TRUE;
    else             Conduit[k].superCritical = FALSE;

    // --- set value of hasLosses flag
    if ( Link[j].cLossInlet  == 0.0 &&
         Link[j].cLossOutlet == 0.0 &&
         Link[j].cLossAvg    == 0.0
       ) Conduit[k].hasLosses = FALSE;
    else Conduit[k].hasLosses = TRUE;
}

//=============================================================================

conduit_reverse(j, k)
//
//  Input:   j = link index
//           k = conduit index
//  Output:  none
//  Purpose: reverses direction of a conduit
//
{
    let i;
    let z;
    let cLoss;

    // --- reverse end nodes
    i = Link[j].node1;
    Link[j].node1 = Link[j].node2;
    Link[j].node2 = i;

    // --- reverse node offsets
    z = Link[j].offset1;
    Link[j].offset1 = Link[j].offset2;
    Link[j].offset2 = z;

    // --- reverse loss coeffs.
    cLoss = Link[j].cLossInlet;
    Link[j].cLossInlet = Link[j].cLossOutlet;
    Link[j].cLossOutlet = cLoss;

    // --- reverse direction & slope
    Conduit[k].slope = -Conduit[k].slope;
    Link[j].direction *= -1;

    // --- reverse initial flow value
    Link[j].q0 = -Link[j].q0;
}

//=============================================================================

conduit_getLength(j)
//
//  Input:   j = link index
//  Output:  returns conduit's length (ft)
//  Purpose: finds true length of a conduit.
//
//  Note: for irregular natural channels, user inputs length of main
//        channel (for FEMA purposes) but program should use length
//        associated with entire flood plain. Transect.lengthFactor
//        is the ratio of these two lengths.
//
{
    let k = Link[j].subIndex;
    let t;
    if ( Link[j].xsect.type != IRREGULAR ) return Conduit[k].length;
    t = Link[j].xsect.transect;
    if ( t < 0 || t >= Nobjects[TRANSECT] ) return Conduit[k].length;
    return Conduit[k].length / Transect[t].lengthFactor;
}

//=============================================================================

conduit_getLengthFactor(j, k, roughness)
//
//  Input:   j = link index
//           k = conduit index
//           roughness = conduit Manning's n
//  Output:  returns factor by which a conduit should be lengthened
//  Purpose: computes amount of conduit lengthing to improve numerical stability.
//
//  The following form of the Courant criterion is used:
//      L = t * v * (1 + Fr) / Fr
//  where L = conduit length, t = time step, v = velocity, & Fr = Froude No.
//  After substituting Fr = v / Math.sqrt(gy), where y = flow depth, we get:
//    L = t * ( Math.sqrt(gy) + v )
//
{
    let ratio;
    let yFull;
    let vFull;
    let tStep;

    // --- evaluate flow depth and velocity at full normal flow condition
    yFull = Link[j].xsect.yFull;
    if ( xsect_isOpen(Link[j].xsect.type) )
    {
        yFull = Link[j].xsect.aFull / xsect_getWofY(Link[j].xsect, yFull);
    }
    vFull = PHI / roughness * Link[j].xsect.sFull *
            Math.sqrt(Math.abs(Conduit[k].slope)) / Link[j].xsect.aFull;

    // --- determine ratio of Courant length to actual length
    if ( LengtheningStep == 0.0 ) tStep = RouteStep;
    else                          tStep = MIN(RouteStep, LengtheningStep);
    ratio = (sqrt(GRAVITY*yFull) + vFull) * tStep / conduit_getLength(j);

    // --- return max. of 1.0 and ratio
    if ( ratio > 1.0 ) return ratio;
    else return 1.0;
}

//=============================================================================

conduit_getSlope(j)
//
//  Input:   j = link index
//  Output:  returns conduit slope
//  Purpose: computes conduit slope.
//
{
    let elev1, elev2, delta, slope;
    let length = conduit_getLength(j);

    // --- check that elevation drop > minimum allowable drop
    elev1 = Link[j].offset1 + Node[Link[j].node1].invertElev;
    elev2 = Link[j].offset2 + Node[Link[j].node2].invertElev;
    delta = Math.abs(elev1 - elev2);
    if ( delta < MIN_DELTA_Z )
    {
        report_writeWarningMsg(WARN04, Link[j].ID);
        delta = MIN_DELTA_Z;
    }

    // --- elevation drop cannot exceed conduit length
    if ( delta >= length )
    {
        report_writeWarningMsg(WARN08, Link[j].ID);
        slope = delta / length;
    }

    // --- slope = elev. drop / horizontal distance
    else slope = delta / Math.sqrt(SQR(length) - SQR(delta));

    // -- check that slope exceeds minimum allowable slope
    if ( MinSlope > 0.0 && slope < MinSlope )
    {
        report_writeWarningMsg(WARN05, Link[j].ID);
        slope = MinSlope;
        // keep min. slope positive for SF or KW routing
        if (RouteModel == SF || RouteModel == KW) return slope;
    }

    // --- change sign for adverse slope
    if ( elev1 < elev2 ) slope = -slope;
    return slope;
}

//=============================================================================

 conduit_initState(j, k)
//
//  Input:   j = link index
//           k = conduit index
//  Output:  none
//  Purpose: sets initial conduit depth to normal depth of initial flow
//
{
    Link[j].newDepth = link_getYnorm(j, Link[j].q0 / Conduit[k].barrels);
    Link[j].oldDepth = Link[j].newDepth;
    Conduit[k].evapLossRate = 0.0;                                             //(5.1.014)
    Conduit[k].seepLossRate = 0.0;                                             //(5.1.014)
}

//=============================================================================

conduit_getInflow(j)
//
//  Input:   j = link index
//  Output:  returns flow in link (cfs)
//  Purpose: finds inflow to conduit from upstream node.
//
{
    let qIn = node_getOutflow(Link[j].node1, j);
    if ( Link[j].qLimit > 0.0 ) qIn = MIN(qIn, Link[j].qLimit);
    return qIn;
}

//=============================================================================

////  This was modified for relese 5.1.014.  ////                     //(5.1.014)

conduit_getLossRate(j, q)
//
//  Input:   j = link index
//           q = current link flow rate (cfs)
//  Output:  returns rate of evaporation & seepage losses (ft3/sec)
//  Purpose: computes volumetric rate of water evaporation & seepage
//           from a conduit (per barrel).
//
{
    let xsect = new TXsect();
    let depth = 0.5 * (Link[j].oldDepth + Link[j].newDepth);
    let length;
    let topWidth;
    let evapLossRate = 0.0,
           seepLossRate = 0.0,
           totalLossRate = 0.0;

    if ( depth > FUDGE )
    {
        xsect = Link[j].xsect;
        length = conduit_getLength(j);

        // --- find evaporation rate for open conduits
        if ( xsect_isOpen(xsect.type) && Evap.rate > 0.0 )
        {
            topWidth = xsect_getWofY(xsect, depth);
            evapLossRate = topWidth * length * Evap.rate;
        }

        // --- compute seepage loss rate
        if ( Link[j].seepRate > 0.0 )
        {
            // limit depth to depth at max width
            if ( depth >= xsect.ywMax ) depth = xsect.ywMax;
			
            // compute seepage loss rate across length of conduit
            seepLossRate = Link[j].seepRate * xsect_getWofY(xsect, depth) *
                           length;
            seepLossRate *= Adjust.hydconFactor;
        }

        // --- compute total loss rate
        totalLossRate = evapLossRate + seepLossRate;

        // --- total loss rate cannot exceed flow rate
        q = ABS(q);
        if (totalLossRate > q)
        {
            evapLossRate = evapLossRate * q / totalLossRate;
            seepLossRate = seepLossRate * q / totalLossRate;
            totalLossRate = q;
        }
    }

    Conduit[Link[j].subIndex].evapLossRate = evapLossRate;
    Conduit[Link[j].subIndex].seepLossRate = seepLossRate;
    return totalLossRate;
}


//=============================================================================
//                        P U M P   M E T H O D S
//=============================================================================

 pump_readParams(j, k, tok, ntoks)
//
//  Input:   j = link index
//           k = pump index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads pump parameters from a tokenized line of input.
//
{
    let    m;
    let    n1, n2;
    let x = new Array(4);
    let  id;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check for valid ID and end node IDs
    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(LINK, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);
    n1 = project_findObject(NODE, tok[1]);
    if ( n1 < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    n2 = project_findObject(NODE, tok[2]);
    if ( n2 < 0 ) return error_setInpError(ERR_NAME, tok[2]);

    // --- parse curve name
    x[0] = -1.;
    if ( ntoks >= 4 )
    {
        if ( !strcomp(tok[3],"*") )
        {
            m = project_findObject(CURVE, tok[3]);
            if ( m < 0 ) return error_setInpError(ERR_NAME, tok[3]);
            x[0] = m;
        }
    }

    // --- parse init. status if present
    x[1] = 1.0;
    if ( ntoks >= 5 )
    {
        m = findmatch(tok[4], OffOnWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[4]);
        x[1] = m;
    }

    // --- parse startup/shutoff depths if present
    x[2] = 0.0;
    if ( ntoks >= 6 )
    {
        ////////////////////////////////////
        returnObj = {y: x[2]}
        returnVal = getDouble(tok[5], returnObj);
        x[2] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[2] < 0.0)
        //if ( null == (x[2] = getDouble(tok[5])) || x[2] < 0.0)
        return error_setInpError(ERR_NUMBER, tok[5]);
    }
    x[3] = 0.0;
    if ( ntoks >= 7 )
    {
        ////////////////////////////////////
        returnObj = {y: x[3]}
        returnVal = getDouble(tok[6], returnObj);
        x[3] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[3] < 0.0 )
        //if ( null == (x[3] = getDouble(tok[6])) || x[3] < 0.0 )
            return error_setInpError(ERR_NUMBER, tok[6]);
    }

    // --- add parameters to pump object
    Link[j].ID = id;
    link_setParams(j, PUMP, n1, n2, k, x);
    return 0;
}

//=============================================================================

 pump_validate(j, k)
//
//  Input:   j = link index
//           k = pump index
//  Output:  none
//  Purpose: validates a pump's properties
//
{
    let m, n1;
    let x, y;

    // ret facil
    let returnObj;
    let returnVal;

    Link[j].xsect.yFull = 0.0;

    // --- check for valid curve type
    m = Pump[k].pumpCurve;
    if ( m < 0 )
    {
        Pump[k].type = IDEAL_PUMP;
    }
    else
    {
        if ( Curve[m].curveType < PUMP1_CURVE ||
             Curve[m].curveType > PUMP4_CURVE )
            report_writeErrorMsg(ERR_NO_CURVE, Link[j].ID);

        // --- store pump curve type with pump's parameters
        else
        {
            Pump[k].type = Curve[m].curveType - PUMP1_CURVE;
            ////////////////////////////////////
            returnObj = {x: x, y: y}
            returnVal = table_getFirstEntry(Curve[m], returnObj)
            x = returnObj.x;
            y = returnObj.y;
            ////////////////////////////////////
            //if ( table_getFirstEntry(Curve[m], x, y) )
            if( returnVal )
            {
                Link[j].qFull = y;
                Pump[k].xMin = x;
                Pump[k].xMax = x;

                ////////////////////////////////////
                returnObj = {x: x, y: y}
                returnVal = table_getNextEntry(Curve[m], returnObj)
                x = returnObj.x;
                y = returnObj.y;
                ////////////////////////////////////
                //while ( table_getNextEntry(Curve[m], x, y) )
                while ( returnVal )
                {
                    Link[j].qFull = Math.max(y, Link[j].qFull);
                    Pump[k].xMax = x;
                    ////////////////////////////////////
                    returnObj = {x: x, y: y}
                    returnVal = table_getNextEntry(Curve[m], returnObj)
                    x = returnObj.x;
                    y = returnObj.y;
                    ////////////////////////////////////
                }
            }
            Link[j].qFull /= UCF(FLOW);
       }
    }

    // --- check that shutoff depth < startup depth
    if ( Pump[k].yOn > 0.0 && Pump[k].yOn <= Pump[k].yOff )
        report_writeErrorMsg(ERR_PUMP_LIMITS, Link[j].ID);

    // --- assign wet well volume to inlet node of Type 1 pump
    if ( Pump[k].type == TYPE1_PUMP )
    {
        n1 = Link[j].node1;
        if ( Node[n1].type != STORAGE )
            Node[n1].fullVolume = MAX(Node[n1].fullVolume,
                                      Pump[k].xMax / UCF(VOLUME));
    }

}

//=============================================================================

 pump_initState(j, k)
//
//  Input:   j = link index
//           k = pump index
//  Output:  none
//  Purpose: initializes pump conditions at start of a simulation
//
{
    Link[j].setting = Pump[k].initSetting;
    Link[j].targetSetting = Pump[k].initSetting;
}

//=============================================================================

pump_getInflow(j)
//
//  Input:   j = link index
//  Output:  returns pump flow (cfs)
//  Purpose: finds flow produced by a pump.
//
{
    let     k, m;
    let     n1, n2;
    let  vol, depth, head;
    let  qIn, qIn1, dh = 0.001;

    k = Link[j].subIndex;
    m = Pump[k].pumpCurve;
    n1 = Link[j].node1;
    n2 = Link[j].node2;

    // --- no flow if setting is closed
    Link[j].flowClass = NO;
    Link[j].setting = Link[j].targetSetting;
    if ( Link[j].setting == 0.0 ) return 0.0;

    // --- pump flow = node inflow for IDEAL_PUMP
    if ( Pump[k].type == IDEAL_PUMP )
        qIn = Node[n1].inflow + Node[n1].overflow;

    // --- pumping rate depends on pump curve type
    else switch(Curve[m].curveType)
    {
      case PUMP1_CURVE:
        vol = Node[n1].newVolume * UCF(VOLUME);
        qIn = table_intervalLookup(Curve[m], vol) / UCF(FLOW);

        // --- check if off of pump curve
        if ( vol < Pump[k].xMin || vol > Pump[k].xMax )
            Link[j].flowClass = YES;
        break;

      case PUMP2_CURVE:
        depth = Node[n1].newDepth * UCF(LENGTH);
        qIn = table_intervalLookup(Curve[m], depth) / UCF(FLOW);

        // --- check if off of pump curve
        if ( depth < Pump[k].xMin || depth > Pump[k].xMax )
            Link[j].flowClass = YES;
        break;

      case PUMP3_CURVE:
        head = ( (Node[n2].newDepth + Node[n2].invertElev) -
                 (Node[n1].newDepth + Node[n1].invertElev) );

		head = MAX(head, 0.0);

        qIn = table_lookup(Curve[m], head*UCF(LENGTH)) / UCF(FLOW);

        // --- compute dQ/dh (slope of pump curve) and
        //     reverse sign since flow decreases with increasing head
    	Link[j].dqdh = -table_getSlope(Curve[m], head*UCF(LENGTH)) *
                       UCF(LENGTH) / UCF(FLOW);

        // --- check if off of pump curve
        head *= UCF(LENGTH);
        if ( head < Pump[k].xMin || head > Pump[k].xMax )
            Link[j].flowClass = YES;
        break;

      case PUMP4_CURVE:
        depth = Node[n1].newDepth;
        qIn = table_lookup(Curve[m], depth*UCF(LENGTH)) / UCF(FLOW);

        // --- compute dQ/dh (slope of pump curve)
        qIn1 = table_lookup(Curve[m], (depth+dh)*UCF(LENGTH)) / UCF(FLOW);
        Link[j].dqdh = (qIn1 - qIn) / dh;

        // --- check if off of pump curve
        depth *= UCF(LENGTH);
        if ( depth < Pump[k].xMin ) Link[j].flowClass = DN_DRY;
        if ( depth > Pump[k].xMax ) Link[j].flowClass = UP_DRY;
        break;

      default: qIn = 0.0;
    }

    // --- do not allow reverse flow through pump
    if ( qIn < 0.0 )  qIn = 0.0;
    return qIn * Link[j].setting;
}


//=============================================================================
//                    O R I F I C E   M E T H O D S
//=============================================================================

 orifice_readParams(j, k, tok, ntoks)
//
//  Input:   j = link index
//           k = orifice index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads orifice parameters from a tokenized line of input.
//
{
    let  m;
    let  n1, n2;
    let  x = new Array(5);
    let  id;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check for valid ID and end node IDs
    if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(LINK, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);
    n1 = project_findObject(NODE, tok[1]);
    if ( n1 < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    n2 = project_findObject(NODE, tok[2]);
    if ( n2 < 0 ) return error_setInpError(ERR_NAME, tok[2]);

    // --- parse orifice parameters
    m = findmatch(tok[3], OrificeTypeWords);
    if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[3]);
    x[0] = m;                                              // type
    if ( LinkOffsets == ELEV_OFFSET && tok[4] == '*' ) x[1] = MISSING;
    else {
        ////////////////////////////////////
        returnObj = {y: x[3]}
        returnVal = getDouble(tok[4], returnObj);
        x[3] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[3] < 0.0 )
        //if ( null == (x[1] = getDouble(tok[4])) )                 // crest height
            return error_setInpError(ERR_NUMBER, tok[4]);
    }
    ////////////////////////////////////
    returnObj = {y: x[2]}
    returnVal = getDouble(tok[5], returnObj);
    x[2] = returnObj.y;
    ////////////////////////////////////
    if( !returnVal || x[2] < 0.0 )
    //if ( null == (x[2] = getDouble(tok[5])) || x[2] < 0.0 )        // cDisch
        return error_setInpError(ERR_NUMBER, tok[5]);
    x[3] = 0.0;
    if ( ntoks >= 7 )
    {
        m = findmatch(tok[6], NoYesWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[6]);
        x[3] = m;                                          // flap gate
    }
    x[4] = 0.0;
    if ( ntoks >= 8 )
    {
        ////////////////////////////////////
        returnObj = {y: x[4]}
        returnVal = getDouble(tok[7], returnObj);
        x[4] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[4] < 0.0 )
        //if ( null == (x[4] = getDouble(tok[7])) || x[4] < 0.0 )    // orate
            return error_setInpError(ERR_NUMBER, tok[7]);
    }

    // --- add parameters to orifice object
    Link[j].ID = id;
    link_setParams(j, ORIFICE, n1, n2, k, x);
    return 0;
}

//=============================================================================

 orifice_validate(j, k)
//
//  Input:   j = link index
//           k = orifice index
//  Output:  none
//  Purpose: validates an orifice's properties
//
{
    let    err = 0;

    // --- check for valid xsection
    if ( Link[j].xsect.type != RECT_CLOSED
    &&   Link[j].xsect.type != CIRCULAR ) err = ERR_REGULATOR_SHAPE;
    if ( err > 0 )
    {
        report_writeErrorMsg(err, Link[j].ID);
        return;
    }

    // --- check for negative offset
    if ( Link[j].offset1 < 0.0 ) Link[j].offset1 = 0.0;

    // --- compute partial flow adjustment
    orifice_setSetting(j, 0.0);

    // --- compute an equivalent length
    Orifice[k].length = 2.0 * RouteStep * Math.sqrt(GRAVITY * Link[j].xsect.yFull);
    Orifice[k].length = MAX(200.0, Orifice[k].length);
    Orifice[k].surfArea = 0.0;
}

//=============================================================================

 orifice_setSetting(j, tstep)
//
//  Input:   j = link index
//           tstep = time step over which setting is adjusted (sec)
//  Output:  none
//  Purpose: updates an orifice's setting as a result of a control action.
//
{
    let    k = Link[j].subIndex;
    let delta, step;
    let h, f;

    // --- case where adjustment rate is instantaneous
    if ( Orifice[k].orate == 0.0 || tstep == 0.0)
        Link[j].setting = Link[j].targetSetting;

    // --- case where orifice setting depends on time step
    else
    {
        delta = Link[j].targetSetting - Link[j].setting;
        step = tstep / Orifice[k].orate;
        if ( step + 0.001 >= Math.abs(delta) )
            Link[j].setting = Link[j].targetSetting;
        else Link[j].setting += SGN(delta) * step;
    }

    // --- find effective orifice discharge coeff.
    h = Link[j].setting * Link[j].xsect.yFull;
    f = xsect_getAofY(Link[j].xsect, h) * Math.sqrt(2.0 * GRAVITY);
    Orifice[k].cOrif = Orifice[k].cDisch * f;

    // --- find equiv. discharge coeff. for when weir flow occurs
    Orifice[k].cWeir = orifice_getWeirCoeff(j, k, h) * f;
}

//=============================================================================

orifice_getWeirCoeff(j, k, h)
//
//  Input:   j = link index
//           k = orifice index
//           h = height of orifice opening (ft)
//  Output:  returns a discharge coefficient (ft^1/2)
//  Purpose: computes the discharge coefficient for an orifice
//           at the critical depth where weir flow begins.
//
{
    let w, aOverL;

    // --- this is for bottom orifices
    if ( Orifice[k].type == BOTTOM_ORIFICE )
    {
        // --- find critical height above opening where orifice flow
        //     turns into weir flow. It equals (Co/Cw)*(Area/Length)
        //     where Co is the orifice coeff., Cw is the weir coeff/sqrt(2g),
        //     Area is the area of the opening, and Length = circumference
        //     of the opening. For a basic sharp crested weir, Cw = 0.414.
        if (Link[j].xsect.type == CIRCULAR) aOverL = h / 4.0;
        else
        {
            w = Link[j].xsect.wMax;
            aOverL = (h*w) / (2.0*(h+w));
        }
        h = Orifice[k].cDisch / 0.414 * aOverL;
        Orifice[k].hCrit = h;
    }

    // --- this is for side orifices
    else
    {
        // --- critical height is simply height of opening
        Orifice[k].hCrit = h;

        // --- head on orifice is distance to center line
        h = h / 2.0;
    }

    // --- return a coefficient for the critical depth
    return Orifice[k].cDisch * Math.sqrt(h);
}

//=============================================================================

orifice_getInflow(j)
//
//  Input:   j = link index
//  Output:  returns orifice flow rate (cfs)
//  Purpose: finds the flow through an orifice.
//
{
    let    k, n1, n2;
    let head, h1, h2, y1, dir;
    let f;
    let hcrest = 0.0;
    let hcrown = 0.0;
    let hmidpt;
    let q, ratio;

    // --- get indexes of end nodes and link's orifice
    n1 = Link[j].node1;
    n2 = Link[j].node2;
    k  = Link[j].subIndex;

    // --- find heads at upstream & downstream nodes
    if ( RouteModel == DW )
    {
        h1 = Node[n1].newDepth + Node[n1].invertElev;
        h2 = Node[n2].newDepth + Node[n2].invertElev;
    }
    else
    {
        h1 = Node[n1].newDepth + Node[n1].invertElev;
        h2 = Node[n1].invertElev;
    }
    dir = (h1 >= h2) ? +1.0 : -1.0;

    // --- exchange h1 and h2 for reverse flow
    y1 = Node[n1].newDepth;
    if ( dir < 0.0 )
    {
        head = h1;
        h1 = h2;
        h2 = head;
        y1 = Node[n2].newDepth;
    }

    // --- orifice is a bottom orifice (oriented in horizontal plane)
    if ( Orifice[k].type == BOTTOM_ORIFICE )
    {
        // --- compute crest elevation
        hcrest = Node[n1].invertElev + Link[j].offset1;

        // --- compute head on orifice
        if (h1 < hcrest) head = 0.0;
        else if (h2 > hcrest) head = h1 - h2;
        else head = h1 - hcrest;

        // --- find fraction of critical height for which weir flow occurs
        f = head / Orifice[k].hCrit;
        f = MIN(f, 1.0);
    }

    // --- otherwise orifice is a side orifice (oriented in vertical plane)
    else
    {
        // --- compute elevations of orifice crest and crown
        hcrest = Node[n1].invertElev + Link[j].offset1;
        hcrown = hcrest + Link[j].xsect.yFull * Link[j].setting;
        hmidpt = (hcrest + hcrown) / 2.0;

        // --- compute degree of inlet submergence
        if ( h1 < hcrown && hcrown > hcrest )
            f = (h1 - hcrest) / (hcrown - hcrest);
        else f = 1.0;

        // --- compute head on orifice
        if ( f < 1.0 )          head = h1 - hcrest;
        else if ( h2 < hmidpt ) head = h1 - hmidpt;
        else                    head = h1 - h2;
    }

    // --- return if head is negligible or flap gate closed
    if ( head <= FUDGE || y1 <= FUDGE ||
         link_setFlapGate(j, n1, n2, dir) )
    {
        Link[j].newDepth = 0.0;
        Link[j].flowClass = DRY;
        Orifice[k].surfArea = FUDGE * Orifice[k].length;
        Link[j].dqdh = 0.0;
        return 0.0;
    }

    // --- determine flow class
    Link[j].flowClass = SUBCRITICAL;
    if ( hcrest > h2 )
    {
        if ( dir == 1.0 ) Link[j].flowClass = DN_CRITICAL;
        else              Link[j].flowClass = UP_CRITICAL;
    }

    // --- compute flow depth and surface area
    y1 = Link[j].xsect.yFull * Link[j].setting;
    if ( Orifice[k].type == SIDE_ORIFICE )
    {
        Link[j].newDepth = y1 * f;
        Orifice[k].surfArea =
            xsect_getWofY(Link[j].xsect, Link[j].newDepth) *
            Orifice[k].length;
    }
    else
    {
        Link[j].newDepth = y1;
        Orifice[k].surfArea = xsect_getAofY(Link[j].xsect, y1);
    }

    // --- find flow through the orifice
    q = dir * orifice_getFlow(j, k, head, f, Link[j].hasFlapGate);

    // --- apply Villemonte eqn. to correct for submergence
    if ( f < 1.0 && h2 > hcrest )
    {
        ratio = (h2 - hcrest) / (h1 - hcrest);
        q *= Math.pow( (1.0 - Math.pow(ratio, 1.5)), 0.385);
    }
    return q;
}

//=============================================================================

orifice_getFlow(j, k, head, f, hasFlapGate)
//
//  Input:   j = link index
//           k = orifice index
//           head = head across orifice
//           f = fraction of critical depth filled
//           hasFlapGate = flap gate indicator
//  Output:  returns flow through an orifice
//  Purpose: computes flow through an orifice as a of head.
//
{
    let area, q;
    let veloc, hLoss;

    // --- case where orifice is closed
    if ( head == 0.0 || f <= 0.0  )
    {
        Link[j].dqdh = 0.0;
        return 0.0;
    }

    // --- case where inlet depth is below critical depth;
    //     orifice behaves as a weir
    else if ( f < 1.0 )
    {
        q = Orifice[k].cWeir * Math.pow(f, 1.5);
        Link[j].dqdh = 1.5 * q / (f * Orifice[k].hCrit);
    }

    // --- case where normal orifice flow applies
    else
    {
        q = Orifice[k].cOrif * Math.sqrt(head);
        Link[j].dqdh = q / (2.0 * head);
    }

    // --- apply ARMCO adjustment for headloss from flap gate
    if ( hasFlapGate )
    {
        // --- compute velocity for current orifice flow
        area = xsect_getAofY(Link[j].xsect,
                             Link[j].setting * Link[j].xsect.yFull);
        veloc = q / area;

        // --- compute head loss from gate
        hLoss = (4.0 / GRAVITY) * veloc * veloc *
                 exp(-1.15 * veloc / Math.sqrt(head) );

        // --- update head (for orifice flow)
        //     or critical depth fraction (for weir flow)
        if ( f < 1.0 )
        {
            f = f - hLoss/Orifice[k].hCrit;
            if ( f < 0.0 ) f = 0.0;
        }
        else
        {
            head = head - hLoss;
            if ( head < 0.0 ) head = 0.0;
        }

        // --- make recursive call to this function, with hasFlapGate
        //     set to false, to find flow values at adjusted head value
        q = orifice_getFlow(j, k, head, f, FALSE);
    }
    return q;
}

//=============================================================================
//                           W E I R   M E T H O D S
//=============================================================================

  weir_readParams(j, k, tok, ntoks)
//
//  Input:   j = link index
//           k = weir index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads weir parameters from a tokenized line of input.
//
{
    let m;
    let n1, n2;
    let x = new Array(10);                                                              //(5.1.013)
    let id;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- check for valid ID and end node IDs
    if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(LINK, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);
    n1 = project_findObject(NODE, tok[1]);
    if ( n1 < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    n2 = project_findObject(NODE, tok[2]);
    if ( n2 < 0 ) return error_setInpError(ERR_NAME, tok[2]);

    // --- parse weir parameters
    m = findmatch(tok[3], WeirTypeWords);
    if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[3]);
    x[0] = m;                                              // type
    if ( LinkOffsets == ELEV_OFFSET && tok[4] == '*' ) x[1] = MISSING;
    else {
        ////////////////////////////////////
        returnObj = {y: x[1]}
        returnVal = getDouble(tok[4], returnObj);
        x[1] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[1] = getDouble(tok[4])) )                 // height
            return error_setInpError(ERR_NUMBER, tok[4]);
    }
    ////////////////////////////////////
    returnObj = {y: x[2]}
    returnVal = getDouble(tok[5], returnObj);
    x[2] = returnObj.y;
    ////////////////////////////////////
    if( !returnVal || x[2] < 0.0 )
    //if ( null == (x[2] = getDouble(tok[5])) || x[2] < 0.0 )        // cDisch1
        return error_setInpError(ERR_NUMBER, tok[5]);
    x[3] = 0.0;
    x[4] = 0.0;
    x[5] = 0.0;
    x[6] = 1.0;
    x[7] = 0.0;
    x[8] = 0.0;
    x[9] = -1.0;                                                               //(5.1.013)
    if ( ntoks >= 7 && tok[6] != '*' )
    {
        m = findmatch(tok[6], NoYesWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[6]);
        x[3] = m;                                          // flap gate
    }
    if ( ntoks >= 8 && tok[7] != '*' ) 
    {
        ////////////////////////////////////
        returnObj = {y: x[4]}
        returnVal = getDouble(tok[7], returnObj);
        x[4] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[4] < 0.0 )
        //if ( null == (x[4] = getDouble(tok[7])) || x[4] < 0.0 )     // endCon
            return error_setInpError(ERR_NUMBER, tok[7]);
    }
    if ( ntoks >= 9 && tok[8] != '*' )
    {
        ////////////////////////////////////
        returnObj = {y: x[5]}
        returnVal = getDouble(tok[8], returnObj);
        x[5] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal || x[5] < 0.0 )
        //if ( null == ( x[5] = getDouble(tok[8])) || x[5] < 0.0 )     // cDisch2
            return error_setInpError(ERR_NUMBER, tok[8]);
    }

    if ( ntoks >= 10 && tok[9] != '*' )
    {
        m = findmatch(tok[9], NoYesWords);
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[9]);
        x[6] = m;                                           // canSurcharge
    }

    if ( (m = x[0]) == ROADWAY_WEIR )
    {
        if ( ntoks >= 11 )                                  // road width
        {
            ////////////////////////////////////
            returnObj = {y: x[7]}
            returnVal = getDouble(tok[10], returnObj);
            x[7] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal || x[7] < 0.0 )
            //if ( null == (x[7] = getDouble(tok[10])) || x[7] < 0.0 ) 
                return error_setInpError(ERR_NUMBER, tok[10]);
        }
        if ( ntoks >= 12 )                                  // road surface
        {
            if ( strcomp(tok[11], "PAVED") ) x[8] = 1.0;
            else if ( strcomp(tok[11], "GRAVEL") ) x[8] = 2.0;
        }
    }

    if (ntoks >= 13 && tok[12] != '*')                                        //(5.1.013)
    {                                                                          //
        m = project_findObject(CURVE, tok[12]);             // coeff. curve    //
        if (m < 0) return error_setInpError(ERR_NAME, tok[12]);                //
        x[9] = m;                                                              //
    }                                                                          //

    // --- add parameters to weir object
    Link[j].ID = id;
    link_setParams(j, WEIR, n1, n2, k, x);
    return 0;
}

//=============================================================================

 weir_validate(j, k)
//
//  Input:   j = link index
//           k = weir index
//  Output:  none
//  Purpose: validates a weir's properties
//
{
    let    err = 0;
    let q, q1, q2, head;
 
    // --- check for valid cross section
    switch ( Weir[k].type)
    {
      case TRANSVERSE_WEIR:
      case SIDEFLOW_WEIR:
      case ROADWAY_WEIR:
        if ( Link[j].xsect.type != RECT_OPEN ) err = ERR_REGULATOR_SHAPE;
        Weir[k].slope = 0.0;
        break;

      case VNOTCH_WEIR:
        if ( Link[j].xsect.type != TRIANGULAR ) err = ERR_REGULATOR_SHAPE;
        else
        {
            Weir[k].slope = Link[j].xsect.sBot;
        }
        break;

      case TRAPEZOIDAL_WEIR:
        if ( Link[j].xsect.type != TRAPEZOIDAL ) err = ERR_REGULATOR_SHAPE;
        else
        {
            Weir[k].slope = Link[j].xsect.sBot;
        }
        break;
    }
    if ( err > 0 )
    {
        report_writeErrorMsg(err, Link[j].ID);
        return;
    }

    // --- check for negative offset
    if ( Link[j].offset1 < 0.0 ) Link[j].offset1 = 0.0;

    // --- compute an equivalent length
    Weir[k].length = 2.0 * RouteStep * Math.sqrt(GRAVITY * Link[j].xsect.yFull);
    Weir[k].length = MAX(200.0, Weir[k].length);
    Weir[k].surfArea = 0.0;

    // --- find flow through weir when water level equals weir height
    head = Link[j].xsect.yFull;
    weir_getFlow(j, k, head, 1.0, FALSE, q1, q2);
    q = q1 + q2;

    // --- compute equivalent orifice coeff. (for CFS flow units)
    head = head / 2.0;  // head seen by equivalent orifice
    Weir[k].cSurcharge = q / Math.sqrt(head); 
}

//=============================================================================

weir_setSetting(j)
//
//  Input:   j = link index
//  Output:  none
//  Purpose: updates a weir's setting as a result of a control action.
//
{
    let    k = Link[j].subIndex;
    let h, q, q1, q2;

    // --- adjust weir setting
    Link[j].setting = Link[j].targetSetting;
    if ( !Weir[k].canSurcharge ) return;
    if ( Weir[k].type == ROADWAY_WEIR ) return;

    // --- find orifice coeff. for surcharged flow
    if ( Link[j].setting == 0.0 ) Weir[k].cSurcharge = 0.0;
    else
    {
        // --- find flow through weir when water level equals weir height
        h = Link[j].setting * Link[j].xsect.yFull;
        weir_getFlow(j, k, h, 1.0, FALSE, q1, q2);
        q = q1 + q2;

        // --- compute equivalent orifice coeff. (for CFS flow units)
        h = h / 2.0;  // head seen by equivalent orifice
        Weir[k].cSurcharge = q / Math.sqrt(h);
    }
}

//=============================================================================

weir_getInflow(j)
//
//  Input:   j = link index
//  Output:  returns weir flow rate (cfs)
//  Purpose: finds the flow over a weir.
//
{
    let n1;          // index of upstream node
    let n2;          // index of downstream node
    let k;           // index of weir
    let q1;          // flow through central part of weir (cfs)
    let q2;          // flow through end sections of weir (cfs)
    let head;        // head on weir (ft)
    let h1;          // upstrm nodal head (ft)
    let h2;          // downstrm nodal head (ft)
    let hcrest;      // head at weir crest (ft)
    let hcrown;      // head at weir crown (ft)
    let y;           // water depth in weir (ft)
    let dir;         // direction multiplier
    let ratio;
    let weirPower =     [1.5,       // transverse weir
                        5./3.,     // side flow weir
                        2.5,       // v-notch weir
                        1.5];      // trapezoidal weir

    n1 = Link[j].node1;
    n2 = Link[j].node2;
    k  = Link[j].subIndex;
    if ( RouteModel == DW )
    {
        h1 = Node[n1].newDepth + Node[n1].invertElev;
        h2 = Node[n2].newDepth + Node[n2].invertElev;
    }
    else
    {
        h1 = Node[n1].newDepth + Node[n1].invertElev;
        h2 = Node[n1].invertElev;
    }
    dir = (h1 > h2) ? +1.0 : -1.0;

    // --- exchange h1 and h2 for reverse flow
    if ( dir < 0.0 )
    {
        head = h1;
        h1 = h2;
        h2 = head;
    }

    // --- find head of weir's crest and crown
    hcrest = Node[n1].invertElev + Link[j].offset1;
    hcrown = hcrest + Link[j].xsect.yFull;

    // --- treat a roadway weir as a special case
    if ( Weir[k].type == ROADWAY_WEIR )
        return roadway_getInflow(j, dir, hcrest, h1, h2);

    // --- adjust crest ht. for partially open weir
    hcrest += (1.0 - Link[j].setting) * Link[j].xsect.yFull;

    // --- compute head relative to weir crest
    head = h1 - hcrest;

    // --- return if head is negligible or flap gate closed
    Link[j].dqdh = 0.0;
    if ( head <= FUDGE || hcrest >= hcrown ||
         link_setFlapGate(j, n1, n2, dir) )
    {
        Link[j].newDepth = 0.0;
        Link[j].flowClass = DRY;
        return 0.0;
    }

    // --- determine flow class
    Link[j].flowClass = SUBCRITICAL;
    if ( hcrest > h2 )
    {
        if ( dir == 1.0 ) Link[j].flowClass = DN_CRITICAL;
        else              Link[j].flowClass = UP_CRITICAL;
    }

    // --- compute new equivalent surface area
    y = Link[j].xsect.yFull - (hcrown - MIN(h1, hcrown));
    Weir[k].surfArea = xsect_getWofY(Link[j].xsect, y) * Weir[k].length;

    // --- head is above crown
    if ( h1 >= hcrown )
    {
        // --- use equivalent orifice if weir can surcharge
        if ( Weir[k].canSurcharge )
        {
            y = (hcrest + hcrown) / 2.0;
            if ( h2 < y ) head = h1 - y;
            else          head = h1 - h2;
            y = hcrown - hcrest;
            q1 = weir_getOrificeFlow(j, head, y, Weir[k].cSurcharge);
            Link[j].newDepth = y;
            return dir * q1;
        }

        // --- otherwise limit head to height of weir opening
        else head = hcrown - hcrest;
    }

    // --- use weir eqn. to find flows through central (q1)
    //     and end sections (q2) of weir
    weir_getFlow(j, k, head, dir, Link[j].hasFlapGate, q1, q2);

    // --- apply Villemonte eqn. to correct for submergence
    if ( h2 > hcrest )
    {
        ratio = (h2 - hcrest) / (h1 - hcrest);
        q1 *= Math.pow( (1.0 - Math.pow(ratio, weirPower[Weir[k].type])), 0.385);
        if ( q2 > 0.0 )
            q2 *= Math.pow( (1.0 - Math.pow(ratio, weirPower[VNOTCH_WEIR])), 0.385);
    }

    // --- return total flow through weir
    Link[j].newDepth = MIN((h1 - hcrest), Link[j].xsect.yFull);
    return dir * (q1 + q2);
}

//=============================================================================

weir_getFlow(j, k, head, dir, hasFlapGate,
                   q1,  q2)
//
//  Input:   j    = link index
//           k    = weir index
//           head = head across weir (ft)
//           dir  = flow direction indicator
//           hasFlapGate = flap gate indicator
//  Output:  q1 = flow through central portion of weir (cfs)
//           q2 = flow through end sections of weir (cfs)
//  Purpose: computes flow over weir given head.
//
{
    let length;
    let h;
    let y;
    let hLoss;
    let area;
    let veloc;
    let wType;
    let cdCurve = Weir[k].cdCurve;                                          //(5.1.013)
    let cDisch1 = Weir[k].cDisch1;                                          //

    // --- q1 = flow through central portion of weir,
    //     q2 = flow through end sections of trapezoidal weir
    q1 = 0.0;
    q2 = 0.0;
    Link[j].dqdh = 0.0;
    if ( head <= 0.0 ) return;

    // --- convert weir length & head to original units
    length = Link[j].xsect.wMax * UCF(LENGTH);
    h = head * UCF(LENGTH);

    // --- lookup tabulated discharge coeff.                                   //(5.1.013)
    if ( cdCurve >= 0 ) cDisch1 = table_lookup(Curve[cdCurve], h);            //

    // --- use appropriate formula for weir flow
    wType = Weir[k].type;
    if ( wType == VNOTCH_WEIR &&
         Link[j].setting < 1.0 ) wType = TRAPEZOIDAL_WEIR;
    switch (wType)
    {
      case TRANSVERSE_WEIR:

        // --- reduce length when end contractions present 
        length -= 0.1 * Weir[k].endCon * h;
        length = Math.max(length, 0.0);
        q1 = cDisch1 * length * Math.pow(h, 1.5);                                  //(5.1.013)
        break;

      case SIDEFLOW_WEIR:

        // --- reduce length when end contractions present
        length -= 0.1 * Weir[k].endCon * h;
        length = Math.max(length, 0.0);

        // --- weir behaves as a transverse weir under reverse flow
        if ( dir < 0.0 )
            q1 = cDisch1 * length * Math.pow(h, 1.5);                              //(5.1.013)
        else

       //  Corrected formula (see Metcalf & Eddy, Inc.,
       //  Wastewater Engineering, McGraw-Hill, 1972 p. 164).
            q1 = cDisch1 * Math.pow(length, 0.83) * Math.pow(h, 1.67);                  //(5.1.013)

        break;

      case VNOTCH_WEIR:
        q1 = cDisch1 * Weir[k].slope * Math.pow(h, 2.5);                           //(5.1.013)
        break;

      case TRAPEZOIDAL_WEIR:
        y = (1.0 - Link[j].setting) * Link[j].xsect.yFull;
        length = xsect_getWofY(Link[j].xsect, y) * UCF(LENGTH);
        q1 = cDisch1 * length * Math.pow(h, 1.5);                                 //(5.1.013)
        q2 = Weir[k].cDisch2 * Weir[k].slope * Math.pow(h, 2.5);
    }

    // --- convert CMS flows to CFS
    if ( UnitSystem == SI )
    {
        q1 /= M3perFT3;
        q2 /= M3perFT3;
    }

    // --- apply ARMCO adjustment for headloss from flap gate
    if ( hasFlapGate )
    {
        // --- compute flow area & velocity for current weir flow
        area = weir_getOpenArea(j, head);
        if ( area > TINY )
        {
            veloc = (q1 + q2) / area;

            // --- compute headloss and subtract from original head
            hLoss = (4.0 / GRAVITY) * veloc * veloc *
                     exp(-1.15 * veloc / Math.sqrt(head) );
            head = head - hLoss;
            if ( head < 0.0 ) head = 0.0;

            // --- make recursive call to this function, with hasFlapGate
            //     set to false, to find flow values at adjusted head value
            weir_getFlow(j, k, head, dir, FALSE, q1, q2);
        }
    }
    Link[j].dqdh = weir_getdqdh(k, dir, head, q1, q2);
}

//=============================================================================

weir_getOrificeFlow(j, head, y, cOrif)
//
//  Input:   j = link index
//           head = head across weir (ft)
//           y = height of upstream water level above weir crest (ft)
//           cOrif = orifice flow coefficient
//  Output:  returns flow through weir
//  Purpose: finds flow through a surcharged weir using the orifice equation.
//
{
    let a, q, v, hloss;

    // --- evaluate the orifice flow equation
    q = cOrif * Math.sqrt(head);

    // --- apply Armco adjustment if weir has a flap gate
    if ( Link[j].hasFlapGate )
    {
        a = weir_getOpenArea(j, y);
        if ( a > 0.0 )
        {
            v = q / a;
            hloss = (4.0 / GRAVITY) * v * v * exp(-1.15 * v / Math.sqrt(y) );
            head -= hloss;
            head = MAX(head, 0.0);
            q = cOrif * Math.sqrt(head);
        }
    }
    if ( head > 0.0 ) Link[j].dqdh = q / (2.0 * head);
    else Link[j].dqdh = 0.0;
    return q;
}

//=============================================================================

weir_getOpenArea(j, y)
//
//  Input:   j = link index
//           y = depth of water above weir crest (ft)
//  Output:  returns area between weir crest and y (ft2)
//  Purpose: finds flow area through a weir.
//
{
    let z, zy;

    // --- find offset of weir crest due to control setting
    z = (1.0 - Link[j].setting) * Link[j].xsect.yFull;

    // --- ht. of crest + ht of water above crest
    zy = z + y;
    zy = MIN(zy, Link[j].xsect.yFull);

    // --- return difference between area of offset + water depth
    //     and area of just the offset
    return xsect_getAofY(Link[j].xsect, zy) -
           xsect_getAofY(Link[j].xsect, z);
}

//=============================================================================

 weir_getdqdh(k, dir, h, q1, q2)
{
    let q1h;
    let q2h;

    if ( Math.abs(h) < FUDGE ) return 0.0;
    q1h = Math.abs(q1/h);
    q2h = Math.abs(q2/h);

    switch (Weir[k].type)
    {
      case TRANSVERSE_WEIR: return 1.5 * q1h;

      case SIDEFLOW_WEIR:
        // --- weir behaves as a transverse weir under reverse flow
        if ( dir < 0.0 ) return 1.5 * q1h;
        else return 1.67 * q1h;

      case VNOTCH_WEIR:
        if ( q2h == 0.0 ) return 2.5 * q1h;  // Fully open
        else return 1.5 * q1h + 2.5 * q2h;   // Partly open

      case TRAPEZOIDAL_WEIR: return 1.5 * q1h + 2.5 * q2h;
    }
    return 0.0;
}


//=============================================================================
//               O U T L E T    D E V I C E    M E T H O D S
//=============================================================================

outlet_readParams(j, k, tok, ntoks)
//
//  Input:   j = link index
//           k = outlet index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads outlet parameters from a tokenized  line of input.
//
{
    let    i, m, n;
    let    n1, n2;
    let x = new Array(6);
    let  id;
    let  s;

    //return facilitators
    let returnObj;
    let returnVal;

    // --- check for valid ID and end node IDs
    if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(LINK, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);
    n1 = project_findObject(NODE, tok[1]);
    if ( n1 < 0 ) return error_setInpError(ERR_NAME, tok[1]);
    n2 = project_findObject(NODE, tok[2]);
    if ( n2 < 0 ) return error_setInpError(ERR_NAME, tok[2]);

    // --- get height above invert
    if ( LinkOffsets == ELEV_OFFSET && tok[3] == '*' ) x[0] = MISSING;
    else
    {
        ////////////////////////////////////
        returnObj = {y: x[0]}
        returnVal = getDouble(tok[3], returnObj);
        x[0] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[0] = getDouble(tok[3])) )
            return error_setInpError(ERR_NUMBER, tok[3]);
	if ( LinkOffsets == DEPTH_OFFSET && x[0] < 0.0 ) x[0] = 0.0;
    }

    // --- see if outlet flow relation is tabular or functional
    m = findmatch(tok[4], RelationWords);
    if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[4]);
    x[1] = 0.0;
    x[2] = 0.0;
    x[3] = -1.0;
    x[4] = 0.0;

    // --- see if rating curve is head or depth based
    x[5] = NODE_DEPTH;                                //default is depth-based
    s = strtok(tok[4], "/");                          //parse token for
    s = strtok(null, "/");                            //  qualifier term
    if ( strcomp(s, w_HEAD) ) x[5] = NODE_HEAD;       //check if its "HEAD"

    // --- get params. for functional outlet device
    if ( m == FUNCTIONAL )
    {
        if ( ntoks < 7 ) return error_setInpError(ERR_ITEMS, "");
        ////////////////////////////////////
        returnObj = {y: x[1]}
        returnVal = getDouble(tok[5], returnObj);
        x[1] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[1] = getDouble(tok[5])) )
            return error_setInpError(ERR_NUMBER, tok[5]);
        ////////////////////////////////////
        returnObj = {y: x[2]}
        returnVal = getDouble(tok[6], returnObj);
        x[2] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[2] = getDouble(tok[6])) )
            return error_setInpError(ERR_NUMBER, tok[6]);
        n = 7;
    }

    // --- get name of outlet rating curve
    else
    {
        i = project_findObject(CURVE, tok[5]);
        if ( i < 0 ) return error_setInpError(ERR_NAME, tok[5]);
        x[3] = i;
        n = 6;
    }

    // --- check if flap gate specified
    if ( ntoks > n)
    {
        i = findmatch(tok[n], NoYesWords);
        if ( i < 0 ) return error_setInpError(ERR_KEYWORD, tok[n]);
        x[4] = i;
    }

    // --- add parameters to outlet object
    Link[j].ID = id;
    link_setParams(j, OUTLET, n1, n2, k, x);
    return 0;
}

//=============================================================================

outlet_getInflow(j)
//
//  Input:   j = link index
//  Output:  outlet flow rate (cfs)
//  Purpose: finds the flow through an outlet.
//
{
    let    k, n1, n2;
    let head, hcrest, h1, h2, y1, dir;

    // --- get indexes of end nodes
    n1 = Link[j].node1;
    n2 = Link[j].node2;
    k  = Link[j].subIndex;

    // --- find heads at upstream & downstream nodes
    if ( RouteModel == DW )
    {
        h1 = Node[n1].newDepth + Node[n1].invertElev;
        h2 = Node[n2].newDepth + Node[n2].invertElev;
    }
    else
    {
        h1 = Node[n1].newDepth + Node[n1].invertElev;
        h2 = Node[n1].invertElev;
    }
    dir = (h1 >= h2) ? +1.0 : -1.0;

    // --- exchange h1 and h2 for reverse flow
    y1 = Node[n1].newDepth;
    if ( dir < 0.0 )
    {
        y1 = h1;
        h1 = h2;
        h2 = y1;
        y1 = Node[n2].newDepth;
    }

    // --- for a NODE_DEPTH rating curve the effective head across the
    //     outlet is the depth above the crest elev. while for a NODE_HEAD
    //     curve it is the difference between upstream & downstream heads
    hcrest = Node[n1].invertElev + Link[j].offset1;
    if ( Outlet[k].curveType == NODE_HEAD && RouteModel == DW )
        head = h1 - MAX(h2, hcrest);
    else head = h1 - hcrest;

    // --- no flow if either no effective head difference,
    //     no upstream water available, or closed flap gate
    if ( head <= FUDGE || y1 <= FUDGE ||
         link_setFlapGate(j, n1, n2, dir) )
    {
        Link[j].newDepth = 0.0;
        Link[j].flowClass = DRY;
        return 0.0;
    }

    // --- otherwise use rating curve to compute flow
    Link[j].newDepth = head;
    Link[j].flowClass = SUBCRITICAL;
    return dir * Link[j].setting * outlet_getFlow(k, head);
}

//=============================================================================

outlet_getFlow(k, head)
//
//  Input:   k    = outlet index
//           head = head across outlet (ft)
//  Output:  returns outlet flow rate (cfs)
//  Purpose: computes flow rate through an outlet given head.
//
{
    let    m;
    let h;

    // --- convert head to original units
    h = head * UCF(LENGTH);

    // --- look-up flow in rating curve table if provided
    m = Outlet[k].qCurve;
    if ( m >= 0 ) return table_lookup(Curve[m], h) / UCF(FLOW);

    // --- otherwise use to find flow
    else return Outlet[k].qCoeff * Math.pow(h, Outlet[k].qExpon) / UCF(FLOW);
}


class TStorageVol{
    constructor(k, v){
        // Storage unit index
        this.k = k;
        // Storage unit volume (ft3)
        this.v = v;
    }
}

//
//  Input:   j = node index
//           type = node type code
//           k = index of node type
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads node properties from a tokenized line of input.
//
node_readParams(j, type, k, tok, ntoks){
    switch ( type )
    {
      case JUNCTION: return junc_readParams(j, k, tok, ntoks);
      case OUTFALL:  return outfall_readParams(j, k, tok, ntoks);
      case STORAGE:  return storage_readParams(j, k, tok, ntoks);
      case DIVIDER:  return divider_readParams(j, k, tok, ntoks);
      default:       return 0;
    }
}


//=============================================================================

 node_setParams(j, type, k, x)
//
//  Input:   j = node index
//           type = node type code
//           k = index of node type
//           x[] = array of property values
//  Output:  none
//  Purpose: assigns property values to a node.
//
{
    Node[j].type       = type;
    Node[j].subIndex   = k;
    Node[j].invertElev = x[0] / UCF(LENGTH);
    Node[j].crownElev  = Node[j].invertElev;
    Node[j].initDepth  = 0.0;
    Node[j].newVolume  = 0.0;
    Node[j].fullVolume = 0.0;
    Node[j].fullDepth  = 0.0;
    Node[j].surDepth   = 0.0;
    Node[j].pondedArea = 0.0;
    Node[j].degree     = 0;
    switch (type)
    {
      case JUNCTION:
        Node[j].fullDepth = x[1] / UCF(LENGTH);
        Node[j].initDepth = x[2] / UCF(LENGTH);
        Node[j].surDepth  = x[3] / UCF(LENGTH);
        Node[j].pondedArea = x[4] / (UCF(LENGTH)*UCF(LENGTH));
        break;

      case OUTFALL:
        Outfall[k].type        = x[1];
        Outfall[k].fixedStage  = x[2] / UCF(LENGTH);
        Outfall[k].tideCurve   = x[3];
        Outfall[k].stageSeries = x[4];
        Outfall[k].hasFlapGate = x[5];
        Outfall[k].routeTo     = x[6];
        Outfall[k].wRouted     = null;
        if ( Outfall[k].routeTo >= 0 )
        {
            /*Outfall[k].wRouted =
                (double *) calloc(Nobjects[POLLUT], sizeof(double));*/
            Outfall[k].wRouted = new Array(Nobjects[POLLUT]);
        }
        break;

      case STORAGE:
        Node[j].fullDepth  = x[1] / UCF(LENGTH);
        Node[j].initDepth  = x[2] / UCF(LENGTH);
        Storage[k].aCoeff  = x[3];
        Storage[k].aExpon  = x[4];
        Storage[k].a = x[5];
        Storage[k].aCurve  = x[6];

        // Surcharge depth replaces ponded area                                //(5.1.013)
        Node[j].surDepth   = x[7] / UCF(LENGTH);                               //
        
        Storage[k].fEvap   = x[8];
        break;

      case DIVIDER:
        Divider[k].link      = x[1];
        Divider[k].type      = x[2];
        Divider[k].flowCurve = x[3];
        Divider[k].qMin      = x[4] / UCF(FLOW);
        Divider[k].dhMax     = x[5];
        Divider[k].cWeir     = x[6];
        Node[j].fullDepth    = x[7] / UCF(LENGTH);
        Node[j].initDepth    = x[8] / UCF(LENGTH);
        Node[j].surDepth     = x[9] / UCF(LENGTH);
        Node[j].pondedArea   = x[10] / (UCF(LENGTH)*UCF(LENGTH));
        break;
    }
}

//=============================================================================

 node_validate(j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: validates a node's properties.
//
{
    let inflow = new TDwfInflow();

    // ret facil
    let returnObj;
    let returnVal;

    // --- see if full depth was increased to accommodate conduit crown
    if ( Node[j].fullDepth > Node[j].oldDepth && Node[j].oldDepth > 0.0 )
    {
        report_writeWarningMsg(WARN02, Node[j].ID);
    }

    // --- check that initial depth does not exceed max. depth
    if ( Node[j].initDepth > Node[j].fullDepth + Node[j].surDepth )
        report_writeErrorMsg(ERR_NODE_DEPTH, Node[j].ID);

    // --- check for negative volume for storage node at full depth            //(5.1.015)
    if (Node[j].type == STORAGE)                                               //
        if (node_getVolume(j, Node[j].fullDepth) < 0.0)                        //
            report_writeErrorMsg(ERR_STORAGE_VOLUME, Node[j].ID);              //

    if ( Node[j].type == DIVIDER ) divider_validate(j);

    // --- initialize dry weather inflows
    inflow = Node[j].dwfInflow;
    while (inflow)
    {
        ////////////////////////////////////
        returnObj = {inflow: inflow}
        returnVal = inflow_initDwfInflow(returnObj)
        inflow = returnObj.inflow;
        ////////////////////////////////////

        //inflow_initDwfInflow(inflow);
        inflow = inflow.next;
    }
}


//=============================================================================

node_initState(j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: initializes a node's state variables at start of simulation.
//
{
    let p, k;

    // --- initialize depth
    Node[j].oldDepth = Node[j].initDepth;
    Node[j].newDepth = Node[j].oldDepth;
    Node[j].crownElev = Node[j].invertElev;

    Node[j].fullVolume = node_getVolume(j, Node[j].fullDepth);
    Node[j].oldVolume = node_getVolume(j, Node[j].oldDepth);
    Node[j].newVolume = Node[j].oldVolume;

    // --- initialize water quality state
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        Node[j].oldQual[p]  = 0.0;
        Node[j].newQual[p]  = 0.0;
    }

    // --- initialize any inflow
    Node[j].oldLatFlow = 0.0;
    Node[j].newLatFlow = 0.0;
    Node[j].losses = 0.0;

    // --- initialize storage nodes
    if ( Node[j].type == STORAGE )
    {
        // --- set hydraulic residence time to 0
        k = Node[j].subIndex;
        Storage[k].hrt = 0.0;

        // --- initialize exfiltration properties
        if ( Storage[k].exfil ) exfil_initState(k);
    }

    // --- initialize flow stream routed from outfall onto a subcatchment
    if ( Node[j].type == OUTFALL )
    {
        k = Node[j].subIndex;
        if ( Outfall[k].routeTo >= 0 )
        {
            Outfall[k].vRouted = 0.0;
            for (p = 0; p < Nobjects[POLLUT]; p++) Outfall[k].wRouted[p] = 0.0;
        }
    }
}

//=============================================================================

node_setOldHydState(j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: replaces a node's old hydraulic state values with new ones.
//
{
    Node[j].oldDepth    = Node[j].newDepth;
    Node[j].oldVolume   = Node[j].newVolume;
}

//=============================================================================

node_setOldQualState(j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: replaces a node's old water quality state values with new ones.
//
{
    let p;
    for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        Node[j].oldQual[p] = Node[j].newQual[p];
        Node[j].newQual[p] = 0.0;
    }
}

//=============================================================================

node_initInflow(j, tStep)
//
//  Input:   j = node index
//           tStep = time step (sec)
//  Output:  none
//  Purpose: initializes a node's inflow at start of next time step.
//
{
    // --- initialize inflow & outflow
    Node[j].oldFlowInflow = Node[j].inflow;
    Node[j].oldNetInflow  = Node[j].inflow - Node[j].outflow;
    Node[j].inflow = Node[j].newLatFlow;
    Node[j].outflow = Node[j].losses;

    // --- set overflow to any excess stored volume
    if ( Node[j].newVolume > Node[j].fullVolume )
        Node[j].overflow = (Node[j].newVolume - Node[j].fullVolume) / tStep;
    else Node[j].overflow = 0.0;
}

//=============================================================================

node_getDepth(j, v)
//
//  Input:   j = node index
//           v = volume (ft3)
//  Output:  returns depth of water at a node (ft)
//  Purpose: computes a node's water depth from its volume.
//
{
    switch ( Node[j].type )
    {
      case STORAGE: return storage_getDepth(j, v);
      default:      return 0.0;
    }
}

//=============================================================================

node_getVolume(j, d)
//
//  Input:   j = node index
//           d = water depth (ft)
//  Output:  returns volume of water at a node (ft3)
//  Purpose: computes volume stored at a node from its water depth.
//
{
    switch ( Node[j].type )
    {
      case STORAGE: return storage_getVolume(j, d);

      default:
        if ( Node[j].fullDepth > 0.0 )
            return Node[j].fullVolume * (d / Node[j].fullDepth);
        else return 0.0;
    }
}

//=============================================================================

 node_getSurfArea(j, d)
//
//  Input:   j = node index
//           d = water depth (ft)
//  Output:  returns surface area of water at a node (ft2)
//  Purpose: computes surface area of water stored at a node from water depth.
//
{
    switch (Node[j].type)
    {
      case STORAGE: return storage_getSurfArea(j, d);
      default:      return 0.0;        
    }
}

//=============================================================================

node_getOutflow(j, k)
//
//  Input:   j = node index
//           k = link index
//  Output:  returns flow rate (cfs)
//  Purpose: computes outflow from node available for inflow into a link.
//
{
    switch ( Node[j].type )
    {
      case DIVIDER: return divider_getOutflow(j, k);
      case STORAGE: return storage_getOutflow(j, k);
      default:      return Node[j].inflow + Node[j].overflow;
    }
}

//=============================================================================

node_getMaxOutflow(j, q, tStep)
//
//  Input:   j = node index
//           q = original outflow rate (cfs)
//           tStep = time step (sec)
//  Output:  returns modified flow rate (cfs)
//  Purpose: limits outflow rate from a node with storage volume.
//
{
    let qMax;
    if ( Node[j].fullVolume > 0.0 )
    {
        qMax = Node[j].inflow + Node[j].oldVolume / tStep;
        if ( q > qMax ) q = qMax;
    }
    return MAX(0.0, q);
}

//=============================================================================
// This should be taking in isFlooded's parent 
node_getSystemOutflow(j, isFlooded)
//
//  Input:   j = node index
//           isFlooded = TRUE if node becomes flooded
//  Output:  returns flow rate lost from system (cfs)
//  Purpose: computes flow rate at outfalls and flooded nodes.
//
{
    let outflow = 0.0;;

    // --- assume there is no flooding
    isFlooded = FALSE;

    // --- if node is an outfall
    if ( Node[j].type == OUTFALL )
    {
        // --- node receives inflow from outfall conduit
        if ( Node[j].outflow == 0.0 ) outflow = Node[j].inflow;

        // --- node sends flow into outfall conduit
        //     (therefore it has a negative outflow)
        else
        {
            if ( Node[j].inflow == 0.0 )
            {
                outflow = -Node[j].outflow;
                Node[j].inflow = Math.abs(outflow);
            }
        }

        // --- set overflow and volume to 0
        Node[j].overflow = 0.0;
        Node[j].newVolume = 0.0;
    }

    // --- node is a terminal node under Steady or Kin. Wave routing
    else if ( RouteModel != DW &&
              Node[j].degree == 0 &&
              Node[j].type != STORAGE
            )
    {
        if ( Node[j].outflow == 0.0 ) outflow = Node[j].inflow;
        Node[j].overflow = 0.0;
        Node[j].newVolume = 0.0;
    }

    // --- otherwise node is an interior node and any
    //     overflow is considered as system outflow and flooding
    else 
    {
        if ( Node[j].newVolume <= Node[j].fullVolume)
            outflow = Node[j].overflow;
        if ( outflow > 0.0 ) isFlooded = TRUE;
    }
    return outflow;
}

//=============================================================================

node_getResults(j, f, x)
//
//  Input:   j = node index
//           f = weighting factor
//           x[] = array of nodal reporting variables
//  Output:  none
//  Purpose: computes weighted average of old and new results at a node.
//
{
    let p;
    let z;
    let f1 = 1.0 - f;

    z = (f1 * Node[j].oldDepth + f * Node[j].newDepth) * UCF(LENGTH);
    x[NODE_DEPTH] = z;
    z = Node[j].invertElev * UCF(LENGTH);
    x[NODE_HEAD] = x[NODE_DEPTH] + z;
    z = (f1*Node[j].oldVolume + f*Node[j].newVolume) * UCF(VOLUME);
    x[NODE_VOLUME]  = z;
    z = (f1*Node[j].oldLatFlow + f*Node[j].newLatFlow) * UCF(FLOW); 
    x[NODE_LATFLOW] = z;
    z = (f1*Node[j].oldFlowInflow + f*Node[j].inflow) * UCF(FLOW);
    x[NODE_INFLOW] = z;
    z = Node[j].overflow * UCF(FLOW);
    x[NODE_OVERFLOW] = z;

    if ( !IgnoreQuality ) for (p = 0; p < Nobjects[POLLUT]; p++)
    {
        z = f1*Node[j].oldQual[p] + f*Node[j].newQual[p];
        x[NODE_QUAL+p] = z;
    }
}

//=============================================================================

  node_setOutletDepth(j, yNorm, yCrit, z)
//
//  Input:   j = node index
//           yNorm = normal flow depth (ft)
//           yCrit = critical flow depth (ft)
//           z = offset of connecting outfall link from node invert (ft)
//  Output:  none
//  Purpose: sets water depth at a node that serves as an outlet point.
//
{
    switch (Node[j].type)
    {
      // --- do nothing if outlet is a storage unit
      case STORAGE:
        return;

      // --- if outlet is a designated outfall then use outfall's specs
      case OUTFALL:
        outfall_setOutletDepth(j, yNorm, yCrit, z);
        break;

      // --- for all other nodes, use min. of critical & normal depths
      default:
        if ( z > 0.0 ) Node[j].newDepth = 0.0;
        else Node[j].newDepth = MIN(yNorm, yCrit);
    }
}

//=============================================================================

node_getPondedArea(j, d)
//
//  Input:   j = node index
//           d = water depth (ft)
//  Output:  returns surface area of water at a node (ft2)
//  Purpose: computes surface area of water at a node based on depth.
//
{
    let a;

    // --- use regular getSurfArea if node not flooded
    if ( d <= Node[j].fullDepth || Node[j].pondedArea == 0.0 )
    {
        return node_getSurfArea(j, d);
    }

    // --- compute ponded depth
    d = d - Node[j].fullDepth;

    // --- use ponded area for flooded node
    a = Node[j].pondedArea;
    if ( a <= 0.0 ) a = node_getSurfArea(j, Node[j].fullDepth);
    return a;
}

//=============================================================================

node_getLosses(j, tStep)
//
//  Input:   j = node index
//           tStep = time step (sec)
//  Output:  returns water loss rate at node (ft3)
//  Purpose: computes the rates of evaporation and infiltration over a given
//           time step for a node.
//
{
    if ( Node[j].type == STORAGE ) return storage_getLosses(j, tStep);
    else return 0.0;
}

//=============================================================================
//                   J U N C T I O N   M E T H O D S
//=============================================================================

junc_readParams(j, k, tok, ntoks)
//
//  Input:   j = node index
//           k = junction index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error message
//  Purpose: reads a junction's properties from a tokenized line of input.
//
//  Format of input line is:
//     nodeID  elev  maxDepth  initDepth  surDepth  aPond 
{
    let  i;
    let  x = new Array(6);
    let  id;

    // return facilitators
    let returnObj;
    let returnVal;

    if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(NODE, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);

    // --- parse invert elev., max. depth, init. depth, surcharged depth,
    //     & ponded area values
    for ( i = 1; i <= 5; i++ )
    {
        x[i-1] = 0.0;
        if ( i < ntoks )
        {
            ////////////////////////////////////
            returnObj = {y: x[i-1]}
            returnVal = getDouble(tok[i], returnObj);
            x[i-1] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal )
            //if ( null == (x[i-1] = getDouble(tok[i])) )
                return error_setInpError(ERR_NUMBER, tok[i]);
        }
    }

    // --- check for non-negative values (except for invert elev.)
    for ( i = 1; i <= 4; i++ )
    {
        if ( x[i] < 0.0 ) return error_setInpError(ERR_NUMBER, tok[i+1]);
    }

    // --- add parameters to junction object
    Node[j].ID = id;
    node_setParams(j, JUNCTION, k, x);
    return 0;
}

//=============================================================================
//                   S T O R A G E   M E T H O D S
//=============================================================================

storage_readParams(j, k, tok, ntoks)
//
//  Input:   j = node index
//           k = storage unit index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error message
//  Purpose: reads a storage unit's properties from a tokenized line of input.
//
//  Format of input line is:
//     nodeID  elev  maxDepth  initDepth  FUNCTIONAL a1 a2 a0 surDepth fEvap (infil) //(5.1.013)
//     nodeID  elev  maxDepth  initDepth  TABULAR    curveID  surDepth fEvap (infil) //
//
{
    let i, m, n;
    let x = new Array(9);
    let id;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- get ID name
    if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, '');
    id = project_findID(NODE, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);

    // --- get invert elev, max. depth, & init. depth
    for ( i = 1; i <= 3; i++ )
    {
        ////////////////////////////////////
        returnObj = {y: x[i-1]}
        returnVal = getDouble(tok[i], returnObj);
        x[i-1] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[i-1] = getDouble(tok[i])) )
            return error_setInpError(ERR_NUMBER, tok[i]);
    }

    // --- get surf. area relation type
    m = findmatch(tok[4], RelationWords);
    if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[4]);
    x[3] = 0.0;                        // a1 
    x[4] = 0.0;                        // a2
    x[5] = 0.0;                        // a0
    x[6] = -1.0;                       // curveID
    x[7] = 0.0;                        // aPond
    x[8] = 0.0;                        // fEvap

    // --- get surf. area coeffs.
    if ( m == FUNCTIONAL )
    {
        for (i=5; i<=7; i++)
        {
            if ( i < ntoks )
            {
                ////////////////////////////////////
                returnObj = {y: x[i-2]}
                returnVal = getDouble(tok[i], returnObj);
                x[i-2] = returnObj.y;
                ////////////////////////////////////
                if( !returnVal )
                //if ( null == (x[i-2] = getDouble(tok[i])) )
                    return error_setInpError(ERR_NUMBER, tok[i]);
            }
        }
        n = 8;
    }

    // --- get surf. area curve name
    else
    {
        m = project_findObject(CURVE, tok[5]);
        if ( m < 0 ) return error_setInpError(ERR_NAME, tok[5]);
        x[6] = m;
        n = 6;
    }

    // --- ponded area replaced by surcharge depth                             //(5.1.013)
    if ( ntoks > n)
    {
        ////////////////////////////////////
        returnObj = {y: x[7]}
        returnVal = getDouble(tok[n], returnObj);
        x[7] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[7] = getDouble(tok[n])) )
            return error_setInpError(ERR_NUMBER, tok[n]);
        n++;
    }

    // --- get evaporation fraction if present
    if ( ntoks > n )
    {
        ////////////////////////////////////
        returnObj = {y: x[8]}
        returnVal = getDouble(tok[n], returnObj);
        x[8] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[8] = getDouble(tok[n])) )
            return error_setInpError(ERR_NUMBER, tok[n]);
        n++;
    }

    // --- add parameters to storage unit object
    Node[j].ID = id;
    node_setParams(j, STORAGE, k, x);

    // --- read exfiltration parameters if present
    if ( ntoks > n ) return exfil_readStorageParams(k, tok, ntoks, n);
    return 0;
}

//=============================================================================

storage_getDepth(j, v)
//
//  Input:   j = node index
//           v = volume (ft3)
//  Output:  returns depth of water at a storage node (ft)
//  Purpose: computes a storage node's water depth from its volume.
//
{
    let k = Node[j].subIndex;
    let i = Storage[k].aCurve;
    let d, e;
    let storageVol = new TStorageVol();
    
    // ret facil
    let returnObj;
    let returnVal;

    // --- return max depth if a max. volume has been computed
    //     and volume is > max. volume
    if ( Node[j].fullVolume > 0.0
    &&   v >= Node[j].fullVolume ) return Node[j].fullDepth;
    if ( v == 0.0 ) return 0.0;

    // --- use tabular area v. depth curve
    if ( i >= 0 )
        return table_getInverseArea(Curve[i], v*UCF(VOLUME)) / UCF(LENGTH);

    // --- use functional area v. depth relation
    else
    {
        v *= UCF(VOLUME);
        if ( Storage[k].aExpon == 0.0 )
        {
            d = v / (Storage[k].a+ Storage[k].aCoeff);
        }
        else if ( Storage[k].a== 0.0 )
        {
            e = 1.0 / (Storage[k].aExpon + 1.0);
            d = Math.pow(v / (Storage[k].aCoeff * e), e);
        }
        else
        {
            storageVol.k = k;
            storageVol.v = v;
            d = v / (Storage[k].a+ Storage[k].aCoeff);
            ////////////////////////////////////
            returnObj = {rts: d, p: storageVol}
            returnVal = findroot_Newton(0.0, Node[j].fullDepth*UCF(LENGTH)
                            , returnObj, 0.001, storage_getVolDiff)
            d = returnObj.rts;
            storageVol = returnObj.p
            ////////////////////////////////////
            //findroot_Newton(0.0, Node[j].fullDepth*UCF(LENGTH), d,
            //                0.001, storage_getVolDiff, storageVol);            
        }
        d /= UCF(LENGTH);
        if ( d > Node[j].fullDepth ) d = Node[j].fullDepth;
        return d;
    }
}

//=============================================================================

 storage_getVolDiff(y, f, df, p)
//
//  Input:   y = depth of water (ft)
//  Output:  f = volume of water (ft3)
//           df = dVolume/dDepth (ft2)
//  Purpose: computes volume and its derivative with respect to depth
//           at storage node Kstar using the node's area versus depth function.
//
{
    let    k;
    let e, v;

    // ... cast void pointer p to a TStorageVol object
    k = p.k;

    // ... find storage volume at depth y
    e = Storage[k].aExpon + 1.0;
    v = Storage[k].a* y + Storage[k].aCoeff / e * Math.pow(y, e);

    // ... compute difference between this volume and target volume
    //     as well as its derivative w.r.t. y
    f = v - p.v;
    df = Storage[k].a+ Storage[k].aCoeff * Math.pow(y, e-1.0);
}

//=============================================================================

storage_getVolume(j, d)
//
//  Input:   j = node index
//           d = depth (ft)
//  Output:  returns volume of stored water (ft3)
//  Purpose: computes a storage node's water volume from its depth.
//
{
    let k = Node[j].subIndex;
    let i = Storage[k].aCurve;
    let v;

    // --- return full volume if depth >= max. depth
    if ( d == 0.0 ) return 0.0;
    if ( d >= Node[j].fullDepth
    &&   Node[j].fullVolume > 0.0 ) return Node[j].fullVolume;

    // --- use table integration if area v. depth table exists
    if ( i >= 0 )
      return table_getArea(Curve[i], d*UCF(LENGTH)) / UCF(VOLUME);

    // --- otherwise use functional area v. depth relation
    else
    {
        d *= UCF(LENGTH);
        v = Storage[k].a* d;
        v += Storage[k].aCoeff / (Storage[k].aExpon+1.0) *
        Math.pow(d, Storage[k].aExpon+1.0);
        return v / UCF(VOLUME);

    }
}

//=============================================================================

storage_getSurfArea(j, d)
//
//  Input:   j = node index
//           d = depth (ft)
//  Output:  returns surface area (ft2)
//  Purpose: computes a storage node's surface area from its water depth.
//
{
    let area;
    let k = Node[j].subIndex;
    let i = Storage[k].aCurve;
    if ( i >= 0 )
        area = table_lookupEx(Curve[i], d*UCF(LENGTH));
    else
    {
        if ( Storage[k].aCoeff <= 0.0 ) area = Storage[k].aConst;
        else if ( Storage[k].aExpon == 0.0 )
            area = Storage[k].a+ Storage[k].aCoeff;
        else area = Storage[k].a+ Storage[k].aCoeff *
                Math.pow(d*UCF(LENGTH), Storage[k].aExpon);
    }
    return area / UCF(LENGTH) / UCF(LENGTH);
}

//=============================================================================

storage_getOutflow(j, i)
//
//  Input:   j = node index
//           i = link index
//  Output:  returns flow from storage node into conduit link (cfs)
//  Purpose: finds outflow from a storage node into its connecting conduit link
//           ( non-conduit links have their own getInflow functions).
//
{
    let    k;
    let a, y;

    // --- link must be a conduit
    if ( Link[i].type != CONDUIT ) return 0.0;

    // --- find depth of water in conduit
    y = Node[j].newDepth - Link[i].offset1;

    // --- return 0 if conduit empty or full flow if full
    if ( y <= 0.0 ) return 0.0;
    if ( y >= Link[i].xsect.yFull ) return Link[i].qFull;

    // --- if partially full, return normal flow
    k = Link[i].subIndex;
    a = xsect_getAofY(Link[i].xsect, y);
    return Conduit[k].beta * xsect_getSofA(Link[i].xsect, a);
}

//=============================================================================

storage_getLosses(j, tStep)
//
//  Input:   j = node index
//           tStep = time step (sec)
//  Output:  returns evaporation + infiltration rate (cfs)
//  Purpose: computes combined rate of water evaporated & infiltrated from
//           a storage node.
//
{
    let k;
    let depth;
    let area;
    let evapRate = 0.0;
    let exfilRate = 0.0;
    let totalLoss = 0.0;
    let lossRatio;
    let exfil = new TExfil();

        // --- get node's evap. rate (ft/s) &  exfiltration object
        k = Node[j].subIndex;
        evapRate = Evap.rate * Storage[k].fEvap;
        exfil = Storage[k].exfil;

        // --- if either of these apply
        if ( evapRate > 0.0 || exfil != null) 
        {
            // --- obtain storage depth & surface area 
            depth = Node[j].newDepth;
            area = storage_getSurfArea(j, depth);

            // --- compute evap rate over this area (cfs)
            if (Node[j].newVolume > FUDGE)
                evapRate = area * evapRate;

            // --- find exfiltration rate (cfs) through bottom and side banks
            if ( exfil != null )
            {
                exfilRate = exfil_getLoss(exfil, tStep, depth, area);
            }

            // --- total loss over time step cannot exceed stored volume
            totalLoss = (evapRate + exfilRate) * tStep;
            if ( totalLoss > Node[j].newVolume )
            {
                lossRatio = Node[j].newVolume / totalLoss;
                evapRate *= lossRatio;
                exfilRate *= lossRatio; 
            }
        }
 
    // --- save evap & infil losses at the node
    Storage[Node[j].subIndex].evapLoss = evapRate * tStep;
    Storage[Node[j].subIndex].exfilLoss = exfilRate * tStep;
    return evapRate + exfilRate;
}

//=============================================================================
//                   D I V I D E R   M E T H O D S
//=============================================================================

divider_readParams(j, k, tok, ntoks)
//
//  Input:   j = node index
//           k = divider index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error message
//  Purpose: reads a flow divider's properties from a tokenized line of input.
//
//  Format of input line is:
//    nodeID  elev  divLink  TABULAR  curveID (optional params)
//    nodeID  elev  divLink  OVERFLOW (optional params)
//    nodeID  elev  divLink  CUTOFF  qCutoff (optional params)
//    nodeID  elev  divLink  WEIR    qMin  dhMax  cWeir (optional params)
//  where optional params are:
//    maxDepth  initDepth  surDepth  aPond    
//
{
    let i, m, m1, m2, n;
    let x = new Array(11);
    let id;

    // return facilitators
    let returnObj;
    let returnVal;

    // --- get ID name
    if ( ntoks < 4 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(NODE, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);

    // --- get invert elev.
    ////////////////////////////////////
    returnObj = {y: x[0]}
    returnVal = getDouble(tok[1], returnObj);
    x[0] = returnObj.y;
    ////////////////////////////////////
    if( !returnVal )
    //if ( null == (x[0] = getDouble(tok[1])) ) 
        return error_setInpError(ERR_NUMBER, tok[1]);

    // --- initialize parameter values
    for ( i=1; i<11; i++) x[i] = 0.0;

    // --- check if no diverted link supplied
    if ( tok[2].length == 0 || strcmp(tok[2], "*") == 0 ) x[1] = -1.0;

    // --- otherwise get index of diverted link
    else
    {
        m1 = project_findObject(LINK, tok[2]);
        if ( m1 < 0 ) return error_setInpError(ERR_NAME, tok[2]);
        x[1] = m1;
    }
    
    // --- get divider type
	n = 4;
    m1 = findmatch(tok[3], DividerTypeWords);
    if ( m1 < 0 ) return error_setInpError(ERR_KEYWORD, tok[3]);
    x[2] = m1;

    // --- get index of flow diversion curve for Tabular divider
    x[3] = -1;
    if ( m1 == TABULAR_DIVIDER )
    {
        if ( ntoks < 5 ) return error_setInpError(ERR_ITEMS, "");
        m2 = project_findObject(CURVE, tok[4]);
        if ( m2 < 0 ) return error_setInpError(ERR_NAME, tok[4]);
        x[3] = m2;
        n = 5;
    }

    // --- get cutoff flow for Cutoff divider
    if ( m1 == CUTOFF_DIVIDER )
    {
        if ( ntoks < 5 ) return error_setInpError(ERR_ITEMS, "");
        ////////////////////////////////////
        returnObj = {y: x[4]}
        returnVal = getDouble(tok[4], returnObj);
        x[4] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[4] = getDouble(tok[4])) )
            return error_setInpError(ERR_NUMBER, tok[4]);
        n = 5;
    }

    // --- get qmin, dhMax, & cWeir for Weir divider
    if ( m1 == WEIR_DIVIDER )
    {
        if ( ntoks < 7 ) return error_setInpError(ERR_ITEMS, "");
        for (i=4; i<7; i++){
            ////////////////////////////////////
            returnObj = {y: x[i]}
            returnVal = getDouble(tok[i], returnObj);
            x[i] = returnObj.y;
            ////////////////////////////////////
            if( !returnVal )
            //if ( null == (x[i] = getDouble(tok[i])) )
                return error_setInpError(ERR_NUMBER, tok[i]);
        }
        n = 7;
    }

    // --- no parameters needed for Overflow divider
    if ( m1 == OVERFLOW_DIVIDER ) n = 4;

    // --- retrieve optional full depth, init. depth, surcharged depth
    //      & ponded area
    m = 7;
    for (i=n; i<ntoks && m<11; i++)
    {
        ////////////////////////////////////
        returnObj = {y: x[m]}
        returnVal = getDouble(tok[i], returnObj);
        x[m] = returnObj.y;
        ////////////////////////////////////
        if( !returnVal )
        //if ( null == (x[m] = getDouble(tok[i])) )
        {
            return error_setInpError(ERR_NUMBER, tok[i]);
        }
        m++;
    }
 
    // --- add parameters to data base
    Node[j].ID = id;
    node_setParams(j, DIVIDER, k, x);
    return 0;
}

//=============================================================================

 divider_validate(j)
//
//  Input:   j = node index
//  Output:  none
//  Purpose: validates a flow divider's properties.
//
{
    let i, k;

    // --- check that diverted link is attached to divider
    k = Node[j].subIndex;
    i = Divider[k].link;
    if ( i < 0 || ( Link[i].node1 != j && Link[i].node2 != j) )
    {
        report_writeErrorMsg(ERR_DIVIDER_LINK, Node[j].ID);
    }

    // --- validate parameters supplied for weir-type divider
    if ( Divider[k].type == WEIR_DIVIDER )
    {
        if ( Divider[k].dhMax <= 0.0 || Divider[k].cWeir <= 0.0 )
            report_writeErrorMsg(ERR_WEIR_DIVIDER, Node[j].ID);
        else
        {
            // --- find flow when weir is full
            Divider[k].qMax = Divider[k].cWeir * Math.pow(Divider[k].dhMax, 1.5)
                              / UCF(FLOW);
            if ( Divider[k].qMin > Divider[k].qMax )
                report_writeErrorMsg(ERR_WEIR_DIVIDER, Node[j].ID);
        }
    }
}

//=============================================================================

divider_getOutflow(j, k)
//
//  Input:   j = node index
//           k = index of diversion link
//  Output:  returns diverted flow rate (cfs)
//  Purpose: computes flow sent through divider node into its diversion link.
//
//  NOTE: requires that links be previously sorted so that the non-diversion
//        link always gets evaluated before the diversion link
{
    let i;                      // index of divider node
    let m;                      // index of diverted flow table
    let qIn;                    // inflow to divider
    let qOut;                   // diverted outflow
    let f;                      // fraction of weir divider full

    qIn = Node[j].inflow + Node[j].overflow;
    i = Node[j].subIndex;
    switch ( Divider[i].type )
    {
      case CUTOFF_DIVIDER:
        if ( qIn <= Divider[i].qMin ) qOut = 0.0;
        else qOut = qIn - Divider[i].qMin;
        break;

      case OVERFLOW_DIVIDER:
        // --- outflow sent into non-diversion link is simply node's inflow
        if ( k != Divider[i].link ) qOut = qIn;

        // --- diversion link receives any excess of node's inflow and
        //     outflow sent previously into non-diversion link
        else qOut = qIn - Node[j].outflow;
        if ( qOut < FLOW_TOL ) qOut = 0.0;
        return qOut;

      case WEIR_DIVIDER:
        // --- no flow if inflow < qMin
        if ( qIn <= Divider[i].qMin ) qOut = 0.0;

        // --- otherwise use weir eqn.
        else
        {
            // --- find fractional depth of flow over weir
            f = (qIn - Divider[i].qMin) /
                (Divider[i].qMax - Divider[i].qMin);

            // --- if weir surcharged, use orifice eqn.
            if ( f > 1.0 ) qOut = Divider[i].qMax * Math.sqrt(f);
            
            // --- otherwise use weir eqn.
            else qOut = Divider[i].cWeir *
                    Math.pow(f*Divider[i].dhMax, 1.5) / UCF(FLOW);
        }
        break;

      case TABULAR_DIVIDER:
        m = Divider[i].flowCurve;
        if ( m >= 0 )
            qOut = table_lookup(Curve[m], qIn * UCF(FLOW)) / UCF(FLOW);
        else qOut = 0.0;
        break;

      default: qOut = 0.0;
    }

    // --- make sure outflow doesn't exceed inflow
    if ( qOut > qIn ) qOut = qIn;

    // --- if link k not the diversion link, then re-define qOut as 
    //     the undiverted flow
    if ( k != Divider[i].link )
    {
        qOut = qIn - qOut;
    }
    return qOut;
}


//=============================================================================
//                    O U T F A L L   M E T H O D S
//=============================================================================

outfall_readParams(j, k, tok, ntoks)
//
//  Input:   j = node index
//           k = outfall index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error message
//  Purpose: reads an outfall's properties from a tokenized line of input.
//
//  Format of input line is:
//    nodeID  elev  FIXED  fixedStage (flapGate) (routeTo)
//    nodeID  elev  TIDAL  curveID (flapGate) (routeTo)
//    nodeID  elev  TIMESERIES  tseriesID (flapGate) (routTo)
//    nodeID  elev  FREE (flapGate) (routeTo)
//    nodeID  elev  NORMAL (flapGate) (routeTo)
//
{
    let i, m, n;
    let x = new Array(7);
    let id;

    // return facilitators
    let returnObj;
    let returnVal;

    if ( ntoks < 3 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(NODE, tok[0]);                      // node ID
    if ( id == null )
        return error_setInpError(ERR_NAME, tok[0]);

    ////////////////////////////////////
    returnObj = {y: x[0]}
    returnVal = getDouble(tok[1], returnObj);
    x[0] = returnObj.y;
    ////////////////////////////////////
    if( !returnVal )
    //if ( null == (x[0] = getDouble(tok[1])) )                       // invert elev. 
        return error_setInpError(ERR_NUMBER, tok[1]);
    i = findmatch(tok[2], OutfallTypeWords);               // outfall type
    if ( i < 0 ) return error_setInpError(ERR_KEYWORD, tok[2]);
    x[1] = i;                                              // outfall type
    x[2] = 0.0;                                            // fixed stage
    x[3] = -1.;                                            // tidal curve
    x[4] = -1.;                                            // tide series
    x[5] = 0.;                                             // flap gate
    x[6] = -1.;                                            // route to subcatch//(5.1.008)

    n = 4;
    if ( i >= FIXED_OUTFALL )
    {
        if ( ntoks < 4 ) return error_setInpError(ERR_ITEMS, "");
        n = 5;
        switch ( i )
        {
        case FIXED_OUTFALL:                                // fixed stage
          ////////////////////////////////////
          returnObj = {y: x[2]}
          returnVal = getDouble(tok[3], returnObj);
          x[2] = returnObj.y;
          ////////////////////////////////////
          if( !returnVal )
          //if ( null == (x[2] = getDouble(tok[3])) )
              return error_setInpError(ERR_NUMBER, tok[3]);
          break;
        case TIDAL_OUTFALL:                                // tidal curve
          m = project_findObject(CURVE, tok[3]);              
          if ( m < 0 ) return error_setInpError(ERR_NAME, tok[3]);
          x[3] = m;
          break;
        case TIMESERIES_OUTFALL:                           // stage time series
          m = project_findObject(TSERIES, tok[3]);            
          if ( m < 0 ) return error_setInpError(ERR_NAME, tok[3]);
          x[4] = m;
          Tseries[m].refersTo = TIMESERIES_OUTFALL;
        }
    }
    if ( ntoks == n )
    {
        m = findmatch(tok[n-1], NoYesWords);               // flap gate
        if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[n-1]);
        x[5] = m;
    }

    if ( ntoks == n+1)
    {
        m = project_findObject(SUBCATCH, tok[n]);
        if ( m < 0 ) return error_setInpError(ERR_NAME, tok[n]);
        x[6] = m;
    }

    Node[j].ID = id;
    node_setParams(j, OUTFALL, k, x);
    return 0;
}

//=============================================================================

outfall_setOutletDepth(j, yNorm, yCrit, z)
//
//  Input:   j = node index
//           yNorm = normal flow depth in outfall conduit (ft)
//           yCrit = critical flow depth in outfall conduit (ft)
//           z = height to outfall conduit invert (ft)
//  Output:  none
//  Purpose: sets water depth at an outfall node.
//
{
    let x, y;                     // x,y values in table
    let yNew;                     // new depth above invert elev. (ft)
    let stage;                    // water elevation at outfall (ft)
    let k;                        // table index
    let i = Node[j].subIndex;     // outfall index
    let currentDate = new Date();              // current date/time in days

    // ret facil
    let returnObj;
    let returnVal;

    switch ( Outfall[i].type )
    {
      case FREE_OUTFALL:
        if ( z > 0.0 ) Node[j].newDepth = 0.0;
        else Node[j].newDepth = MIN(yNorm, yCrit);
        return;

      case NORMAL_OUTFALL:
        if ( z > 0.0 ) Node[j].newDepth = 0.0;
        else Node[j].newDepth = yNorm;
        return;

      case FIXED_OUTFALL:
        stage = Outfall[i].fixedStage;
        break;

      case TIDAL_OUTFALL:
        k = Outfall[i].tideCurve;

        ////////////////////////////////////
        returnObj = {x: x, y: y}
        returnVal = table_getFirstEntry(Curve[k], returnObj)
        x = returnObj.x;
        y = returnObj.y;
        ////////////////////////////////////
        //table_getFirstEntry(Curve[k], x, y);
        currentDate = NewRoutingTime / MSECperDAY;
        x += ( currentDate - Math.floor(currentDate) ) * 24.0;
        stage = table_lookup(Curve[k], x) / UCF(LENGTH);
        break;

      case TIMESERIES_OUTFALL:
        k = Outfall[i].stageSeries;
        currentDate = StartDateTime + NewRoutingTime / MSECperDAY;
        ////////////////////////////////////
        returnObj = {table: Tseries[k]}
        returnVal = table_tseriesLookup(returnObj, currentDate, true);
        Tseries[k] = returnObj.table;
        ////////////////////////////////////
        stage = returnVal / UCF(LENGTH);
        //stage = table_tseriesLookup(Tseries[k], currentDate, true) / UCF(LENGTH);
        break;
      default: stage = Node[j].invertElev;
    }

    // --- now determine depth at node given outfall stage elev.
 
    // --- let critical flow depth be min. of critical & normal depth
    yCrit = MIN(yCrit, yNorm);

    // --- if elev. of critical depth is below outfall stage elev. then
    //     the outfall stage determines node depth
    if ( yCrit + z + Node[j].invertElev < stage )
    {
        yNew = stage - Node[j].invertElev;
    }

    // --- otherwise if the outfall conduit lies above the outfall invert
    else if ( z > 0.0 )
    {
        // --- if the outfall stage lies below the bottom of the outfall
        //     conduit then the result is distance from node invert to stage
        if ( stage < Node[j].invertElev + z )
            yNew = MAX(0.0, (stage - Node[j].invertElev));

        // --- otherwise stage lies between bottom of conduit and critical
        //     depth in conduit so result is elev. of critical depth
        else yNew = z + yCrit;
    }

    // --- and for case where there is no conduit offset and outfall stage
    //     lies below critical depth, then node depth = critical depth 
    else yNew = yCrit;
    Node[j].newDepth = yNew;
}

//=============================================================================


//-----------------------------------------------------------------------------
//   iface.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/14   (Build 5.1.001)
//   Author:   L. Rossman
//
//   Routing interface file functions.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Imported variables
//-----------------------------------------------------------------------------
//Qcf = [];                   // flow units conversion factors
                                       // (see swmm5.c)

//-----------------------------------------------------------------------------                  
//  Shared variables
//-----------------------------------------------------------------------------                  
     IfaceFlowUnits;        // flow units for routing interface file
     IfaceStep;             // interface file time step (sec)
     NumIfacePolluts;       // number of pollutants in interface file
    IfacePolluts = [];          // indexes of interface file pollutants
     NumIfaceNodes;         // number of nodes on interface file
    IfaceNodes = [];            // indexes of nodes on interface file
OldIfaceValues = [];        // interface flows & WQ at previous time
NewIfaceValues = [];        // interface flows & WQ at next time
  IfaceFrac;             // fraction of interface file time step
OldIfaceDate;          // previous date of interface values
NewIfaceDate;          // next date of interface values

//-----------------------------------------------------------------------------
//  External Functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  iface_readFileParams     (called by input_readLine)
//  iface_openRoutingFiles   (called by routing_open)
//  iface_closeRoutingFiles  (called by routing_close)
//  iface_getNumIfaceNodes   (called by addIfaceInflows in routing.c)
//  iface_getIfaceNode       (called by addIfaceInflows in routing.c)
//  iface_getIfaceFlow       (called by addIfaceInflows in routing.c)
//  iface_getIfaceQual       (called by addIfaceInflows in routing.c)
//  iface_saveOutletResults  (called by output_saveResults)


//=============================================================================
// char* tok[], int ntoks
iface_readFileParams(tok, ntoks)
//
//  Input:   tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads interface file information from a line of input data.
//
//  Data format is:
//  USE/SAVE  FileType  FileName
//
{
    let  k;
    let  j;

    // --- determine file disposition and type
    if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
    k = findmatch(tok[0], FileModeWords);
    if ( k < 0 ) return error_setInpError(ERR_KEYWORD, tok[0]);
    j = findmatch(tok[1], FileTypeWords);
    if ( j < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);
    if ( ntoks < 3 ) return 0;

    // --- process file name
    switch ( j )
    {
      case RAINFALL_FILE:
        Frain.mode = k;
        sstrncpy(Frain.name, tok[2], MAXFNAME);
        break;

      case RUNOFF_FILE:
        Frunoff.mode = k;
        sstrncpy(Frunoff.name, tok[2], MAXFNAME);
        break;

      case HOTSTART_FILE:
        if ( k == USE_FILE )
        {
            Fhotstart1.mode = k;
            sstrncpy(Fhotstart1.name, tok[2], MAXFNAME);
        }
        else if ( k == SAVE_FILE )
        {
            Fhotstart2.mode = k;
            sstrncpy(Fhotstart2.name, tok[2], MAXFNAME);
        }
        break;

      case RDII_FILE:
        Frdii.mode = k;
        sstrncpy(Frdii.name, tok[2], MAXFNAME);
        break;

      case INFLOWS_FILE:
        if ( k != USE_FILE ) return error_setInpError(ERR_ITEMS, "");
        Finflows.mode = k;
        sstrncpy(Finflows.name, tok[2], MAXFNAME);
        break;

      case OUTFLOWS_FILE:
        if ( k != SAVE_FILE ) return error_setInpError(ERR_ITEMS, "");
        Foutflows.mode = k;
        sstrncpy(Foutflows.name, tok[2], MAXFNAME);
        break;
    }
    return 0;
}

//=============================================================================

iface_openRoutingFiles()
//
//  Input:   none
//  Output:  none
//  Purpose: opens routing interface files.
//
{
    // --- initialize shared variables
    NumIfacePolluts = 0;
    IfacePolluts = null;
    NumIfaceNodes = 0;
    IfaceNodes = null;
    OldIfaceValues = null;
    NewIfaceValues = null;

    // --- check that inflows & outflows files are not the same
    if ( Foutflows.mode != NO_FILE && Finflows.mode != NO_FILE )
    {
        if ( strcomp(Foutflows.name, Finflows.name) )
        {
            report_writeErrorMsg(ERR_ROUTING_FILE_NAMES, "");
            return;
        }
    }

    // --- open the file for reading or writing
    if ( Foutflows.mode == SAVE_FILE ) openFileForOutput();
    if ( Finflows.mode == USE_FILE ) openFileForInput();
}

//=============================================================================

iface_closeRoutingFiles()
//
//  Input:   none
//  Output:  none
//  Purpose: closes routing interface files.
//
{
    FREE(IfacePolluts);
    FREE(IfaceNodes);
    if ( OldIfaceValues != null ) project_freeMatrix(OldIfaceValues);
    if ( NewIfaceValues != null ) project_freeMatrix(NewIfaceValues);
    if ( Finflows.file )  fclose(Finflows.file);
    if ( Foutflows.file ) fclose(Foutflows.file);
}

//=============================================================================
// DateTime currentDate
iface_getNumIfaceNodes(currentDate)
//
//  Input:   currentDate = current date/time
//  Output:  returns number of interface nodes if data exists or
//           0 otherwise
//  Purpose: reads inflow data from interface file at current date.
//
{
    // --- return 0 if file begins after current date
    if ( OldIfaceDate > currentDate ) return 0;

    // --- keep updating new interface values until current date bracketed
    while ( NewIfaceDate < currentDate && NewIfaceDate != NO_DATE )
    {
        setOldIfaceValues();
        readNewIfaceValues();
    }

    // --- return 0 if no data available
    if ( NewIfaceDate == NO_DATE ) return 0;

    // --- find fraction current date is bewteen old & new interface dates
    IfaceFrac = (currentDate - OldIfaceDate) / (NewIfaceDate - OldIfaceDate);
    IfaceFrac = MAX(0.0, IfaceFrac);
    IfaceFrac = MIN(IfaceFrac, 1.0);

    // --- return number of interface nodes
    return NumIfaceNodes;
}

//=============================================================================
// int index
iface_getIfaceNode(index)
//
//  Input:   index = interface file node index
//  Output:  returns project node index
//  Purpose: finds index of project node associated with interface node index
//
{
    if ( index >= 0 && index < NumIfaceNodes ) return IfaceNodes[index];
    else return -1;
}

//=============================================================================
// int index
iface_getIfaceFlow(index)
//
//  Input:   index = interface file node index
//  Output:  returns inflow to node
//  Purpose: finds interface flow for particular node index.
//
{
    let q1, q2;

    if ( index >= 0 && index < NumIfaceNodes )
    {
        // --- interpolate flow between old and new values
        q1 = OldIfaceValues[index][0];
        q2 = NewIfaceValues[index][0];
        return (1.0 - IfaceFrac)*q1 + IfaceFrac*q2;
    }
    else return 0.0;
}

//=============================================================================
// int index, int pollut
iface_getIfaceQual(index,  pollut)
//
//  Input:   index = index of node on interface file
//           pollut = index of pollutant on interface file
//  Output:  returns inflow pollutant concentration
//  Purpose: finds interface concentration for particular node index & pollutant.
//
{
    let    j;
    let c1, c2;

    if ( index >= 0 && index < NumIfaceNodes )
    {
        // --- find index of pollut on interface file
        j = IfacePolluts[pollut];
        if ( j < 0 ) return 0.0;

        // --- interpolate flow between old and new values
        //     (remember that 1st col. of values matrix is for flow)
        c1 = OldIfaceValues[index][j+1];
        c2 = NewIfaceValues[index][j+1];
        return (1.0 - IfaceFrac)*c1 + IfaceFrac*c2;
    }
    else return 0.0;
}

//=============================================================================
// DateTime reportDate, FILE* file
iface_saveOutletResults(reportDate, file)
//
//  Input:   reportDate = reporting date/time
//           file = ptr. to interface file
//  Output:  none
//  Purpose: saves system outflows to routing interface file.
//
{
    let i, p, yr, mon, day, hr, min, sec;
    let theDate; // char[25]
    let returnObj;
    //datetime_decodeDate(reportDate, yr, mon, day);
    ////////////////////////////////////
    returnObj = {year: yr, month: mon, day: day}
    datetime_decodeDate(reportDate, returnObj);
    yr = returnObj.year;
    mon = returnObj.month;
    day = returnObj.day;
    ////////////////////////////////////
    //datetime_decodeTime(reportDate, hr, min, sec);
    ////////////////////////////////////
    returnObj = {h: hr, min: m, s: sec}
    datetime_decodeTime(reportDate, returnObj);
    hr = returnObj.h;
    min = returnObj.m;
    sec = returnObj.s;
    ////////////////////////////////////

    let val1 = yr.toString().padStart(4, '0')
    let val2 = mon.toString().padStart(2, '0')
    let val3 = day.toString().padStart(2, '0')
    let val4 = hr.toString().padStart(2, '0')
    let val5 = min.toString().padStart(2, '0')
    let val6 = sec.toString().padStart(2, '0')
    theDate = ` ${val1} ${val2}  ${val3}  ${val4}  ${val5}  ${val6} `;
    for (i=0; i<Nobjects[NODE]; i++)
    {
        // --- check that node is an outlet node
        if ( !isOutletNode(i) ) continue;

        // --- write node ID, date, flow, and quality to file
        fprintf(file, "\n%-16s", Node[i].ID);
        fprintf(file, "%s", theDate);
        fprintf(file, " %-10f", Node[i].inflow * UCF(FLOW));
        for ( p = 0; p < Nobjects[POLLUT]; p++ )
        {
            fprintf(file, " %-10f", Node[i].newQual[p]);
        }
    }
}

//=============================================================================

openFileForOutput()
//
//  Input:   none
//  Output:  none
//  Purpose: opens a routing interface file for writing.
//
{
    let i, n;

    // --- open the routing file for writing text
    Foutflows.file = fopen(Foutflows.name, "wt");
    if ( Foutflows.file == null )
    {
        report_writeErrorMsg(ERR_ROUTING_FILE_OPEN, Foutflows.name);
        return;
    }

    // --- write title & reporting time step to file
    fprintf(Foutflows.file, "SWMM5 Interface File");
    fprintf(Foutflows.file, "\n%s", Title[0]);
    fprintf(Foutflows.file, "\n%-4d - reporting time step in sec", ReportStep);

    // --- write number & names of each constituent (including flow) to file
    fprintf(Foutflows.file, "\n%-4d - number of constituents as listed below:",
            Nobjects[POLLUT] + 1);
    fprintf(Foutflows.file, "\nFLOW %s", FlowUnitWords[FlowUnits]);
    for (i=0; i<Nobjects[POLLUT]; i++)
    {
        fprintf(Foutflows.file, "\n%s %s", Pollut[i].ID,
            QualUnitsWords[Pollut[i].units]);
    }

    // --- count number of outlet nodes
    n = 0;
    for (i=0; i<Nobjects[NODE]; i++)
    {
        if ( isOutletNode(i) ) n++;
    }

    // --- write number and names of outlet nodes to file
    fprintf(Foutflows.file, "\n%-4d - number of nodes as listed below:", n);
    for (i=0; i<Nobjects[NODE]; i++)
    {
          if ( isOutletNode(i) )
            fprintf(Foutflows.file, "\n%s", Node[i].ID);
    }

    // --- write column headings
    fprintf(Foutflows.file,
        "\nNode             Year Mon Day Hr  Min Sec FLOW      ");
    for (i=0; i<Nobjects[POLLUT]; i++)
    {
        fprintf(Foutflows.file, " %-10s", Pollut[i].ID);
    }

    // --- if reporting starts immediately, save initial outlet values
    if ( ReportStart == StartDateTime )
    {
        iface_saveOutletResults(ReportStart, Foutflows.file);
    }
}

//=============================================================================

openFileForInput()
//
//  Input:   none
//  Output:  none
//  Purpose: opens a routing interface file for reading.
//
{
    let   err;                         // error code
    let  line;             // line from Routing interface file
    let  s;                // general string variable

    // --- open the routing interface file for reading text
    Finflows.file = fopen(Finflows.name, "rt");
    if ( Finflows.file == null )
    {
        report_writeErrorMsg(ERR_ROUTING_FILE_OPEN, Finflows.name);
        return;
    }

    // --- check for correct file type
    fgets(line, MAXLINE, Finflows.file);
    sscanf(line, "%s", s);
    if ( !strcomp(s, "SWMM5") )
    {
        report_writeErrorMsg(ERR_ROUTING_FILE_FORMAT, Finflows.name);
        return;
    }

    // --- skip title line
    fgets(line, MAXLINE, Finflows.file);

    // --- read reporting time step (sec)
    IfaceStep = 0;
    fgets(line, MAXLINE, Finflows.file);
    sscanf(line, "%d", IfaceStep);
    if ( IfaceStep <= 0 )
    {
        report_writeErrorMsg(ERR_ROUTING_FILE_FORMAT, Finflows.name);
        return;
    }

    // --- match constituents in file with those in project
    err = getIfaceFilePolluts();
    if ( err > 0 )
    {
        report_writeErrorMsg(err, Finflows.name);
        return;
    }

    // --- match nodes in file with those in project
    err = getIfaceFileNodes();
    if ( err > 0 )
    {
        report_writeErrorMsg(err, Finflows.name);
        return;
    }

    // --- create matrices for old & new interface flows & WQ values
    OldIfaceValues = project_createMatrix(NumIfaceNodes,
                                         1+NumIfacePolluts);
    NewIfaceValues = project_createMatrix(NumIfaceNodes,
                                         1+NumIfacePolluts);
    if ( OldIfaceValues == null || NewIfaceValues == null )
    {
        report_writeErrorMsg(ERR_MEMORY, "");
        return;
    }

    // --- read in new interface flows & WQ values
    readNewIfaceValues();
    OldIfaceDate = NewIfaceDate;
}

//=============================================================================

 getIfaceFilePolluts()
//
//  Input:   none
//  Output:  returns an error code
//  Purpose: reads names of pollutants saved on the inflows interface file.
//
{
    let   i, j;
    let  line;             // line from inflows interface file
    let  s1;               // general string variable
    let  s2;         

    // --- read number of pollutants (minus FLOW)
    fgets(line, MAXLINE, Finflows.file);
    sscanf(line, "%d", NumIfacePolluts);
    NumIfacePolluts--;
    if ( NumIfacePolluts < 0 ) return ERR_ROUTING_FILE_FORMAT;

    // --- read flow units
    fgets(line, MAXLINE, Finflows.file);
    sscanf(line, "%s %s", s1, s2);
    if ( !strcomp(s1, "FLOW") )  return ERR_ROUTING_FILE_FORMAT;
    IfaceFlowUnits = findmatch(s2, FlowUnitWords);
    if ( IfaceFlowUnits < 0 ) return ERR_ROUTING_FILE_FORMAT;

    // --- allocate memory for pollutant index array
    if ( Nobjects[POLLUT] > 0 )
    {
        //IfacePolluts = (int *) calloc(Nobjects[POLLUT], sizeof(int));
        IfacePolluts = new Array(Nobjects[POLLUT])
        if ( !IfacePolluts ) return ERR_MEMORY;
        for (i=0; i<Nobjects[POLLUT]; i++) IfacePolluts[i] = -1;
    }

    // --- read pollutant names & units
    if ( NumIfacePolluts > 0 )
    {
        // --- check each pollutant name on file with project's pollutants
        for (i=0; i<NumIfacePolluts; i++)
        {
            if ( feof(Finflows.file) ) return ERR_ROUTING_FILE_FORMAT;
            fgets(line, MAXLINE, Finflows.file);
            sscanf(line, "%s %s", s1, s2);
            if ( Nobjects[POLLUT] > 0 )
            {
                j = project_findObject(POLLUT, s1);
                if ( j < 0 ) continue;
                if ( !strcomp(s2, QualUnitsWords[Pollut[j].units]) )
                    return ERR_ROUTING_FILE_NOMATCH;
                IfacePolluts[j] = i;
            }
        }
    }
    return 0;
}

//=============================================================================

getIfaceFileNodes()
//
//  Input:   none
//  Output:  returns an error code
//  Purpose: reads names of nodes contained on inflows interface file.
//
{
    let   i;
    let  line;             // line from inflows interface file
    let  s;                // general string variable

    // --- read number of interface nodes
    fgets(line, MAXLINE, Finflows.file);
    sscanf(line, "%d", NumIfaceNodes);
    if ( NumIfaceNodes <= 0 ) return ERR_ROUTING_FILE_FORMAT;

    // --- allocate memory for interface nodes index array
    //IfaceNodes = (int *) calloc(NumIfaceNodes, sizeof(int));
    IfaceNodes = new Array(NumIfaceNodes);
    if ( !IfaceNodes ) return ERR_MEMORY;

    // --- read names of interface nodes from file & save their indexes
    for ( i=0; i<NumIfaceNodes; i++ )
    {
        if ( feof(Finflows.file) ) return ERR_ROUTING_FILE_FORMAT;
        fgets(line, MAXLINE, Finflows.file);
        sscanf(line, "%s", s);
        IfaceNodes[i] = project_findObject(NODE, s);
    }

    // --- skip over column headings line
    if ( feof(Finflows.file) ) return ERR_ROUTING_FILE_FORMAT;
    fgets(line, MAXLINE, Finflows.file);
    return 0;
}

//=============================================================================

readNewIfaceValues()
//
//  Input:   none
//  Output:  none
//  Purpose: reads data from inflows interface file for next date.
//
{
    let    i, j;
    let  s;
    let    yr = 0, mon = 0, day = 0,
		   hr = 0, min = 0, sec = 0;   // year, month, day, hour, minute, second
    let   line;            // line from interface file

    // --- read a line for each interface node
    NewIfaceDate = NO_DATE;
    for (i=0; i<NumIfaceNodes; i++)
    {
        if ( feof(Finflows.file) ) return;
        fgets(line, MAXLINE, Finflows.file);

        // --- parse date & time from line
        if ( strtok(line, SEPSTR) == null ) return;
        s = strtok(null, SEPSTR);
        if ( s == null ) return;
        yr  = atoi(s);
        s = strtok(null, SEPSTR);
        if ( s == null ) return;
        mon = atoi(s);
        s = strtok(null, SEPSTR);
        if ( s == null ) return;
        day = atoi(s);
        s = strtok(null, SEPSTR);
        if ( s == null ) return;
        hr  = atoi(s);
        s = strtok(null, SEPSTR);
        if ( s == null ) return;
        min = atoi(s);
        s = strtok(null, SEPSTR);
        if ( s == null ) return;
        sec = atoi(s);

        // --- parse flow value
        s = strtok(null, SEPSTR);
        if ( s == null ) return;
        NewIfaceValues[i][0] = atof(s) / Qcf[IfaceFlowUnits]; 

        // --- parse pollutant values
        for (j=1; j<=NumIfacePolluts; j++)
        {
            s = strtok(null, SEPSTR);
            if ( s == null ) return;
            NewIfaceValues[i][j] = atof(s);
        }

    }

    // --- encode date & time values
    NewIfaceDate = datetime_encodeDate(yr, mon, day) +
                   datetime_encodeTime(hr, min, sec);
}

//=============================================================================

setOldIfaceValues()
//
//  Input:   none
//  Output:  none
//  Purpose: replaces old values read from routing interface file with new ones. 
//
{
    let i, j;
    OldIfaceDate = NewIfaceDate;
    for ( i=0; i<NumIfaceNodes; i++)
    {
        for ( j=0; j<NumIfacePolluts+1; j++ )
        {
            OldIfaceValues[i][j] = NewIfaceValues[i][j];
        }
    }
}

//=============================================================================
// int i
 isOutletNode(i)
//
//  Input:   i = node index
//  Output:  returns 1 if node is an outlet, 0 if not.
//  Purpose: determines if a node is an outlet point or not.
//
{
    // --- for DW routing only outfalls are outlets
    if ( RouteModel == DW )
    {
        return (Node[i].type == OUTFALL);
    }

    // --- otherwise outlets are nodes with no outflow links (degree is 0)
    else return (Node[i].degree == 0);
}

//-----------------------------------------------------------------------------
//   gage.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/20/10  (Build 5.1.001)
//             09/15/14  (Build 5.1.007)
//             05/10/18  (Build 5.1.013)
//   Author:   L. Rossman
//
//   Rain gage functions.
//
//   Build 5.1.007:
//   - Support for monthly rainfall adjustments added.
//
//   Build 5.1.013:
//   - Validation no longer performed on unused gages.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Constants
//-----------------------------------------------------------------------------
OneSecond = 1.1574074e-5;

//-----------------------------------------------------------------------------
//  External functions (declared in funcs.h)
//-----------------------------------------------------------------------------
//  gage_readParams        (called by input_readLine)
//  gage_validate          (called by project_validate)
//  gage_initState         (called by project_init)
//  gage_setState          (called by runoff_execute & getRainfall in rdii.c)
//  gage_getPrecip         (called by subcatch_getRunoff)
//  gage_getNextRainDate   (called by runoff_getTimeStep)

//=============================================================================
// int j, char* tok[], int ntoks
gage_readParams(j, tok, ntoks)
//
//  Input:   j = rain gage index
//           tok[] = array of string tokens
//           ntoks = number of tokens
//  Output:  returns an error code
//  Purpose: reads rain gage parameters from a line of input data
//
//  Data formats are:
//    Name RainType RecdFreq SCF TIMESERIES SeriesName
//    Name RainType RecdFreq SCF FILE FileName Station Units StartDate
//
{
    let     k, err;
    let     id;
    let     fname;
    let     staID;
    let   x = new Array(7);

    // --- check that gage exists
    if ( ntoks < 2 ) return error_setInpError(ERR_ITEMS, "");
    id = project_findID(GAGE, tok[0]);
    if ( id == null ) return error_setInpError(ERR_NAME, tok[0]);

    // --- assign default parameter values
    x[0] = -1.0;         // No time series index
    x[1] = 1.0;          // Rain type is volume
    x[2] = 3600.0;       // Recording freq. is 3600 sec
    x[3] = 1.0;          // Snow catch deficiency factor
    x[4] = NO_DATE;      // Default is no start/end date
    x[5] = NO_DATE;
    x[6] = 0.0;          // US units
    fname = "";
    staID = "";

    if ( ntoks < 5 ) return error_setInpError(ERR_ITEMS, "");
    k = findmatch(tok[4], GageDataWords);
    if      ( k == RAIN_TSERIES )
    {
        err = readGageSeriesFormat(tok, ntoks, x);
    }
    else if ( k == RAIN_FILE    )
    {
        if ( ntoks < 8 ) return error_setInpError(ERR_ITEMS, "");
        sstrncpy(fname, tok[5], MAXFNAME);
        sstrncpy(staID, tok[6], MAXMSG);
        err = readGageFileFormat(tok, ntoks, x);
    }
    else return error_setInpError(ERR_KEYWORD, tok[4]);

    // --- save parameters to rain gage object
    if ( err > 0 ) return err;
    Gage[j].ID = id;
    Gage[j].tSeries      = x[0];
    Gage[j].rainType     = x[1];
    Gage[j].rainInterval = x[2];
    Gage[j].snowFactor   = x[3];
    Gage[j].rainUnits    = x[6];
    if ( Gage[j].tSeries >= 0 ) Gage[j].dataSource = RAIN_TSERIES;
    else                        Gage[j].dataSource = RAIN_FILE;
    if ( Gage[j].dataSource == RAIN_FILE )
    {
        sstrncpy(Gage[j].fname, fname, MAXFNAME);
        sstrncpy(Gage[j].staID, staID, MAXMSG);
        Gage[j].startFileDate = x[4];
        Gage[j].endFileDate = x[5];
    }
    Gage[j].unitsFactor = 1.0;
    Gage[j].coGage = -1;
    Gage[j].isUsed = false;
    return 0;
}

//=============================================================================
// char* tok[], int ntoks, double x[]
readGageSeriesFormat(tok, ntoks, x)
{
    let m, ts;
    let aTime;

    // return facilitators
    let returnObj;
    let returnVal;

    if ( ntoks < 6 ) return error_setInpError(ERR_ITEMS, "");

    // --- determine type of rain data
    m = findmatch(tok[1], RainTypeWords);
    if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);
    x[1] = m;

    // --- get data time interval & convert to seconds
    ////////////////////////////////////
    returnObj = {y: x[2]}
    returnVal = getDouble(tok[2], returnObj);
    x[2] = returnObj.y;
    ////////////////////////////////////
    
    if ( returnVal ) x[2] = Math.floor(x[2]*3600 + 0.5);
    //else if ( datetime_strToTime(tok[2], aTime) )
    else{
        ////////////////////////////////////
        returnObj = {t: aTime}
        returnVal = datetime_strToTime(tok[2], returnObj);
        aTime = returnObj.t;
        ////////////////////////////////////
        if (returnVal)
        {
            x[2] = Math.floor(aTime*SECperDAY + 0.5);
        } else {
            return error_setInpError(ERR_DATETIME, tok[2]);
        }
    }
    
    if ( x[2] <= 0.0 ) return error_setInpError(ERR_DATETIME, tok[2]);

    // --- get snow catch deficiency factor
    ////////////////////////////////////
    returnObj = {y: x[3]}
    returnVal1 = getDouble(tok[3], returnObj);
    x[3] = returnObj.y;
    ////////////////////////////////////
    if( !returnVal1 )
    //if ( null == (x[3] = getDouble(tok[3])))
        return error_setInpError(ERR_DATETIME, tok[3]);

    // --- get time series index
    ts = project_findObject(TSERIES, tok[5]);
    if ( ts < 0 ) return error_setInpError(ERR_NAME, tok[5]);
    x[0] = ts;
    tok[2] = "";
    return 0;
}

//=============================================================================
// char* tok[], int ntoks, double x[]
readGageFileFormat(tok, ntoks, x)
{
    let   m, u;
    let aDate;
    let aTime;

    // return facilitators
    let returnObj;
    let returnVal1;
    let returnVal2;

    // --- determine type of rain data
    m = findmatch(tok[1], RainTypeWords);
    if ( m < 0 ) return error_setInpError(ERR_KEYWORD, tok[1]);
    x[1] = m;

    // --- get data time interval & convert to seconds
    ////////////////////////////////////
    returnObj = {y: x[2]}
    returnVal1 = getDouble(tok[2], returnObj);
    x[2] = returnObj.y;
    ////////////////////////////////////

    ////////////////////////////////////
    returnObj = {t: aTime}
    returnVal2 = datetime_strToTime(tok[2], returnObj);
    aTime = returnObj.t;
    ////////////////////////////////////
    if (  !returnVal1 ) x[2] *= 3600;
    //else if ( datetime_strToTime(tok[2], aTime) )
    else if(returnVal2)
    {
        x[2] = Math.floor(aTime*SECperDAY + 0.5);
    }
    else return error_setInpError(ERR_DATETIME, tok[2]);
    if ( x[2] <= 0.0 ) return error_setInpError(ERR_DATETIME, tok[2]);

    // --- get snow catch deficiency factor
    ////////////////////////////////////
    returnObj = {y: x[3]}
    returnVal1 = getDouble(tok[3], returnObj);
    x[3] = returnObj.y;
    ////////////////////////////////////
    if(!returnVal1) 
    //if ( null == ( x[3] = getDouble(tok[3])))
        return error_setInpError(ERR_NUMBER, tok[3]);
 
    // --- get rain depth units
    u = findmatch(tok[7], RainUnitsWords);
    if ( u < 0 ) return error_setInpError(ERR_KEYWORD, tok[7]);
    x[6] = u;

    // --- get start date (if present)
    if ( ntoks > 8 && tok[8] != '*')
    {
        ////////////////////////////////////
        returnObj = {d: aDate}
        returnVal2 = datetime_strToDate(tok[8], returnObj);
        aDate = returnObj.d;
        ////////////////////////////////////
        //if ( !datetime_strToDate(tok[8], aDate) )
        if ( !returnVal2 )
            return error_setInpError(ERR_DATETIME, tok[8]);
        x[4] =  aDate;
    }
    return 0;
}

//=============================================================================
// int j
 gage_validate(j)
//
//  Input:   j = rain gage index
//  Output:  none
//  Purpose: checks for valid rain gage parameters
//
//  NOTE: assumes that any time series used by a rain gage has been
//        previously validated.
//
{
    let i, k;
    let gageInterval;

    // --- for gage with time series data:
    if ( Gage[j].dataSource == RAIN_TSERIES )
    {
        // --- no validation for an unused gage
        if ( !Gage[j].isUsed ) return;

        // --- see if gage uses same time series as another gage
        k = Gage[j].tSeries;
        for (i=0; i<j; i++)
        {
            if ( Gage[i].dataSource == RAIN_TSERIES && Gage[i].tSeries == k
                 && Gage[i].isUsed )
            {
                Gage[j].coGage = i;

                // --- check that both gages record same type of data
                if ( Gage[j].rainType != Gage[i].rainType )
                {
                    report_writeErrorMsg(ERR_RAIN_GAGE_FORMAT, Gage[j].ID);
                }
                return;
            }
        }

        // --- check gage's recording interval against that of time series
        if ( Tseries[k].refersTo >= 0 )
        {
            report_writeErrorMsg(ERR_RAIN_GAGE_TSERIES, Gage[j].ID);
        }
        gageInterval = (Math.floor(Tseries[k].dxMin*SECperDAY + 0.5));
        if ( gageInterval > 0 && Gage[j].rainInterval > gageInterval )
        {
            report_writeErrorMsg(ERR_RAIN_GAGE_INTERVAL, Gage[j].ID);
        } 
        if ( Gage[j].rainInterval < gageInterval )
        {
            report_writeWarningMsg(WARN09, Gage[j].ID);
        }
        if ( Gage[j].rainInterval < WetStep )
        {
            report_writeWarningMsg(WARN01, Gage[j].ID);
            WetStep = Gage[j].rainInterval;
        }
    }
}

//=============================================================================
// int j
 gage_initState(j)
//
//  Input:   j = rain gage index
//  Output:  none
//  Purpose: initializes state of rain gage.
//
{
    // --- initialize actual and reported rainfall                             //(5.1.013)
    Gage[j].rainfall = 0.0;
    Gage[j].reportRainfall = 0.0;
    if ( IgnoreRainfall ) return;

    // --- for gage with file data:
    if ( Gage[j].dataSource == RAIN_FILE )
    {
        // --- set current file position to start of period of record
        Gage[j].currentFilePos = Gage[j].startFilePos;

        // --- assign units conversion factor
        //     (rain depths on interface file are in inches)
        if ( UnitSystem == SI ) Gage[j].unitsFactor = MMperINCH;
    }

    // --- get first & next rainfall values
    if ( getFirstRainfall(j) )
    {
        // --- find date at end of starting rain interval
        Gage[j].endDate = datetime_addSeconds(
                          Gage[j].startDate, Gage[j].rainInterval);

        // --- if rainfall record begins after start of simulation,
        if ( Gage[j].startDate > StartDateTime )
        {
            // --- make next rainfall date the start of the rain record
            Gage[j].nextDate = Gage[j].startDate;
            Gage[j].nextRainfall = Gage[j].rainfall;

            // --- make start of current rain interval the simulation start
            Gage[j].startDate = StartDateTime;
            Gage[j].endDate = Gage[j].nextDate;
            Gage[j].rainfall = 0.0;
        }

        // --- otherwise find next recorded rainfall
        else if ( !getNextRainfall(j) ) Gage[j].nextDate = NO_DATE;
    }
    else Gage[j].startDate = NO_DATE;
}

//=============================================================================
// int j, DateTime t
gage_setState(j, t)
//
//  Input:   j = rain gage index
//           t = a calendar date/time
//  Output:  none
//  Purpose: updates state of rain gage for specified date. 
//
{
    // --- return if gage not used by any subcatchment
    if ( Gage[j].isUsed == false ) return;

    // --- set rainfall to zero if disabled
    if ( IgnoreRainfall )
    {
        Gage[j].rainfall = 0.0;
        return;
    }

    // --- use rainfall from co-gage (gage with lower index that uses
    //     same rainfall time series or file) if it exists
    if ( Gage[j].coGage >= 0)
    {
        Gage[j].rainfall = Gage[Gage[j].coGage].rainfall;
        return;
    }

    // --- otherwise march through rainfall record until date t is bracketed
    t += OneSecond;
    for (;;)
    {
        // --- no rainfall if no interval start date
        if ( Gage[j].startDate == NO_DATE )
        {
            Gage[j].rainfall = 0.0;
            return;
        }

        // --- no rainfall if time is before interval start date
        if ( t < Gage[j].startDate )
        {
            Gage[j].rainfall = 0.0;
            return;
        }

        // --- use current rainfall if time is before interval end date
        if ( t < Gage[j].endDate )
        {
            return;
        }

        // --- no rainfall if t >= interval end date & no next interval exists
        if ( Gage[j].nextDate == NO_DATE )
        {
            Gage[j].rainfall = 0.0;
            return;
        }

        // --- no rainfall if t > interval end date & <  next interval date
        if ( t < Gage[j].nextDate )
        {
            Gage[j].rainfall = 0.0;
            return;
        }

        // --- otherwise update next rainfall interval date
        Gage[j].startDate = Gage[j].nextDate;
        Gage[j].endDate = datetime_addSeconds(Gage[j].startDate,
                          Gage[j].rainInterval);
        Gage[j].rainfall = Gage[j].nextRainfall;
        if ( !getNextRainfall(j) ) Gage[j].nextDate = NO_DATE;
    }
}

//=============================================================================
// int j, DateTime aDate
gage_getNextRainDate(j, aDate)
//
//  Input:   j = rain gage index
//           aDate = calendar date/time
//  Output:  next date with rainfall occurring
//  Purpose: finds the next date from  specified date when rainfall occurs.
//
{
    if ( Gage[j].isUsed == false ) return aDate;
    aDate += OneSecond;
    if ( aDate < Gage[j].startDate ) return Gage[j].startDate;
    if ( aDate < Gage[j].endDate   ) return Gage[j].endDate;
    return Gage[j].nextDate;
}

//=============================================================================
////////////////////////////////////
//let returnObj = {rainfall: val1, snowfall: val2}
//let returnVal = gage_getPrecip(j, returnObj)
//val1 = returnObj.rainfall;
//val2 = returnObj.snowfall;
////////////////////////////////////
gage_getPrecip(j, inObj)
//double gage_getPrecip(int j, double *rainfall, double *snowfall)
//
//  Input:   j = rain gage index
//  Output:  rainfall = rainfall rate (ft/sec)
//           snowfall = snow fall rate (ft/sec)
//           returns total precipitation (ft/sec)
//  Purpose: determines whether gage's recorded rainfall is rain or snow.
//
{
    inObj.rainfall = 0.0;
    inObj.snowfall = 0.0;
    if ( !IgnoreSnowmelt && Temp.ta <= Snow.snotmp )
    {
        inObj.snowfall = Gage[j].rainfall * Gage[j].snowFactor / UCF(RAINFALL);
    }
    else inObj.rainfall = Gage[j].rainfall / UCF(RAINFALL);
    return (inObj.rainfall) + (inObj.snowfall);
} 

//=============================================================================
// int j, DateTime reportDate
gage_setReportRainfall(j, reportDate)
//
//  Input:   j = rain gage index
//           reportDate = date/time value of current reporting time
//  Output:  none
//  Purpose: sets the rainfall value reported at the current reporting time.
//
{
    let result;

    // --- use value from co-gage if it exists
    if ( Gage[j].coGage >= 0)
    {
        Gage[j].reportRainfall = Gage[Gage[j].coGage].reportRainfall;
        return;
    }

    // --- otherwise increase reporting time by 1 second to avoid
    //     roundoff problems
    reportDate += OneSecond;

    // --- use current rainfall if report date/time is before end
    //     of current rain interval
    if ( reportDate < Gage[j].endDate ) result = Gage[j].rainfall;

    // --- use 0.0 if report date/time is before start of next rain interval
    else if ( reportDate < Gage[j].nextDate ) result = 0.0;

    // --- otherwise report date/time falls right on end of current rain
    //     interval and start of next interval so use next interval's rainfall
    else result = Gage[j].nextRainfall;
    Gage[j].reportRainfall = result;
}

//=============================================================================
// int j
getFirstRainfall(j)
//
//  Input:   j = rain gage index
//  Output:  returns true if successful
//  Purpose: positions rainfall record to date with first rainfall.
//
{
    let    k;                          // time series index
    let  vFirst;                     // first rain volume (ft or m)
    let rFirst;                     // first rain intensity (in/hr or mm/hr)

    // rat facil
    let returnObj;
    let returnVal;

    // --- assign default values to date & rainfall
    Gage[j].startDate = NO_DATE;
    Gage[j].rainfall = 0.0;

    // --- initialize internal cumulative rainfall value
    Gage[j].rainAccum = 0;

    // --- use rain interface file if applicable
    if ( Gage[j].dataSource == RAIN_FILE )
    {
        if ( Frain.file && Gage[j].endFilePos > Gage[j].startFilePos )
        {
            // --- retrieve 1st date & rainfall volume from file
            fseek(Frain.file, Gage[j].startFilePos, SEEK_SET);
            fread(Gage[j].startDate, sizeof(DateTime), 1, Frain.file);
            fread(vFirst, sizeof, 1, Frain.file);
            Gage[j].currentFilePos = ftell(Frain.file);

            // --- convert rainfall to intensity
            Gage[j].rainfall = convertRainfall(j, vFirst);
            return 1;
        }
        return 0;
    }

    // --- otherwise access user-supplied rainfall time series
    else
    {
        k = Gage[j].tSeries;
        if ( k >= 0 )
        {
            // --- retrieve first rainfall value from time series
            ////////////////////////////////////
            returnObj = {x: Gage[j].startDate, y: rFirst}
            returnVal = table_getFirstEntry(Tseries[k], returnObj)
            Gage[j].startDate = returnObj.x;
            rFirst = returnObj.y;
            ////////////////////////////////////
            //if ( table_getFirstEntry(Tseries[k], Gage[j].startDate, rFirst) )
            if ( returnVal )
            {
                // --- convert rainfall to intensity
                Gage[j].rainfall = convertRainfall(j, rFirst);
                return 1;
            }
        }
        return 0;
    }
}

//=============================================================================
// int j
getNextRainfall(j)
//
//  Input:   j = rain gage index
//  Output:  returns 1 if successful; 0 if not
//  Purpose: positions rainfall record to date with next non-zero rainfall
//           while updating the gage's next rain intensity value.
//
//  Note: zero rainfall values explicitly entered into a rain file or
//        time series are skipped over so that a proper accounting of
//        wet and dry periods can be maintained.
//
{
    let    k;                          // time series index
    let  vNext;                      // next rain volume (ft or m)
    let rNext;                      // next rain intensity (in/hr or mm/hr)

    // ret facil
    let returnObj;
    let returnVal;

    Gage[j].nextRainfall = 0.0;
    do
    {
        if ( Gage[j].dataSource == RAIN_FILE )
        {
            if ( Frain.file && Gage[j].currentFilePos < Gage[j].endFilePos )
            {
                fseek(Frain.file, Gage[j].currentFilePos, SEEK_SET);
                fread(Gage[j].nextDate, sizeof(DateTime), 1, Frain.file);
                fread(vNext, sizeof, 1, Frain.file);
                Gage[j].currentFilePos = ftell(Frain.file);
                rNext = convertRainfall(j, vNext);
            }
            else return 0;
        }

        else
        {
            k = Gage[j].tSeries;
            if ( k >= 0 )
            {
                ////////////////////////////////////
                returnObj = {x: Gage[j].nextDate, y: rNext}
                returnVal = table_getNextEntry(Tseries[k], returnObj)
                Gage[j].nextDate = returnObj.x;
                rNext = returnObj.y;
                ////////////////////////////////////
                if( !returnVal ) {
                //if ( !table_getNextEntry(Tseries[k], Gage[j].nextDate, rNext) ){
                    return 0;
                }
                rNext = convertRainfall(j, rNext);
            }
            else return 0;
        }
    } while (rNext == 0.0);
    Gage[j].nextRainfall = rNext;
    return 1;
}

//=============================================================================
// int j, double r
convertRainfall(j, r)
//
//  Input:   j = rain gage index
//           r = rainfall value (user units)
//  Output:  returns rainfall intensity (user units)
//  Purpose: converts rainfall value to an intensity (depth per hour).
//
{
    let r1;
    switch ( Gage[j].rainType )
    {
      case RAINFALL_INTENSITY:
        r1 = r;
        break;

      case RAINFALL_VOLUME:
        r1 = r / Gage[j].rainInterval * 3600.0;
        break;

      case CUMULATIVE_RAINFALL:
        if ( r  < Gage[j].rainAccum )
             r1 = r / Gage[j].rainInterval * 3600.0;
        else r1 = (r - Gage[j].rainAccum) / Gage[j].rainInterval * 3600.0;
        Gage[j].rainAccum = r;
        break;

      default: r1 = r;
    }
    return r1 * Gage[j].unitsFactor * Adjust.rainFactor;
}

//=============================================================================

//-----------------------------------------------------------------------------
//   swmm5.c
//
//   Project:  EPA SWMM5
//   Version:  5.1
//   Date:     03/19/14  (Build 5.1.001)
//             03/19/15  (Build 5.1.008)
//             08/01/16  (Build 5.1.011)
//             03/14/17  (Build 5.1.012)
//             05/10/18  (Build 5.1.013)
//             04/01/20  (Build 5.1.015)
//   Author:   L. Rossman
//
//   This is the main module of the computational engine for Version 5 of
//   the U.S. Environmental Protection Agency's Storm Water Management Model
//   (SWMM). It contains functions that control the flow of computations.
//
//   This engine should be compiled into a shared object library whose API
//   functions are listed in swmm5.h.
//
//   Build 5.1.008:
//   - Support added for the MinGW compiler.
//   - Reporting of project options moved to swmm_start. 
//   - Hot start file now read before routing system opened.
//   - Final routing step adjusted so that total duration not exceeded.
//
//   Build 5.1.011:
//   - Made sure that MS exception handling only used with MS C compiler.
//   - Added name of module handling an exception to error report.
//   - Elapsed simulation time now saved to new global variable ElaspedTime.
//   - Added swmm_getError() that retrieves error code and message.
//   - Changed WarningCode to Warnings (# warnings issued).
//   - Added swmm_getWarnings() to retrieve value of Warnings.
//   - Fixed error code returned on swmm_xxx functions.
//
//   Build 5.1.012:
//   - #include <direct.h> only used when compiled for Windows.
//
//   Build 5.1.013:
//   - Support added for saving average results within a reporting period.
//   - SWMM engine now always compiled to a shared object library.
//
//   Build 5.1.015:
//   - Fixes bug in summary statistics when Report Start date > Start Date.
//-----------------------------------------------------------------------------

 MAX_EXCEPTIONS = 100            // max. number of exceptions handled

//-----------------------------------------------------------------------------
//  Unit conversion factors
//-----------------------------------------------------------------------------
Ucf =[
      //  US      SI
      [43200.0,   1097280.0 ],         // RAINFALL (in/hr, mm/hr --> ft/sec)
      [12.0,      304.8     ],         // RAINDEPTH (in, mm --> ft)
      [1036800.0, 26334720.0],         // EVAPRATE (in/day, mm/day --> ft/sec)
      [1.0,       0.3048    ],         // LENGTH (ft, m --> ft)
      [2.2956e-5, 0.92903e-5],         // LANDAREA (ac, ha --> ft2)
      [1.0,       0.02832   ],         // VOLUME (ft3, m3 --> ft3)
      [1.0,       1.608     ],         // WINDSPEED (mph, km/hr --> mph)
      [1.0,       1.8       ],         // TEMPERATURE (deg F, deg C --> deg F)
      [2.203e-6,  1.0e-6    ],         // MASS (lb, kg --> mg)
      [43560.0,   3048.0    ]          // GWFLOW (cfs/ac, cms/ha --> ft/sec)
      ];
Qcf =                            // Flow Conversion Factors:
    [1.0,     448.831, 0.64632,        // cfs, gpm, mgd --> cfs
     0.02832, 28.317,  2.4466 ];       // cms, lps, mld --> cfs

//-----------------------------------------------------------------------------
//  Shared variables
//-----------------------------------------------------------------------------
 IsOpenFlag;           // true if a project has been opened
 IsStartedFlag;        // true if a simulation has been started
 SaveResultsFlag;      // true if output to be saved to binary file
 ExceptionCount;       // number of exceptions handled
 DoRunoff;             // true if runoff is computed
 DoRouting;            // true if flow routing is computed

//-----------------------------------------------------------------------------
//  External API functions (prototyped in swmm5.h)
//-----------------------------------------------------------------------------
//  swmm_run
//  swmm_open
//  swmm_start
//  swmm_step
//  swmm_end
//  swmm_report
//  swmm_close
//  swmm_getMassBalErr
//  swmm_getVersion

//=============================================================================

 swmm_read_files(f1, f2, f3)
//
//  Input:   f1 = name of input file
//           f2 = name of report file
//           f3 = name of binary output file
//  Output:  returns error code
//  Purpose: runs a SWMM simulation.
//
{
    let newHour, oldHour = 0;
    let theDay, theHour;
    let elapsedTime = 0.0;

    // ret facil
    let returnObj;
    let returnVal;

    // --- initialize flags                                                    //(5.1.013)
    IsOpenFlag = false;                                                        //
    IsStartedFlag = false;                                                     //
    SaveResultsFlag = true;                                                    //

    // --- open the files & read input data
    ErrorCode = 0;
    swmm_open(f1, f2, f3);

    // --- report results
    if ( Fout.mode == SCRATCH_FILE ) swmm_report();

    // --- close the system
    //swmm_close();
    return error_getCode(ErrorCode);
}

//=============================================================================
/*
 swmm_run(f1, f2, f3)
//
//  Input:   f1 = name of input file
//           f2 = name of report file
//           f3 = name of binary output file
//  Output:  returns error code
//  Purpose: runs a SWMM simulation.
//
{
    let newHour, oldHour = 0;
    let theDay, theHour;
    let elapsedTime = 0.0;

    // ret facil
    let returnObj;
    let returnVal;

    // --- initialize flags                                                    //(5.1.013)
    IsOpenFlag = false;                                                        //
    IsStartedFlag = false;                                                     //
    SaveResultsFlag = true;                                                    //

    // --- open the files & read input data
    ErrorCode = 0;
    swmm_open(f1, f2, f3);

    // --- run the simulation if input data OK
    if ( !ErrorCode )
    {
        // --- initialize values
        swmm_start(true);

        // --- execute each time step until elapsed time is re-set to 0
        if ( !ErrorCode )
        {
            writecon("\n o  Simulating day: 0     hour:  0");
            do
            {
                ////////////////////////////////////
                returnObj = {elapsedTime: elapsedTime}
                returnVal = swmm_step(returnObj)
                elapsedTime = returnObj.elapsedTime;
                ////////////////////////////////////
                //swmm_step(elapsedTime);
                newHour = (elapsedTime * 24.0);
                if ( newHour > oldHour )
                {
                    theDay = elapsedTime;
                    theHour = ((elapsedTime - Math.floor(elapsedTime)) * 24.0);
                    writecon("\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
                    Msg = `${parseInt(theDay).toString().padEnd(5, ' ')} hour: ${parseInt(theHour).toString().padEnd(2, ' ')}`;        //(5.1.013)
                    writecon(Msg);
                    oldHour = newHour;
                }
            } while ( elapsedTime > 0.0 && !ErrorCode );
            writecon("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
            writecon("Simulation complete           ");
        }

        // --- clean up
        swmm_end();
    }

    // --- report results
    if ( Fout.mode == SCRATCH_FILE ) swmm_report();

    // --- close the system
    swmm_close();
    return error_getCode(ErrorCode);
}*/

//=============================================================================

swmm_open(f1, f2, f3)
//
//  Input:   f1 = name of input file
//           f2 = name of report file
//           f3 = name of binary output file
//  Output:  returns error code
//  Purpose: opens a SWMM project.
//
{
// --- to be safe, reset the state of the floating point unit                  //(5.1.013)
    // --- initialize error & warning codes
    datetime_setDateFormat(M_D_Y);
    ErrorCode = 0;
    ErrorMsg = '';
    Warnings = 0;
    IsOpenFlag = false;
    IsStartedFlag = false;
    ExceptionCount = 0;

    // --- open a SWMM project
    project_open(f1, f2, f3);
    if ( ErrorCode ) return error_getCode(ErrorCode);
    IsOpenFlag = true;
    report_writeLogo();
    writecon(FMT06);

    // --- retrieve project data from input file
    project_readInput();
    if ( ErrorCode ) return error_getCode(ErrorCode);

    // --- write project title to report file & validate data
    report_writeTitle();
    project_validate();

    // --- write input summary to report file if requested
    if ( RptFlags.input ) inputrpt_writeInput();


    return error_getCode(ErrorCode);
}

//=============================================================================

swmm_start(saveResults)
//
//  Input:   saveResults = true if simulation results saved to binary file 
//  Output:  returns an error code
//  Purpose: starts a SWMM simulation.
//
{
    // --- check that a project is open & no run started
    if ( ErrorCode ) return error_getCode(ErrorCode);
    if ( !IsOpenFlag || IsStartedFlag )
    {
        report_writeErrorMsg(ERR_NOT_OPEN, "");
        return error_getCode(ErrorCode);
    }

    // --- save saveResults flag to global variable
    SaveResultsFlag = saveResults;
    ExceptionCount = 0;

    // --- initialize elapsed time in decimal days
    ElapsedTime = 0.0;

    // --- initialize runoff, routing & reporting time (in milliseconds)
    NewRunoffTime = 0.0;
    NewRoutingTime = 0.0;
    ReportTime =   (1000 * ReportStep);
    TotalStepCount = 0;                                                    //(5.1.015)
    ReportStepCount = 0;                                                   //(5.1.015)
    NonConvergeCount = 0;
    IsStartedFlag = true;

    // --- initialize global continuity errors
    RunoffError = 0.0;
    GwaterError = 0.0;
    FlowError = 0.0;
    QualError = 0.0;

    // --- open rainfall processor (creates/opens a rainfall
    //     interface file and generates any RDII flows)
    if ( !IgnoreRainfall ) rain_open();
    if ( ErrorCode ) return error_getCode(ErrorCode);

    // --- initialize state of each major system component
    project_init();

    // --- see if runoff & routing needs to be computed
    if ( Nobjects[SUBCATCH] > 0 ) DoRunoff = true;
    else DoRunoff = false;
    if ( Nobjects[NODE] > 0 && !IgnoreRouting ) DoRouting = true;
    else DoRouting = false;

    // --- open binary output file
    output_open();

    // --- open runoff processor
    if ( DoRunoff ) runoff_open();

    // --- open & read hot start file if present
    if ( !hotstart_open() ) return ErrorCode;

    // --- open routing processor
    if ( DoRouting ) routing_open();

    // --- open mass balance and statistics processors
    massbal_open();
    stats_open();

    // --- write project options to report file 
    report_writeOptions();
    if ( RptFlags.controls ) report_writeControlActionsHeading();
}
//=============================================================================
////////////////////////////////////
//let returnObj = {elapsedTime: val1}
//let returnVal = swmm_step(returnObj)
//val1 = returnObj.elapsedTime;
////////////////////////////////////
swmm_step(inObj)
// int DLLEXPORT swmm_step(double* elapsedTime)
//
//  Input:   elapsedTime = current elapsed time in decimal days
//  Output:  updated value of elapsedTime,
//           returns error code
//  Purpose: advances the simulation by one routing time step.
//
{
    // --- check that simulation can proceed
    if ( ErrorCode ) return error_getCode(ErrorCode);
    if ( !IsOpenFlag || !IsStartedFlag  )
    {
        report_writeErrorMsg(ERR_NOT_OPEN, "");
        return error_getCode(ErrorCode);
    }

    // --- if routing time has not exceeded total duration
    if ( NewRoutingTime < TotalDuration )
    {
        // --- route flow & WQ through drainage system
        //     (runoff will be calculated as needed)
        //     (NewRoutingTime is updated)
        execRouting();
    }

////  Following code segment modified for release 5.1.013.  ////               //(5.1.013)
    // --- if saving results to the binary file
    if ( SaveResultsFlag )
    {
        // --- and it's time to save results
        if ( NewRoutingTime >= ReportTime )
        {
            // --- if user requested that average results be saved:
            if ( RptFlags.averages )
            {
                // --- include latest results in current averages
                //     if current time equals the reporting time
                if ( NewRoutingTime == ReportTime ) output_updateAvgResults();

                // --- save current average results to binary file
                //     (which will re-set averages to 0)
                //output_saveResults(ReportTime);

                // --- if current time exceeds reporting period then
                //     start computing averages for next period
                if ( NewRoutingTime > ReportTime ) output_updateAvgResults();
            }

            // --- otherwise save interpolated point results
            else //output_saveResults(ReportTime);

            // --- advance to next reporting period
            ReportTime = ReportTime + (1000 * ReportStep);
        }

        // --- not a reporting period so update average results if applicable
        else if ( RptFlags.averages ) output_updateAvgResults();
    }
////

    // --- update elapsed time (days)
    if ( NewRoutingTime < TotalDuration )
    {
        ElapsedTime = NewRoutingTime / MSECperDAY;
    }

    // --- otherwise end the simulation
    else ElapsedTime = 0.0;
    inObj.elapsedTime = ElapsedTime;

    return error_getCode(ErrorCode);
}

//=============================================================================

execRouting()
//
//  Input:   none
//  Output:  none
//  Purpose: routes flow & WQ through drainage system over a single time step.
//
{
    let nextRoutingTime;          // updated elapsed routing time (msec)
    let routingStep;              // routing time step (sec)


    // --- determine when next routing time occurs
    TotalStepCount++;                                                      //(5.1.015)
    if ( !DoRouting ) routingStep = Math.min(WetStep, ReportStep);
    else routingStep = routing_getRoutingStep(RouteModel, RouteStep);
    if ( routingStep <= 0.0 )
    {
        ErrorCode = ERR_TIMESTEP;
        return;
    }
    nextRoutingTime = NewRoutingTime + 1000.0 * routingStep;

    // --- adjust routing step so that total duration not exceeded
    if ( nextRoutingTime > TotalDuration )
    {
        routingStep = (TotalDuration - NewRoutingTime) / 1000.0;
        routingStep = Math.max(routingStep, 1. / 1000.0);
        nextRoutingTime = TotalDuration;
    }

    // --- compute runoff until next routing time reached or exceeded
    if ( DoRunoff ) while ( NewRunoffTime < nextRoutingTime )
    {
        runoff_execute();
        if ( ErrorCode ) return;
    }

    // --- if no runoff analysis, update climate state (for evaporation)
    else climate_setState(getDateTime(NewRoutingTime));

    // --- route flows & pollutants through drainage system
    //     (while updating NewRoutingTime)
    if ( DoRouting ) routing_execute(RouteModel, routingStep);
    else
    NewRoutingTime = nextRoutingTime;

}

//=============================================================================

swmm_end()
//
//  Input:   none
//  Output:  none
//  Purpose: ends a SWMM simulation.
//
{
    // --- check that project opened and run started
    if ( !IsOpenFlag )
    {
        report_writeErrorMsg(ERR_NOT_OPEN, "");
        return error_getCode(ErrorCode);
    }

    if ( IsStartedFlag )
    {
        // --- write ending records to binary output file
        if ( Fout.file ) output_end();

        // --- report mass balance results and system statistics
        if ( !ErrorCode )
        {
            massbal_report();
            stats_report();
        }

        // --- close all computing systems
        stats_close();
        massbal_close();
        if ( !IgnoreRainfall ) rain_close();
        if ( DoRunoff ) runoff_close();
        if ( DoRouting ) routing_close(RouteModel);
        hotstart_close();
        IsStartedFlag = false;
    }
    return error_getCode(ErrorCode);
}

//=============================================================================

swmm_report()
//
//  Input:   none
//  Output:  returns an error code
//  Purpose: writes simulation results to report file.
//
{
    if ( Fout.mode == SCRATCH_FILE ) output_checkFileSize();
    if ( ErrorCode ) report_writeErrorCode();
    else
    {
        writecon(FMT07);
        report_writeReport();
    }
    return error_getCode(ErrorCode);
}

//=============================================================================

swmm_close()
//
//  Input:   none
//  Output:  returns an error code
//  Purpose: closes a SWMM project.
//
{
    if ( Fout.file ) output_close();
    if ( IsOpenFlag ) project_close();
    report_writeSysTime();
    if ( Finp.file != null ) fclose(Finp.file);
    if ( Frpt.file != null ) fclose(Frpt.file);
    //if ( Fout.file != null )
    //{
    //    fclose(Fout.file);
    //    if ( Fout.mode == SCRATCH_FILE ) remove(Fout.name);
    //}
    IsOpenFlag = false;
    IsStartedFlag = false;
    return 0;
}

//=============================================================================

swmm_getMassBalErr(runoffErr, flowErr,
                                  qualErr)
//
//  Input:   none
//  Output:  runoffErr = runoff mass balance error (percent)
//           flowErr   = flow routing mass balance error (percent)
//           qualErr   = quality routing mass balance error (percent)
//           returns an error code
//  Purpose: reports a simulation's mass balance errors.
//
{
    runoffErr = 0.0;
    flowErr   = 0.0;
    qualErr   = 0.0;

    if ( IsOpenFlag && !IsStartedFlag)
    {
        runoffErr = RunoffError;
        flowErr   = FlowError;
        qualErr   = QualError;
    }
    return 0;
}

//=============================================================================

swmm_getVersion()
//
//  Input:   none
//  Output:  returns SWMM engine version number
//  Purpose: retrieves version number of current SWMM engine which
//           uses a format of xyzzz where x = major version number,
//           y = minor version number, and zzz = build number.
//
//  NOTE: Each New Release should be updated in consts.h
{
    return VERSION;
}

//=============================================================================

swmm_getWarnings()
//
//  Input:  none
//  Output: returns number of warning messages issued.
//  Purpose: retireves number of warning messages issued during an analysis.
{
    return Warnings;
}

//=============================================================================

swmm_getError(errMsg, msgLen)
//
//  Input:   errMsg = character array to hold error message text
//           msgLen = maximum size of errMsg
//  Output:  returns error message code number and text of error message.
//  Purpose: retrieves the code number and text of the error condition that
//           caused SWMM to abort its analysis.
{
    let errMsgLen = msgLen;

    // --- copy text of last error message into errMsg
    if ( ErrorCode > 0 && ErrorMsg.length == 0 ) errMsg = "";
    else
    {
        errMsgLen = MIN(errMsgLen, ErrorMsg.length);
        errMsg = ErrorMsg;
    }

    // --- remove leading line feed from errMsg
    if ( errMsgLen > 0 && errMsg[0] == '\n' ) errMsg[0] = ' ';
    return error_getCode(ErrorCode);
}

//=============================================================================
//   General purpose functions
//=============================================================================

UCF(u)
//
//  Input:   u = integer code of quantity being converted
//  Output:  returns a units conversion factor
//  Purpose: computes a conversion factor from SWMM's internal
//           units to user's units
//
{
    if ( u < FLOW ) return Ucf[u][UnitSystem];
    else            return Qcf[FlowUnits];
}

//=============================================================================

/*sstrncpy(dest, src, maxlen)
//
//  Input:   dest = string to be copied to
//           src = string to be copied from
//           maxlen = number of characters to copy
//  Output:  returns a pointer to dest
//  Purpose: safe version of standard strncpy function
//
{
     dest = src;
     return dest;
}*/

//=============================================================================

strcomp(s1, s2)
//
//  Input:   s1 = a character string
//           s2 = a character string
//  Output:  returns 1 if s1 is same as s2, 0 otherwise
//  Purpose: does a case insensitive comparison of two strings.
//
{
    /*let i;
    for (i = 0; UCHAR(s1[i]) == UCHAR(s2[i]); i++)
    {
        if (!s1[i+1] && !s2[i+1]) return(1);
    }
    return(0);*/
    if (s1.toUpperCase().localeCompare(s2.toUpperCase()) == 0){
        return 1;
    } else {
        return 0;
    }
}

//=============================================================================

getTempFileName(fname)
//
//  Input:   fname = file name string (with max size of MAXFNAME)
//  Output:  returns pointer to file name
//  Purpose: creates a temporary file name with path prepended to it.
//
{
    let name = null;
    let dir = null;

    // --- set dir to user's choice of a temporary directory
    if (TempDir.length > 0)
    {
        _mkdir(TempDir);
        dir = TempDir;
    }

    // --- use _tempnam to get a pointer to an unused file name
    name = _tempnam(dir, "swmm");
    if (name == null) return null;

    // --- copy the file name to fname
    if (name.length < MAXFNAME) strncpy(fname, name, MAXFNAME);
    else fname = null;

    // --- free the pointer returned by _tempnam
    name = null;

    // --- return the new contents of fname
    return fname;

}

//=============================================================================
//let returnObj = {days: d, hrs: h, mins: m}
//getElapsedTime(aDate, returnObj)
//d = returnObj.days
//h = returnObj.hrs
//m = returnObj.mins
getElapsedTime(aDate, inObj)
// getElapsedTime(aDate, days, hrs, mins)
//
//  Input:   aDate = simulation calendar date + time
//  Output:  days, hrs, mins = elapsed days, hours & minutes for aDate
//  Purpose: finds elapsed simulation time for a given calendar date
//
{
    let x;
    let secs;
    x = aDate - StartDateTime;
    if ( x <= 0.0 )
    {
        inObj.days = 0;
        inObj.hrs  = 0;
        inObj.mins = 0;
    }
    else
    {
        inObj.days = x;
        //datetime_decodeTime(x, hrs, mins, secs);
        ////////////////////////////////////
        let returnObj = {h: inObj.hrs, m: inObj.mins, s: secs}
        datetime_decodeTime(x, returnObj);
        inObj.hrs = returnObj.h;
        inObj.mins = returnObj.m;
        inObj.secs = returnObj.s;
        ////////////////////////////////////
    }
}

//=============================================================================

getDateTime(elapsedMsec)
//
//  Input:   elapsedMsec = elapsed milliseconds
//  Output:  returns date/time value
//  Purpose: finds calendar date/time value for elapsed milliseconds of
//           simulation time.
//
{
    return datetime_addSeconds(StartDateTime, (elapsedMsec+1)/1000.0);
}

//=============================================================================

 writecon(s)
//
//  Input:   s = a character string
//  Output:  none
//  Purpose: writes string of characters to the console.
//
{
    console.log(s);
}

//=============================================================================


xfilter(xc, module, elapsedTime, step)
//
//  Input:   xc          = exception code
//           module      = name of code module where exception was handled
//           elapsedTime = simulation time when exception occurred (days)
//           step        = step count at time when exception occurred
//  Output:  returns an exception handling code
//  Purpose: exception filtering routine for operating system exceptions
//           under Windows and the Microsoft C compiler.
//
{
    let  rc;                           // result code
    let hour;                         // current hour of simulation
    let msg;                      // exception type text
    let xmsg = '';                    // error message text
    switch (xc)
    {
    case EXCEPTION_ACCESS_VIOLATION:
        msg += "\n  Access violation ";
        rc = EXCEPTION_EXECUTE_HANDLER;
        break;
    case EXCEPTION_FLT_DENORMAL_OPERAND:
        msg += "\n  Illegal floating point operand ";
        rc = EXCEPTION_CONTINUE_EXECUTION;
        break;
    case EXCEPTION_FLT_DIVIDE_BY_ZERO:
        msg += "\n  Floating point divide by zero ";
        rc = EXCEPTION_CONTINUE_EXECUTION;
        break;
    case EXCEPTION_FLT_INVALID_OPERATION:
        msg += "\n  Illegal floating point operation ";
        rc = EXCEPTION_CONTINUE_EXECUTION;
        break;
    case EXCEPTION_FLT_OVERFLOW:
        msg += "\n  Floating point overflow ";
        rc = EXCEPTION_CONTINUE_EXECUTION;
        break;
    case EXCEPTION_FLT_STACK_CHECK:
        msg += "\n  Floating point stack violation ";
        rc = EXCEPTION_EXECUTE_HANDLER;
        break;
    case EXCEPTION_FLT_UNDERFLOW:
        msg += "\n  Floating point underflow ";
        rc = EXCEPTION_CONTINUE_EXECUTION;
        break;
    case EXCEPTION_INT_DIVIDE_BY_ZERO:
        msg += "\n  Integer divide by zero ";
        rc = EXCEPTION_CONTINUE_EXECUTION;
        break;
    case EXCEPTION_INT_OVERFLOW:
        msg += "\n  Integer overflow ";
        rc = EXCEPTION_CONTINUE_EXECUTION;
        break;
    default:
        msg += "\n  Exception %d ", xc;
        rc = EXCEPTION_EXECUTE_HANDLER;
    }
    hour = (long)(elapsedTime / 1000.0 / 3600.0);

    let val1 = msg
    let val2 = module
    let val3 = step.toString()
    let val4 = hour.toString()
    xmsg = `${val1}in module ${val2} at step ${val3}, hour ${val4}`;
    if ( rc == EXCEPTION_EXECUTE_HANDLER ||
         ++ExceptionCount >= MAX_EXCEPTIONS )
    {
        strcat(xmsg, " --- execution halted.");
        rc = EXCEPTION_EXECUTE_HANDLER;
    }
    report_writeLine(xmsg);
    return rc;
}
}